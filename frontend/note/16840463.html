<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>
       11月份整理的知识点 |  前端迷
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="前端迷,前端开发,前端知识大全,前端优化,前端导航,小程序,ru23.com,JavaScript,ajax,angular,css,webpack,react,gulp,htmlhtml5,mocha,nginx,node,css3,vue,vue-cli,scss">
     <meta name="description" content="理解事件原理事件捕获/冒泡DOM事件流DOM2级事件规定事件包括三个阶段：① 事件捕获阶段② 处于目标阶段③ 事件冒泡阶段stopPropagation ES6let const ()=&amp;gt; 模板字符串 解析结构 函数默认参数 展开运算符 对象字面量 与 class、 Promise Redux state ， action，reducer state的改变只能通过触发特定的action完成（">
<meta name="keywords" content="知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="11月份整理的知识点">
<meta property="og:url" content="https://ru23.com/note/16840463.html">
<meta property="og:site_name" content="前端迷">
<meta property="og:description" content="理解事件原理事件捕获/冒泡DOM事件流DOM2级事件规定事件包括三个阶段：① 事件捕获阶段② 处于目标阶段③ 事件冒泡阶段stopPropagation ES6let const ()=&amp;gt; 模板字符串 解析结构 函数默认参数 展开运算符 对象字面量 与 class、 Promise Redux state ， action，reducer state的改变只能通过触发特定的action完成（">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-11-12T07:10:39.894Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="11月份整理的知识点">
<meta name="twitter:description" content="理解事件原理事件捕获/冒泡DOM事件流DOM2级事件规定事件包括三个阶段：① 事件捕获阶段② 处于目标阶段③ 事件冒泡阶段stopPropagation ES6let const ()=&amp;gt; 模板字符串 解析结构 函数默认参数 展开运算符 对象字面量 与 class、 Promise Redux state ， action，reducer state的改变只能通过触发特定的action完成（">  
    <link rel="icon" href="//cdn.ru23.com/img/favicon.ico">
    
    <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="//cdn.ru23.com/css/style.css"> <script src="//cdn.ru23.com/js/pace.min.js"></script> 
  
  <div style="display: none;">
    <script src="//s22.cnzz.com/z_stat.php?id=1275440747&web_id=1275440747" language="JavaScript"></script>
  </div>


  </head>
</html>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">前端迷</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a href="/">
                        <i class="fa fa-home"></i>
                        <span>主页</span>
                    </a>
                    
                    <a href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>归档</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="//cdn.ru23.com/img/images/chrome.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        前端迷
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        凡事预则立，不预则废
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="公众号" target="_blank" href="https://mp.weixin.qq.com/s/K3yG4eyuQvZxXIU9jas8kA">
                          <img src="//cdn.ru23.com/icon/mp.png" alt="logo">
                          </a>
                    
                        <a title="掘金" target="_blank" href="https://juejin.im/user/57fb24cf816dfa0056c1f8af">
                          <img src="//cdn.ru23.com/icon/juejin.png" alt="logo">
                          </a>
                    
                        <a title="Github" target="_blank" href="//github.com/ru23">
                          <img src="//cdn.ru23.com/icon/github.png" alt="logo">
                          </a>
                    
                        <a title="知乎" target="_blank" href="https://www.zhihu.com/people/58fe/activities">
                          <img src="//cdn.ru23.com/icon/zhihu.png" alt="logo">
                          </a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
          <div class="outer-section">
            <section id="main" class="body-wrap"><article id="post-2018-11-11月份整理的知识点" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            
  
    <h1 class="post-title" itemprop="name">
      11月份整理的知识点
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/front-end/">front-end</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2017-11-08
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

            
        </header>
        
        <div class="article-entry post-content" itemprop="articleBody">
            
            
            <h3 id="理解事件原理"><a href="#理解事件原理" class="headerlink" title="理解事件原理"></a>理解事件原理</h3><p>事件捕获/冒泡<br>DOM事件流<br>DOM2级事件规定事件包括三个阶段：<br>① 事件捕获阶段<br>② 处于目标阶段<br>③ 事件冒泡阶段<br>stopPropagation</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>let const ()=&gt; 模板字符串 解析结构 函数默认参数 展开运算符 对象字面量 与 class、 Promise</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p> state ， action，reducer<br> state的改变只能通过触发特定的action完成（action 是一个用于描述已发生事件的普通对象）Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。</p>
<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p><a href="https://www.cnblogs.com/wubaiqing/p/6726429.html" target="_blank" rel="noopener">https://www.cnblogs.com/wubaiqing/p/6726429.html</a><br>DOM 很慢，为啥说它慢，先看一下 Webkit 引擎，所有浏览器都遵循类似的工作流，只<br>是在细节处理有些不同。一旦浏览器接收到一个 HTML 文件，渲染引擎 Render Engine<br>就开始解析它，根据 HTML 元素 Elements 对应地生成 DOM 节点 Nodes，最终组成一<br>棵 DOM 树。<br>构造了渲染树以后，浏览器引擎开始着手布局 Layout。布局时，渲染树上的每个节点根据<br>其在屏幕上应该出现的精确位置，分配一组屏幕坐标值。接着，浏览器将会通过遍历渲染树，<br>调用每个节点的 Paint 方法来绘制这些 Render 对象。Paint 方法根据浏览器平台，使用不<br>同的 UI后端 API（Agnostic UI Backend API）通过绘制，最终将在屏幕上展示内容。只要<br>在这过程中进行一次 DOM 更新，整个渲染流程都会重做一遍。<br>DOM 树上的结构、属性信息我们都可以很容易地用 javascript 对象表示出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> olE = &#123;</span><br><span class="line">  tagName: <span class="string">'ol'</span>, <span class="comment">// 标签名</span></span><br><span class="line">  props: &#123; <span class="comment">// 属性用对象存储键值对</span></span><br><span class="line">    id: <span class="string">'ol-list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 1"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 2"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 3"</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是所谓的 Virtual DOM 算法：</p>
<p>用 javascript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文<br>档当中当状态变更时，重新构造一棵新的对象树。然后用新的树和旧的树进行比较两个数的差异。<br>然后把差异更新到久的树上，整个视图就更新了。Virtual DOM 本质就是在 JS 和 DOM 之间做<br>了一个缓存。既然已经知道 DOM 慢，就在 JS 和 DOM 之间加个缓存。JS 先操作 Virtual DOM<br>对比排序/变更，最后再把整个变更写入真实 DOM。</p>
<h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><p>流程：<br>　解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树<br>概念：<br><code>DOM Tree</code>：浏览器将HTML解析成树形的数据结构。</p>
<p><code>CSS Rule Tree</code>：浏览器将CSS解析成树形的数据结构。</p>
<p><code>Render Tree</code>: DOM和CSSOM合并后生成Render Tree。</p>
<p><code>layout</code>: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</p>
<p><code>painting</code>: 按照算出来的规则，通过显卡，把内容画到屏幕上。</p>
<p><code>reflow</code>（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</html></p>
<p><code>repaint</code>（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。<br>注意：(1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。</p>
<p>　　   (2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</p>
<p>　　　(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。<br>过程：</p>
<ol>
<li><p>浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p>
</li>
<li><p>将CSS解析成 CSS Rule Tree 。</p>
</li>
<li><p>根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。</p>
</li>
<li><p>有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。</p>
</li>
<li><p>再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</p>
</li>
</ol>
<h3 id="JS中EventLoop事件循环机制"><a href="#JS中EventLoop事件循环机制" class="headerlink" title="JS中EventLoop事件循环机制"></a>JS中EventLoop事件循环机制</h3><p><strong>什么是单线程</strong></p>
<p>主程序只有一个线程，即同一时间片断内其只能执行单个任务。</p>
<p>为什么选择单线程？</p>
<p>javascript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p>
<p>单线程意味着什么？</p>
<p>单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致IO操作（耗时但cpu闲置）时造成性能浪费的问题。</p>
<p>如何解决单线程带来的性能问题？</p>
<p>答案是异步！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）</p>
<p>注： 当主线程阻塞时，任务队列仍然是能够被推入任务的<br><strong>Event Loop 是什么：</strong><br>javascript的事件分两种，宏任务(macro-task)和微任务(micro-task)<br>宏任务：包括整体代码script，setTimeout，setInterval<br>微任务：Promise.then(非new Promise)，process.nextTick(node中)<br><a href="https://segmentfault.com/a/1190000012806637?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012806637?utm_source=tag-newest</a></p>
<h3 id="javascript-内存模型"><a href="#javascript-内存模型" class="headerlink" title="javascript 内存模型"></a>javascript 内存模型</h3><h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="headerlink" title="箭头函数和普通函数有什么区别"></a>箭头函数和普通函数有什么区别</h3><p>1.普通function的声明在变量提升中是最高的，箭头函数没有函数提升<br>2.箭头函数没有this，它会捕获其所在上下文的 this 值，作为自己的 this 值<br>3.箭头函数不绑定arguments,取而代之用rest参数…解决<br>4.箭头函数不能作为构造函数，不能被new，没有property,<br>5.call和apply方法只有参数，没有作用域</p>
<h3 id="vue和react的比较，不同点"><a href="#vue和react的比较，不同点" class="headerlink" title="vue和react的比较，不同点"></a>vue和react的比较，不同点</h3><p>Vue提供了更多的语法糖来让开发更便利，比如props的动态实时更新、双向的数据绑定、指令系统，实例的事件接口等。而React的中心思想即状态驱动视图的更改，所有UI层的变更都尽量通过setState来触发， 通信方式通过UIAction的行为来实现清晰的单向数据流。<br>吧啦吧啦网上一堆资料，就不详细展开了</p>
<h3 id="js处理异步的几种方式"><a href="#js处理异步的几种方式" class="headerlink" title="js处理异步的几种方式"></a>js处理异步的几种方式</h3><p>javascript语言的执行环境是”单线程”（single thread，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推）。</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p>
<p>为了解决这个问题，javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。</p>
<p>“同步模式” 就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>
<p>“异步模式” 非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。</p>
<h3 id="Cookie、session和localStorage的区别"><a href="#Cookie、session和localStorage的区别" class="headerlink" title="Cookie、session和localStorage的区别"></a>Cookie、session和localStorage的区别</h3><p>共同点：都是保存在浏览器端，且同源的。<br>区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。</p>
<h3 id="如何获悉一个对象的具体类型"><a href="#如何获悉一个对象的具体类型" class="headerlink" title="如何获悉一个对象的具体类型"></a>如何获悉一个对象的具体类型</h3><p>javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。<br><a href="https://www.cnblogs.com/ww-ervin-72/p/5103540.html" target="_blank" rel="noopener">https://www.cnblogs.com/ww-ervin-72/p/5103540.html</a></p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>prototype 属性使您有能力向对象添加属性和方法。</p>
<h3 id="问call和apply的作用是什么？区别是什么？"><a href="#问call和apply的作用是什么？区别是什么？" class="headerlink" title="问call和apply的作用是什么？区别是什么？"></a>问call和apply的作用是什么？区别是什么？</h3><p>每个函数都包含两个非继承而来的方法：apply()和call()。<br>call与apply都属于Function.prototype的一个方法，所以每个function实例都有call、apply属性；<br>作用：call（）方法和apply（）方法的作用相同：改变this指向。<br>区别：他们的区别在于接收参数的方式不同：<br><code>call（）</code>：第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。在使用call（）方法时，传递给函数的参数必须逐个列举出来。</p>
<p><code>apply（）</code>：传递给函数的是参数数组<br> javascript 有几种类型的值？能否画一下它们的内存图？<br> 如下代码做出解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">3</span>&#125;; </span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16 </span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br></pre></td></tr></table></figure>
<h3 id="js的事件流"><a href="#js的事件流" class="headerlink" title="js的事件流"></a>js的事件流</h3><p>一、事件流<br>事件冒泡<br>事件捕获<br>DOM事件流</p>
<p>一面电话直接问了很多比较基础的问题，比如区分行内元素与块级元素，还有查看，比如他给出一个例子，让你写出捕获，冒泡各几次等。。。。对于初学者的确平时没有太注意相关问题。</p>
<h3 id="谈谈http协议"><a href="#谈谈http协议" class="headerlink" title="谈谈http协议"></a>谈谈http协议</h3><p>HTTP（HyperText TransportProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。</p>
<p>通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个指示头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<p>主要还得记得http中Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：</p>
<p>1xx:信息响应类，表示接收到请求并且继续处理<br>2xx:处理成功响应类，表示动作被成功接收、理解和接受<br>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理<br>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行<br>5xx:服务端错误，服务器不能正确执行一个正确的请求</p>
<h3 id="1-看项目中使用了dva，为什么要用dva？直接用saga也能达到同样的效果，dva相比好在哪里？"><a href="#1-看项目中使用了dva，为什么要用dva？直接用saga也能达到同样的效果，dva相比好在哪里？" class="headerlink" title="1. 看项目中使用了dva，为什么要用dva？直接用saga也能达到同样的效果，dva相比好在哪里？"></a>1. 看项目中使用了dva，为什么要用dva？直接用saga也能达到同样的效果，dva相比好在哪里？</h3><p>dva 是基于现有应用架构 (redux + react-router + redux-saga 等)的一层轻量封装，没有引入任何新概念，全部代码不到 100 行。( Inspired by elm and choo. )<br>dva 是 framework，不是 library，类似 emberjs，会很明确地告诉你每个部件应该怎么写，这对于团队而言，会更可控。另外，除了 react 和 react-dom 是 peerDependencies 以外，dva 封装了所有其他依赖。<br>dva 实现上尽量不创建新语法，而是用依赖库本身的语法，比如 router 的定义还是用 react-router 的 JSX 语法的方式(dynamic config 是性能的考虑层面，之后会支持)。<br>他最核心的是提供了 app.model 方法，用于把 reducer, initialState, action, saga 封装到一起</p>
<h3 id="2-说说react的单向数据流。"><a href="#2-说说react的单向数据流。" class="headerlink" title="2. 说说react的单向数据流。"></a>2. 说说react的单向数据流。</h3><p>React是单向数据流，数据主要从父节点传递到子节点（通过props）。<br><a href="http://www.cnblogs.com/hanguidong/p/9514078.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanguidong/p/9514078.html</a><br>如果顶层（父级）的某个props改变了，React会重渲染所有的子节点。</p>
<ol start="3">
<li><p>react中state与界面通信的函数（connect）。</p>
</li>
<li><p>react的性能，如果只更新最底层的数据，怎么重新渲染界面？</p>
</li>
<li><p>如果有一个比较复杂的逻辑 需要更改state 应该放在reducer中还是effect中？</p>
</li>
<li><p>在哪里调用ajax，同步异步的区别 ajax是否有副作用？</p>
</li>
<li><p>vue和react相比优点和缺点。</p>
</li>
<li><p>vue中与reducer effect相对应的部分是什么？</p>
</li>
<li><p>vue的计算属性 watch react中有相对应的部分吗？如果要添加 应该加在哪个回调函数里？</p>
</li>
</ol>
<p>http和https的区别，<br>算法加密，<br>前端网络安全问题，<br>手撕代码：<br>字符串中的数字替换成特殊字符，<br>将数字分为千分位的形式。<br>正则表达式，<br>闭包。<br>纯函数是啥？</p>
<p>(一)问题：<br>1.基础问题：<br>说说js的继承实现<br>js的闭包<br>2.项目问题：<br>在项目中遇到的问题<br>假如让你重新做这个项目，你会怎么做？</p>
<p>二.第二次电面<br>(一)问题：<br>1.基础知识：<br>性能：页面加载过程<br>怎么理解模块化<br>commentJs<br>jq的ajax使用<br>正则表达式的使用<br>2.项目问题：<br>数据如何传输处理的？<br>url请求的过程</p>
<p>三.第三次电面<br>(一)问题：<br>5.说说浏览器兼容和性能优化<br>6.浏览器的缓存机制</p>
<h3 id="7-http请求的状态码"><a href="#7-http请求的状态码" class="headerlink" title="7.http请求的状态码"></a>7.http请求的状态码</h3><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304 Not Modified 自从上次请求后，请求的网页未修改过。</p>
<p>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁止访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。</p>
<p>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p>
<p>前端开发人员必须要知道的一类安全知识。</p>
<p>7：介绍下浏览器缓存</p>
<p>刚好和状态码 304 结合起来。</p>
<p>8：介绍 js 中事件 （冒泡 委托）</p>
<p>事件冒泡和事件捕获，执行的先后顺序，还可以说一说关于事件委托。</p>
<p>请解释事件委托（event delegation）。<br>事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器。当触发子元素时，事件会冒泡到父元素，监听器就会触发。这种技术的好处是：</p>
<p>内存占用减少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。<br>无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。</p>
<h3 id="哪些流行的前端技术，对前端的前景和职责"><a href="#哪些流行的前端技术，对前端的前景和职责" class="headerlink" title="哪些流行的前端技术，对前端的前景和职责"></a>哪些流行的前端技术，对前端的前景和职责</h3><p>移动端会越来越重要<br>比较火的有 MVVM 框架 react、vue，ES6 肯定会在近几年统治前端，Nodejs 也是前端必备技能。关于前端的前景，我觉得 H5 配合 react、vue 是热门，前端可视化（ant-design），webVR 可能会在未来的几年大火一次。职责还是负责与用户的交互，考虑性能、资源方面的优化，全栈是每个前端程序员的梦想。</p>
<p>14：js 基本数据类型</p>
<p>光知道基本数据，如果能扩展，就更好了，比如引用数据类型和非引用数据类型，就是常说的堆和栈。</p>
<p>16：call apaly 区别</p>
<p>可以定义上下文，参数不一样，apply 的参数是数组，如果能和 bind 扩展就更好了。</p>
<h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>  存储大小：<br>      cookie数据大小不能超过4k。<br>      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>  有期时间：<br>      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>      sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>      cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<h3 id="javascript原型，原型链-有什么特点？"><a href="#javascript原型，原型链-有什么特点？" class="headerlink" title="javascript原型，原型链 ? 有什么特点？"></a>javascript原型，原型链 ? 有什么特点？</h3><p> 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br> 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br> 于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br> 关系：instance.constructor.prototype = instance.<strong>proto</strong></p>
<p> 特点：<br>javascript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<p>当我们需要一个属性的时，javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，<br>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Func.prototype.name = <span class="string">"Sean"</span>;</span><br><span class="line">Func.prototype.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Func();<span class="comment">//现在可以参考var person = Object.create(oldObject);</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getInfo());<span class="comment">//它拥有了Func的属性和方法</span></span><br><span class="line"><span class="comment">//"Sean"</span></span><br><span class="line"><span class="built_in">console</span>.log(Func.prototype);</span><br><span class="line"><span class="comment">// Func &#123; name="Sean", getInfo=function()&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="javascript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#javascript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="javascript有几种类型的值？，你能画一下他们的内存图吗？"></a>javascript有几种类型的值？，你能画一下他们的内存图吗？</h3><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（对象、数组和函数）</p>
<p> 两种类型的区别是：存储位置不同；<br> 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br> 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体<br> <a href="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" target="_blank" rel="noopener">https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966</a></p>
<p> 1、构造继承<br> 2、原型继承<br> 3、实例继承<br> 4、拷贝继承</p>
<p> 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'wang'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.age = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</span><br><span class="line">alert(demo.age);</span><br><span class="line">alert(demo.name);<span class="comment">//得到被继承的属性</span></span><br></pre></td></tr></table></figure></p>
<h3 id="javascript作用链域"><a href="#javascript作用链域" class="headerlink" title="javascript作用链域?"></a>javascript作用链域?</h3><p> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。<br> 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，<br> 直至全局函数，这种组织形式就是作用域链。</p>
<p>用原生javascript的实现过什么功能吗？</p>
<h3 id="Ajax-是什么-如何创建一个Ajax？"><a href="#Ajax-是什么-如何创建一个Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个Ajax？"></a>Ajax 是什么? 如何创建一个Ajax？</h3><p> ajax的全称：Asynchronous javascript And XML。<br> 异步传输+js+xml。<br> 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p>
<p> (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br> (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br> (3)设置响应HTTP请求状态变化的函数<br> (4)发送HTTP请求<br> (5)获取异步调用返回的数据<br> (6)使用javascript和DOM实现局部刷新</p>
<h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点?"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</h3><p> （1）创建新节点<br>    createDocumentFragment()    //创建一个DOM片段<br>    createElement()   //创建一个具体的元素<br>    createTextNode()   //创建一个文本节点<br>  （2）添加、移除、替换、插入<br>    appendChild()<br>    removeChild()<br>    replaceChild()<br>    insertBefore() //在已有的子节点前插入一个新的子节点<br>  （3）查找<br>    getElementsByTagName()    //通过标签名称<br>    getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>    getElementById()    //通过元素Id，唯一性</p>
<h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h3><p> 例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);</p>
<p>   注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</p>
<pre><code>function add(a,b)
{
    alert(a+b);
}

function sub(a,b)
{
    alert(a-b);
}

add.call(sub,3,1);
</code></pre><h3 id="JS-怎么实现一个类。怎么实例化这个类"><a href="#JS-怎么实现一个类。怎么实例化这个类" class="headerlink" title="JS 怎么实现一个类。怎么实例化这个类"></a>JS 怎么实现一个类。怎么实例化这个类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.study=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'我会学习'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'我会吃饭'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="javascript中的作用域与变量声明提升？"><a href="#javascript中的作用域与变量声明提升？" class="headerlink" title="javascript中的作用域与变量声明提升？"></a>javascript中的作用域与变量声明提升？</h3><p>如何编写高性能的javascript？<br>那些操作会造成内存泄漏？<br> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<p> setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br> 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）<br>angular vue react的优缺点</p>
<p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</p>
<p>请介绍一下JS之事件节流？</p>
<h3 id="什么是JS的函数防抖？"><a href="#什么是JS的函数防抖？" class="headerlink" title="什么是JS的函数防抖？"></a>什么是JS的函数防抖？</h3><p>函数防抖(debounce)</p>
<p>概念： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
<p>生活中的实例： 如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。</p>
<p>函数节流(throttle)</p>
<p>概念： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p>
<p>生活中的实例： 我们知道目前的一种说法是当 1 秒内连续播放 24 张以上的图片时，在人眼的视觉中就会形成一个连贯的动画，所以在电影的播放（以前是，现在不知道）中基本是以每秒 24 张的速度播放的，为什么不 100 张或更多是因为 24 张就可以满足人类视觉需求的时候，100 张就会显得很浪费资源。</p>
<p>应用场景</p>
<p>对于函数防抖，有以下几种应用场景：</p>
<p>给按钮加函数防抖防止表单多次提交。<br>对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数。<br>判断 scroll 是否滑到底部， 滚动事件 + 函数防抖<br>总的来说，适合多次事件 一次响应 的情况</p>
<p>对于函数节流，有如下几个场景：</p>
<p>游戏中的刷新率<br>DOM元素拖拽<br>Canvas画笔功能</p>
<h3 id="描述一下React-生命周期"><a href="#描述一下React-生命周期" class="headerlink" title="描述一下React 生命周期"></a>描述一下React 生命周期</h3><p>   初始化</p>
<ul>
<li>constructor</li>
<li>getInitialState</li>
<li>getDefaultProps</li>
<li>componentWillMount</li>
<li>render</li>
<li><p>componentDidMount<br>  更新过程</p>
</li>
<li><p>componentWillReceiveProps</p>
</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li><p>componentDidUpdate</p>
<p> 卸载过程</p>
</li>
<li><p>componentWillUnmount</p>
</li>
</ul>
<h3 id="React-router-路由的实现原理？"><a href="#React-router-路由的实现原理？" class="headerlink" title="React-router 路由的实现原理？"></a>React-router 路由的实现原理？</h3><p>说说React Native,Weex框架的实现原理？</p>
<p>React为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？<br>用过 React 技术栈中哪些数据流管理库？<br>Redux\Dva </p>
<h3 id="Redux是如何做到可预测呢？"><a href="#Redux是如何做到可预测呢？" class="headerlink" title="Redux是如何做到可预测呢？"></a>Redux是如何做到可预测呢？</h3><p>Redux将React组件划分为哪两种？</p>
<h3 id="Redux是如何将state注入到React组件上的？"><a href="#Redux是如何将state注入到React组件上的？" class="headerlink" title="Redux是如何将state注入到React组件上的？"></a>Redux是如何将state注入到React组件上的？</h3><h3 id="请描述一次完整的-Redux-数据流"><a href="#请描述一次完整的-Redux-数据流" class="headerlink" title="请描述一次完整的 Redux 数据流"></a>请描述一次完整的 Redux 数据流</h3><h3 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h3><p>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，<br>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、<br>到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p>
<p>详细版：<br>1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>4、进行HTTP协议会话，客户端发送报头(请求报头);<br>5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>6、进入部署好的后端应用，如 PHP、Java、javascript、Python 等，找到对应的请求处理;<br>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
<p>简洁版：<br>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；<br>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；<br>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；<br>载入解析到的资源文件，渲染页面，完成。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="1-JS基本的数据类型和引用类型"><a href="#1-JS基本的数据类型和引用类型" class="headerlink" title="1. JS基本的数据类型和引用类型"></a>1. JS基本的数据类型和引用类型</h3><p>基本数据类型：number、string、null、undefined、boolean、symbol – 栈<br>引用数据类型：object、array、function – 堆<br>两种数据类型存储位置不同<br>原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；<br>引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。<br>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
<h3 id="2-介绍JS的内置对象"><a href="#2-介绍JS的内置对象" class="headerlink" title="2.介绍JS的内置对象"></a>2.介绍JS的内置对象</h3><p>数据封装类对象：Object、String、Number、Boolean、Array<br>其他对象：Function、Data、Math、Arguments、RegExp、Error<br>ES6新增对象：Promise、Proxy、Map、Set、Symbol、Reflect</p>
<h3 id="5-对闭包的理解"><a href="#5-对闭包的理解" class="headerlink" title="5.对闭包的理解"></a>5.对闭包的理解</h3><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数里创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链，将函数内部的变量和方法传递到外部</p>
<p>闭包的特性：函数内嵌套函数；内部函数可以引用外部的参数和变量；参数和变量不会被垃圾回收机制回收</p>
<h3 id="6-http状态码有哪些"><a href="#6-http状态码有哪些" class="headerlink" title="6.http状态码有哪些"></a>6.http状态码有哪些</h3><p>简单版</p>
<p>  100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>  200  OK         正常返回信息<br>  201  Created    请求成功并且服务器创建了新的资源<br>  202  Accepted   服务器已接受请求，但尚未处理<br>  301  Moved Permanently  请求的网页已永久移动到新位置。<br>  302 Found       临时性重定向。<br>  303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。<br>  304  Not Modified 自从上次请求后，请求的网页未修改过。</p>
<p>  400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>  401 Unauthorized 请求未授权。<br>  403 Forbidden   禁止访问。<br>  404 Not Found   找不到如何与 URI 相匹配的资源。</p>
<p>  500 Internal Server Error  最常见的服务器端错误。<br>  503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。<br>完整版</p>
<p>  1**(信息类)：表示接收到请求并且继续处理<br>    100——客户必须继续发出请求<br>    101——客户要求服务器根据请求转换HTTP协议版本</p>
<p>  2**(响应成功)：表示动作被成功接收、理解和接受<br>    200——表明该请求被成功地完成，所请求的资源发送回客户端<br>    201——提示知道新文件的URL<br>    202——接受和处理、但处理未完成<br>    203——返回信息不确定或不完整<br>    204——请求收到，但返回信息为空<br>    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>    206——服务器已经完成了部分用户的GET请求</p>
<p>  3**(重定向类)：为了完成指定的动作，必须接受进一步处理<br>    300——请求的资源可在多处得到<br>    301——本网页被永久性转移到另一个URL<br>    302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。<br>    303——建议客户访问其他URL或访问方式<br>    304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用<br>    305——请求的资源必须从服务器指定的地址得到<br>    306——前一版本HTTP中使用的代码，现行版本中不再使用<br>    307——申明请求的资源临时性删除</p>
<p>  4**(客户端错误类)：请求包含错误语法或不能正确执行<br>    400——客户端请求有语法错误，不能被服务器所理解<br>    401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>    402——保留有效ChargeTo头响应<br>    403——禁止访问，服务器收到请求，但是拒绝提供服务<br>    404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL<br>    405——用户在Request-Line字段定义的方法不允许<br>    406——根据用户发送的Accept拖，请求资源不可访问<br>    407——类似401，用户必须首先在代理服务器上得到授权<br>    408——客户端没有在用户指定的饿时间内完成请求<br>    409——对当前资源状态，请求不能完成<br>    410——服务器上不再有此资源且无进一步的参考地址<br>    411——服务器拒绝用户定义的Content-Length属性请求<br>    412——一个或多个请求头字段在当前请求中错误<br>    413——请求的资源大于服务器允许的大小<br>    414——请求的资源URL长于服务器允许的长度<br>    415——请求资源不支持请求项目格式<br>    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p>
<p>  5**(服务端错误类)：服务器不能正确执行一个正确的请求<br>    500 - 服务器遇到错误，无法完成请求<br>    502 - 网关错误<br>    503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</p>
<h3 id="7-描述浏览器渲染的过程，DOM书和渲染树的区别"><a href="#7-描述浏览器渲染的过程，DOM书和渲染树的区别" class="headerlink" title="7.描述浏览器渲染的过程，DOM书和渲染树的区别"></a>7.描述浏览器渲染的过程，DOM书和渲染树的区别</h3><p>浏览器渲染过程：</p>
<p>解析HTML构建DOM，并行请求css、image、js<br>css文件下载完成，开始构建CSSOM（CSS树）<br>CSSOM构建结束后，和DOM一起生成Render Tree（渲染树）<br>布局（layout）：计算出每个节点在屏幕中的位置<br>显示：通过显卡把页面画到屏幕上<br>DOM树和渲染树的区别</p>
<p>DOM树与HTML标签一一对应，包括head和隐藏元素<br>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个独立节点都有对应的css属性</p>
<h3 id="8-如何最小化重绘（repaint）和回流（reflow）"><a href="#8-如何最小化重绘（repaint）和回流（reflow）" class="headerlink" title="8.如何最小化重绘（repaint）和回流（reflow）"></a>8.如何最小化重绘（repaint）和回流（reflow）</h3><p>需要创建多个DOM节点时，使用DocumentFragment创建完成后一次性的加入document<br>缓存layout属性值，减少回流次数，如const offsetLeft=element.offsetLeft<br>尽量避免使用table布局（table元素一旦触发回流就会导致table里所有的其他元素回流）<br>避免使用css表达式，因为每次调用都会重新计算值（也会重新加载页面）<br>尽量使用css属性简写<br>将多次修改元素样式合并成一次操作</p>
<h3 id="9-介绍javascript的原型、原型链？有啥特点"><a href="#9-介绍javascript的原型、原型链？有啥特点" class="headerlink" title="9.介绍javascript的原型、原型链？有啥特点"></a>9.介绍javascript的原型、原型链？有啥特点</h3><p>原型：</p>
<p>javascript的所有对象中都包含了一个 (<strong>proto</strong> ) 内部属性，这个属性所对应的就是该对象的原型<br>javascript的函数对象，除了原型 (<strong>proto</strong>) 之外，还预置了 prototype 属性<br>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型( <strong>proto</strong>)。<br>原型链：</p>
<p>当一个对象调用的属性/方法自身不存在时，就会去自己(<strong>proto</strong> )关联的前辈 prototype 对象上去找<br>如果没找到，就会去该 prototype 原型 ( <strong>proto</strong>) 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”<br>原型特点：</p>
<p>javascript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</p>
<h3 id="10-javascript如何实现继承"><a href="#10-javascript如何实现继承" class="headerlink" title="10.javascript如何实现继承"></a>10.javascript如何实现继承</h3><p>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Apple</span>(<span class="params">size, num</span>) </span>&#123;</span><br><span class="line">    Fruit.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6使用extends继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实例继承：将子对象的prototype指向父对象的一个实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple.prototype = <span class="keyword">new</span> Fruit()</span><br><span class="line">Apple.prototype.constructor = Apple</span><br></pre></td></tr></table></figure></p>
<p>原型继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">  　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">  　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">  　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">  　　　   c[i] = p[i];</span><br><span class="line">  　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-什么是window对象，什么是Document对象"><a href="#11-什么是window对象，什么是Document对象" class="headerlink" title="11.什么是window对象，什么是Document对象"></a>11.什么是window对象，什么是Document对象</h3><p>Window 对象表示当前浏览器的窗口，是javascript的顶级对象。<br>我们创建的所有对象、函数、变量都是 Window 对象的成员。<br>Window 对象的方法和属性是在全局范围内有效的。<br>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）<br>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问<br>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问</p>
<h3 id="12-在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？"><a href="#12-在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？" class="headerlink" title="12. 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？"></a>12. 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</h3><p>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）<br>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获<br>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</p>
<h3 id="13-事件的代理-委托"><a href="#13-事件的代理-委托" class="headerlink" title="13. 事件的代理/委托"></a>13. 事件的代理/委托</h3><p>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件<br>优点：</p>
<p>可以减少事件注册，节省大量内存占用<br>可以将事件应用于动态添加的子元素上<br>缺点：</p>
<p>使用不当会造成事件在不应该触发时触发</p>
<h3 id="14-编写一个方法-求一个字符串的字节长度"><a href="#14-编写一个方法-求一个字符串的字节长度" class="headerlink" title="14. 编写一个方法 求一个字符串的字节长度"></a>14. 编写一个方法 求一个字符串的字节长度</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetBytes</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = str.length;</span><br><span class="line">    <span class="keyword">var</span> bytes = len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) bytes++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line">alert(GetBytes(<span class="string">"你好,as"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="15-列举一下javascript数组和对象有哪些原生方法？"><a href="#15-列举一下javascript数组和对象有哪些原生方法？" class="headerlink" title="15. 列举一下javascript数组和对象有哪些原生方法？"></a>15. 列举一下javascript数组和对象有哪些原生方法？</h3><p>数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr.concat(arr1, arr2, arrn);</span><br><span class="line">arr.join(<span class="string">","</span>);</span><br><span class="line">arr.sort(func);</span><br><span class="line">arr.pop();</span><br><span class="line">arr.push(e1, e2, en);</span><br><span class="line">arr.shift();</span><br><span class="line">arr.unshift(e1, e2, en);</span><br><span class="line">arr.reverse();</span><br><span class="line">arr.slice(start, end);</span><br><span class="line">arr.splice(index, count, e1, e2, en);</span><br><span class="line">arr.indexOf(el);</span><br><span class="line">arr.includes(el); <span class="comment">// ES6</span></span><br></pre></td></tr></table></figure></p>
<p>对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object.hasOwnProperty(prop);</span><br><span class="line">object.propertyIsEnumerable(prop);</span><br><span class="line">object.valueOf();</span><br><span class="line">object.toString();</span><br><span class="line">object.toLocaleString();</span><br><span class="line">Class.prototype.isPropertyOf(object);</span><br></pre></td></tr></table></figure></p>
<h3 id="栈内存、堆内存和预处理"><a href="#栈内存、堆内存和预处理" class="headerlink" title="栈内存、堆内存和预处理"></a>栈内存、堆内存和预处理</h3><h3 id="闭包，prototype链，内存分配的概念和应用"><a href="#闭包，prototype链，内存分配的概念和应用" class="headerlink" title="闭包，prototype链，内存分配的概念和应用"></a>闭包，prototype链，内存分配的概念和应用</h3><p><a href="https://juejin.im/post/5bb470295188255c5e66f88f?utm_source=gold_browser_extension#heading-7" target="_blank" rel="noopener">https://juejin.im/post/5bb470295188255c5e66f88f?utm_source=gold_browser_extension#heading-7</a></p>
<p>实现双向绑定的哪几种手法(观察者、渲染劫持、脏检测)</p>

            <div class="post-copyright">
    <div class="content">
        <!-- <p>最后更新： 2019年11月12日 15:10</p> -->
        <p>转载请保持原始链接</p>
        <p>原始链接： <a class="post-url" href="/note/16840463.html" title="11月份整理的知识点">https://ru23.com/note/16840463.html</a></p>
        <footer>
            <a href="https://ru23.com">
                <img src="//cdn.ru23.com/img/images/chrome.png" alt="frank">
                frank
            </a>
        </footer>
    </div>
</div>

            
            
            

            
        </div>
        <footer class="article-footer">
            
            
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://ru23.com/note/16840463.html&title=《11月份整理的知识点》 — 前端迷&pic=//cdn.ru23.com/img/images/chrome.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://ru23.com/note/16840463.html&title=《11月份整理的知识点》 — 前端迷&source=frank，前端开发爱好者，沉迷前端，无法自拔,欢迎一切技术交流（不局限于前端），邮箱fanqianweb@gmail.com" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://ru23.com/note/16840463.html" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《11月份整理的知识点》 — 前端迷&url=https://ru23.com/note/16840463.html&via=https://ru23.com" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://ru23.com/note/16840463.html" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABzklEQVR42u3aSY7CQAwFUO5/6fS2pc7wbVPVIL1aIUjCg4Xl6fWKz/HrVK/5+37ytNHBxcUdc4/bc3VNcu/V9Vev7+/FxcXdz72KGL1HJ2Hr6voHGy4u7gdz85+RJEO4uLjfzr2/6z55wsXF/S7upGi55ybEJbUaLi7ugJt3Kde9XtLfxcXFbXGP4slD0ry9cvLtuLi4W7i9MiZPX+4Hrr3vxcXFXc09WqfXKu2VSSf/Ky4u7hbue1evkhQnf85JIMPFxd3CrRYzkxWKfGRychcuLu5GbnXwWe1h9oYrl8UPLi7uYm6+KtFbvaomT4XWCS4u7jJuQiz3X4MwVy2cChkZLi7umFsdmlZDWK8oevj7cHFxF3Mnrcze0LSaq0S1Gi4u7lu57y1+kvcnK6G4uLg7ub0hSjXM9ZKkaAkDFxd3Mbc3ICknKEFR9FCr4eLibuTmrc/JoCUJi9HHuLi4C7hH8eQt0WpRFP0wXFzcLdxqcEnWrXp35ekOLi7uHm41eE0+fcN4BhcXdyN3vh6RjE+SCPpwFy4u7kdy8zFJvtJRGN7g4uJ+PLc3Oh21UHFxcTdyJ0tXSSnVS5twcXH/i9sbfPYSlN5KBy4u7kbuD7CJkJ8soKVIAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>

<div class="mask"></div>

            
            <ul class="article-footer-menu">
                
                
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/知识点/" class="color4">知识点</a>
      
  </li>

            </ul>
            
        </footer>
    </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#理解事件原理"><span class="post-toc-text">理解事件原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6"><span class="post-toc-text">ES6</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Redux"><span class="post-toc-text">Redux</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Virtual-DOM"><span class="post-toc-text">Virtual DOM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#浏览器渲染原理"><span class="post-toc-text">浏览器渲染原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JS中EventLoop事件循环机制"><span class="post-toc-text">JS中EventLoop事件循环机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript-内存模型"><span class="post-toc-text">javascript 内存模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#箭头函数和普通函数有什么区别"><span class="post-toc-text">箭头函数和普通函数有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue和react的比较，不同点"><span class="post-toc-text">vue和react的比较，不同点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js处理异步的几种方式"><span class="post-toc-text">js处理异步的几种方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Cookie、session和localStorage的区别"><span class="post-toc-text">Cookie、session和localStorage的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何获悉一个对象的具体类型"><span class="post-toc-text">如何获悉一个对象的具体类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#prototype"><span class="post-toc-text">prototype</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#问call和apply的作用是什么？区别是什么？"><span class="post-toc-text">问call和apply的作用是什么？区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js的事件流"><span class="post-toc-text">js的事件流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谈谈http协议"><span class="post-toc-text">谈谈http协议</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-看项目中使用了dva，为什么要用dva？直接用saga也能达到同样的效果，dva相比好在哪里？"><span class="post-toc-text">1. 看项目中使用了dva，为什么要用dva？直接用saga也能达到同样的效果，dva相比好在哪里？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-说说react的单向数据流。"><span class="post-toc-text">2. 说说react的单向数据流。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-http请求的状态码"><span class="post-toc-text">7.http请求的状态码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#哪些流行的前端技术，对前端的前景和职责"><span class="post-toc-text">哪些流行的前端技术，对前端的前景和职责</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><span class="post-toc-text">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript原型，原型链-有什么特点？"><span class="post-toc-text">javascript原型，原型链 ? 有什么特点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript有几种类型的值？，你能画一下他们的内存图吗？"><span class="post-toc-text">javascript有几种类型的值？，你能画一下他们的内存图吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript作用链域"><span class="post-toc-text">javascript作用链域?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Ajax-是什么-如何创建一个Ajax？"><span class="post-toc-text">Ajax 是什么? 如何创建一个Ajax？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><span class="post-toc-text">DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#call-和-apply-的区别？"><span class="post-toc-text">.call() 和 .apply() 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JS-怎么实现一个类。怎么实例化这个类"><span class="post-toc-text">JS 怎么实现一个类。怎么实例化这个类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript中的作用域与变量声明提升？"><span class="post-toc-text">javascript中的作用域与变量声明提升？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是JS的函数防抖？"><span class="post-toc-text">什么是JS的函数防抖？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#描述一下React-生命周期"><span class="post-toc-text">描述一下React 生命周期</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-router-路由的实现原理？"><span class="post-toc-text">React-router 路由的实现原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Redux是如何做到可预测呢？"><span class="post-toc-text">Redux是如何做到可预测呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Redux是如何将state注入到React组件上的？"><span class="post-toc-text">Redux是如何将state注入到React组件上的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#请描述一次完整的-Redux-数据流"><span class="post-toc-text">请描述一次完整的 Redux 数据流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><span class="post-toc-text">一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#快速排序"><span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-JS基本的数据类型和引用类型"><span class="post-toc-text">1. JS基本的数据类型和引用类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-介绍JS的内置对象"><span class="post-toc-text">2.介绍JS的内置对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-对闭包的理解"><span class="post-toc-text">5.对闭包的理解</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-http状态码有哪些"><span class="post-toc-text">6.http状态码有哪些</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-描述浏览器渲染的过程，DOM书和渲染树的区别"><span class="post-toc-text">7.描述浏览器渲染的过程，DOM书和渲染树的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-如何最小化重绘（repaint）和回流（reflow）"><span class="post-toc-text">8.如何最小化重绘（repaint）和回流（reflow）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-介绍javascript的原型、原型链？有啥特点"><span class="post-toc-text">9.介绍javascript的原型、原型链？有啥特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-javascript如何实现继承"><span class="post-toc-text">10.javascript如何实现继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11-什么是window对象，什么是Document对象"><span class="post-toc-text">11.什么是window对象，什么是Document对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？"><span class="post-toc-text">12. 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-事件的代理-委托"><span class="post-toc-text">13. 事件的代理/委托</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#14-编写一个方法-求一个字符串的字节长度"><span class="post-toc-text">14. 编写一个方法 求一个字符串的字节长度</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#15-列举一下javascript数组和对象有哪些原生方法？"><span class="post-toc-text">15. 列举一下javascript数组和对象有哪些原生方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#栈内存、堆内存和预处理"><span class="post-toc-text">栈内存、堆内存和预处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#闭包，prototype链，内存分配的概念和应用"><span class="post-toc-text">闭包，prototype链，内存分配的概念和应用</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/note/54b36672.html" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          浅谈styled-components
        
      </span>
    </a>
  
  
    <a href="/note/57b0b360.html" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">es6在react中的应用</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>




<!-- Valine Comments -->
<div class="comments vcomment" id="comments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<!-- Valine Comments script -->
<script>
    var GUEST_INFO = ['nick', 'mail', 'link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function (item) {
        return GUEST_INFO.indexOf(item) > -1
    });
    new Valine({
        el: '#comments',
        notify: 'true' == 'true',
        verify: 'false' == 'true',
        appId: "OOiJvCREqswvpnTL4RuSShLq-gzGzoHsz",
        appKey: "OPfVBB2YjMrT3ngcc8mu6w8g",
        avatar: "mm",
        qrcode: "",
        placeholder: "输入评论...",
        guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
        pageSize: "10"
    })
</script>
<!-- Valine Comments end -->

</section>
            <div class="outer-ad-aside" id="outer-ad-aside">
                
                  
                    <a title="腾讯云：11.11 爆品秒杀" target="_blank" href="https://cloud.tencent.com/act/cps/redirect?redirect=1049&cps_key=3bd05bbfb4f3f97d7bb5964ef12edda9&from=console">
                      
                        <div class="ad-text" style='text-align:center;color: red;'>
                          腾讯云双11爆品秒杀，活动截止2019-12-02
                        </div>
                      
                      <img src="https://upload-dianshi-1255598498.file.myqcloud.com/345-200-2e775f9b5cb10db244b6bd2791a26f7e862701a5.jpg" alt="腾讯云：11.11 爆品秒杀">
                    </a>
                  
                    <a title="阿里云Hi拼团" target="_blank" href="https://www.aliyun.com/acts/hi-group-buying-share?ptCode=6BF0A48A53ED78A511EDC58935AD349589B9F59A2D8E8A59&userCode=jh5fwy2j&activityId=3&share_source=copy_link">
                      
                        <div class="ad-text" style='text-align:center;color: red;'>
                          阿里云Hi拼团，活动截止2019-12-12
                        </div>
                      
                      <img src="https://img.alicdn.com/tfs/TB1w1T2mrj1gK0jSZFuXXcrHpXa-1880-640.png" alt="阿里云Hi拼团">
                    </a>
                  
                    <a title="阿里返利" target="_blank" href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=jh5fwy2j">
                      
                        <div class="ad-text" style='text-align:center;color: red;'>
                          阿里云新老用户通用红包
                        </div>
                      
                      <img src="https://img.alicdn.com/tfs/TB1Gc3zmAL0gK0jSZFxXXXWHVXa-259-194.jpg" alt="阿里返利">
                    </a>
                  
                    <a title="微信公众号：前端迷" target="_blank" ">
                      
                      <img src="//cdn.ru23.com/hexo/public/wechat-mp.png" alt="微信公众号：前端迷">
                    </a>
                  
                    <a title="微信前端技术交流群" target="_blank" ">
                      
                      <img src="//cdn.ru23.com/hexo/public/group.png" alt="微信前端技术交流群">
                    </a>
                  
                
            </div>
          </div>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        <!-- Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a> -->
        &copy; 2019 frank<br>
      </p>
    </div>
  </div>
</footer>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="https://js.fundebug.cn/fundebug.1.5.1.min.js" apikey="912ba8d8c6f372862c218e996a28cebb732bbb78559e974fc031204c813142f9"></script>
<script>
  var mihoConfig = {
    root: "https://ru23.com",
    animate: false,
    isHome: false,
    share: true,
    reward: 2
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/algorithm/">algorithm</a><a class="category-link" href="/categories/back-end/">back-end</a><a class="category-link" href="/categories/fed-shared/">fed-shared</a><a class="category-link" href="/categories/front-end/">front-end</a><a class="category-link" href="/categories/hexo/">hexo</a><a class="category-link" href="/categories/todolist/">todolist</a><a class="category-link" href="/categories/tools/">tools</a><a class="category-link" href="/categories/前端自动化/">前端自动化</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/CSS/" style="font-size: 13.08px;">CSS</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/HTTP/" style="font-size: 10.77px;">HTTP</a> <a href="/tags/Immutable/" style="font-size: 11.54px;">Immutable</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/Snippet/" style="font-size: 13.08px;">Snippet</a> <a href="/tags/Vue/" style="font-size: 13.08px;">Vue</a> <a href="/tags/ajax/" style="font-size: 11.54px;">ajax</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/api/" style="font-size: 12.31px;">api</a> <a href="/tags/atom/" style="font-size: 10px;">atom</a> <a href="/tags/axios/" style="font-size: 12.31px;">axios</a> <a href="/tags/bootstrap/" style="font-size: 10.77px;">bootstrap</a> <a href="/tags/canvas/" style="font-size: 11.54px;">canvas</a> <a href="/tags/cookie/" style="font-size: 10px;">cookie</a> <a href="/tags/css/" style="font-size: 16.15px;">css</a> <a href="/tags/dom/" style="font-size: 13.08px;">dom</a> <a href="/tags/dva/" style="font-size: 11.54px;">dva</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/editconfig/" style="font-size: 10px;">editconfig</a> <a href="/tags/es6/" style="font-size: 13.85px;">es6</a> <a href="/tags/eslint/" style="font-size: 10.77px;">eslint</a> <a href="/tags/fed-shared/" style="font-size: 11.54px;">fed-shared</a> <a href="/tags/fetch/" style="font-size: 10px;">fetch</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/front-end/" style="font-size: 10px;">front-end</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 11.54px;">github</a> <a href="/tags/gulp/" style="font-size: 10.77px;">gulp</a> <a href="/tags/hexo/" style="font-size: 10.77px;">hexo</a> <a href="/tags/hide/" style="font-size: 12.31px;">hide</a> <a href="/tags/html5/" style="font-size: 16.92px;">html5</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/hybrid/" style="font-size: 10px;">hybrid</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/jquery/" style="font-size: 17.69px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js代码片段/" style="font-size: 12.31px;">js代码片段</a> <a href="/tags/mock/" style="font-size: 10px;">mock</a> <a href="/tags/ms/" style="font-size: 10px;">ms</a> <a href="/tags/mvvm/" style="font-size: 11.54px;">mvvm</a> <a href="/tags/nginx/" style="font-size: 12.31px;">nginx</a> <a href="/tags/node/" style="font-size: 13.85px;">node</a> <a href="/tags/npm/" style="font-size: 13.08px;">npm</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/react/" style="font-size: 19.23px;">react</a> <a href="/tags/redux/" style="font-size: 13.08px;">redux</a> <a href="/tags/sublime/" style="font-size: 15.38px;">sublime</a> <a href="/tags/svn/" style="font-size: 10.77px;">svn</a> <a href="/tags/taro/" style="font-size: 10px;">taro</a> <a href="/tags/todo/" style="font-size: 10.77px;">todo</a> <a href="/tags/todolist/" style="font-size: 10px;">todolist</a> <a href="/tags/video/" style="font-size: 10px;">video</a> <a href="/tags/vscode/" style="font-size: 11.54px;">vscode</a> <a href="/tags/vue/" style="font-size: 18.46px;">vue</a> <a href="/tags/vuex/" style="font-size: 10.77px;">vuex</a> <a href="/tags/webpack/" style="font-size: 13.08px;">webpack</a> <a href="/tags/webstorm/" style="font-size: 10px;">webstorm</a> <a href="/tags/xhtml/" style="font-size: 10px;">xhtml</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事件/" style="font-size: 10px;">事件</a> <a href="/tags/事件流/" style="font-size: 10px;">事件流</a> <a href="/tags/优质文章分享/" style="font-size: 11.54px;">优质文章分享</a> <a href="/tags/作用域/" style="font-size: 10px;">作用域</a> <a href="/tags/前端优化/" style="font-size: 10.77px;">前端优化</a> <a href="/tags/前端基础/" style="font-size: 10px;">前端基础</a> <a href="/tags/前端自动化/" style="font-size: 10px;">前端自动化</a> <a href="/tags/前端规范/" style="font-size: 14.62px;">前端规范</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/小程序/" style="font-size: 13.85px;">小程序</a> <a href="/tags/居中/" style="font-size: 10px;">居中</a> <a href="/tags/异步回调/" style="font-size: 10px;">异步回调</a> <a href="/tags/微信开发/" style="font-size: 11.54px;">微信开发</a> <a href="/tags/快应用/" style="font-size: 10px;">快应用</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/排序算法/" style="font-size: 10px;">排序算法</a> <a href="/tags/最佳实践/" style="font-size: 10px;">最佳实践</a> <a href="/tags/正则表达式/" style="font-size: 10.77px;">正则表达式</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/知识点/" style="font-size: 11.54px;">知识点</a> <a href="/tags/移动端/" style="font-size: 13.08px;">移动端</a> <a href="/tags/组件化/" style="font-size: 10px;">组件化</a> <a href="/tags/继承/" style="font-size: 10.77px;">继承</a> <a href="/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/tags/读书笔记/" style="font-size: 10.77px;">读书笔记</a> <a href="/tags/跨域/" style="font-size: 11.54px;">跨域</a> <a href="/tags/踩过的坑/" style="font-size: 16.92px;">踩过的坑</a> <a href="/tags/适配/" style="font-size: 10px;">适配</a> <a href="/tags/速查表/" style="font-size: 10px;">速查表</a> <a href="/tags/部署/" style="font-size: 10.77px;">部署</a> <a href="/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/tags/面向对象/" style="font-size: 10.77px;">面向对象</a> <a href="/tags/面试/" style="font-size: 12.31px;">面试</a> <a href="/tags/高阶函数/" style="font-size: 10.77px;">高阶函数</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a href="/">
                    <i class="fa fa-home"></i><span>主页</span>
                </a>
            </li>
            
            <li>
                <a href="/archives">
                    <i class="fa fa-archive"></i><span>归档</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/CSS/" style="font-size: 13.08px;">CSS</a> <a href="/tags/Emmet/" style="font-size: 10px;">Emmet</a> <a href="/tags/HTTP/" style="font-size: 10.77px;">HTTP</a> <a href="/tags/Immutable/" style="font-size: 11.54px;">Immutable</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/Snippet/" style="font-size: 13.08px;">Snippet</a> <a href="/tags/Vue/" style="font-size: 13.08px;">Vue</a> <a href="/tags/ajax/" style="font-size: 11.54px;">ajax</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/api/" style="font-size: 12.31px;">api</a> <a href="/tags/atom/" style="font-size: 10px;">atom</a> <a href="/tags/axios/" style="font-size: 12.31px;">axios</a> <a href="/tags/bootstrap/" style="font-size: 10.77px;">bootstrap</a> <a href="/tags/canvas/" style="font-size: 11.54px;">canvas</a> <a href="/tags/cookie/" style="font-size: 10px;">cookie</a> <a href="/tags/css/" style="font-size: 16.15px;">css</a> <a href="/tags/dom/" style="font-size: 13.08px;">dom</a> <a href="/tags/dva/" style="font-size: 11.54px;">dva</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/editconfig/" style="font-size: 10px;">editconfig</a> <a href="/tags/es6/" style="font-size: 13.85px;">es6</a> <a href="/tags/eslint/" style="font-size: 10.77px;">eslint</a> <a href="/tags/fed-shared/" style="font-size: 11.54px;">fed-shared</a> <a href="/tags/fetch/" style="font-size: 10px;">fetch</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/front-end/" style="font-size: 10px;">front-end</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 11.54px;">github</a> <a href="/tags/gulp/" style="font-size: 10.77px;">gulp</a> <a href="/tags/hexo/" style="font-size: 10.77px;">hexo</a> <a href="/tags/hide/" style="font-size: 12.31px;">hide</a> <a href="/tags/html5/" style="font-size: 16.92px;">html5</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/hybrid/" style="font-size: 10px;">hybrid</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/jquery/" style="font-size: 17.69px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js代码片段/" style="font-size: 12.31px;">js代码片段</a> <a href="/tags/mock/" style="font-size: 10px;">mock</a> <a href="/tags/ms/" style="font-size: 10px;">ms</a> <a href="/tags/mvvm/" style="font-size: 11.54px;">mvvm</a> <a href="/tags/nginx/" style="font-size: 12.31px;">nginx</a> <a href="/tags/node/" style="font-size: 13.85px;">node</a> <a href="/tags/npm/" style="font-size: 13.08px;">npm</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/react/" style="font-size: 19.23px;">react</a> <a href="/tags/redux/" style="font-size: 13.08px;">redux</a> <a href="/tags/sublime/" style="font-size: 15.38px;">sublime</a> <a href="/tags/svn/" style="font-size: 10.77px;">svn</a> <a href="/tags/taro/" style="font-size: 10px;">taro</a> <a href="/tags/todo/" style="font-size: 10.77px;">todo</a> <a href="/tags/todolist/" style="font-size: 10px;">todolist</a> <a href="/tags/video/" style="font-size: 10px;">video</a> <a href="/tags/vscode/" style="font-size: 11.54px;">vscode</a> <a href="/tags/vue/" style="font-size: 18.46px;">vue</a> <a href="/tags/vuex/" style="font-size: 10.77px;">vuex</a> <a href="/tags/webpack/" style="font-size: 13.08px;">webpack</a> <a href="/tags/webstorm/" style="font-size: 10px;">webstorm</a> <a href="/tags/xhtml/" style="font-size: 10px;">xhtml</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/事件/" style="font-size: 10px;">事件</a> <a href="/tags/事件流/" style="font-size: 10px;">事件流</a> <a href="/tags/优质文章分享/" style="font-size: 11.54px;">优质文章分享</a> <a href="/tags/作用域/" style="font-size: 10px;">作用域</a> <a href="/tags/前端优化/" style="font-size: 10.77px;">前端优化</a> <a href="/tags/前端基础/" style="font-size: 10px;">前端基础</a> <a href="/tags/前端自动化/" style="font-size: 10px;">前端自动化</a> <a href="/tags/前端规范/" style="font-size: 14.62px;">前端规范</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/小程序/" style="font-size: 13.85px;">小程序</a> <a href="/tags/居中/" style="font-size: 10px;">居中</a> <a href="/tags/异步回调/" style="font-size: 10px;">异步回调</a> <a href="/tags/微信开发/" style="font-size: 11.54px;">微信开发</a> <a href="/tags/快应用/" style="font-size: 10px;">快应用</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/排序算法/" style="font-size: 10px;">排序算法</a> <a href="/tags/最佳实践/" style="font-size: 10px;">最佳实践</a> <a href="/tags/正则表达式/" style="font-size: 10.77px;">正则表达式</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/知识点/" style="font-size: 11.54px;">知识点</a> <a href="/tags/移动端/" style="font-size: 13.08px;">移动端</a> <a href="/tags/组件化/" style="font-size: 10px;">组件化</a> <a href="/tags/继承/" style="font-size: 10.77px;">继承</a> <a href="/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/tags/读书笔记/" style="font-size: 10.77px;">读书笔记</a> <a href="/tags/跨域/" style="font-size: 11.54px;">跨域</a> <a href="/tags/踩过的坑/" style="font-size: 16.92px;">踩过的坑</a> <a href="/tags/适配/" style="font-size: 10px;">适配</a> <a href="/tags/速查表/" style="font-size: 10px;">速查表</a> <a href="/tags/部署/" style="font-size: 10.77px;">部署</a> <a href="/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/tags/面向对象/" style="font-size: 10.77px;">面向对象</a> <a href="/tags/面试/" style="font-size: 12.31px;">面试</a> <a href="/tags/高阶函数/" style="font-size: 10.77px;">高阶函数</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="//cdn.ru23.com/js/search.js"></script>
<script src="//cdn.ru23.com/js/main.js"></script>









<script src="//cdn.ru23.com/js/pop-img.js"></script>
<script>
  $(".article-entry p img").popImg();
</script>

  </div>
<script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script></body>
</html>