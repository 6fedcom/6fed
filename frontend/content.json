{"meta":{"title":"前端迷 (front-end fan)","subtitle":"欢迎投稿、合作，交流QQ：188105274(微信，邮箱同Q)","description":"前端开发爱好者frank的工作笔记","author":"frank","url":"https://ru23.com"},"pages":[{"title":"前端资讯分享","date":"2018-09-04T11:52:49.000Z","updated":"2018-09-20T03:46:25.556Z","comments":true,"path":"share/index.html","permalink":"https://ru23.com/share/index.html","excerpt":"","text":""},{"title":"目录","date":"2018-08-27T11:47:23.000Z","updated":"2018-09-30T10:51:59.635Z","comments":false,"path":"categories/index.html","permalink":"https://ru23.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-27T11:26:57.000Z","updated":"2018-09-20T03:30:42.162Z","comments":false,"path":"tags/index.html","permalink":"https://ru23.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"跨域问题携带cookie加入withCredentials保错原因以及解决方案","slug":"2018-10-跨域问题携带cookie加入withCredentials保错原因以及解决方案","date":"2018-10-22T10:26:41.000Z","updated":"2018-10-22T11:19:40.806Z","comments":true,"path":"/frontend/cjnk8twxg003cwwa1zkbfriyt/","link":"","permalink":"https://ru23.com/frontend/cjnk8twxg003cwwa1zkbfriyt/","excerpt":"","text":"1.跨域允许解决方法：服务器发送允许客户端发送源的报文头header(‘Access-Control-Allow-Origin:’.$_SERVER[“HTTP_ORIGIN”]);2.客户端无法携带跨域cookie这个时候就可以在extjs中加入withCredentials1234567891011121314$.ajax(&#123; url: 'http://120.111.111.123/setcookie.php', method: 'POST', params: &#123; 'text': 'hello world' &#125;, withCredentials: true, success: function(transport)&#123; // do something &#125;, failure: function(transport)&#123; alert(\"Error: \" - transport.responseText); &#125;&#125;); 3.因为加了withCredentials报文头，可是客户端不知道服务器允不允许报的错（耿直的客户端）这个时候就在服务器发送Access-Control-Allow-Credentialsheader(‘Access-Control-Allow-Credentials:true’);4.由于客户端不知道服务端是否允许POST请求而报的错这个时候要在服务器端加入123header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;); 以上汇总起来就是12345678header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;); header(&apos;Access-Control-Allow-Origin:&apos;.$_SERVER[&apos;HTTP_ORIGIN&apos;]);header(&apos;Access-Control-Allow-Credentials:true&apos;);header(&apos;Access-Control-Allow-Methods:GET, POST, PUT, DELETE, OPTIONS&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);header(&apos;Access-Control-Allow-Headers:Origin, No-Cache, X-Requested-With, If-Modified-Since, 1.跨域允许不允许报错的跨域12Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. 报这个错就说明我们跨域了，不在允许的访问源，于是乎我在服务的setcookie.php加入header(&#39;Access-Control-Allow-Origin:*&#39;);允许所有源然后又报错1234XMLHttpRequest cannot load http://120.111.111.123/setcookie.php. Request header field X-Requested-With is not allowed by Access-Control-Allow-Headers in preflight response.``` 在跨域的时候，js不会直接发post请求，而是先发送一个option请求，看看服务器允许什么访问头（比如是不是允许post请求），验证成功后才会发送真正的请求 #用谷歌的开发者工具抓的option报文OPTIONS /setcookie.php HTTP/1.1Host: 120.111.111.123Connection: keep-alivePragma: no-cacheCache-Control: no-cacheAccess-Control-Request-Method: POSTOrigin: nullUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36Access-Control-Request-Headers: x-requested-withAccept: /Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.812 #path /setcookie.php session_start();header(‘Access-Control-Allow-Origin:*’); header(‘Access-Control-Allow-Methods:OPTIONS, GET, POST’); // 允许option，get，post请求header(‘Access-Control-Allow-Headers:x-requested-with’); // 允许x-requested-with请求头header(‘Access-Control-Max-Age:86400’); // 允许访问的有效期 // 功能…// …12345678910111213141516171819继续测试我们的新功能，成功的解决了跨域问题但是，cookie没有“设置成功”。而之所以没有“设置成功”，是因为cookie存在本地，但是每个cookie都有一个domain，当你本地的cookie中存在你当前访问的域时，才会被带过去，而我的index.html文件是本地访问的，即http://localhost/index.html，而cookie的域是要跨域的域名的，所以不行了。```js$.ajax(&#123; type: &quot;POST&quot;, url: &quot;跨域的url&quot;, xhrFields: &#123; withCredentials: true &#125;, // 发送凭据 contentType: &quot;application/json; charset=utf-8&quot;, data: JSON.stringify(data), dataType: &quot;json&quot;, success: function (message) &#123; &#125;, error: function (message) &#123; console.log(message) &#125;&#125;); 继续访问，报错123Response to preflight request doesn&apos;t pass access control check: A wildcard &apos;*&apos; cannot be used in the &apos;Access-Control-Allow-Origin&apos; header when the credentials flag is true. Origin &apos;null&apos; is therefore not allowed access. The credentials mode of an XMLHttpRequest is controlled by the withCredentials attribute. 现在这个错误产生的原因就是1.因为加入了withCredentials之后，Access-Control-Allow-Origin就不能用“*”了，既然不允许访问这个源，那我就让你发个报文头让你允许访问呗！ 12345678910111213#path setcookie.phpsession_start();// 是否存在请求源if(isset($_SERVER[&quot;HTTP_ORIGIN&quot;])) &#123; header(&apos;Access-Control-Allow-Origin:&apos;.$_SERVER[&quot;HTTP_ORIGIN&quot;]); &#125;header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;);// 功能...// ... 好了，上传完代码，继续测试。发送请求之后，又报错了12Response to preflight request doesn&apos;t pass access control check: Credentials flag is &apos;true&apos;, but the &apos;Access-Control-Allow-Credentials&apos; header is &apos;&apos;. It must be &apos;true&apos; to allow credentials. Origin &apos;null&apos; is therefore not allowed access. 大概的意思就是说我给你发了withCredentials报文头，但是你服务器没有跟我说允许我带这个报文头，那么解决方法就是加上允许发这个报文头的报文头 123456789101112131415session_start();// 是否存在请求源if(isset($_SERVER[&quot;HTTP_ORIGIN&quot;])) &#123; header(&apos;Access-Control-Allow-Origin:&apos;.$_SERVER[&quot;HTTP_ORIGIN&quot;]); &#125;header(&apos;Access-Control-Allow-Origin:null&apos;); header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;);header(&apos;Access-Control-Allow-Credentials:true&apos;);// 功能...// ... 终于成功了！ 摘自链接：https://www.jianshu.com/p/552daaf2869c來源：简书","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[]},{"title":"输入框input类型为number时，去掉上下箭头样式","slug":"2018-10-输入框input类型为number时，去掉上下箭头方式","date":"2018-10-22T08:57:28.000Z","updated":"2018-10-22T09:55:39.482Z","comments":true,"path":"/frontend/cjnk8twxj003fwwa1za29kfp2/","link":"","permalink":"https://ru23.com/frontend/cjnk8twxj003fwwa1za29kfp2/","excerpt":"","text":"1234567891011&lt;input type=\"number\" ...&gt;&lt;style&gt; input::-webkit-outer-spin-button, input::-webkit-inner-spin-button &#123; -webkit-appearance: none; &#125; input[type=\"number\"]&#123; -moz-appearance: textfield; &#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://ru23.com/tags/html5/"}]},{"title":"蓝灯导致关闭蓝灯后电脑一直异常的解决方案","slug":"2018-10-蓝灯导致关闭蓝灯后电脑一直异常的解决方案","date":"2018-10-04T09:58:17.000Z","updated":"2018-10-22T10:19:18.620Z","comments":true,"path":"/frontend/cjnk8twx80036wwa1lvziev6h/","link":"","permalink":"https://ru23.com/frontend/cjnk8twx80036wwa1lvziev6h/","excerpt":"","text":"电脑关闭Lantern以后发现qq浏览器都没办法上网，这是应为Lantern未完全退出导致，那关闭蓝灯后不能上网怎么解决呢？下面给大家分享关闭蓝灯不能上网的方法。 步骤： 1、按win+r打开运行窗口，输入regedit，如图所示： regedit 2、注册表找到：HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections，然后删除Connections这一目录，如图所示： 删除Connections 以上就是关闭蓝灯后不能上网的解决方法，是不是很简单，有遇到这情况的用户可以参考文中方法进行尝试，希望今天的分享对大家有所帮助。 作者：binkcheng链接：https://www.jianshu.com/p/6193b3410342來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[]},{"title":"开发者工具调试网页授权 确认按钮点击无任何反应","slug":"2018-10-开发者工具调试网页授权-确认按钮点击无任何反应","date":"2018-10-02T11:07:15.000Z","updated":"2018-10-22T09:43:04.938Z","comments":true,"path":"/frontend/cjnk8twxc0039wwa1nmosgek4/","link":"","permalink":"https://ru23.com/frontend/cjnk8twxc0039wwa1nmosgek4/","excerpt":"","text":"场景： qq 20181002084610 解决方法开发者工具调试网页授权 确认按钮点击无任何反应！！！V1以上就会有这个问题 很迷 我看其他社区的回答 说的是 点击“获得你的公开信息”那行字大概就可以，应该是显示屏分辨率的问题","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"微信开发","slug":"微信开发","permalink":"https://ru23.com/tags/微信开发/"}]},{"title":"前端开发最全面试题","slug":"2018-09-前端开发最全面试题","date":"2018-09-30T10:13:33.000Z","updated":"2018-10-22T09:40:51.800Z","comments":true,"path":"/frontend/cjnk8twwo002pwwa17rl7ey8c/","link":"","permalink":"https://ru23.com/frontend/cjnk8twwo002pwwa17rl7ey8c/","excerpt":"","text":"前端问题记录 HTML相关 CSS相关 JAVASCRIPT相关 DOM相关 HTTP相关 VUE相关 算法相关 网络安全相关 webpack相关 其他Html相关1 html语义化意义：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。注意：1.尽可能少的使用无语义的标签div和span；2.在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；3.不要使用纯样式标签，如：b、font、u等，改用css设置。4.需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；5.使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；6.表单域要用fieldset标签包起来，并用legend标签说明表单的用途；7.每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 新标签： h5新元素 2 meta viewport相关1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; H5标准声明，使用 HTML5 doctype，不区分大小写&lt;head lang=”en”&gt; 标准的 lang 属性写法&lt;meta charset=’utf-8′&gt; 声明文档使用的字符编码&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; 优先使用 IE 最新版本和 Chrome&lt;meta name=”description” content=”不超过150个字符”/&gt; 页面描述&lt;meta name=”keywords” content=””/&gt; 页面关键词&lt;meta name=”author” content=”name, email@gmail.com”/&gt; 网页作者&lt;meta name=”robots” content=”index,follow”/&gt; 搜索引擎抓取&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; 为移动设备添加 viewport&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; iOS 设备 begin&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; 添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; 设置苹果工具栏颜色&lt;meta name=”renderer” content=”webkit”&gt; 启用360浏览器的极速模式(webkit)&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; 避免IE使用兼容模式&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; 不让百度转码&lt;meta name=”HandheldFriendly” content=”true”&gt; 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name=”MobileOptimized” content=”320″&gt; 微软的老式浏览器&lt;meta name=”screen-orientation” content=”portrait”&gt; uc强制竖屏&lt;meta name=”x5-orientation” content=”portrait”&gt; QQ强制竖屏&lt;meta name=”full-screen” content=”yes”&gt; UC强制全屏&lt;meta name=”x5-fullscreen” content=”true”&gt; QQ强制全屏&lt;meta name=”browsermode” content=”application”&gt; UC应用模式&lt;meta name=”x5-page-mode” content=”app”&gt; QQ应用模式&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; windows phone 点击无高光设置页面不缓存&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt; 3 canvas 相关1234567使用前需要获得上下文环境，暂不支持3d常用api: 1.fillRect(x,y,width,height)实心矩形 2.strokeRect(x,y,width,height)空心矩形 3.fillText(\"Hello world\",200,200);实心文字 4.strokeText(\"Hello world\",200,300)空心文字各种东西！！！ 新标签兼容低版本 ie9之前版本通过createElement创建html5新标签 引入html5shiv.jsCSS相关1.盒模型1.ie盒模型算上border、padding及自身（不算margin），标准的只算上自身窗体的大小css设置方法如下1234/* 标准模型 */box-sizing:content-box; /*IE模型*/box-sizing:border-box; 2.margin、border、padding、content由外到里3.几种获得宽高的方式 dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。 dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持。 window.getComputedStyle(dom).width/height 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。 dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的 dom.offsetWidth/offsetHeight 这个就没什么好说的了，最常用的，也是兼容最好的。 4.拓展 各种获得宽高的方式 获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width 获取屏幕工作区域的高度和宽度（去掉状态栏）：window.screen.availHeight/availWidth 网页全文的高度和宽度：document.body.scrollHeight/Width 滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft 网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth 网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth 5.边距重叠解决方案(BFC)BFC原理 内部的box会在垂直方向，一个接一个的放置每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反） box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠 bfc的区域不会与浮动区域的box重叠 bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的 计算bfc高度的时候，浮动元素也会参与计算创建bfc float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible 根元素demo1234567891011&lt;section class=\"top\"&gt; &lt;h1&gt;上&lt;/h1&gt; 这块margin-bottom:30px;&lt;/section&gt;&lt;!-- 给下面这个块添加一个父元素，在父元素上创建bfc --&gt;&lt;div style=\"overflow:hidden\"&gt; &lt;section class=\"bottom\"&gt; &lt;h1&gt;下&lt;/h1&gt; 这块margin-top:50px; &lt;/section&gt;&lt;/div&gt; css reset 和 normalize.css 有什么区别 两者都是通过重置样式，保持浏览器样式的一致性 前者几乎为所有标签添加了样式，后者保持了许多浏览器样式，保持尽可能的一致 后者修复了常见的桌面端和移动端浏览器的bug：包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。 前者中含有大段的继承链 后者模块化，文档较前者来说丰富居中方法水平方向上1234针对inline, 内联块inline-block, 内联表inline-table, inline-flex元素及img,span,button等元素.text_div&#123; text-align:center;&#125; 1234不定宽块状元素居中.text_div&#123; margin:0 auto;&#125; 12345678910通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。.wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; left:-50%;&#125; 垂直居中1234567单行内联(inline-)元素垂直居中 通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。.text_div&#123; height: 120px; line-height: 120px;&#125; 12345678利用表布局.father &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle;&#125; 123456flex布局.center-flex &#123; display: flex; flex-direction: column;//上下排列 justify-content: center;&#125; 1234567891011121314151617181920绝对布局方式已知高度.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; &#125;未知高度.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 垂直水平居中根据上方结合1234567891011121314flex方式.parent &#123; display: flex; justify-content: center; align-items: center;&#125;grid方式.parent &#123; height: 140px; display: grid;&#125;.child &#123; margin: auto;&#125; css优先级确定 每个选择器都有权值，权值越大越优先 继承的样式优先级低于自身指定样式 ！important优先级最高 js也无法修改 权值相同时，靠近元素的样式优先级高 顺序为内联样式表（标签内部）&gt; 内部样式表（当前文件中）&gt; 外部样式表（外部文件中）bfc内容见盒模型如何清除浮动不清楚浮动会发生高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷） clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式： {clear:both;height:0;overflow:hidden;} 给浮动元素父级设置高度 父级同时浮动（需要给父级同级元素添加浮动） 父级设置成inline-block，其margin: 0 auto居中方式失效 利用br标签的clear属性 给父级添加overflow:hidden 清除浮动方法 万能清除法 after伪类 清浮动（现在主流方法，推荐使用）1234567891011.float_div:after&#123; content:\".\"; clear:both; display:block; height:0; overflow:hidden; visibility:hidden;&#125;.float_div&#123; zoom:1&#125; 自适应布局思路： 左侧浮动或者绝对定位，然后右侧margin撑开 使用div包含，然后靠负margin形成bfc 使用flex画三角形123456789#item &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid transparent; border-bottom: 50px solid blue; background: white;&#125; link @import导入css link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 ink支持使用Javascript控制DOM去改变样式；而@import不支持。animation 长宽比方案 使用padding方式结合calc实现 长宽一项设置百分比另一项aspect-ratio实现（需借助插件实现）display相关 block:div等容器类型 inline:img span等行内类型 table系列：将样式变成table类型 flex:重点把握，非常强大 grid:同上 inline-block:可设置宽度，两者间有一点间隙 inherit:继承父级JavaScript相关1 [“1”, “2”, “3”].map(parseInt)123456789101112131415161718首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值其中回调函数接受三个参数 currentValue, index, arrary;而题目中, map只传入了回调函数--parseInt.其次, parseInt 只接受两个两个参数 string, radix(基数). 本题理解来说也就是key与 index 所以本题即问parseInt('1', 0);parseInt('2', 1);parseInt('3', 2);parseInt(string, radix)string 必需。要被解析的字符串。radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。 2 [[3,2,1].reduce(Math.pow), [].reduce(Math.pow)]12345arr.reduce(callback[, initialValue])reduce接受两个参数, 一个回调, 一个初始值.回调函数接受四个参数 previousValue, currentValue, currentIndex, array需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9 3123456789var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;);我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.0 in ary; =&gt; true3 in ary; =&gt; false10 in ary; =&gt; true也就是说 从 3 - 9 都是没有初始化的bug !, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些坑的. 4 [typeof null, null instanceof Object]123456789101112typeof 返回一个表示类型的字符串.instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.type resultUndefined \"undefined\"Null \"object\"Boolean \"boolean\"Number \"number\"String \"string\"Symbol \"symbol\"Host object Implementation-dependentFunction \"function\"Object \"object\" 5 js数据类型1.number; 2.string; 3.boolean; 4.undefined; 5.null; 6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。 7.Object.（包括Object，Array，Function） 6 promise 用法123456789101112131415161718192021定义var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);使用promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;);//等价于：promise.then(function()&#123; //success&#125;).catch(function()&#123; //failure&#125;) 7 es6 promise ajax123456789101112131415161718192021222324252627定义const myHttpClient = url =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;);&#125;;使用myHttpClient('https://www.baidu.com').then(res =&gt; &#123; console.log(res);&#125;).catch(error =&gt; &#123; console.log(error);&#125;); 8闭包1234567891011function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10);结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 9 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） 10 async/await 语法123456789101112131415161718192021222324252627282930作用：异步代码的新方式promise示例const makeRequest = () =&gt; &#123; return getJSON() .then(data =&gt; &#123; if (data.needsAnotherRequest) &#123; return makeAnotherRequest(data) .then(moreData =&gt; &#123; console.log(moreData) return moreData &#125;) &#125; else &#123; console.log(data) return data &#125; &#125;)&#125;async/await示例const makeRequest = async () =&gt; &#123; const data = await getJSON() if (data.needsAnotherRequest) &#123; const moreData = await makeAnotherRequest(data); console.log(moreData) return moreData &#125; else &#123; console.log(data) return data &#125;&#125;函数前面多了一个aync关键字。await关键字只能用在aync定义的函数内。async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值。(示例中reosolve值就是字符串\"done\") 11 深浅拷贝12345678910111213141516171819202122let a = &#123; aa: 1, bb: 2, cc: 3, dd: &#123; ee: 5, &#125;, ff: &#123; gg: 6, &#125;&#125;;let d = JSON.parse(JSON.stringify(a));//深复制包含子对象let c = &#123;...a&#125;;//深拷贝单不包含子对象let b = a;//浅拷贝b.bb = 22;c.cc = 33;c.dd.ee = 55;d.ff.gg = 66;console.log(a);console.log(b);console.log(c);console.log(d); 12数组去重123456思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 setlet arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); 13正则实现trim()功能12345function myTrim(str) &#123; let reg = /^\\s+|\\s+$/g; return str.replace(reg, \"\");&#125;console.log(myTrim(' asdf ')); 14 JS原型121.每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性2.个人粗略理解与python的类方法静态方法实例方法差不多 #####15 es6 class1面向对象，java中类 16 JS 如何实现继承121.使用原型继承（既继承了父类的模板，又继承了父类的原型对象。优点是继承了父类的模板，又继承了父类的原型对象，缺点就是父类实例传参，不是子类实例化传参，不符合常规语言的写法）2.使用call的方式（继承了父类的模板，不继承了父类的原型对象。优点是方便了子类实例传参，缺点就是不继承了父类的原型对象） 17 手写jquery插件1234567891011(function ($) &#123; $.fn.myPlugins = function (options) &#123; //参数赋值 options = $.extend(defaults, options);//对象合并 this.each(function () &#123; //执行代码逻辑 &#125;); &#125;;&#125;)(jQuery);$(selector).myPlugins(&#123;参数&#125;); 18 数组合并去重排序12345let arr1 = [1, 25, 2, 26, 1234, 6, 213];let arr2 = [2, 6, 2134, 6, 31, 623];let c = [...new Set([...arr1, ...arr2])].sort((a, b) =&gt; &#123; return a - b;&#125;); 19 call apply作用：在函数调用时改变函数的执行上下文也就是this的值区别：call采用不定长的参数列表，而apply使用一个参数数组。性能优化图 性能优化 20 for 中setTimeOut要为循环题创建不同的循环副本 21 sort函数V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 插入，比10大的数组则使用 快排。 22 navigator Navigator 23 jquery绑定方式 click后者覆盖 bind后者覆盖 on(jquery&gt;=1.7) live delegate24 事件流向 冒泡：子节点一层层冒泡到根节点 捕获顺序与冒泡相反 addEventListener最后个参数true代表捕获反之代表冒泡 阻止冒泡不停止父节点捕获25原生操作class123456789101112131415161718192021//判断有无function hasClass(ele, cls) &#123; return ele.className.match(new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\"));&#125;//添加function addClass(ele, cls) &#123; if (!this.hasClass(ele, cls)) ele.className += \" \" + cls;&#125;//删除function removeClass(ele, cls) &#123; if (hasClass(ele, cls)) &#123; let reg = new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\"); ele.className = ele.className.replace(reg, \" \"); &#125;&#125;html5中加入classList 一系列操作兼容至IE10 DOM相关dom事件模型DOM之事件模型分脚本模型、内联模型(同类一个，后者覆盖)、动态绑定(同类多个)demo12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt;&lt;!--行内绑定：脚本模型--&gt;&lt;button onclick=\"javascrpt:alert('Hello')\"&gt;Hello1&lt;/button&gt;&lt;!--内联模型--&gt;&lt;button onclick=\"showHello()\"&gt;Hello2&lt;/button&gt;&lt;!--动态绑定--&gt;&lt;button id=\"btn3\"&gt;Hello3&lt;/button&gt;&lt;/body&gt;&lt;script&gt;/*DOM0：同一个元素，同类事件只能添加一个，如果添加多个，* 后面添加的会覆盖之前添加的*/function shoeHello() &#123;alert(\"Hello\");&#125;var btn3 = document.getElementById(\"btn3\");btn3.onclick = function () &#123;alert(\"Hello\");&#125;/*DOM2:可以给同一个元素添加多个同类事件*/btn3.addEventListener(\"click\",function () &#123;alert(\"hello1\");&#125;);btn3.addEventListener(\"click\",function () &#123;alert(\"hello2\");&#125;)if (btn3.attachEvent)&#123;/*IE*/btn3.attachEvent(\"onclick\",function () &#123;alert(\"IE Hello1\");&#125;)&#125;else &#123;/*W3C*/btn3.addEventListener(\"click\",function () &#123;alert(\"W3C Hello\");&#125;)&#125;&lt;/script&gt; 冒泡解释：当点击一个元素触发事件时. 事件会先从元素的最外层父元素一层一层进入到触发的元素, 然后在从触发元素一层一层返回到最外层父元素, 从最外层一层一层进入的阶段叫事件捕获阶段, 从最里层一层一层往外的阶段叫事件冒泡, 移动端触摸事件①touchstart：当手指触碰到屏幕的时候触发②touchmove：当手指在屏幕上滑动的时候触发③touchend：当手指离开屏幕的时候时候触发④touchcancel事件：当系统停止跟踪触摸的时候触发(这个事件很少会用，一般不做深入研究)。 电话接入或者弹出信息等其他事件切入event： touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个touch对象包含的属性 clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier：标识触摸的唯一ID。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：触摸目标在屏幕中的x坐标。 screenY：触摸目标在屏幕中的y坐标。 target：触目的DOM节点目标。 事件委托参考定义：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件好处：给重复的节点添加相同操作，减少dom交互，提高性能实现思路：给父组件添加事件，通过事件冒泡，排查元素是否为指定元素，并进行系列操作 HTTP相关常见状态码2开头 （请求成功）表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 缓存 Expires在http1.0中使用，与服务器时间有误差，在1.1中由Cache-control替代 cdn Cache-Control 和 Etag 的区别如下图 区别图 Cookie sessionStorage localStorage共同点：都是保存在浏览器端，且同源的。区别：cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据不能超过4k(适合保存小数据)。sessionStorage和localStorage容量较大，数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效。localStorage：始终有效，窗口或浏览器关闭也一直保存，需手动清楚；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同。sessionStorage不在不同的浏览器窗口中共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 应用场景：localStorage：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage ：敏感账号一次性登录； cookies与服务器交互。 GET POST区别 get_post 请求行，请求头，请求体详解 如图 1,2,3请求行，4请求体，5请求体 跨域、JSONP 、CORS、postMessage跨域概念解释：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。如下表 图 jsoup实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849原生&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt; jquery$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;);vuethis.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res); &#125;)配合的后端node实现,其他服务器语言也可以const querystring = require('querystring');const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');jsoup缺点只能实现get请求 CORS：跨源资源共享 Cross-Origin Resource Sharing(CORS)，通常服务器设置，若带cookie请求，则前后端都需要设置后端常见设置response.setHeader(“Access-Control-Allow-Origin”, “http://www.domain1.com&quot;); // 若有端口需写全（协议+域名+端口），允许那些外源请求response.setHeader(“Access-Control-Allow-Credentials”, “true”); //是否需要验证 前端示例 1234567891011121314151617181920212223原生var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin'); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;jquery$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 12345678910111213141516171819202122232425262728293031323334353637postMessage(data,origin)方法接受两个参数demoa.html&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;b.html 与a.html不同源&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; osi模型七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层tcp ucp属于传输层；http属于应用层 http2.0 http1 HTTP2.0的基本单位为二进制帧 HTTP2.0中帧具有优先级 HTTP2.0的多路复用（ 1次连接） HTTP2.0压缩消息头 HTTP2.0服务端推送 HTTP2.0只适用于HTTPS的场景Vue相关 生命周期顺序 生命周期 组件通信1.父传子用props,父用子用ref 子调父用$emit,无关系用Bus Vuex组件通信库，可以避免子组件无法改变props的弊端等mutations 同步操作， 用于改变状态 官方不推荐异步action 执行多个mutaions，官方推荐异步操作mapState、mapGetters、mapActions使用示例123456789101112131415161718&lt;template&gt; &lt;el-dialog :visible.sync=\"show\"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; //这里的三点叫做 : 扩展运算符 ...mapState(&#123; show:state=&gt;state.dialog.show &#125;), &#125;&#125;&lt;/script&gt;后两者类似 VueRouter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185定义var routes = [ &#123; path:\"/one\", component:导入的组件1 &#125;, &#123; path:\"/two\", component:导入的组件2 &#125;,];// 定义路由组件var router = new VueRouter(&#123; routes&#125;);// 定义路由new Vue(&#123; el:\"#box\", router&#125;); 访问设定的路由后 会将&lt;router-view&gt;&lt;/router-view&gt;替换成相应的模版 html访问方式 &lt;router-link to=\"/one\"&gt;One&lt;/router-link&gt;(类似a标签) js访问方式 this.$router.push('/one'); replace方式 替换当前页面 携带的参数 可以通过this.$route.query.xxxx来获取``` ##### Vue双向绑定原理：利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。缺点：双向数据流是自动管理状态的, 但是在实际应用中会有很多不得不手动处理状态变化的逻辑, 使得程序复杂度上升, 难以调试。##### computed watch methods用法：区别：1. 前两者自动追踪数据，执行相关函数，最后一个手动调用；2. computed是计算属性，用法与data一致3. watch像事件监听，对象发生变化时，执行相关操作4. methods与js中执行方法类似5. computed通常只有get属性6. 数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择7. watch的对象必须事先声明#### &lt;div id=\"sort\"&gt;算法相关&lt;/div&gt;##### 各种排序实现相关数据![表格](http://pd4ar0u4q.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AD%89%E7%AD%89.png)```javascript// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样冒泡demo:function bubbleSort(arr) &#123; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]; &#125; &#125; &#125; return arr;&#125;// 1) 首先，在数组中选择一个中间项作为主元// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到// 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作// 3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成快排demo:function quickSort(arr, left, right) &#123; let len = arr.length; let partitionIndex; left = typeof left !== 'number' ? 0 : left; right = typeof right !== 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr;&#125;function partition(arr, left, right) &#123; //分区操作 let pivot = left; //设定基准值（pivot） let index = pivot + 1; for (let i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; [arr[i], arr[index]] = [arr[index], arr[i]]; index++; &#125; &#125; [arr[pivot], arr[index - 1]] = [arr[index - 1], arr[pivot]]; return index - 1;&#125;// 选择排序：大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)选择demo:function selectionSort(arr) &#123; let len = arr.length; let minIndex; for (let i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; &#125;return arr;&#125;// 插入排序：每次排一个数组项，假设数组的第一项已经排序，接着，把第二项与第一项进行对比，第二项是该插入到第一项之前还是之后，第三项是该插入到第一项之前还是第一项之后还是第三项插入demo:function insertionSort(arr) &#123; let len = arr.length; let preIndex, current; for (let i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125;// 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)// 归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组归并demo:function mergeSort(arr) &#123; //采用自上而下的递归方法 let len = arr.length; if(len &lt; 2) &#123; return arr; &#125; let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; let result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; result.push(...left); result.push(...right); return result;&#125;//堆排序：堆排序把数组当中二叉树来排序而得名。// 1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2*L；4）节点R的右子节点为2*R + 1// 本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个堆demo:var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; //建立大顶堆 len = arr.length; for (let i = Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; //堆调整 let left = 2 * i + 1; let right = 2 * i + 2; let largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest !== i) &#123; [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(arr, largest); &#125;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (let i = arr.length - 1; i &gt; 0; i--) &#123; [arr[0],arr[i]]=[arr[i],arr[0]]; len--; heapify(arr, 0); &#125; return arr;&#125; 二分查找思路（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。（2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。（3）如果某一步数组为空，则表示找不到目标元素。1234567891011121314151617181920212223242526272829303132333435// 非递归算法function binary_search(arr, key) &#123; let low = 0; let high = arr.length - 1; while(low &lt;= high)&#123; let mid = parseInt((high + low) / 2); if(key === arr[mid])&#123; return mid; &#125;else if(key &gt; arr[mid])&#123; low = mid + 1; &#125;else if(key &lt; arr[mid])&#123; high = mid -1; &#125;else&#123; return -1; &#125; &#125;&#125; // 递归算法function binary_search(arr,low, high, key) &#123; if (low &gt; high)&#123; return -1; &#125; let mid = parseInt((high + low) / 2); if(arr[mid] === key)&#123; return mid; &#125;else if (arr[mid] &gt; key)&#123; high = mid - 1; return binary_search(arr, low, high, key); &#125;else if (arr[mid] &lt; key)&#123; low = mid + 1; return binary_search(arr, low, high, key); &#125;&#125;; 二叉树相关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849创建function Node(data,left,right)&#123; this.data = data;//数值 this.left = left;//左节点 this.right = right;//右节点&#125;;插入二叉树function insert(node,data)&#123; //创建一个新的节点 let newNode = new Node(data,null,null); //判断是否存在根节点，没有将新节点存入 if(node == null)&#123; node = newNode; &#125;else&#123; //获取根节点 let current = node; let parent; while(true)&#123; //将当前节点保存为父节点 parent = current; //将小的数据放在左节点 if(data &lt; current.data)&#123; //获取当前节点的左节点 //判断当前节点下的左节点是否有数据 current = current.left; if(current == null)&#123; //如果没有数据将新节点存入当前节点下的左节点 parent.left = newNode; break; &#125; &#125;else&#123; current = current.right; if(current == null)&#123; parent.right = newNode; break; &#125; &#125; &#125; &#125;&#125;翻转二叉树function invertTree(node) &#123; if (node !== null) &#123; node.left, node.right = node.left, node.right; invertTree(node.left); invertTree(node.right); &#125; return node;&#125; 1234查找链表中倒数第k个结点2个思路1：先遍历出长度，然后查找长度-k+1的值2：2个指针，一个指针先走k-1，然后两个一起走到底部，后者就是结果 网络安全相关XSS CSRFXSS(跨站脚本攻击)，恶意的注入html代码，其他用户访问时，会被执行特点：能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击防御手段： 浏览器禁止页面的JS访问带有HttpOnly属性的Cookie 两端进行输入格式检查 通过编码转义的方式进行输出检查CSRF(攻击跨站请求伪造)特点：重要操作的所有参数都是可以被攻击者猜测到的。攻击者预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求。防御手段： token验证机制，比如请求数据字段中添加一个token，响应请求时校验其有效性 用户操作限制，比如验证码（繁琐，用户体验差） 请求来源限制，比如限制HTTP Referer才能完成操作（防御效果相比较差）实践中常用第一种 webpack相关#####打包体积优化思路 提取第三方库或通过引用外部文件的方式引入第三方库 代码压缩插件UglifyJsPlugin 服务器启用gzip压缩 按需加载资源文件 require.ensure 优化devtool中的source-map 剥离css文件，单独打包 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致#####打包效率 开发环境采用增量构建，启用热更新 开发环境不做无意义的工作如提取css计算文件hash等 配置devtool 选择合适的loader 个别loader开启cache 如babel-loader 第三方库采用引入方式 提取公共代码 优化构建时的搜索路径 指明需要构建目录及不需要构建目录 模块化引入需要的部分Loader编写一个loader123456789101112131415161718loader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API。reverse-txt-loader定义module.exports = function(src) &#123; //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split('').reverse().join(''); //返回JavaScript源码，必须是String或者Buffer return `module.exports = '$&#123;result&#125;'`;&#125;使用&#123; test: /\\.txt$/, use: [ &#123; './path/reverse-txt-loader' &#125; ]&#125;, plugins使用范围更广，通常只需要require()然后添加到plugins数组中，且需要new一个 其他URL到界面显示发生了什么 DNS解析先本地缓存找，在一层层找将常见的地址解析成唯一对应的ip地址基本顺序为：本地域名服务器-&gt;根域名服务器-&gt;com顶级域名服务器依次类推下去,找到后记录并缓存下来如www.google.com为. -&gt; .com -&gt; google.com. -&gt; www.google.com. TCP连接三次握手，只要没收到确认消息就要重新发 主机向服务器发送一个建立连接的请求（您好，我想认识您）； 服务器接到请求后发送同意连接的信号（好的，很高兴认识您）； 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。 发送HTTP请求浏览器会分析这个url，并设置好请求报文发出。请求报文中包括请求行、请求头、空行、请求主体。https默认请求端口443， http默认80。常见的http请求如下1234567891011121314POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley第一部分：请求行，第一行说明是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。4. 服务器处理请求并返回HTTP报文后端处理返回http报文如下 12345678910111213141516HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt;第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 浏览器解析渲染页面 通过HTML解析器解析HTML文档，构建一个DOM Tree，同时通过CSS解析器解析HTML中存在的CSS，构建Style Rules，两者结合形成一个Attachment。 通过Attachment构造出一个呈现树（Render Tree） Render Tree构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。 最后将全部的节点遍历绘制出来后，一个页面就展现出来了。遇到script会停下来执行，所以通常把script放在底部 连接结束 组件封装目的：为了重用，提高开发效率和代码质量注意：低耦合，单一职责，可复用性，可维护性常用操作： 分析布局 初步开发 化繁为简 组件抽象 JS异步加载 动态生成script标签 添加h5的async defer属性，前者乱序不适合依赖性加载 async 是“下载完就执行”， defer 是“渲染完再执行” css与js动画差异 css性能好 css代码逻辑相对简单 js动画控制好 js兼容性好 js可实现的动画多 js可以添加事件 负载均衡多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用 http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱） 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量 CDN内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 内存泄漏定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题js中可能出现的内存泄漏情况结果：变慢，崩溃，延迟大等原因： 全局变量 dom清空时，还存在引用 ie中使用闭包 定时器未清理 子元素存在引起的内存泄露 避免策略： 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收； 注意程序逻辑，避免“死循环”之类的 ； 避免创建过多的对象 原则：不用了的东西要及时归还。 减少层级过多的引用babel原理ES6、7代码输入 -&gt; babylon进行解析 -&gt; 得到AST（抽象语法树）-&gt; plugin用babel-traverse对AST树进行遍历转译 -&gt;得到新的AST树-&gt;用babel-generator通过AST树生成ES5代码、 promise特性：Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获 js自定义事件三要素：document.createEvent()event.initEvent()element.dispatchEvent()1234567891011121314151617181920212223242526272829demo:(en:自定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function()&#123; var demo = document.getElementById(\"demo\"); demo.addEvent(\"test\",function()&#123;console.log(\"handler1\")&#125;); demo.addEvent(\"test\",function()&#123;console.log(\"handler2\")&#125;); demo.onclick = function()&#123; this.triggerEvent(\"test\"); &#125;&#125;Element.prototype.addEvent = function(en,fn)&#123; this.pools = this.pools || &#123;&#125;; if(en in this.pools)&#123; this.pools[en].push(fn); &#125;else&#123; this.pools[en] = []; this.pools[en].push(fn); &#125;&#125;Element.prototype.triggerEvent = function(en)&#123; if(en in this.pools)&#123; var fns = this.pools[en]; for(var i=0,il=fns.length;i&lt;il;i++)&#123; fns[i](); &#125; &#125;else&#123; return; &#125;&#125; es6模块 commonjs amd cmd CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 CommonJS是同步加载模块,在浏览器中会出现堵塞情况，所以不适用 AMD 异步，需要定义回调define方式 es6 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 es6还可以导出类、方法，自动适用严格模式 前后端路由差别1.后端每次路由请求都是重新访问服务器2.前端路由实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合。","categories":[{"name":"前端周刊","slug":"前端周刊","permalink":"https://ru23.com/categories/前端周刊/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://ru23.com/tags/分享/"}]},{"title":"redux入门","slug":"2018-09-redux入门","date":"2018-09-28T11:43:17.000Z","updated":"2018-10-22T09:39:52.201Z","comments":true,"path":"/frontend/cjnk8twwk002kwwa1z4rj5clw/","link":"","permalink":"https://ru23.com/frontend/cjnk8twwk002kwwa1z4rj5clw/","excerpt":"","text":"Redux由Flux演变而来，提供几个简单的API来实现状态管理，所谓状态指的是应用数据，所以，Redux本质上是用来管理数据的。进一步，Redux配合支持数据绑定的视图库使用，就可以将应用状态和视图一一对应，开发者不需要再去关心DOM操作，只关心如何组织数据即可。 由于Redux对于数据的管理拆分很细，一时间会有很多概念，并且Redux有自己丰富的生态，所以容易眼花缭乱。所以强烈建议从头开始一步一步的来，深入体验并理解Redux的思想，不要步子迈太大。✦ 不要一开始过多的纠结代码放在哪个目录✦ 不要一开始就想对action和reducer的代码做精简✦ 不要一开始就考虑数据缓存，离线数据等问题✦ 不要一开始就过度设计数据，考虑数据扁平化的问题反正一句话，饭要一口一口的吃，路要一步一步的走，Redux对于状态管理的东西拆得太细，需要多花一些时间去体会。 Redux是什么？Redux其实很简单，总结起来就三句话：✦ 将整个应用的state储存在唯一的store对象中。✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。✦ 使用reducer来描述action如何改变state。 是的，简而言之就是：Redux让应用的数据被集中管理，并且只能通过触发action的方式来修改，而具体如何修改state，是由reducer来决定的。 那么问题来了：✦ store是什么鬼？✦ action是什么鬼？✦ reducer是什么鬼?✦ 最重要的是，为啥要使用Redux，它能给我们带什么什么好处？或者说，引入这么一个状态理器到底有啥用？ 接下来，我们先捉这三只鬼。 store是什么鬼？前面提过，Redux的目的就是为了对应用数据进行集中管理，也就是state，而state是个普通对象。为了防止state被不小心更新，Redux创建了store对象，专门用来管理state数据。 所以，store就是state的守门员，管理并维护应用数据。 创建store我们通过createStore(reducer, [initialState], enhancer)的方式来创建store。需要注意的是，应用中应该有且只有一个store。12345678910111213141516171819202122232425262728293031import &#123; createStore &#125; from 'redux'// 这是reducer，后文会详细介绍function todos(state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([ action.text ]) default: return state &#125;&#125;// 创建store，并且给state一个初始值['HTML']let store = createStore(todos, [ 'HTML' ])// state.dispatch()，最常用的API// 修改state的唯一方式就是调用store.dispatch()方法// 显然，其中的描述性对象// &#123;// type: 'ADD_TODO',// text: 'CSS'// &#125;// 就是actionstore.dispatch(&#123; type: 'ADD_TODO', text: 'CSS'&#125;)// store.getState()，另一个常用的API// 用来获取state的值console.log(store.getState()); // [ 'HTML', 'CSS' ] store的API们store的API很简单，这儿我按重要顺序列出所有的API，主要记住前两个。✦ dispatch(action)：触发action，再次声明，这是改变state的唯一方式，请默念两次✦ getState()：获取当前的state✦ subscribe(listener)：注册一个监听函数，state发生变化时触发✦ replaceReducer(nextReducer)：替换reducer，用得较少 总结一下，store提供了简单的API，用来管理应用内的数据，它限制了只能通过dispatch(action)来修改state，那么这个action是什么呢？ action是什么鬼？前文提过，action就是一个描述性的普通对象，所以它非常简单！说白了，就是一坨数据，然后这坨数据有名字。 actionaction是一个描述性的普通对象。推荐如下的action结构，type是action的名称，payload是附带的数据。12345678&#123; // 显然，这个名字取得很浅显易懂 type: UPDATE_ARTICLES_LIST, payload: &#123; articles: articles, lastkey: lastkey &#125;&#125; 值得注意的是：实际项目中，我们应该尽量减少action中附带的数据，比如想要更新某篇文章的标题，我们只需要携带文章id和文章新标题即可，而不需要携带整个新文章字段。为了让action更便于维护，我们通常使用action creator而不是action。 action creatoraction create就是一个简单的函数，直接将action作为返回值。12345678910111213141516171819202122232425262728// action creator，返回一个action// 除此之外，没有其他的动作function updateArticlesList(normalizeData, lastkey) &#123; return &#123; type: UPDATE_ARTICLES_LIST, payload: &#123; normalizeData: normalizeData, listLastkey: lastkey &#125; &#125;&#125;// 通过dispatch触发一个action，这是我们修改state的唯一方式dispatch(updateArticlesList( normalizeData, lastkey));// 将dispatch(action)整个动作取个别名，方便调用const updatePosts = (normalizeData, lastkey) =&gt; &#123; return dispatch(updateArticlesList( normalizeData, lastkey ));&#125;updatePosts(...); 那么为什么需要action creatore呢？试想一个场景，我们有好几处dispatch(action)，现在突然想要修改这个action的定义，那么我们需要修改所有地方，代码也比较冗余!而使用action creator，相当于对action做了简单的封装，避免了这些问题。既灵活又便于维护！ 异步action creator我们已经知道，修改state的唯一方式就是触发action，也就是dispatch(action)。但是如果是异步操作，比如一个网络请求，我们需要等到请求返回之后才会返回action，怎么办呢？123456789function updateArticlesList() &#123; return GET(url).then(function(res) &#123; // 难道直接return action？ // 显然是不行的，这儿的返回值并不是updateArticlesList函数的返回值 return action; &#125;).catch(function(err) &#123; console.log(err); &#125;);&#125; 对于异步场景，我们的解决方案是返回函数而不是直接返回action。就像下面这样。为了让dispatch方法可以接受函数作为参数，我们需要使用redux-thunk这个中间件。 1234567import thunk from 'redux-thunk';import &#123; rootReducer &#125; from './reducer.js';const store = createStore( rootReducer, applyMiddleware(thunk)); 然后你就可以dispatch一个函数了12345678910111213function fetchArticlesList() &#123; // 传入dispatch/getstate，当然是为了获取state以及更新state return (dispatch, getState) =&gt; &#123; return GET(url).then(function(res) &#123; dispatch(updateArticlesList( normalizeData, lastkey )); &#125;).catch(function(err) &#123; console.log(err); &#125;); &#125;&#125; 看起来有点迷糊？其实就是把异步请求抽象成action creator，然后放到了redux的代码中。试想一下，如果没有这种方式，你会怎么去处理异步请求？是不是会在组件或者页面中去发异步请求，然后在回调函数中dispatch(action)更新state。本质上也没太大区别。但是好处却是很明显的。 稍微提一下，如果我们可以使用async/await的话，异步action creator可以长得和同步action creator差不多。 action就是一坨数据，它并没有告诉Redux应该怎么去更新state，接下来介绍的reducer就是负责如何更新state这个工作的。 reducer是什么鬼？action本身没有任何意义，就是一个描述性的普通对象。它并没有说明这个数据应该如何更新state。具体如何更新state，是由reducer决定的。reducer的核心就一行代码：(state, action) =&gt; newstate12345678910111213141516171819202122232425262728293031// ------------------------------------// Action Handlers// ------------------------------------const ACTION_HANDLERS = &#123; [UPDATE_ARTICLES_DETAIL]: (articles, action) =&gt; articles, [UPDATE_ARTICLES_LIST]: (articles, action) =&gt; &#123; let payload = action.payload, normalizeData = payload.normalizeData, list = articles.list.concat(normalizeData.result), listLastkey = payload.listLastkey; // 更新articles.list字段和articles.lastkey字段 // 这儿为什么不是state，而是articles呢？留着后文介绍 return updateObject(articles, &#123; list, listLastkey &#125;); &#125;&#125;// ------------------------------------// Reducer// ------------------------------------export function articlesReducer(articles = &#123; list: [], listLastkey: 0&#125;, action) &#123; const handler = ACTION_HANDLERS[action.type] return handler ? handler(articles, action) : articles&#125; reducer函数应该是纯函数，它要保证：只要传入参数相同，那么返回的新state就一定相同。所以永远不要再reducer中做如下操作：✦ 修改传入的state参数✦ 执行有副作用的操作，比如API请求，路由跳转等✦ 调用非纯函数，比如Math.random()或Date.now() 而一旦state变得复杂、层级较多的时候，如何设计reducer就是一个比较复杂的话题了。关于如何设计state？如何分拆reducer？reducer之间如何共享数据？以及如何重构reducer的代码？可以移步另一篇博客：如何最佳实践的设计reducer。 那么，回到最初的话题，引入Redux到我们的应用中，到底有什么好处？我们为什么需要一个专门的状态管理器？ 为啥要使用redux？早些时候，前端并没有这么复杂，几乎不怎么涉及数据管理。随着前端的发展，前端也开始引入MVC之类的架构，对数据、视图、逻辑进行拆分处理。为了保持数据和视图的同步，我们会频繁的操作DOM元素。简直是噩梦。而后KnockoutJS，angularJS等出现了，他们都支持数据绑定，终于让开发可以不在频繁的操作DOM，而是仅仅修改数据，然后自动同步到view。但这还不够彻底，数据仍然是分散的。我们会在controller中写很多操作数据、操作视图的代码，甚至存在冗余数据，想要修改、更新、同步的话，有很大的隐患。Redux的出现，提供了对数据的集中管理，让单向数据流成为了可能。另外，Redux还让前后端彻底分离变成了可能，这一点也有极大的意义。 Redux的数据流Redux通过一些限制告诉你：数据只能保存在我这儿，别想太分散！想要修改数据？告诉我一个带新数据的action，我会通过reducer自动修改，然后返回修改后的数据给你！是的，redux很想“数据库”，数据被集中存储，并且只能通过“预先定义的action操作”来修改。 更厉害的是，配上支持数据绑定的视图库，你会发现一个神奇的事情：之前我们是面向view和controller编程，随着项目的复杂，代码会彼此影响而且数据会分散到各处。而引入redux之后，我们单纯的面向数据编程即可，我们在Redux中统一的管理数据，然后数据变换会反映到view上，而数据上的交互，本质上也是触发了Redux中的action。如下图 Redux数据流所以，设计redux程序的时候，提前想清楚state的结构尤其重要，就好比设计数据库表结构之于后台。 服务器渲染让前后端彻底分离成为了可能上图也可以看出，Redux构建出一份单向数据流。这让服务端渲染变成了可能，而这个特性，让前后端彻底分离变成了可能，还不用担心SEO的问题。想当初，为了解决前后端分离的问题，大家费尽心思，奈何进展甚微，淘宝甚至提出中途岛midway项目，通过中间搭建由前端维护的Nodejs服务器来实现简单的渲染然后返回HTML，但其实这个Nodejs服务器一点都不简单，需要考虑太多东西，比如安全、性能、缓存等。 总结Redux主要用于对数据进行集中管理，并且让整个应用的数据流变得清晰。让应用开发更流畅，数据管理更有效。有了Redux，开发者们慢慢的转化为面向数据编程，而不再是频繁的操作DOM，维护越来越复杂的controller逻辑。简单来说，Redux的东西不多，更重要的是理解它的思路：✦ 将整个应用的state储存在唯一的store对象中。✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。✦ 使用reducer来描述action如何改变state。✦ Redux的单向数据流，可以实现服务端渲染，让前后端彻底分离成为可能，这个有里程碑的意义。✦ Redux非常适合复杂的应用，尤其是多交互、多数据源的应用。 还是那句话，Redux将数据管理拆得很细，所以会有很多新东西去了解，但其实只要了解它的思想，其他的就很顺其自然了。 作者：齐修_qixiuss链接：https://www.jianshu.com/p/d296a8c34936來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"Module not found: Error: Cannot resolve module 'fs' in","slug":"2018-03-Module-not-found-Error-Cannot-resolve-module-fs-in","date":"2018-09-22T10:32:13.000Z","updated":"2018-10-22T09:39:00.879Z","comments":true,"path":"/frontend/cjnk8twry0003wwa1ljvfbnhm/","link":"","permalink":"https://ru23.com/frontend/cjnk8twry0003wwa1ljvfbnhm/","excerpt":"","text":"控制台报错：123456789However I see this error./~/adal-node/lib/util.jsModule not found: Error: Cannot resolve module 'fs' in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/libresolve module fs in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib looking for modules in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib/fs doesn't exist (module as directory) resolve 'file' fs in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib resolve file 解决方案： add this to webpack.config.js1target: 'node', 原文：https://stackoverflow.com/questions/40541044/module-not-found-error-cannot-resolve-module-fs-in","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://ru23.com/tags/npm/"}]},{"title":"JS 数组克隆方法总结","slug":"2018-09-JS-数组克隆方法总结","date":"2018-09-21T11:22:37.000Z","updated":"2018-10-22T09:38:50.928Z","comments":true,"path":"/frontend/cjnk8twva001qwwa1gctr9jwg/","link":"","permalink":"https://ru23.com/frontend/cjnk8twva001qwwa1gctr9jwg/","excerpt":"","text":"ES5 方法总结slice12345let arr = [2,4,434,43]let arr1= arr.slice()arr[0] = 'a'console.log(arr,arr1) // [ 2, 4, 434, 43 ]console.log(arr1 === arr) // false 遍历数组1234567891011Array.prototype.clone = function()&#123; let a=[]; for(let i=0,l=this.length;i&lt;l;i++) &#123; a.push(this[i]); &#125; return a;&#125;let arr = ['aaa','bbb','ccc','wwwww','ddd']let arr2 = arr.clone()console.log(arr2)console.log( arr2 === arr ) concat()12345678Array.prototype.clone=function()&#123; return [].concat(this); //或者 return this.concat();&#125;let arr = ['aaa','asss']let arr1 = arr.clone()arr[0] = 123console.log(arr,arr1) ES6 方法总结Object.assign() 浅复制，也可以实现数组的克隆12345let arr = ['sdsd',123,123,123]let arr1 = []Object.assign(arr1,arr)arr[1] = 'aaaa'console.log(arr,arr1) // [ 'sdsd', 'aaaa', 123, 123 ] [ 'sdsd', 123, 123, 123 ] 扩展运算符12345const a1 = [1, 2];// 写法一const a2 = [...a1];a1[0] = 'aaa'console.log(a1,a2)","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"前端周刊-2018年09月第3周","slug":"2018-09-前端周刊-2018年09月第3周","date":"2018-09-21T08:24:00.000Z","updated":"2018-10-22T09:40:47.950Z","comments":true,"path":"/frontend/cjnk8twws002swwa1u7af5pke/","link":"","permalink":"https://ru23.com/frontend/cjnk8twws002swwa1u7af5pke/","excerpt":"","text":"编写「可读」代码的实践链接:http://taobaofed.org/blog/2017/01/05/writing-readable-code/ 摘要伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复打磨自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。 React + Redux 组件化方案链接:http://imweb.io/topic/57c531bc6227a4f55a8872c2 摘要组件化方案:理想中的组件化，第一步应该就是组件的标签化， 例如有一个 Header 组件，无需关注组件内部的实现，我们只需要使用一个 标签就能调用它，通过设置属性的方式，来控制它的显示的内容，和对应的事件。借助 jsx 语法，React 已经实现上述想法。但是由于 React 的数据流向是单向的， 子组件的数据和方法只能由父级组件赋予，一旦组件嵌套层次变深，传递数据将会变得非常复杂。redux 框架解决了这个问题，简单来说，它将 react 由父级传递数据，变为了由一个统一的数据源 store 单向地向各个组件传递数据。所有数据都存放在 store 中，组件内部不维护任何数据。 store 提供了 dispatch 方法来触发改变 store 中数据。 dispatch 传入的值被称作 action。 dispatch(action) 之后，会进入到 store 中称为 reducer 的处理函数，这些 reducer 会依据不同的 action 的类型，进行不同的处理，reducer 返回的值就会作为 store 中新的数据，一个 reducer 对应的是 store 中一个数据字段，每多一个reducer， store 中就多一个数据字段。数据发生改变后， store 就会通知对应的组件重新渲染。 通过 redux 框架提供的 connect 高阶函数， 直接从 store 选取需要的数据和申明需要使用的方法传入组件中，这些申明的方法是组件事件具体的逻辑的实现，例如发送请求，上报逻辑等等，所以通常调用 dispatch(action) 的逻辑也会包含在里面。 ANT DESIGN PRO-开箱即用的中台前端/设计解决方案链接:https://github.com/ant-design/ant-design-pro?utm_source=gold_browser_extension 摘要💎 优雅美观：基于 Ant Design 体系精心设计；📐 常见设计模式：提炼自中后台应用的典型页面和场景；🚀 最新技术栈：使用 React/dva/antd 等前端前沿技术开发；📱 响应式：针对不同屏幕大小设计；🎨 主题：可配置的主题满足多样化的品牌诉求；🌐 国际化：内建业界通用的国际化方案；⚙️ 最佳实践：良好的工程实践助您持续产出高质量代码；🔢 Mock 数据：实用的本地数据调试方案；✅ UI 测试：自动化测试保障前端产品质量； 实现一个完美符合Promise/A+规范的Promise链接:https://github.com/forthealllight/blog/issues/4 摘要Promise允许我们通过链式调用的方式来解决“回调地狱”的问题，特别是在异步过程中，通过Promise可以保证代码的整洁性和可读性。本文主要解读Promise/A+规范，并在此规范的基础上，自己实现一个Promise. Vue知识点整理链接https://segmentfault.com/a/1190000016344599 对于MVVM的理解？ Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View 代表UI 组件，它负责将数据模型转化成UI 展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Vue的生命周期（8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后) Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。beforeCreate（创建前） 在数据观测和初始化事件还未开始created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vue实现数据双向绑定的原理：Object.defineProperty（） Vue组件间的参数传递1.父组件与子组件传值父组件传给子组件：子组件通过props方法接受数据;子组件传给父组件：$emit方法传递参数2.非父子组件间的数据传递，兄弟组件传值eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适 vue路由的钩子函数 首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next： to：route即将进入的目标路由对象， from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 vuex是什么？怎么使用？哪种功能场景使用它只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车","categories":[{"name":"前端周刊","slug":"前端周刊","permalink":"https://ru23.com/categories/前端周刊/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://ru23.com/tags/分享/"}]},{"title":"前端开发规范-used by frank","slug":"2018-09-前端开发规范-used-by-frank","date":"2018-09-21T08:20:34.000Z","updated":"2018-10-22T09:40:56.801Z","comments":true,"path":"/frontend/cjnk8twwv002vwwa1es43l7do/","link":"","permalink":"https://ru23.com/frontend/cjnk8twwv002vwwa1es43l7do/","excerpt":"","text":"js方法注释规范规范的注释很重要代码是写给人看的，顺便给机器运行，多谢注释可以增加代码的可读性 123456789101112131415161718/** ************** * @func 教师端请假功能 ; * @param &#123;String&#125; token 教师端头部的token; * @param &#123;string&#125; a - 参数a; * @param &#123;number&#125; b=1 - 参数b默认值为1; * @param &#123;string&#125; c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx; * @param &#123;object&#125; d - 参数d为一个对象; * @param &#123;string&#125; d.e - 参数d的e属性; * @param &#123;string&#125; d.f - 参数d的f属性; * @param &#123;object[]&#125; g - 参数g为一个对象数组; * @param &#123;string&#125; g.h - 参数g数组中一项的h属性; * @param &#123;string&#125; g.i - 参数g数组中一项的i属性; * @param &#123;string&#125; [j] - 参数j是一个可选参数; * @description 2018年4月19日被frank开发于dev_sprint65分支， * XX年XX月被XX在xx分支修改（原因或者修改的功能）; ****************/ 变量命名规范1.标准变量命名使用驼峰式命名 eg. let thisIsMyName;2.常量全部大写，并使用下划线连接 eg. const MAX_COUNT = 10; 项目规范变量声明尽量提在函数首部，用一个var声明，不允许出现连着的两个var声明(也包括let，const) 1234567891011function doSomethingWithItems(items) &#123; // use one var var value = 10, result = value + 10, i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; result += 10; &#125;&#125; undefind使用规范（永远不要直接使用undefined进行变量判断，使用typeof和字符串’undefined’对变量进行判断。） 123456789// not goodif (person === undefined) &#123; ...&#125;// goodif (typeof person === 'undefined') &#123; ...&#125; 用’===’和’!==’代替’==’, ‘!=’使用对象的属性简写123456789const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 使用拓展运算符 … 复制数组1234567891011// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] render使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051render: (h, params) =&gt; &#123; return h('div', [ h('span', &#123; attrs: &#123; class: \"table_details\" &#125;, on: &#123; click: () =&gt; &#123; this.edit(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_continue\" &#125;, on: &#123; click: () =&gt; &#123; this.show(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125;, on: &#123; click: () =&gt; &#123; this.remove(params.row.id) &#125; &#125; &#125;,), h('Poptip', &#123; props: &#123; title:\"项目变更\", content:\"项目迁出\", placement:\"bottom-end\" &#125;, on: &#123; 'on-ok': () =&gt; &#123; &#125; &#125; &#125;, [ h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125; &#125;) ]) ])&#125; 文档：有时间整理一下http://taobaofed.org/blog/2017/01/05/writing-readable-code/","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"前端自动化","slug":"前端自动化","permalink":"https://ru23.com/tags/前端自动化/"}]},{"title":"VsCode读取项目文件的Eslint规则 保存时自动修复格式错误","slug":"2018-09-VsCode读取项目文件的Eslint规则-保存时自动修复格式错误","date":"2018-09-17T08:29:10.000Z","updated":"2018-10-22T09:39:56.933Z","comments":true,"path":"/frontend/cjnk8twvt0021wwa1wka5313j/","link":"","permalink":"https://ru23.com/frontend/cjnk8twvt0021wwa1wka5313j/","excerpt":"","text":"配置：安装VsCode的EsLint和vetur插件为项目安装EsLint包注意要安装在开发环境上，还有就是如果你使用的是脚手架的话，选了Eslint选项，会自带这些包。 在项目的根目录下添加.eslintrc.js用于校验代码格式，根据项目情况，可自行编写校验规则：123module.exports = &#123; // Eslint规则&#125; 首选项设置：将下面这部分放入首选项设置中： \"eslint.autoFixOnSave\": true, // 启用保存时自动修复,默认只支持.js文件 \"eslint.validate\": [ \"javascript\", // 用eslint的规则检测js文件 { \"language\": \"vue\", // 检测vue文件 \"autoFix\": true // 为vue文件开启保存自动修复的功能 }, { \"language\": \"html\", \"autoFix\": true }, ], 大功告成：点开文件，你可能会看到如下报错，无需一个一个去改，只要保存一下文件，就可以自动修复这些代码格式上的问题了。 注意：如果整个文件都飘红的话，不会一次性修改如果的格式问题，会一下改一部分，你可能需要多按几次保存。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[]},{"title":"前端周刊-2018年09月第2周","slug":"2018-09-前端周刊-2018年09月第2周","date":"2018-09-11T08:18:25.000Z","updated":"2018-10-22T09:40:45.456Z","comments":true,"path":"/frontend/cjnk8twwg002hwwa18g7w9etv/","link":"","permalink":"https://ru23.com/frontend/cjnk8twwg002hwwa18g7w9etv/","excerpt":"","text":"es6常用基础合集url:https://www.jianshu.com/p/cfb0893c34f1知识点:let,const箭头函数模板字符串解析结构函数默认参数展开运算符对象字面量与classPromise ES6新特性概览url： http://www.cnblogs.com/Wayou/p/es6_new_features.html知识点:箭头操作符类的支持增强的对象字面量字符串模板解构参数默认值，不定参数，拓展参数let与const 关键字for of 值遍历iterator, generator模块Map，Set 和 WeakMap，WeakSetProxiesSymbolsMath，Number，String，Object 的新API 透彻掌握Promise的使用，读这篇就够了url：https://www.jianshu.com/p/fe5f173276bd知识点：实现方法1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。2.resolve。成功的执行方法3.reject。失败的执行方法4.catch。失败的捕获。5.then。链式调用下一步。原理：内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行123456789101112131415161718192021class Promise &#123; result: any; callbacks = []; failbacks = []; constructor(fn) &#123; fn(this.resolve.bind(this), this.reject.bind(this)); &#125; resolve(res) &#123; if (this.callbacks.length &gt; 0) this.callbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; reject(res) &#123; this.callbacks = []; if (this.failbacks.length &gt; 0) this.failbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; catch (fn) &#123; this.failbacks.push(fn); &#125; then(fn) &#123; this.callbacks.push(fn); return this; &#125;&#125; 调用示例：1234567891011var a = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(\"成功\"); &#125;, 1000);&#125;).then(function(result, resolve, reject) &#123; console.log(result) reject(\"失败\")&#125;).catch (function(err) &#123; console.log(err);&#125;); es6写法：1234567891011121314151617//创建promisevar promise = new Promise(function(resolve, reject) &#123; // 进行一些异步或耗时操作 if ( /*如果成功 */ ) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;);//绑定处理程序promise.then(function(result) &#123; //promise成功的话会执行这里 console.log(result); // \"Stuff worked!\"&#125;, function(err) &#123; //promise失败会执行这里 console.log(err); // Error: \"It broke\"&#125;); 4.前端算法相关url:https://github.com/qianbin01/frontend_train#sort知识点冒泡排序 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样 快速排序: 1) 首先，在数组中选择一个中间项作为主元2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成 选择排序: 大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2) 归并排序: 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 堆排序： 堆排序把数组当中二叉树来排序而得名。1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2L；4）节点R的右子节点为2R + 1本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 5.javaScript常用知识点url: https://github.com/qianbin01/frontend_train#javascript知识点map,reduce,filter的用法js数据类型(7种) 1.number;2.string;3.boolean;4.undefined;5.null;6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。7.Object.（包括Object，Array，Function）闭包12345678function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10); 结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011//常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） async/await 语法深浅拷贝数组去重思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 set12let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); JS原型","categories":[{"name":"前端周刊","slug":"前端周刊","permalink":"https://ru23.com/categories/前端周刊/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://ru23.com/tags/分享/"}]},{"title":"reactjs中事件传参(关于event)","slug":"2018-09-reactjs中事件传参-关于event","date":"2018-09-10T07:06:44.000Z","updated":"2018-10-22T09:39:47.267Z","comments":true,"path":"/frontend/cjnk8tww4002awwa1xvwlm0vq/","link":"","permalink":"https://ru23.com/frontend/cjnk8tww4002awwa1xvwlm0vq/","excerpt":"","text":"问题描述我们在事件中通常需要获取控件的值，通常通过event.target.value的方式来取值，在绑定事件时，event参数也不需要传递，在方法中直接使用即可。但是，有些时候需要传入一些其他的参数，比如需要循环绑定一些输入框，在绑定onChange事件时，需要传入索引index和数据源的索引进行对应1234567891011121314151617181920212223242526onHandleChange(index,event)&#123; let val=event.target.value&#125;//关键代码source.map((item,index)=&gt;&#123; return &lt;input type=\"text\" value=&#123;item.name&#125; onChange=&#123;this.onHandleChange.bind(this,index)&#125; /&gt;&#125;);``` #### 代码解释有的同学应该已经看出区别了，onHandleChange在声明时有两个参数，但在调用时却只传递了一个参数，这就是今天要讲的:&gt; **在给方法传递新参数时，方法原有的参数会排在新参数之后**做过reactjs的同学都知道，event这个参数是不需要手动传递的，直接在方法中声明就可以使用，如下代码：```jsxonChangeHandle(event)&#123; let val=event.target.value;&#125;render()&#123; return (&lt;div&gt; &lt;input type=\"text\" onChange=&#123;this.onChangeHandle.bind(this)&#125; /&gt;&lt;/div&gt;)&#125; 摘自 作者：不将就人生链接：https://www.jianshu.com/p/1026d71d04d6來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"前端开发周刊-(2018年09月第2周)","slug":"2018-09-ES6-基础-【好文分享】","date":"2018-09-10T03:48:21.000Z","updated":"2018-10-22T09:37:32.422Z","comments":true,"path":"/frontend/cjnk8twvh001twwa1bh6lgtf7/","link":"","permalink":"https://ru23.com/frontend/cjnk8twvh001twwa1bh6lgtf7/","excerpt":"","text":"es6常用基础合集url:https://www.jianshu.com/p/cfb0893c34f1知识点:let,const箭头函数模板字符串解析结构函数默认参数展开运算符对象字面量与classPromise ES6新特性概览url： http://www.cnblogs.com/Wayou/p/es6_new_features.html知识点:箭头操作符类的支持增强的对象字面量字符串模板解构参数默认值，不定参数，拓展参数let与const 关键字for of 值遍历iterator, generator模块Map，Set 和 WeakMap，WeakSetProxiesSymbolsMath，Number，String，Object 的新API 透彻掌握Promise的使用，读这篇就够了url：https://www.jianshu.com/p/fe5f173276bd知识点：实现方法1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。2.resolve。成功的执行方法3.reject。失败的执行方法4.catch。失败的捕获。5.then。链式调用下一步。原理：内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行123456789101112131415161718192021class Promise &#123; result: any; callbacks = []; failbacks = []; constructor(fn) &#123; fn(this.resolve.bind(this), this.reject.bind(this)); &#125; resolve(res) &#123; if (this.callbacks.length &gt; 0) this.callbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; reject(res) &#123; this.callbacks = []; if (this.failbacks.length &gt; 0) this.failbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; catch (fn) &#123; this.failbacks.push(fn); &#125; then(fn) &#123; this.callbacks.push(fn); return this; &#125;&#125; 调用示例：1234567891011var a = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(\"成功\"); &#125;, 1000);&#125;).then(function(result, resolve, reject) &#123; console.log(result) reject(\"失败\")&#125;).catch (function(err) &#123; console.log(err);&#125;); es6写法：1234567891011121314151617//创建promisevar promise = new Promise(function(resolve, reject) &#123; // 进行一些异步或耗时操作 if ( /*如果成功 */ ) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;);//绑定处理程序promise.then(function(result) &#123; //promise成功的话会执行这里 console.log(result); // \"Stuff worked!\"&#125;, function(err) &#123; //promise失败会执行这里 console.log(err); // Error: \"It broke\"&#125;); 4.前端算法相关url:https://github.com/qianbin01/frontend_train#sort知识点冒泡排序 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样 快速排序: 1) 首先，在数组中选择一个中间项作为主元2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成 选择排序: 大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2) 归并排序: 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 堆排序： 堆排序把数组当中二叉树来排序而得名。1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2L；4）节点R的右子节点为2R + 1本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 5.javaScript常用知识点url: https://github.com/qianbin01/frontend_train#javascript知识点map,reduce,filter的用法js数据类型(7种) 1.number;2.string;3.boolean;4.undefined;5.null;6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。7.Object.（包括Object，Array，Function）闭包12345678function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10); 结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011//常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） async/await 语法深浅拷贝数组去重思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 set12let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); JS原型","categories":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"https://ru23.com/categories/优质文章分享/"}],"tags":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"https://ru23.com/tags/优质文章分享/"}]},{"title":"NodeJS连接MySQL时遇到的问题 Error Connection lost The server closed the connection.","slug":"2018-09-NodeJS连接MySQL时遇到的问题-Error-Connection-lost-The-server-closed-the-connection","date":"2018-09-07T07:54:30.000Z","updated":"2018-10-22T09:39:06.050Z","comments":true,"path":"/frontend/cjnk8twvo001xwwa1i3ubgeq1/","link":"","permalink":"https://ru23.com/frontend/cjnk8twvo001xwwa1i3ubgeq1/","excerpt":"","text":"今天用NodeJS连接Mysql时遇到点折磨人的问题，记录下解决方法。 NodeJS和Mysql都已经正确安装了，但是NodeJS和Mysql的连接出现问题，查找网上一些解决办法都不能解决问题。报错如下： image 经过查找定位，在mysql官网找到了解决方案： 官网链接 》》MySQL Connector/Node.jsMySql 针对node的连接器对mysql的版本有要求，且需要另外的插件： image 然后下载的最新版的mysql mysql-installer-community-5.7.20.0.msi 执行 :123npm install mysqlnpm install @mysql/xdevapi 运行官方示例，成功。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://ru23.com/tags/node/"}]},{"title":"ES6学习笔记","slug":"2018-09-小邵教你玩转es6","date":"2018-09-07T02:57:11.000Z","updated":"2018-10-22T09:41:14.615Z","comments":true,"path":"/frontend/cjnk8twwz002zwwa19kop0rjh/","link":"","permalink":"https://ru23.com/frontend/cjnk8twwz002zwwa19kop0rjh/","excerpt":"","text":"前言：大家好，我叫邵威儒，大家都喜欢喊我小邵，学的金融专业却凭借兴趣爱好入了程序猿的坑，从大学买的第一本vb和自学vb，我就与编程结下不解之缘，随后自学易语言写游戏辅助、交易软件，至今进入了前端领域，看到不少朋友都写文章分享，自己也弄一个玩玩，以下文章纯属个人理解，便于记录学习，肯定有理解错误或理解不到位的地方，意在站在前辈的肩膀，分享个人对技术的通俗理解，共同成长！ 后续我会陆陆续续更新javascript方面，尽量把javascript这个学习路径体系都写一下包括前端所常用的es6、angular、react、vue、nodejs、koa、express、公众号等等都会从浅到深，从入门开始逐步写，希望能让大家有所收获，也希望大家关注我~ 文章列表：https://juejin.im/user/5a84f871f265da4e82634f2d/posts Author: 邵威儒Email: 166661688@qq.comWechat: 166661688github: https://github.com/iamswr/ 接下来我主要给大家讲下我对常用的es6的理解，我们工作当中，其实有很多用不上的，如果想详细了解的话可以看看阮一峰老师的es6：http://es6.ruanyifeng.com/ 这篇文章主要让你学会工作当中常用的es6技巧，以及扩展如实现数据双向绑定，class用es5如何实现、如何给伪数组添加迭代器等等。 var、let、const1234567891011121314151617181920212223242526272829303132333435// 1.var存在变量作用域的提升console.log(a) // 打印输出 undefinedvar a = 1// 怎么理解作用域的提升呢？// var str = &apos;hello swr&apos;// function()&#123;// console.log(str) // 打印输出 undefined// var str = &apos;goodbye swr&apos;// &#125;// test()// 上面这段代码实际上是var str = &apos;hello swr&apos;function()&#123; var str console.log(str) // 打印输出undefined // 实际上就是var声明的变量，拿到 // 当前作用域的最顶层，而此时尚未赋值 // 只是声明，所以打印出undefined，而非当运行 // 到这段代码时才声明，优先声明， // 当运行到那行的时候，实际上是赋值 // 同样的，function xx()&#123;&#125;也存在作用域提升 str = &apos;goodbye swr&apos;&#125;test()// var 不存在块级作用域的概念// 我的理解是在es6之前，是没有块级作用域的概念，// 变量只有遇到函数的时候才会变为局部变量&#123; var str 1 = &apos;hello swr&apos;&#125;console.log(str1) // 打印输出 hello swr 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 2.let// 2.1 不存在变量作用域提升，这样可以避免了我们还没声明变量就拿变量来用// 2.2 同一作用域的同一个变量不能够重复声明，避免我们重复声明变量// 2.3 let声明的变量不会到全局上// 2.4 let和代码块&#123;&#125;结合使用会形成块级作用域// 2.1// console.log(a) // 报错，a未声明// let a = &apos;hello swr&apos;// 2.2// let a = &apos;hello swr&apos;// let a = &apos;hello swr&apos; // 报错，变量被重复声明// 2.3// let a = &apos;hello swr&apos;// console.log(window.a) // undefined// 2.4// 在代码块以外调用str2，会报错&#123; let str2 = &apos;hello swr&apos;&#125;console.log(str2) // 报错，未找到变量// 上面这种写法，也有点类型es6之前的立即执行函数(function()&#123; var str2 = &apos;hello swr&apos;&#125;)()// 一个例子// 使用var，会发现最终console.log中打印的i都是3// 因为for循环不是函数，而此时var i是处于全局当中// for循环是同步代码，所以会执行完同步代码后// 再执行setTimeout的异步代码，此时i已为3，所以打印出来都是3for(var i = 0;i &lt; 3;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000)&#125;// 那么我们用let试下// let和代码块结合起来使用会形成块级作用域// 那么当for时，这3个setTimeout会分别在3个不同的块级作用域// 当执行setTimeout的console.log(i)时，会先寻找最近的块级作用域中的i// 所以会依次打印出0 1 2for(let j = 0;j &lt; 3;j++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000)&#125; 1234567891011121314151617// 3.const// 3.1 const和let基本上可以说是完全一致的，但是const声明的对象不能更改其指向的引用地址（即堆区）// 3.1// 当用普通值赋值给const声明的变量后，再重新赋值时// 值引用会被更改，所以会报错const STR1 = &apos;hello swr&apos;STR1 = &apos;goodbye swr&apos; // 报错,Assignment to constant variable// 当我们修改这个引用地址里面的内容时，则不会报错// 因为这个变量是指向这个引用地址的const OBJ = &#123;name:&quot;swr&quot;&#125;OBJ.name = &apos;hello swr&apos;console.log(OBJ) // &#123;name:&quot;hello swr&quot;&#125;// 但是当我们把这个变量重新赋值一个引用地址时，则会报错OBJ = &#123;&#125; // 报错 解构赋值解构赋值主要分为对象的解构和数组的解构，在没有解构赋值的时候，我们赋值是这样的1234let arr = [0,1,2]let a = arr[0]let b = arr[1]let c = arr[2] 这样写很繁琐，那么我们有没办法既声明，又赋值，更优雅的写法呢？肯定是有的，那就是解构赋值，解构赋值，简单理解就是等号的左边和右边相等。 数组的解构赋值12345let arr = [0,1,2]let [a,b,c] = arrconsole.log(a) // 0console.log(b) // 1console.log(c) // 2 但是很多时候，数据并非一一对应的，并且我们希望得到一个默认值1234567let arr = [,1,2]let [a=&apos;我是默认值&apos;,b,c] = arrconsole.log(a) // &apos;我是默认值&apos;console.log(b) // 1console.log(c) // 2// 从这个例子可以看出，在解构赋值的过程中，a=undefined时，会使用默认值// 那么当a=null时呢？当a=null时，那么a就不会使用默认值，而是使用null 12345678// 数组的拼接let a = [0,1,2]let b = [3,4,5]let c = a.concat(b)console.log(c) // [0,1,2,3,4,5]let d = [...a,...b]console.log(d) // [0,1,2,3,4,5] 12345678910111213141516// 数组的克隆// 假如我们简单地把一个数组赋值给另外一个变量let a = [0,1,2,3]let b = ab.push(4)console.log(a) // [0,1,2,3,4]console.log(b) // [0,1,2,3,4]// 因为这只是简单的把引用地址赋值给b，而不是重新开辟一个内存地址，所以// a和b共享了同一个内存地址，该内存地址的更改，会影响到所有引用该地址的变量// 那么用下面的方法，把数组进行克隆一份，互不影响let a = [0,1,2,3]let b = [...a]b.push(4)console.log(a) // [0,1,2,3]console.log(b) // [0,1,2,3,4] 对象的解构赋值对象的解构赋值和数组的解构赋值其实类似，但是数组的数组成员是有序的而对象的属性则是无序的，所以对象的解构赋值简单理解是等号的左边和右边的结构相同123let &#123;name,age&#125; = &#123;name:&quot;swr&quot;,age:28&#125;console.log(name) // &apos;swr&apos;console.log(age) // 28 对象的解构赋值是根据key值进行匹配12345// 这里可以看出，左侧的name和右侧的name，是互相匹配的key值// 而左侧的name匹配完成后，再赋值给真正需要赋值的Namelet &#123; name:Name,age &#125; = &#123; name:&apos;swr&apos;,age:28 &#125;console.log(Name) // &apos;swr&apos;console.log(age) // 28 那么当变量已经被声明了呢？12345let name,age// 需要用圆括号，包裹起来(&#123;name,age&#125; = &#123;name:&quot;swr&quot;,age:28&#125;)console.log(name) // &apos;swr&apos;console.log(age) // 28 变量能否也设置默认值？1234let &#123;name=&quot;swr&quot;,age&#125; = &#123;age:28&#125;console.log(name) // &apos;swr&apos;console.log(age) // 28// 这里规则和数组的解构赋值一样，当name = undefined时，则会使用默认值 12345let [a] = [&#123;name:&quot;swr&quot;,age:28&#125;]console.log(a) // &#123;name:&quot;swr&quot;,age:28&#125;let &#123; length &#125; = &quot;hello swr&quot;console.log(length) // 9 1234567function ajax(&#123;method,url,type=&apos;params&apos;&#125;)&#123; console.log(method) // &apos;get&apos; console.log(url) // &apos;/&apos; console.log(type) // &apos;params&apos;&#125;ajax(&#123;method:&quot;get&quot;,url:&quot;/&quot;&#125;) 扩展运算符我们先看下代码12345678910111213// 在以往，我们给函数传不确定参数数量时，是通过arguments来获取的function sum() &#123; console.log(arguments) // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5, &apos;5&apos;: 6 &#125; // 我们可以看出，arguments不是一个数组，而是一个伪数组 let total = 0 let &#123; length &#125; = arguments for(let i = 0;i &lt; length;i++)&#123; total += arguments[i] &#125; return total&#125;console.log(sum(1,2,3,4,5,6)) // 21 1234567// 接下来我们用扩展运算符看看function sum(...args)&#123; // 使用...扩展运算符 console.log(args) // [ 1, 2, 3, 4, 5, 6 ] args是一个数组 return eval(args.join(&apos;+&apos;))&#125;console.log(sum(1,2,3,4,5,6)) // 21 得到的args是一个数组，直接对数组进行操作会比对伪数组进行操作更加方便，还有一些注意点需要注意123456789101112131415// 正确的写法 扩展运算符只能放在最后一个参数function sum(a,b,...args)&#123; console.log(a) // 1 console.log(b) // 2 console.log(args) // [ 3, 4, 5, 6 ]&#125;sum(1,2,3,4,5,6)// 错误的写法 扩展运算符只能放在最后一个参数function sum(...args,a,b)&#123; // 报错&#125;sum(1,2,3,4,5,6) 我们可以对比下扩展运算符的方便之处1234567891011// 以往我们是这样拼接数组的let arr1 = [1,2,3]let arr2 = [4,5,6]let arr3 = arr1.concat(arr2)console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ]// 现在我们用扩展运算符看看let arr1 = [1,2,3]let arr2 = [4,5,6]let arr3 = [...arr1,...arr2]console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ] 1234567891011// 以往我们这样来取数组中最大的值function max(...args)&#123; return Math.max.apply(null,args)&#125;console.log(max(1,2,3,4,5,6)) // 6// 现在我们用扩展运算符看看function max(...args)&#123; return Math.max(...args) // 把args [1,2,3,4,5,6]展开为1,2,3,4,5,6&#125;console.log(max(1,2,3,4,5,6)) // 6 1234567891011121314151617// 扩展运算符可以把argument转为数组function max()&#123; console.log(arguments) // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5, &apos;5&apos;: 6 &#125; let arr = [...arguments] console.log(arr) // [1,2,3,4,5,6]&#125;max(1,2,3,4,5,6)// 但是扩展运算符不能把伪数组转为数组（除了有迭代器iterator的伪数组，如arguments）let likeArr = &#123; &quot;0&quot;:1,&quot;1&quot;:2,&quot;length&quot;:2 &#125;let arr = [...likeArr] // 报错 TypeError: likeArr is not iterable// 但是可以用Array.from把伪数组转为数组let likeArr = &#123; &quot;0&quot;:1,&quot;1&quot;:2,&quot;length&quot;:2 &#125;let arr = Array.from(likeArr)console.log(arr) // [1,2] 对象也可以使用扩展运算符 123456789101112// 以往我们这样合并对象let name = &#123; name:&quot;邵威儒&quot; &#125;let age = &#123; age:28 &#125;let person = &#123;&#125;Object.assign(person,name,age)console.log(person) // &#123; name: &apos;邵威儒&apos;, age: 28 &#125;// 使用扩展运算符let name = &#123; name:&quot;邵威儒&quot; &#125;let age = &#123; age:28 &#125;let person = &#123;...name,...age&#125;console.log(person) // &#123; name: &apos;邵威儒&apos;, age: 28 &#125; 需要注意的是，通过扩展运算符和Object.assign对对象进行合并的行为，是属于浅拷贝，那么我们在开发当中，经常需要对对象进行深拷贝，接下来我们看看如何进行深拷贝。 123456789101112131415// 方法一：利用JSON.stringify和JSON.parselet swr = &#123; name:&quot;邵威儒&quot;, age:28&#125;let swrcopy = JSON.parse(JSON.stringify(swr))console.log(swrcopy) // &#123; name:&quot;邵威儒&quot;,age:28 &#125;// 此时我们修改swr的属性swr.age = 29console.log(swr) // &#123; name:&quot;邵威儒&quot;,age:29 &#125;// 但是swrcopy却不会受swr影响console.log(swrcopy) // &#123; name:&quot;邵威儒&quot;,age:28 &#125;// 这种方式进行深拷贝，只针对json数据这样的键值对有效// 对于函数等等反而无效，不好用，接着继续看方法二、三。 1234567891011121314151617181920212223242526272829303132333435363738394041// 方法二：function deepCopy(fromObj,toObj) &#123; // 深拷贝函数 // 容错 if(fromObj === null) return null // 当fromObj为null if(fromObj instanceof RegExp) return new RegExp(fromObj) // 当fromObj为正则 if(fromObj instanceof Date) return new Date(fromObj) // 当fromObj为Date toObj = toObj || &#123;&#125; for(let key in fromObj)&#123; // 遍历 if(typeof fromObj[key] !== &apos;object&apos;)&#123; // 是否为对象 toObj[key] = fromObj[key] // 如果为普通值，则直接赋值 &#125;else&#123; toObj[key] = new fromObj[key].constructor // 如果为object，则new这个object指向的构造函数 deepCopy(fromObj[key],toObj[key]) // 递归 &#125; &#125; return toObj&#125;let dog = &#123; name:&quot;小白&quot;, sex:&quot;公&quot;, firends:[ &#123; name:&quot;小黄&quot;, sex:&quot;母&quot; &#125; ]&#125;let dogcopy = deepCopy(dog)// 此时我们把dog的属性进行修改dog.firends[0].sex = &apos;公&apos;console.log(dog) // &#123; name: &apos;小白&apos;, sex: &apos;公&apos;, firends: [ &#123; name: &apos;小黄&apos;, sex: &apos;公&apos; &#125;] &#125;// 当我们打印dogcopy，会发现dogcopy不会受dog的影响console.log(dogcopy) // &#123; name: &apos;小白&apos;, sex: &apos;公&apos;, firends: [ &#123; name: &apos;小黄&apos;, sex: &apos;母&apos; &#125; ] &#125; 123456789101112131415161718192021222324252627// 方法三：let dog = &#123; name:&quot;小白&quot;, sex:&quot;公&quot;, firends:[ &#123; name:&quot;小黄&quot;, sex:&quot;母&quot; &#125; ]&#125;function deepCopy(obj) &#123; if(obj === null) return null if(typeof obj !== &apos;object&apos;) return obj if(obj instanceof RegExp) return new RegExp(obj) if(obj instanceof Date) return new Date(obj) let newObj = new obj.constructor for(let key in obj)&#123; newObj[key] = deepCopy(obj[key]) &#125; return newObj&#125;let dogcopy = deepCopy(dog)dog.firends[0].sex = &apos;公&apos;console.log(dogcopy) Object.definePropertyObject.defineProperty这个并不是es6的语法，这个是给一个对象，添加属性，但是目前框架很多实用这个方法，来实现数据劫持，也就是数据双向绑定 1234// 平时我们这样给一个对象添加属性let obj = &#123;str:&quot;hello swr&quot;&#125;obj.str = &apos;goodbye swr&apos;console.log(obj.str) // &apos;goodbye swr&apos; 那么当我们想在给一个对象，读取值或写入值时，进行别的操作，该怎么做呢？1234567891011121314151617// 使用Object.defineProperty()// 接收的第一个参数为对象，第二个参数为属性名，第三个参数为配置对象let obj = &#123;&#125;Object.defineProperty(obj,&apos;name&apos;,&#123; enumerable:true,// 是否可枚举，默认值 true // 如果为false的话，打印这个obj对象，是看不到name这个属性 writable:true, // 是否可写，默认值 true // 如果为false的话，给name赋值，不会生效 configurable:true, // 是否可配置（是否可删除），默认值 true // 如果为true，delete obj.name，再打印obj，则显示&#123;&#125; // 如果为false，delete obj.name，再打印obj,则显示&#123;name:undefined&#125; value:&apos;swr&apos;, // name对应的值&#125;)// 上面的写法其实和下面的写法是一样的let obj = &#123;&#125;obj.name = &apos;swr&apos; 那么既然一样，我们有必要写这么大串的代码吗？ 其实核心是get和set，我们继续往下看123456789101112131415161718// 需要注意的是，当使用get set时，则不能使用value和writablelet obj = &#123;&#125;let strObject.defineProperty(obj,&apos;name&apos;,&#123; enumerable:true, configurable:true, get()&#123; // 读，当我们读取时，则会执行到get，比如obj.name // return &apos;swr&apos; // 当我们obj.name进行读取时，会返回&apos;swr&apos; return str &#125;, set(newValue)&#123; // 写，当我们写入时，则会执行到set，比如obj.name = &apos;swr&apos; // 并且会把newValue作为参数传进去 str = newValue &#125;&#125;)obj.name = &apos;swr&apos; // 写入console.log(obj.name) // &apos;swr&apos; // 读取 这样一来，我们可以在get set函数中，写出对应的业务逻辑， 包括很多框架底层，例如123456// 一般不再选择这样的写法Fn.prototype.xxx = xxx// 更多的是选择这样的写法// 这样的好处就是当读取值的时候，可以做一系列我们想做的事情Object.defineProperty(Fn.prototype,&apos;xxx&apos;,&#123;...&#125;) 那么我们实现数据双向绑定呢？这个问题在面试当中，会经常问这个问题，但是面试官更希望听到的是具体底层的实现方式，那么接下来我们也实现一下吧~ （ 简陋版的……(#^.^#) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;对象的数据双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&apos;input&apos; type=&quot;&quot; name=&quot;&quot; value=&quot;&quot;&gt; &lt;script&gt; let el = document.getElementById(&apos;input&apos;) // 1. 获取输入框的dom节点 let obj = &#123; // 2. 创建一个对象 name: &quot;&quot; &#125; function oberseve(obj) &#123; // 3. 对对象进行观察 if (typeof obj !== &apos;object&apos;) return // 3.1 判断参数是否为对象 for (let key in obj) &#123; // 3.2 对对象进行遍历，目的是为了把每个属性都设置get/set defineReactive(obj, key, obj[key]) oberseve(obj[key]) // 3.3 obj[key] 有可能还是一个函数，需要递归，给obj[key]里的属性进行设置get/set &#125; &#125; function defineReactive(target, property, value) &#123; // 4. 使用Object.defineProperty Object.defineProperty(target, property, &#123; get() &#123; el.value = value // 4.1 当读取时，把值赋值给input框 return value &#125;, set(newVal) &#123; el.value = newVal // 4.1 当设置时，把赋值给input框 value = newVal &#125; &#125;) &#125; oberseve(obj) // 5.执行该函数，对obj对象里的属性进行设置get/set el.addEventListener(&apos;input&apos;, function () &#123; // 6.给输入框绑定input事件 obj.name = this.value // 7.当输入框输入内容时，我们会把输入框的 // 内容赋值给obj.name，触发obj.name的set方法 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当我们在输入框输入内容时，再到控制台输入obj.name查看这个值时，会发现打印出”hello swr” 当我们在控制台，给obj.name赋值时，会发现输入框的内容也会作出相应更改 这样我们就实现了一个简陋版的数据双向绑定了，但是这也是有缺点的，这个只是针对对象进行了数据双向绑定,而尤大大的Vuejs就是基于Object.defineProperty实现的。 除了Object.defineProperty可以实现数据双向绑定之外，还有其他方式吗？ 肯定是有其他方式可以实现的，利用es6的proxy代理也可以实现数据双向绑定，但是目前的框架还是比较少使用这种方式。 ProxyProxy代理也可以进行数据劫持，但是和Object.defineProperty不同的是，Proxy是在数据外层套了个壳，然后通过这层壳访问内部的数据，目前Proxy支持13种方式。 Proxy，我的理解是在数据外层套了个壳，然后通过这层壳访问内部的数据，就像下面的图 123456789101112131415161718192021222324252627282930let dog = &#123; name:&quot;小黄&quot;, firends:[&#123; name:&quot;小红&quot; &#125;]&#125;// 1.首先new一个Proxy对象let proxy = new Proxy(dog,&#123; // 2.参数一为需要代理的数据，参数二为上图可以代理的13种的配置对象 get(target,property)&#123; // 3.参数1为上面dog对象，参数2为dog的属性 console.log(&apos;get被监控到了&apos;) return target[property] &#125;, set(target,property,value)&#123; // 4.参数1为上面dog对象，参数2为dog的属性，参数3为设置的新值 // 有点类似Object.defineProperty console.log(&apos;set被监控到了&apos;) target[property] = value &#125;&#125;)// 那么接下来我们设置一下这个属性// dog.name = &apos;小红&apos; // set值时，发现不会打印 &apos;set被监控到了&apos;// dog.name // get值时，发现不会打印 &apos;get被监控到了&apos;// 思考：为什么在set/get值的时候不会打印出来我们需要的东西呢？// 上面说得很明白了，proxy相当于是一个壳，代理我们需要监控的数据，也就是我们要通过proxy来访问内部数据才会被监控到proxy.name = &apos;小红&apos; // 打印输出 &apos;set被监控到了&apos;proxy.name // 打印输出 &apos;get被监控到了&apos; 1234567891011121314// Reflect经常和Proxy搭配使用// 比如我们上面的例子中let proxy = new Proxy(dog,&#123; get(target,property)&#123; console.log(&apos;get被监控到了&apos;) return target[property] &#125;, set(target,property,value)&#123; console.log(&apos;set被监控到了&apos;) // target[property] = value // 这里的target[property] = value 可以用下面的写法 Reflect.set(target,property,value) &#125;&#125;) 123456789101112// 那么我们该怎样实现深度的数据劫持呢？let dog = &#123; name:&quot;小黄&quot;, firend:&#123; name:&quot;小红&quot; &#125;&#125;// 我们首先写一个set方法，希望是通过这样来调用set(dog.firend,funtion(obj)&#123; console.log(obj) // &#123; name:&quot;小红&quot; &#125; 回调函数中的obj代表的是dog.firend的对象&#125;) 123456789101112131415161718192021// 实现let dog = &#123; name:&quot;小黄&quot;, firend:&#123; name:&quot;小红&quot; &#125;&#125;function set(obj,callback)&#123; let proxy = new Proxy(obj,&#123; set(target,property,value)&#123; target[property] = value &#125; &#125;) // 最后把proxy传给我们的回调函数 callback(proxy)&#125;set(dog.firend,function(obj)&#123; console.log(obj) // &#123; name:&quot;小红&quot; &#125; 实际就是从set函数中传出来的proxy对象&#125;) Symbol在js中，常见的数据类型有undefined null string number boolean object，而es6中，则新增了第七种数据类型symbol。 symbol会生成一个独一无二的值，为常量 1234567891011let s1 = Symbol()let s2 = Symbol()console.log(s1 === s2) // false// 因为Symbol生成的是一个独一无二的值，为常量，一般是作为对象的属性let obj = &#123; [s1]:1, [s2]:2&#125;console.log(obj) // &#123; [Symbol()]: 1, [Symbol()]: 2 &#125; Symbol.for与Symbol差不多，但是Symbol.for会生成一个唯一的标识 123456let s1 = Symbol.for(&apos;foo&apos;)let s2 = Symbol.for(&apos;foo&apos;)console.log(s1 === s2) // true// 也可以通过Symbol.keyFor把标识找出来console.log(Symbol.keyFor(s1)) // foo ArrayArray的常用方法有from reduce map forEach findIndex find every some filter includes等等 用法也很简单，我主要讲一下from和reduce。 Array.from把伪数组(包括不含有迭代器的伪数组)转化为数组 12345// 声明一个伪数组let likeArr = &#123; 0:1,1:2,2:3,length:3 &#125;// 转换为数组Array.from(likeArr) // [1,2,3] 那么我们用前面所说的扩展运算符，能够把伪数组转为数组吗？12345// 声明一个伪数组let likeArr = &#123; 0:1,1:2,2:3,length:3 &#125;// 用扩展运算符转换为数组let arr = [...likeArr] // 报错 likeArr is not iterable likeArr is not iterable意思是，likeArr这个伪数组没有迭代器， 那么可以看出，Array.from和…扩展运算符的区别了， Array.from可以将伪数组（包含没有迭代器的伪数组）转为数组， 而…扩展运算符只能把拥有迭代器的伪数组转为数组，如arguments、map、set， 那么我们如果想用…扩展运算符转为数组，该怎么办呢？1234567891011// 既然扩展运算符只能把有迭代器的伪数组转为数组，// 那么我们就给伪数组添加一个迭代器// 迭代器iterator需要一个generator生成器生成// 我们给这个伪数组新增一个[Symbol.iterator]的迭代器let likeArr = &#123; 0:1,1:2,2:3,length:3,[Symbol.iterator]:function *() &#123; for(let i = 0;i &lt; this.length;i++)&#123; yield this[i] &#125;&#125; &#125;console.log([...likeArr]) // [1,2,3] reduce1234567891011let arr = [1,2,3,4,5]// 参数一：前一个值// 参数二：下一个值（当前值）// 参数三：当前的索引// 参数四：arr数组let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next&#125;)console.log(total) // 15 123456789101112131415161718192021222324// 那么reduce是怎样一个运行流程呢？// 我们一步步拆解出来看let arr = [1,2,3,4,5]// arr会一直是[1,2,3,4,5]// 第一步：此时的prev为1，next为2，currentIndex为1let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 1+2=3 并且把3当做下一次的prev&#125;)// 第二步：此时的prev为3，next为3，currentIndex为2let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 3+3=6 并且把6当做下一次的prev&#125;)// 第三步：此时的prev为6，next为4，currentIndex为3let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 6+4=10 并且把10当做下一次的prev&#125;)// 第四步：此时的prev为10，next为5，currentIndex为4let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 10+5=15 最终结果会作为返回值返回&#125;) 那我们自己实现一个reduce，看看是如何实现的123456789101112131415Array.prototype.myReduce = function (callback) &#123; let prev = this[0] for(let i = 0;i &lt; this.length-1;i++)&#123; prev = callback(prev,this[i+1],i+1,this) &#125; return prev&#125;let arr = [1,2,3,4,5]let total = arr.myReduce(function(prev,next,currentIndex,arr)&#123; console.log(prev,next) return prev + next&#125;)console.log(total) // 15 map映射可以把数组返回成一个映射后的数组 12let arr = [1,2,3].map(item =&gt; item+1)console.log(arr) // [2,3,4] find查找，查找到后不再继续查找，查找不到则返回undefined，内部返回true的话，则返回当前item，1234let arr = [1,2,3,4]let val = arr.find(item=&gt;item === 3)console.log(val) // 3 every每个值是否满足条件，如果是则返回true，如果不是则返回false 123456789101112let arr = [1,2,3,4]let isTrue = arr.every(item =&gt; &#123; return item &gt; 0&#125;)console.log(isTrue) // truelet isTrue2 = arr.every(item =&gt; &#123; return item &gt; 2&#125;)console.log(isTrue2) // false some是否有其中一个值满足条件，如果是则返回true，如果不是则返回false 123456789101112let arr = [1,2,3,4]let isTrue = arr.every(item =&gt; &#123; return item &gt; 2&#125;)console.log(isTrue) // truelet isTrue2 = arr.every(item =&gt; &#123; return item &gt; 4&#125;)console.log(isTrue2) // false filter过滤，在回调函数中返回的为false的话，相当于过滤掉当前项，返回一个过滤后的数组 1234567let arr = [1,2,3,4]let newArr = arr.filter(item=&gt;&#123; return item &gt; 2&#125;)console.log(newArr) // [3,4] includes基本和some一样 Setset是放不重复的项，也就是去重 12let set = new Set([1,2,3,4,3,2,1])console.log(set) // Set &#123; 1, 2, 3, 4 &#125; Set有几个常用的方法，add clear delete entries 12345678910111213141516171819202122// addlet set = new Set([1,2,3,4,3,2,1])set.add(5)console.log(set) // Set &#123; 1, 2, 3, 4, 5 &#125;// 添加一个已有的值，则不会添加进去set.add(1)console.log(set) // Set &#123; 1, 2, 3, 4, 5 &#125;// deleteset.delete(3)console.log(set) // Set &#123; 1, 2, 4, 5 &#125;// entriesconsole.log(set.entries()) // SetIterator &#123; [ 1, 1 ], [ 2, 2 ], [ 4, 4 ], [ 5, 5 ] &#125;// clearset.clear()console.log(set) // Set &#123;&#125; Set常用于去重（并集） 123456function distinct(arr1,arr2)&#123; return [...new Set([...arr1,...arr2])]&#125;let arr = distinct([1,2,3],[2,3,4,5])console.log(arr) // [1,2,3,4,5] 求交集 12345678function intersect(arr1,arr2) &#123; // 利用Set里的方法has，来判断new Set(arr2)中是否含有item， // 如果含有，那么则是true，当为true时，filter函数则会保留该项 // 如果没有，则是false,当为false时，filter函数则不会保留该项 return arr1.filter(item =&gt; new Set(arr2).has(item))&#125;console.log(intersect([1,2,3],[2,3,4,5])) // [2,3] 求差集 12345function difference(arr1,arr2)&#123; return arr1.filter(item =&gt; !new Set(arr2).has(item))&#125;console.log(difference([1,2,3],[2,3,4,5])) // [1] Map也是集合，主要格式是 key =&gt; value，同样是不能放重复的key 1234567891011121314// 如果放重复的key会怎样呢？会被覆盖let map = new Map()map.set(&apos;name&apos;,&apos;邵威儒&apos;)map.set(&apos;name&apos;,&apos;swr&apos;)console.log(map) // Map &#123; &apos;name&apos; =&gt; &apos;swr&apos; &#125;// 取的话用getmap.get(&apos;name&apos;) // &apos;swr&apos;// 删的话用deletemap.delete(&apos;name&apos;)console.log(map) // Map &#123;&#125;// 很多方法和set差不多 1234567891011121314let map = new Map()map.set(&apos;name&apos;,&apos;邵威儒&apos;)map.set(&apos;age&apos;,28)// 一般使用for ... of ... 遍历for(let [key,value] of map.entries())&#123; console.log(key,value) // name 邵威儒 // age 28&#125;// 也可以用forEachmap.forEach(item =&gt; &#123; console.log(item) // 邵威儒 // 28&#125;) Set我用得最多的就是去重了，实际上Set Map我在开发中还是比较少会用到 Class类核心还是继承，而Class我认为是es5面向对象的语法糖。 在看Class之前建议看一下js的面向对象 https://juejin.im/post/5b8a8724f265da435450c591 看完后，我们开始进入es6的class 123456789101112131415161718192021222324252627// 语法// 声明一个类Class Person&#123; // 在constructor中写实例属性、方法 constructor()&#123; this.name = &quot;邵威儒&quot; // 实例属性 this.say = function()&#123; // 实例方法 console.log(&quot;我是实例方法上的say&quot;) &#125; &#125; // 原型方法 eat()&#123; console.log(&quot;我是原型方法上的eat&quot;) &#125; // 静态方法 也会被继承 static myName()&#123; return &quot;我是静态方法的myName&quot; &#125; // 在es6中静态属性不能这样写 static name = &quot;邵威儒&quot; 这样会报错 // 在es7中可以这样写static name = &quot;邵威儒&quot;&#125;let p = new Person() // new一个对象console.log(p.name) // 邵威儒p.eat() // 我是原型方法上的eatconsole.log(Person.myName()) // 我是静态方法的myName 那么子类怎么继承父类呢？ 12345678910111213141516171819202122232425// 父类class Person&#123; constructor()&#123; this.name = &quot;swr&quot; &#125; static myName()&#123; return &quot;Person&quot; &#125; eat()&#123; console.log(&apos;eat&apos;) &#125;&#125;// 子类// 子类Child继承父类Person// class Child extends Person实际上相当于// Child.prototype = Object.create(Person.prototype)// 打印出来可以看到// console.log(Child.prototype === Person.prototype) // false// console.log(Child.prototype.__proto__ === Person.prototype) // trueclass Child extends Person&#123; constructor()&#123; super() // 此处的super相当于Person.call(this) &#125;&#125; 前面我说了Class就类型es5面向对象的语法糖，为什么这样说呢？ 接下来我们看一下通过es5怎么模拟实现一个Class（可以用babel转一下，看看转为es5的代码是怎样的） 123456789101112131415let Child = (function()&#123; // 这种闭包的写法，好处可以把作用域封闭起来 // 在Child构造函数外写一系列变量 // 如 let name = &quot;邵威儒&quot;;let age = 28 等等… function Child()&#123; console.log(this) // 打印内部this，看看指向哪里 &#125; return Child&#125;)()// 通过直接调用函数，看看什么情况console.log(Child()) // 此时里面的this是指向全局的// 通过new来生成对象console.log(new Child()) // 此时里面的this是指向这个new出来的新对象 在es6中，不使用new来调用类，会报错 Class constructor Child cannot be invoked without &#39;new&#39; 12345class Child &#123; &#125;Child() // TypeError: Class constructor Child cannot be invoked without &apos;new&apos; 也就是说，想在es5中，模拟类，那么没使用new来调用构造函数时，也要抛出一个错误，那么我们会想到类的校验方法 123456789101112131415161718192021// * 1.声明一个类的校验方法// * 参数一：指向的构造函数// * 参数二：被调用时，this的指向function _classCallCheck(constructor,instance) &#123; // * 2.如果这个instance指向的不是constructor的话，意味着不是通过new来调用构造函数 if(!(instance instanceof constructor))&#123; // * 3.不满足时，则抛出异常 throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;let Child = (function()&#123; function Child()&#123; // * 4.在调用该构造函数的时候，先执行以下类的校验方法 _classCallCheck(Child,this) &#125; return Child&#125;)()// 不通过new调用时，会报错Child() // 报错 Class constructor Child cannot be invoked without &apos;new&apos; 那么我们类上，有实例属性方法、原型属性方法、静态属性方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function _classCallCheck(constructor,instance) &#123; if(!(instance instanceof constructor))&#123; throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;// * 4.描述器 descriptor// 参数一：构造函数// 参数二：描述原型属性方法数组// 参数三：描述静态属性方法数组function _createClass(constructor,protoProperties,staticProperties) &#123; // * 5.如果protoProperties数组有数组成员 if(protoProperties.length)&#123; // * 6.遍历 for(let i = 0;i &lt; protoProperties.length;i++)&#123; // * 7.通过Object.defineProperty把属性方法添加到constructor的原型对象上 Object.defineProperty(constructor.prototype,protoProperties[i].key,&#123; // * 8.利用扩展运算符，把&#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;展开 ...protoProperties[i] &#125;) &#125; &#125;&#125;// * 1.实例属性方法、原型属性方法、静态属性方法// 在es6中，原型属性方法不是通过prototype实现的// 而是通过一个叫描述器的东西实现的let Child = (function()&#123; function Child()&#123; _classCallCheck(Child,this) // * 2.实例属性方法还是写在构造函数内 this.name = &apos;邵威儒&apos; &#125; // * 3.描述器 descriptor // 参数一：构造函数 // 参数二：描述原型属性方法 // 参数三：描述静态属性方法 _createClass(Child, [ &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;, &#123;key:&quot;myname&quot;,value:&quot;iamswr&quot;&#125; ], [ &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125; ]) return Child&#125;)()// * 9.最后我们new一个对象出来，并且调用原型属性方法，看能否调用成功let c = new Child()c.say() // &apos;hello swr&apos; 调用成功 接下来，我们把静态方法，staticProperties也处理一下，此时会发现，protoProperties和staticProperties都会遍历然后使用Object.defineProperty那么我们封装一个方法进行处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function _classCallCheck(constructor,instance) &#123; if(!(instance instanceof constructor))&#123; throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;// * 1.封装一个方法，处理遍历和Object.definePropertyfunction _defineProperty(target,properties) &#123; for (let i = 0; i &lt; properties.length; i++) &#123; Object.defineProperty(target, properties[i].key, &#123; ...properties[i] &#125;) &#125;&#125;function _createClass(constructor,protoProperties,staticProperties) &#123; if(protoProperties.length)&#123; _defineProperty(constructor.prototype, protoProperties) &#125; // * 2.如果staticProperties数组有数组成员 if(staticProperties.length)&#123; // * 3.静态方法需要添加在constructor _defineProperty(constructor, staticProperties) &#125;&#125;let Child = (function()&#123; function Child()&#123; _classCallCheck(Child,this) this.name = &apos;邵威儒&apos; &#125; _createClass(Child, [ &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;, &#123;key:&quot;myname&quot;,value:&quot;iamswr&quot;&#125; ], [ &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125; ]) return Child&#125;)()let c = new Child()c.say()// * 4.最后我们通过Child来调用静态方法console.log(Child.total()) // 100 这样完成了一个雏形，但是还有最重要的继承还没实现，接下来我们实现继承。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function _classCallCheck(constructor,instance) &#123; if(!(instance instanceof constructor))&#123; throw TypeError(&quot;Class constructor Parent cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;function defineProperty(target,properties) &#123; for (let i = 0; i &lt; properties.length; i++) &#123; Object.defineProperty(constructor.prototype, properties[i].key, &#123; ...properties[i] &#125;) &#125;&#125;function _createClass(constructor,protoProperties,staticProperties) &#123; if(protoProperties.length)&#123; defineProperty(constructor.prototype, protoProperties) &#125; if(staticProperties.length)&#123; defineProperty(constructor, staticProperties) &#125;&#125;// * 6.继承方法function _inherits(subClass, superClass) &#123; if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123; throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass); &#125; // * 7.把子类的原型对象指向新的原型对象 组合寄生式继承 继承原型属性方法 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, // 把constructor指向子类 enumerable: false, writable: true, configurable: true &#125; &#125;); // * 8.继承父类的静态方法 if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError(&quot;this hasn&apos;t been initialised - super() hasn&apos;t been called&quot;); &#125; return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;&#125;// * 1.父类let Parent = (function()&#123; function Parent()&#123; _classCallCheck(Parent,this) this.name = &apos;父类实例属性&apos; &#125; _createClass(Parent, [ &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;父类原型方法say&quot;)&#125;&#125;, &#123;key:&quot;myname&quot;,value:&quot;父类原型属性myname&quot;&#125; ], [ &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125; ]) return Parent&#125;)()// * 2.子类let Child = (function (Parent) &#123; // * 4.这里接收传进的参数 父类 // * 5.写一个继承方法，继承原型属性方法和静态方法 _inherits(Child, Parent); function Child() &#123; _classCallCheck(Child, this) // * 9.继承实例属性方法 return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments)); &#125; return Child&#125;)(Parent) // * 3.在这里通过传参，把父类传进去let c = new Child()console.log(c.name) // &apos;父类实例属性&apos; 这样就可以用es5模拟es6的class了，会发现其实es6的class是es5面向对象的一个语法糖，经过这样解剖一下源码实现，会对class有更深刻的理解。 还有个问题，我们在react中，会这样写class 1234567891011class Parent&#123; name = &quot;邵威儒&quot;&#125;// 在正常情况下会报错，但是因为平时项目是使用了babel插件// 会帮我们自动编译语法，这种写法目前还处于草案阶段// 上面的写法实际等价于下面的写法class Parent&#123; constructor()&#123; this.name = &quot;邵威儒&quot; &#125;&#125; decorator 装饰器装饰器是用来装饰类的 123456789class Person &#123;&#125;function myFunction(target) &#123; target[&apos;myName&apos;] = &quot;邵威儒&quot;&#125;myFunction(Person)console.log(Person[&apos;myName&apos;]) // 邵威儒 这种写法，相当于给Person这个类添加了myName的属性那么换成decorator该怎么写呢？ 1234567891011// 在类前面写@myFunction@myFunctionclass Person &#123;&#125;function myFunction(target) &#123; target[&apos;myName&apos;] = &quot;邵威儒&quot;&#125;// myFunction(Person) 这一步可以不写console.log(Person[&apos;myName&apos;]) // 邵威儒 那么我们该怎么给myName传参呢？1234567891011@myFunction(&apos;邵威儒&apos;)class Person &#123;&#125;function myFunction(value) &#123; return function(target)&#123; // target代表的是类 target[&apos;myName&apos;] = value &#125;&#125;console.log(Person[&apos;myName&apos;]) // 邵威儒 修饰符也可以修饰类的方法12345678910111213141516class Person &#123; @myFunction say()&#123;&#125;&#125;// 如果修饰的是方法// 参数一：是Person.prototype// 参数二：是say// 参数三：是描述器function myFunction(target,key,descriptor)&#123; // 给这个类添加一个原型属性 Object.assign(target,&#123;name:&quot;邵威儒&quot;&#125;)&#125;let p = new Person()console.log(p.name) // 邵威儒 修饰符也可以修饰类的属性，比如我们有个不可修改的属性1234567891011class Person &#123; @onlyRead name = &apos;邵威儒&apos;&#125;function onlyRead(target,key,descriptor)&#123; descriptor.writable = false&#125;let p = new Person()p.name = &apos;swr&apos; // 报错，不能赋值 decorator的用处很多，包括重写函数1234567891011function myFunction(target,key,descriptor)&#123; // 拿出原本的函数 let fn = descriptor.value // 并且在原有的fn上加上自己的业务逻辑，比如console.log(&apos;哈哈哈&apos;) descriptor.value = function()&#123; // 这里写我们需要加入的内容 console.log(&apos;哈哈哈&apos;) // 这里执行原来的fn fn() &#125;&#125; 装饰器经常在react中使用~其实decorator是简写，逼格高一些。 es6其实还有很多新语法，但是我们平时并不常用，所以也没一一列举，可以到阮大神的es6看看~","categories":[{"name":"好文分享","slug":"好文分享","permalink":"https://ru23.com/categories/好文分享/"}],"tags":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"https://ru23.com/tags/优质文章分享/"}]},{"title":"使用hexo搭建github.io博客","slug":"2018-09-使用hexo搭建github-io博客","date":"2018-09-07T02:57:11.000Z","updated":"2018-10-22T09:40:22.549Z","comments":true,"path":"/frontend/cjnk8tww7002dwwa1v15j2bgm/","link":"","permalink":"https://ru23.com/frontend/cjnk8tww7002dwwa1v15j2bgm/","excerpt":"","text":"Introduction 回顾一下我三年搭建博客的历程，最初是选择wordpress，Wordpress全部由php编写，数组库采用MySQL。优点：用户只需要将Wordpress的源代码复制到网站根目录下，然后访问网站，之后的安装操作全部在浏览器上完成。即使不是软件行业的人，也可以在几分钟之内完成安装工作。甚至很多虚拟主机供应商都提供了Wordpress的一键式安装工具。用户连上传文件的步骤都省了。缺点：项目太臃肿了，Wordpress耗损CPU严重，不容易操作，运行稍慢。尤其是后期文章数目较多的时候，想要登陆下网站的管理后台，心态简直是抓狂的。loading了好久，有时候还会失败，发一篇文章也很费劲，索性就不维护了。后来在github网站上找到一个vue模板：github地址和demo预览二次开发了一下，的确是实现了很多功能，也挺轻便的，样式也可以自定义，博客可以直接写在github的issue，很方便，用了三个月后才发现百度的搜索引擎居然只收录了首页，搜索引擎的基础爬虫的原理就是抓取你的url，然后获取你的html源代码并解析。 而你的页面通常用了vue等js的数据绑定机制来展示页面数据，爬虫获取到的html是你的模型页面而不是最终数据的渲染页面，所以说用js来渲染数据对seo并不友好。而且github api在国内访问速度也没有想象中那么快，可能是github的CDN被墙屏了。 使用github.io可以搭建一个自己的博客,把静态文件项目托管到github上,可以写博客,可以使用markdown语法,也可以展示作品.灵活性高.但是有较大的难度,但是这对于一个熟悉git操作的前端开发工程师来说，都不算什么的。重点是hexo和github.io的域名和服务器都是免费的。当然也可以选择用自己的服务器和域名。 Quick Start安装 node,git，注册好github账号 (网站有很多教程，安装方法这里就不详细展开了，注意:github账号用户名一定不能有大写.) 安装hexo: 1npm install -g hexo 创建hexo文件夹:cmd窗口切换到对应的目录下,然后执行: hexo init也可以在 E:\\hexo 下右键,选择git bash,在窗口中执行hexo init自动安装了需要的文件. 安装依赖:继续执行: npm install 完成本地安装:继续在 E:\\hexo 下执行: hexo generate 继续执行: hexo server 然后在打开浏览器 localhost:4000 ,就可以看到,本地已经安装好了. 在github上创建博客仓库: image 跳转的后如下填写:(其中Repository name的格式是 ‘用户名’.github.io ),然后点创建仓库，Repository name必须和用户名（Owner）一致，不能有大写字母 image image 创建SSH keys监测是否有已经存在的SSH keys:打开 git bash 终端(可以在 E:\\hexo 下右键打开,也可以直接在开始菜单里打开) 执行: $ ls -al ~/.ssh image 如果没有的话,就生成一个SSH keys: 写自己的邮箱$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 然后会出现:12Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): 就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了.输入一个密码,这个密码后面会用到,所以要记住咯 保存SSH keys:创建成功后,他会提示你SSH keys保存在哪里:1234567Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 找到SSH keys:根据上一步里告诉你的路径,找到保存SSH keys的地方,我的是在 C:\\Users\\2000104591.ssh 其中 id_rsa.pub 就是SSH keys 如果为了防止以后找不到,可以把他们自己另存到其它地方 为github仓库添加SSH keys然后把创建的id_rsa.pub里的内容复制到Key里去,Title部分随便填. 点击’Add key’ 添加的过程中,还要再输入一次github的密码 image 配置_config.yml文件并发布:在 E:\\hexo(文件根目录下) 下,有一个文件叫 _config.yml ,打开它,拉到最底下,做如下修改: 然后再执行: hexo generate hexo deploy 然后访问: https://ye63.github.io/ (用户名改成自己的),就可以看到了. 快捷命令hexo 新建一篇文章给它添加分类和标签:1hexo new &quot;移动端限制input框只能输入数字&quot; 通过mou编辑器打开：添加tags和categories123456789---title: title #文章標題date: 2016-06-01 23:47:44 #文章生成時間categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略tags: #文章标签 可以省略 - 标签1 - 标签2description: #你對本頁的描述 可以省略--- 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 创建新页面1hexo new page &quot;about&quot;","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://ru23.com/categories/Hexo教程/"}],"tags":[]},{"title":"javascript截取文件名的后缀","slug":"2018-09-javascript截取文件名的后缀","date":"2018-09-06T11:22:37.000Z","updated":"2018-10-22T09:38:37.510Z","comments":true,"path":"/frontend/cjnk8tww10026wwa1vej8uxyk/","link":"","permalink":"https://ru23.com/frontend/cjnk8tww10026wwa1vej8uxyk/","excerpt":"","text":"12345678const fileName=\"text.png\";//带.的格式let fileFormat=fileName.substring(fileName.lastIndexOf('.'))// 不带.的格式let fileFormat2=fileName.substring(fileName.lastIndexOf('.')+1);console.log(fileFormat,fileFormat2) image","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"移动端限制input框只能输入数字","slug":"2018-09-移动端限制input框只能输入数字","date":"2018-09-03T08:56:58.000Z","updated":"2018-10-22T09:42:10.747Z","comments":true,"path":"/frontend/cjnk8twx40032wwa1anq2kyng/","link":"","permalink":"https://ru23.com/frontend/cjnk8twx40032wwa1anq2kyng/","excerpt":"","text":"html5 中，input 的 type 属性规定 input 元素的类型。1&lt;input type=\"value\"&gt; 有很多选项，详细可以参考HTML 5 type 属性 但是在移动端，还要区分是安卓用户，还是ios用户，所以这样写： 1&lt;input class=\"num_input\" type='number' pattern=\"[0-9]*\"/&gt; 在安卓端设置input类型为number，可限制键盘只输入数字，在ios端，要加入pattern验证输入字段的模式，才能限制数字输入。 另： autofocus=&quot;autofocus&quot;可以自动对焦。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://ru23.com/tags/html5/"}]},{"title":"React Js 微信分享封装","slug":"2018-09-React-Js-微信分享封装","date":"2018-09-03T07:17:54.000Z","updated":"2018-10-22T09:39:10.664Z","comments":true,"path":"/frontend/cjnk8twvx0024wwa1ua2iu8qm/","link":"","permalink":"https://ru23.com/frontend/cjnk8twvx0024wwa1ua2iu8qm/","excerpt":"","text":"Introductions本篇文章给大家分享的内容是代码详解React Js 微信分享封装，有着一定的参考价值，有需要的朋友可以参考一下 话不多说，直接上源代码： Quick Start分享功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import Fetch from './FetchIt';import API_URL from './url';import Share from './Share';let wxUtils = &#123;&#125;;////////////////////////////////////////////////////////////////////////////////////////// 分享/////////////////////////////////////////////////////////////////////////////////////////** getshareinfo?type= type :goods 课程详情 team 团详情 id 课程id tid 团ID * @param config * @param shareInfo &#123;imgUrl,title,description,link&#125; */function share2wx(config, shareInfo) &#123; const share = new Share(&#123; appid: config.appid, // 必填，公众号的唯一标识 timestamp: config.timestamp, // 必填，生成签名的时间戳 nonceStr: config.nonceStr, // 必填，生成签名的随机串 signature: config.signature, // 必填，签名 &#125;); share.init(Object.assign(&#123;&#125;, shareInfo));&#125;function getConfig(shareInfo) &#123; let href = window.location.href.split('#')[0]; const url = encodeURIComponent(href /*window.location.href*/); Fetch.get(`$&#123;API_URL.mobile.signature_path&#125;?url=$&#123;url&#125;`).then(data =&gt; &#123; share2wx(data, shareInfo); &#125;);&#125;/** * @param shareInfo */wxUtils.share = function (shareInfo) &#123; getConfig(shareInfo);&#125;;////////////////////////////////////////////////////////////////////////////////////////// 分享结束/////////////////////////////////////////////////////////////////////////////////////////** * 是否开启右上角Menu * @param open */wxUtils.optionMenu = function (open = true) &#123; if (open) &#123; openOptionMenu(); &#125; else &#123; disabledOptionMenu(); &#125;&#125;;/** * 是否禁用右上角 */function disabledOptionMenu() &#123; if (typeof WeixinJSBridge === \"undefined\") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady(true), false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady(true)); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady(true)); &#125; &#125; else &#123; onBridgeReady(true); &#125;&#125;/** * 开启menu */function openOptionMenu() &#123; if (typeof WeixinJSBridge === \"undefined\") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady(false), false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady(false)); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady(false)); &#125; &#125; else &#123; onBridgeReady(false); &#125;&#125;function onBridgeReady(disable = true) &#123; if (typeof WeixinJSBridge !== \"undefined\") WeixinJSBridge.call(disable ? 'hideOptionMenu' : 'showOptionMenu');&#125;/** * 隐藏微信网页底部的导航栏 * @param disable */wxUtils.disabledToolbar = function (disable = true) &#123; document.addEventListener('WeixinJSBridgeReady', function onBridgeReady() &#123; // 通过下面这个API隐藏底部导航栏 WeixinJSBridge.call(disable ? 'hideToolbar' : 'showToolbar'); &#125;);&#125;;export default wxUtils; 分享配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 分享function Share(config) &#123; wx.config(&#123; debug: false, // 开启调试模式 appId: config.appid, // 必填，公众号的唯一标识 timestamp: config.timestamp, // 必填，生成签名的时间戳 nonceStr: config.nonceStr, // 必填，生成签名的随机串 signature: config.signature, // 必填，签名，见附录1 jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage', 'onMenuShareWeibo'], // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 &#125;);&#125;Share.prototype = &#123; constructor: Share, init(config) &#123; this.imgUrl = config.imgUrl; this.link = config.link; // this.musicPath = config.musicPath; this.description = config.description; this.title = config.title; wx.ready(() =&gt; &#123; // if (this.musicPath) &#123; // document.getElementById('musicIcon').play(); // &#125; this.toFriend(); this.toTimeline(); &#125;); wx.error(res =&gt; &#123; console.log(`$&#123;res&#125;`); &#125;); &#125;, toFriend() &#123; wx.onMenuShareAppMessage(&#123; imgUrl: this.imgUrl, link: this.link, title: this.title, desc: this.description, success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, &#125;); &#125;, toTimeline() &#123; wx.onMenuShareTimeline(&#123; imgUrl: this.imgUrl, link: this.link, title: this.title, desc: this.description, success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, &#125;); &#125;,&#125;;export default Share; 开启分享12345678//开启分享BaseComponent.wxUtils.optionMenu(true);BaseComponent.wxUtils.share(&#123; imgUrl: activityData.sharePicUrl, title: activityData.shareTitle, description: activityData.shareContent, link: url,&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"错误码：events.js:183 throw er; // Unhandled 'error' event—解决办法","slug":"2018-08-错误码：events-js-183-throw-er-Unhandled-error-event—解决办法","date":"2018-08-30T14:48:30.000Z","updated":"2018-10-22T09:42:18.590Z","comments":true,"path":"/frontend/cjnk8twv2001nwwa1u800xssp/","link":"","permalink":"https://ru23.com/frontend/cjnk8twv2001nwwa1u800xssp/","excerpt":"","text":"控制台报错：12345678910111213141516171819202122232425Hash: 78f0873c3eb47a64bfaeVersion: webpack 1.14.0Time: 16mswebpack: Compiled successfully.events.js:183 throw er; // Unhandled &apos;error&apos; event ^Error: listen EADDRINUSE 127.0.0.1:8080 at Object._errnoException (util.js:1022:11) at _exceptionWithHostPort (util.js:1044:20) at Server.setupListenHandle [as _listen2] (net.js:1367:14) at listenInCluster (net.js:1408:12) at GetAddrInfoReqWrap.doListen [as callback] (net.js:1517:7) at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:97:10)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! webpack-demos@1.0.0 dev: `webpack-dev-server --devtool eval --progress --colors`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the webpack-demos@1.0.0 dev script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\qian\\AppData\\Roaming\\npm-cache\\_logs\\2018-08-30T14_46_37_546Z-debug.log 错误原因：端口号被占用 解决方案1.Win+R,cmd查询使用的端口号是否被占用：netstat -aon|findstr “8080”按回车显示占用8080端口对应的程序的PID号；2.根据PID号找到对应的程序：继续输入命令：tasklist|findstr “15008”按回车后显示出占用该端口的程序；3.按快捷键“Ctrl+Shift+Esc”调出Windows任务管理器，根据PID/程序对应名称结束该程序进程即可。","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://ru23.com/tags/npm/"}]},{"title":"合并数组的相同的key值，并且计算相同key值的个数","slug":"2018-08-合并数组的相同的key值，并且计算相同key值的个数","date":"2018-08-30T07:33:19.000Z","updated":"2018-10-22T09:41:01.723Z","comments":true,"path":"/frontend/cjnk8twut001hwwa1h11duzwk/","link":"","permalink":"https://ru23.com/frontend/cjnk8twut001hwwa1h11duzwk/","excerpt":"","text":"需求：合并数组的相同的key值，并且计算相同key值的个数 场景：根据list数组的每一项的key值coupon_sn合并数组，并且计数 js代码json数组：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364let list = [&#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"1\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;, &#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"2\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;, &#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"2\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;] js代码12345678910111213141516171819202122 let hash = &#123; coupon: &#123;&#125;,&#125;, i = 0, res = [];list.forEach(function(item ) &#123; let coupon_sn = item.coupon.coupon_sn; if (hash[coupon_sn]) &#123; if (!res[hash[coupon_sn] - 1].count) &#123; res[hash[coupon_sn] - 1].count = 1 &#125; res[hash[coupon_sn] - 1].count += 1 &#125; else &#123; hash[coupon_sn] = ++i &amp;&amp; res.push(&#123; \"count\": 1, \"id\": item.id, \"is_use\": item.is_use, \"use_time\": item.use_time, \"expired_time\": item.expired_time, \"coupon\": item.coupon &#125;) &#125;&#125;);console.log(res);","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"怎么把数组倒置，又不影响原来数组，reverse不行","slug":"2018-08-怎么把数组倒置，又不影响原来数组，reverse不行","date":"2018-08-18T15:33:00.000Z","updated":"2018-10-22T09:41:53.851Z","comments":true,"path":"/frontend/cjnk8twuy001kwwa1a0dycapf/","link":"","permalink":"https://ru23.com/frontend/cjnk8twuy001kwwa1a0dycapf/","excerpt":"","text":"情景：怎么把数组倒置，又不影响原来数组，reverse不行，会把原数组也给反过来。1234var arr = [\"1\",\"2\",\"3\",\"4\"];var bbb = arr.reverse()console.log(arr); //[\"4\", \"3\", \"2\", \"1\"]console.log(bbb); //[\"4\", \"3\", \"2\", \"1\"] 直接改的话bbb和arr指向是同一个数组对象。reverse改变的是数组对象，a指向它，所以改变了，要改变就要让其指向不同 解决方案12345678var arr = [\"1\",\"2\",\"3\",\"4\"];//列举4个解决方案var bbb = [...arr].reverse() //方法1var bbb = [].concat(arr).reverse() //方法2var bbb = Object.assign([],arr).reverse()//方法3var bbb = arr.slice().reverse()//方法4console.log(arr); console.log(bbb); ES6语法很方便~","categories":[],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"javascript怎么设置和暂停stream流","slug":"2018-08-javascript怎么设置和暂停stream流","date":"2018-08-16T08:43:46.000Z","updated":"2018-10-22T09:38:33.157Z","comments":true,"path":"/frontend/cjnk8twui001awwa1db3oujim/","link":"","permalink":"https://ru23.com/frontend/cjnk8twui001awwa1db3oujim/","excerpt":"","text":"1234567function stopStream() &#123; if (window.stream) &#123; window.stream.getTracks().forEach(function (track) &#123; track.stop(); &#125;); &#125;&#125; 1234function gotStream(stream) &#123; window.stream = stream; // make stream available to console videoElement.srcObject = stream;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://ru23.com/tags/javascript/"}]},{"title":"vue路由传参的三种基本方式","slug":"2018-08-vue路由传参的三种基本方式","date":"2018-08-15T10:31:11.000Z","updated":"2018-10-22T09:40:13.984Z","comments":true,"path":"/frontend/cjnk8twum001dwwa1poi774hj/","link":"","permalink":"https://ru23.com/frontend/cjnk8twum001dwwa1poi774hj/","excerpt":"","text":"现有如下场景，点击父组件的li元素跳转到子组件中，并携带参数，便于子组件获取数据。父组件中： 1&lt;li v-for=\"article in articles\" @click=\"getDescribe(article.id)\"&gt; methods： 方案一：12345 getDescribe(id) &#123;// 直接调用$router.push 实现携带参数的跳转 this.$router.push(&#123; path: `/describe/$&#123;id&#125;`, &#125;) 方案一，需要对应路由配置如下：12345&#123; path: '/describe/:id', name: 'Describe', component: Describe&#125; 很显然，需要在path中添加/:id来对应 $router.push 中path携带的参数。在子组件中可以使用来获取传递的参数值。1$route.params.id 方案二：父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。123456this.$router.push(&#123; name: 'Describe', params: &#123; id: id &#125; &#125;) 对应路由配置: 注意这里不能使用:/id来传递参数了，因为父组件中，已经使用params来携带参数了。12345&#123; path: '/describe', name: 'Describe', component: Describe&#125; 子组件中: 这样来获取参数1$route.params.id 方案三：父组件：使用path来匹配路由，然后通过query来传递参数这种情况下 query传递的参数会显示在url后面?id=？123456this.$router.push(&#123; path: '/describe', query: &#123; id: id &#125; &#125;) 对应路由配置：12345&#123; path: '/describe', name: 'Describe', component: Describe&#125; 对应子组件: 这样来获取参数1$route.query.id 这里要特别注意 在子组件中 获取参数的时候是$route.params 而不是$router 这很重要~~~","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"组(Array)操作之splice() --删除、插入、替换","slug":"2018-07-组-Array-操作之splice-删除、插入、替换","date":"2018-07-19T09:23:41.000Z","updated":"2018-10-22T09:43:18.976Z","comments":true,"path":"/frontend/cjnk8twud0016wwa10b3pd1cu/","link":"","permalink":"https://ru23.com/frontend/cjnk8twud0016wwa10b3pd1cu/","excerpt":"","text":"splice()方法，号称最强大的数组方法！！ splice()的主要用途是向数组的中部插入项，但是用这种方法的方式则有如下3中。 1、删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。 2、插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0(要删除的项数)和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2, 0, “red”, “green”)会从当前数组的位置2开始插字符串”red”和”green”。 3、替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项不必与删除的项相等。例如，splice(2, 1, “red”, “green”)，会删除当前数组位置2的项，然后再从位置2开始插入字符串”red”和”green”。 splice()方法始终都会返回一个数组，该数组中包含从原数组删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中使用splice()方法的方式。 123456789101112var colors = [\"red\", \"green\", \"blue\"];var removed = colors.splice(0, 1); //删除第一项console.log(\"colors：\" + colors); //green, blueconsole.log(\"返回的数组：\" + removed); //red,返回的数组中只包含一项removed = colors.splice(1, 0, \"yellow\", \"orange\"); //从位置1开始插入两项console.log(\"colors：\" + colors); //green, yellow, orange, blueconsole.log(\"返回的数组：\" + removed); //返回的是一个空数组removed = colors.splice(1, 1, \"red\", \"purple\"); //从位置1 删除一项，插入两项console.log(\"colors：\" + colors); //green, red, purple, orange, blueconsole.log(\"返回的数组：\" + removed); //yellow,返回的数组中只包含一项","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://ru23.com/tags/javascript/"}]},{"title":"vue子组件改变父组件数据的方法 emit方法","slug":"2018-07-vue子组件改变父组件数据的方法-emit方法","date":"2018-07-18T08:45:09.000Z","updated":"2018-10-22T09:40:01.098Z","comments":true,"path":"/frontend/cjnk8twtx000ywwa1uyarbiom/","link":"","permalink":"https://ru23.com/frontend/cjnk8twtx000ywwa1uyarbiom/","excerpt":"","text":"场景：自己封装的插件需要点击子组件的按钮去操作父组件的数据 方法子组件代码12345678910&lt;template&gt; &lt;child @click=&quot;close&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;methods: &#123; close() &#123; this.$emit(&apos;close&apos;,true); //触发close方法，true为向父组件传递的数据 &#125;&#125;&lt;/script&gt; 父组件12345678910111213141516&lt;template&gt; &lt;parent @close=&quot;toClose&quot; :msg=&quot;msg&quot;&gt;&lt;/parent&gt; //监听子组件触发的close事件,然后调用toClose方法 &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;data () &#123; return &#123; msg: false, &#125;&#125;，methods: &#123; toClose(msg) &#123; this.msg = msg; &#125;&#125;&lt;/script&gt; 拓展：vue emit 有多个参数该如何写1this.$emit(&apos;transferName&apos;, &#123;name: this.name, dev: this.des&#125;) 父组件HTML代码1&lt;child @transferName=\"getNameAndDes\"&gt;&lt;/child&gt; JS代码1234getNameAndDes(msg) &#123; this.name = msg.name this.dev = msg.dev&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"react-router v4中，不提供browserHistory等的导出~~怎么解决","slug":"2018-07-react-router-v4中，不提供browserHistory等的导出-怎么解决","date":"2018-07-17T08:48:04.000Z","updated":"2018-10-22T09:39:22.298Z","comments":true,"path":"/frontend/cjnk8twtu000uwwa14ct3bpyu/","link":"","permalink":"https://ru23.com/frontend/cjnk8twtu000uwwa14ct3bpyu/","excerpt":"","text":"问题当我们使用react-router v3的时候，我们想跳转路由，我们一般这样处理我们从react-router导出browserHistory。我们使用browserHistory.push()等等方法操作路由跳转。问题来了，在react-router v4中，不提供browserHistory等的导出~~那怎么办？我如何控制路由跳转呢？？？ 解决方法使用 withRouterwithRouter高阶组件，提供了history让你使用~ 1234567891011import React from \"react\";import &#123;withRouter&#125; from \"react-router-dom\";class MyComponent extends React.Component &#123; ... myFunction() &#123; this.props.history.push(\"/some/Path\"); &#125; ...&#125;export default withRouter(MyComponent); 我们可以不使用推荐的BrowserRouter，依旧使用Router组件。我们自己创建history，其他地方调用自己创建的history。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"React 如何监听路由变化重新渲染数据","slug":"2018-07-React-如何监听路由变化重新渲染数据","date":"2018-07-17T08:46:55.000Z","updated":"2018-10-22T09:39:37.547Z","comments":true,"path":"/frontend/cjnk8twtm000owwa1bk2lvsvj/","link":"","permalink":"https://ru23.com/frontend/cjnk8twtm000owwa1bk2lvsvj/","excerpt":"","text":"应用场景：12345678910// route.js&lt;Router&gt; &lt;Switch&gt; &lt;Route path=\"/\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/a\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/b\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/c\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/d\" component=&#123;NewsList&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt; 12345678910class NewsList extends Component &#123; componentWillMount () &#123; const type = this.props.location.pathname.replace('/', '') || 'top' this.props.dispatch(fetchListData(type)) &#125; render () &#123; ... &#125;&#125; 分析：React组件的生命周期钩子。第一次加载时:1234\"constructor\"\"componentWillMount\"\"render\"\"componentDidMount\" 当组件的props发生改变时，组件更新，会调用如下的生命周期钩子12345&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot; 当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子 怎么做呢？1234567891011121314151617181920class NewsList extends Component &#123; componentDidMount () &#123; this.fetchData(this.props.location); &#125; fetchData(location) &#123; const type = location.pathname.replace('/', '') || 'top' this.props.dispatch(fetchListData(type)) &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.location.pathname != this.props.location.pathname) &#123; this.fetchData(nextProps.location); &#125; &#125; render () &#123; ... &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"使用slice()简单封装实现将数组分割为几个等长度的子数组","slug":"2018-07-使用slice-简单封装实现将数组分割为几个等长度的子数组","date":"2018-07-16T08:42:32.000Z","updated":"2018-10-22T09:40:30.696Z","comments":true,"path":"/frontend/cjnk8twu80014wwa15bxrxpc9/","link":"","permalink":"https://ru23.com/frontend/cjnk8twu80014wwa15bxrxpc9/","excerpt":"","text":"使用数组的时候，我们有时候希望将一个数组分成几个相同长度的子数组，使用slice()方法可以返回一个子数组，所以我们可以将slice()再进行封装一下，以实现上面的功能。 首先我们先来看一下slice()方法： slice() 定义和用法slice() 方法可从已有的数组中返回选定的元素。 语法arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 返回值返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 说明请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 提示和注释注释：您可使用负值从数组的尾部选取元素。注释：如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 封装slice()加入现在有一个数组[1,2,3,4,5,6,7,8,9]，将其分为长度为4的子数组子数组1：[1,2,3,4] 是从数组下标0–&gt;3子数组2：[5,6,7,8] 是从数组下标4–&gt;7子数组3：[9] 是从数组下标8，因为不满4个从上面我们可以看到，一共分为3个数组，所以我们可以使用循环来进行封装。1234567891011121314/* * 将一个数组分成几个同等长度的数组 * array[分割的原数组] * size[每个子数组的长度] */function sliceArray(array, size) &#123; var result = []; for (var x = 0; x &lt; Math.ceil(array.length / size); x++) &#123; var start = x * size; var end = start + size; result.push(array.slice(start, end)); &#125; return result;&#125; 例如：123var array = [1,2,3,4,5,6,7,8,9];var array = sliceArray(array, 4);console.log(array); 将几个数组合并为一个数组concat()1.定义和用法concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。2.语法arrayObject.concat(arrayX,arrayX,……,arrayX) 参数 描述 arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 返回值返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。例如1234var arr1 = [1,2,3];var arr2 = [4,5,6];var arr = [];arr.concat(arr1, arr2); //输出[1, 2, 3, 4, 5, 6]","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://ru23.com/tags/javascript/"}]},{"title":"vue数组中数据变化但是视图没有更新解决方案","slug":"2018-07-vue数组中数据变化但是视图没有更新解决方案","date":"2018-07-11T08:41:15.000Z","updated":"2018-10-22T09:40:08.170Z","comments":true,"path":"/frontend/cjnk8twu00010wwa1o8ojz0wg/","link":"","permalink":"https://ru23.com/frontend/cjnk8twu00010wwa1o8ojz0wg/","excerpt":"","text":"数组更新检测变异方法Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：1234567push()pop()shift()unshift()splice()sort()reverse() 你打开控制台，然后用前面例子的 items 数组调用变异方法：example1.items.push({ message: ‘Baz’ }) 。 替换数组变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组： 123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) 你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength举个例子：1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新： 1234// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名： 1vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice：1vm.items.splice(newLength) 对象更改检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于： 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象：1Vue.set(vm.userProfile, 'age', 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：1vm.$set(vm.userProfile, 'age', 27) 有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 你应该这样做：1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"修改element ui 源码 npm run dist 报错以及解决方案","slug":"2018-06-修改element-ui-源码-npm-run-dist-报错以及解决方案","date":"2018-06-25T08:36:54.000Z","updated":"2018-10-22T09:40:37.353Z","comments":true,"path":"/frontend/cjnk8twtg000lwwa1u4uixtd2/","link":"","permalink":"https://ru23.com/frontend/cjnk8twtg000lwwa1u4uixtd2/","excerpt":"","text":"报错1234567891011121314151617181920212223242526272829D:\\astudy\\element-dev\\packages\\theme-chalk\\src\\fonts\\element-icons.ttf 1:1 error Parsing error: Unexpected character ''D:\\astudy\\element-dev\\packages\\theme-chalk\\src\\fonts\\element-icons.woff 1:5 error Parsing error: Unexpected character ''✖ 2 problems (2 errors, 0 warnings)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! element-ui@2.4.1 lint: `eslint src/**/* test/**/* packages/**/* build/**/* --quiet`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the element-ui@2.4.1 lint script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\terry.wt\\AppData\\Roaming\\npm-cache\\_logs\\2018-06-25T06_12_46_026Z-debug.lognpm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! element-ui@2.4.1 dist: `npm run clean &amp;&amp; npm run build:file &amp;&amp; npm run lint &amp;&amp; webpack --config build/webpack.conf.js &amp;&amp; webpack --config build/webpack.common.js &amp;&amp; webpack --config build/webpack.component.js&amp;&amp; npm run build:utils &amp;&amp; npm run build:umd &amp;&amp; npm run build:theme`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the element-ui@2.4.1 dist script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\terry.wt\\AppData\\Roaming\\npm-cache\\_logs\\2018-06-25T06_12_46_124Z-debug.log 报错是因为eslint检测出空格导致的，网上找了很多在webpack配置关闭eslint的方法不生效 修改方案 找到package.json文件找到script里面的dist方法，删除&amp;&amp;npm run lint方法 就可以了","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://ru23.com/tags/npm/"},{"name":"elementUI","slug":"elementUI","permalink":"https://ru23.com/tags/elementUI/"},{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"[react]-动态添加class","slug":"2018-06-react-动态添加class","date":"2018-06-17T11:09:19.000Z","updated":"2018-10-22T09:39:31.647Z","comments":true,"path":"/frontend/cjnk8twtd000iwwa1h5geps01/","link":"","permalink":"https://ru23.com/frontend/cjnk8twtd000iwwa1h5geps01/","excerpt":"","text":"12345&lt;li className=&#123;['mingxi-tit-one', this.state.buttonType === 1 &amp;&amp; 'mingxi-active'].join(' ')&#125;&gt;&lt;/li&gt;// 数组元素为className，// &amp;&amp; 符号为判断符，若条件成立则执行后面的内容// join为数组的方法，将数组元素拼接为字符串，链接符为一个空字符串","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"【ElementUI】日期选择器时间选择范围限制插入、替换","slug":"2018-05-【ElementUI】日期选择器时间选择范围限制插入、替换","date":"2018-05-14T09:27:47.000Z","updated":"2018-10-22T09:36:53.303Z","comments":true,"path":"/frontend/cjnk8twt3000dwwa1c7x9dhqy/","link":"","permalink":"https://ru23.com/frontend/cjnk8twt3000dwwa1c7x9dhqy/","excerpt":"","text":"ElementUI是饿了么推出的一套基于vue2.x的一个ui框架。官方文档也很详细，这里做一个element-ui日期插件的补充。官方文档中使用picker-options属性来限制可选择的日期，这里举例子稍做补充。 单个输入框的 组件代码：123&lt;el-date-picker v-model=\"value1\" type=\"date\" placeholder=\"选择日期\" :picker-options=\"pickerOptions0\"&gt; &lt;/el-date-picker&gt; 情景1: 设置选择今天以及今天之后的日期1234567891011121314151617181920212223data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now() - 8.64e7; &#125; &#125;, &#125; &#125; ``` **情景2: 设置选择今天以及今天以前的日期**```jsdata ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &gt; Date.now() - 8.64e6 &#125; &#125;, &#125; &#125; 情景3: 设置选择今天之后的日期（不能选择当天时间）1234567891011121314151617181920212223data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now(); &#125; &#125;, &#125; &#125; ``` **情景4: 设置选择今天之前的日期（不能选择当天）**```jsdata ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &gt; Date.now(); &#125; &#125;, &#125; &#125; 情景5: 设置选择三个月之前到今天的日期 123456789101112data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; let curDate = (new Date()).getTime(); let three = 90 * 24 * 3600 * 1000; let threeMonths = curDate - three; return time.getTime() &gt; Date.now() || time.getTime() &lt; threeMonths;; &#125; &#125;, &#125; &#125; 两个输入框 组件代码 123456&lt;el-date-picker v-model=\"value1\" type=\"date\" placeholder=\"开始日期\" :picker-options=\"pickerOptions0\"&gt;&lt;/el-date-picker&gt;&lt;el-date-picker v-model=\"value2\" type=\"date\" placeholder=\"结束日期\":picker-options=\"pickerOptions1\"&gt;&lt;/el-date-picker&gt; 情景1: 限制结束日期不能大于开始日期 12345678910111213141516171819data()&#123; return &#123; pickerOptions0: &#123; disabledDate: (time) =&gt; &#123; if (this.value2 != \"\") &#123; return time.getTime() &gt; Date.now() || time.getTime() &gt; this.value2; &#125; else &#123; return time.getTime() &gt; Date.now(); &#125; &#125; &#125;, pickerOptions1: &#123; disabledDate: (time) =&gt; &#123; return time.getTime() &lt; this.value1 || time.getTime() &gt; Date.now(); &#125; &#125;, &#125; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"elementUI","slug":"elementUI","permalink":"https://ru23.com/tags/elementUI/"}]},{"title":"详解angularJS动态生成的页面中ng-click无效解决办法","slug":"2018-04-详解angularJS动态生成的页面中ng-click无效解决办法","date":"2018-04-24T08:34:39.000Z","updated":"2018-10-22T09:42:35.122Z","comments":true,"path":"/frontend/cjnk8twt8000ewwa1a2g6cimx/","link":"","permalink":"https://ru23.com/frontend/cjnk8twt8000ewwa1a2g6cimx/","excerpt":"","text":"今天碰到了一个这样的需求，在自己写的动态的页面中，写入的AngularJS无效不能点击响应事件，以下给出代码以及解决方案 1.首先将我们要赋值给页面的数据new一下 1234567var html = \"&lt;a href='javascript:void(0);' ng-click='test()'&gt;&lt;/a&gt;\"``` &lt;h5&gt;2.用$compile函数编译一下上边的内容&lt;/h5&gt;```htmlvar $html = $compile(html)($scope); 3.将编译好的内容插入到页面中 1$(\"body\").append($html); 以下是完整版本 1234567891011app.controller('customersCtrl', function ($scope, $http,$compile) &#123; $scope.test = function()&#123; alert('test'); &#125; // TODO 动态生成html中 ng-click无效 解决方法 $compile 是传进来的 //下边这句话就是要写入页面中的内容，首先把你写入的内容赋值给html var html = \"&lt;a href='javascript:void(0);' ng-click='test()'&gt;&lt;/a&gt;\"//用$compile进行编译 var $html = $compile(html)($scope); //添加到页面中，或者你任何想添加的位置。&#125;); $(\"body\").append($html); ng-click就可以触发function了","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"angular","slug":"angular","permalink":"https://ru23.com/tags/angular/"},{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://ru23.com/tags/踩过的坑/"}]},{"title":"frank的前端开发规范（逐步完善）","slug":"2018-04-frank的前端开发规范（逐步完善）","date":"2018-04-19T11:49:01.000Z","updated":"2018-10-22T09:37:37.224Z","comments":true,"path":"/frontend/cjnk8twsw0009wwa1ohji9edf/","link":"","permalink":"https://ru23.com/frontend/cjnk8twsw0009wwa1ohji9edf/","excerpt":"","text":"js方法注释规范规范的注释很重要代码是写给人看的，顺便给机器运行，多谢注释可以增加代码的可读性 123456789101112131415161718/** ************** * @func 教师端请假功能 ; * @param &#123;String&#125; token 教师端头部的token; * @param &#123;string&#125; a - 参数a; * @param &#123;number&#125; b=1 - 参数b默认值为1; * @param &#123;string&#125; c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx; * @param &#123;object&#125; d - 参数d为一个对象; * @param &#123;string&#125; d.e - 参数d的e属性; * @param &#123;string&#125; d.f - 参数d的f属性; * @param &#123;object[]&#125; g - 参数g为一个对象数组; * @param &#123;string&#125; g.h - 参数g数组中一项的h属性; * @param &#123;string&#125; g.i - 参数g数组中一项的i属性; * @param &#123;string&#125; [j] - 参数j是一个可选参数; * @description 2018年4月19日被frank开发于dev_sprint65分支， * XX年XX月被XX在xx分支修改（原因或者修改的功能）; ****************/ 变量命名规范1.标准变量命名使用驼峰式命名 eg. let thisIsMyName;2.常量全部大写，并使用下划线连接 eg. const MAX_COUNT = 10; 项目规范变量声明尽量提在函数首部，用一个var声明，不允许出现连着的两个var声明(也包括let，const) 1234567891011function doSomethingWithItems(items) &#123; // use one var var value = 10, result = value + 10, i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; result += 10; &#125;&#125; undefind使用规范（永远不要直接使用undefined进行变量判断，使用typeof和字符串’undefined’对变量进行判断。） 123456789// not goodif (person === undefined) &#123; ...&#125;// goodif (typeof person === 'undefined') &#123; ...&#125; 用’===’和’!==’代替’==’, ‘!=’使用对象的属性简写123456789const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 使用拓展运算符 … 复制数组1234567891011// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] render使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051render: (h, params) =&gt; &#123; return h('div', [ h('span', &#123; attrs: &#123; class: \"table_details\" &#125;, on: &#123; click: () =&gt; &#123; this.edit(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_continue\" &#125;, on: &#123; click: () =&gt; &#123; this.show(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125;, on: &#123; click: () =&gt; &#123; this.remove(params.row.id) &#125; &#125; &#125;,), h('Poptip', &#123; props: &#123; title:\"项目变更\", content:\"项目迁出\", placement:\"bottom-end\" &#125;, on: &#123; 'on-ok': () =&gt; &#123; &#125; &#125; &#125;, [ h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125; &#125;) ]) ])&#125; 文档：有时间整理一下http://taobaofed.org/blog/2017/01/05/writing-readable-code/","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"开发规范","slug":"开发规范","permalink":"https://ru23.com/tags/开发规范/"}]},{"title":"flex水平垂直居中","slug":"2018-04-flex水平垂直居中","date":"2018-04-11T10:30:39.000Z","updated":"2018-10-22T09:37:24.843Z","comments":true,"path":"/frontend/cjnk8twsr0008wwa19uh0xekq/","link":"","permalink":"https://ru23.com/frontend/cjnk8twsr0008wwa19uh0xekq/","excerpt":"","text":"12345.box &#123; display: flex; align-items: center;/*垂直居中*/ justify-content: center;/*水平居中*/&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ru23.com/tags/css/"}]},{"title":"emoji表情存储后台报错的问题","slug":"2018-03-emoji表情存储后台报错的问题","date":"2018-03-29T08:54:07.000Z","updated":"2018-10-22T09:37:14.592Z","comments":true,"path":"/frontend/cjnk8twsm0007wwa1su29e7bg/","link":"","permalink":"https://ru23.com/frontend/cjnk8twsm0007wwa1su29e7bg/","excerpt":"","text":"123456789101112131415161718192021/** * 用于把用utf16编码的字符转换成实体字符，以供后台存储* @param &#123;string&#125; str 将要转换的字符串，其中含有utf16字符将被自动检出* @return &#123;string&#125; 转换后的字符串，utf16字符将被转换成&amp;#xxxx;形式的实体字符*/utf16toEntities(str) &#123; var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则 str = str.replace(patt, function(char) &#123; var H, L, code; if (char.length === 2) &#123; H = char.charCodeAt(0); // 取出高位 L = char.charCodeAt(1); // 取出低位 code = (H - 0xD800) * 0x400 + 0x10000 + L - 0xDC00; // 转换算法 return \"&amp;#\" + code + \";\"; &#125; else &#123; return char; &#125; &#125;); return str;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://ru23.com/tags/javascript/"}]},{"title":"lazyload页面中间有滚动条，滑动鼠标无法触发图片预加载","slug":"2018-03-lazyload页面中间有滚动条，滑动鼠标无法触发图片预加载","date":"2018-03-22T08:55:50.000Z","updated":"2018-10-22T09:38:56.836Z","comments":true,"path":"/frontend/cjnk8tws80004wwa1fdf3o6pm/","link":"","permalink":"https://ru23.com/frontend/cjnk8tws80004wwa1fdf3o6pm/","excerpt":"","text":"图片在容器里面你可以将插件用在可滚动容器的图片上, 例如带滚动条的 DIV 元素. 你要做的只是将容器定义为 jQuery 对象并作为参数传到初始化方法里面.css代码1234# container &#123; height: 600px; overflow: scroll;&#125; javascript代码1234$(\"img\").lazyload(&#123; placeholder: \"img/grey.gif\", container: $(\"#container\")&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"Hello Hexo Blog","slug":"2015-03-hello-world","date":"2015-09-03T07:17:54.000Z","updated":"2018-10-22T09:38:10.126Z","comments":true,"path":"/frontend/cjnk8twtq000rwwa1a6u203ux/","link":"","permalink":"https://ru23.com/frontend/cjnk8twtq000rwwa1a6u203ux/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://ru23.com/categories/Hexo教程/"}],"tags":[]}]}