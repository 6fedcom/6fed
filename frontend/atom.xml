<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端迷</title>
  
  <subtitle>凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ru23.com/"/>
  <updated>2020-05-09T09:04:13.693Z</updated>
  <id>https://ru23.com/</id>
  
  <author>
    <name>frank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见loader源码简析，以及动手实现一个md2html-loader</title>
    <link href="https://ru23.com/note/9dcfd273.html"/>
    <id>https://ru23.com/note/9dcfd273.html</id>
    <published>2020-04-06T14:39:47.000Z</published>
    <updated>2020-05-09T09:04:13.693Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文会带你简单的认识一下webpack的loader，动手实现一个利用md转成抽象语法树，再转成html字符串的loader。顺便简单的了解一下几个style-loader，vue-loader，babel-loader的源码以及工作流程。</p><p><a href="https://github.com/6fedcom/fe-blog/blob/master/webpack-loader/loaders/md-loader.js" target="_blank" rel="noopener">md2html-loader源码地址</a></p><h3 id="loader简介"><a href="#loader简介" class="headerlink" title="loader简介"></a>loader简介</h3><p>webpack允许我们使用loader来处理文件，loader是一个导出为function的node模块。可以将匹配到的文件进行一次转换，同时loader可以链式传递。<br>loader文件处理器是一个CommonJs风格的函数，该函数接收一个 String/Buffer 类型的入参，并返回一个 String/Buffer 类型的返回值。</p><h3 id="loader-的配置的两种形式"><a href="#loader-的配置的两种形式" class="headerlink" title="loader 的配置的两种形式"></a>loader 的配置的两种形式</h3><p>方案1:<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [{</span><br><span class="line">      test: <span class="regexp">/.vue$/</span>,</span><br><span class="line">      loader: <span class="string">'vue-loader'</span></span><br><span class="line">    }, {</span><br><span class="line">      test: <span class="regexp">/.scss$/</span>,</span><br><span class="line">      <span class="comment">// 先经过 sass-loader，然后将结果传入 css-loader，最后再进入 style-loader。</span></span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,<span class="comment">//从JS字符串创建样式节点</span></span><br><span class="line">        <span class="string">'css-loader'</span>,<span class="comment">// 把  CSS 翻译成 CommonJS</span></span><br><span class="line">        {</span><br><span class="line">          loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">          options: {</span><br><span class="line">            data: <span class="string">'$color: red;'</span><span class="comment">// 把 Sass 编译成 CSS</span></span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    }]</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>方法2（右到左地被调用）<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module</span></span><br><span class="line"><span class="keyword">import</span> Styles <span class="keyword">from</span> <span class="string">'style-loader!css-loader?modules!./styles.css'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>当链式调用多个 loader 的时候，请记住它们会以相反的顺序执行。取决于数组写法格式，从右向左或者从下向上执行。像流水线一样，挨个处理每个loader，前一个loader的结果会传递给下一个loader，最后的 Loader 将处理后的结果以 String 或 Buffer 的形式返回给 compiler。</p><h3 id="使用-loader-utils-能够编译-loader-的配置，还可以通过-schema-utils-进行验证"><a href="#使用-loader-utils-能够编译-loader-的配置，还可以通过-schema-utils-进行验证" class="headerlink" title="使用 loader-utils 能够编译 loader 的配置，还可以通过 schema-utils 进行验证"></a>使用 loader-utils 能够编译 loader 的配置，还可以通过 schema-utils 进行验证</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { getOptions } <span class="keyword">from</span> <span class="string">'loader-utils'</span>; </span><br><span class="line"><span class="keyword">import</span> { validateOptions } <span class="keyword">from</span> <span class="string">'schema-utils'</span>;  </span><br><span class="line"><span class="keyword">const</span> schema = {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>{</span><br><span class="line">  <span class="comment">// 获取 options</span></span><br><span class="line">  <span class="keyword">const</span> options = getOptions(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 检验loader的options是否合法</span></span><br><span class="line">  validateOptions(schema, options, <span class="string">'Demo Loader'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里写转换 loader 的逻辑</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> content;   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>content: 表示源文件字符串或者buffer</li><li>map: 表示sourcemap对象</li><li>meta: 表示元数据，辅助对象<h3 id="同步loader"><a href="#同步loader" class="headerlink" title="同步loader"></a>同步loader</h3>同步 loader，我们可以通过<code>return</code>和<code>this.callback</code>返回输出的内容<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>{</span><br><span class="line">  <span class="comment">//一些同步操作</span></span><br><span class="line">  outputContent=someSyncOperation(content)</span><br><span class="line">  <span class="keyword">return</span> outputContent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>如果返回结果只有一个，也可以直接使用 return 返回结果。但是，如果有些情况下还需要返回其他内容，如sourceMap或是AST语法树，这个时候可以借助webpack提供的api <code>this.callback</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.callback(</span><br><span class="line">    err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">    content: string | Buffer,</span><br><span class="line">    sourceMap?: SourceMap,</span><br><span class="line">    meta?: any</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第一个参数必须是 Error 或者 null<br>第二个参数是一个 string 或者 Buffer。<br>可选的：第三个参数必须是一个可以被这个模块解析的 source map。<br>可选的：第四个选项，会被 webpack 忽略，可以是任何东西【可以将抽象语法树(abstract syntax tree - AST)（例如 ESTree）作为第四个参数（meta），如果你想在多个 loader 之间共享通用的 AST，这样做有助于加速编译时间。】。</p><h3 id="异步loader"><a href="#异步loader" class="headerlink" title="异步loader"></a>异步loader</h3><p>异步loader，使用 this.async 来获取 callback 函数。<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让 Loader 缓存</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    <span class="comment">// 做异步的事</span></span><br><span class="line">    doSomeAsyncOperation(content, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>{</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> callback(err);</span><br><span class="line">        callback(<span class="literal">null</span>, result);</span><br><span class="line">    });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><p>详情请参考<a href="https://www.webpackjs.com/api/loaders/#%E5%90%8C%E6%AD%A5-loader" target="_blank" rel="noopener">官网API</a></p><h3 id="开发一个简单的md-loader"><a href="#开发一个简单的md-loader" class="headerlink" title="开发一个简单的md-loader"></a>开发一个简单的md-loader</h3> <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">"marked"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">"loader-utils"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>{</span><br><span class="line">    <span class="keyword">this</span>.cacheable && <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        marked.setOptions(options);</span><br><span class="line">        <span class="keyword">return</span> marked(content)</span><br><span class="line">    } <span class="keyword">catch</span> (err) {</span><br><span class="line">        <span class="keyword">this</span>.emitError(err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>上述的例子是通过现成的插件把markdown文件里的content转成html字符串，但是如果没有这个插件，改怎么做呢？这个情况下，我们可以考虑另外一种解法，借助 AST 语法树，来协助我们更加便捷地操作转换。</p><h3 id="利用-AST-作源码转换"><a href="#利用-AST-作源码转换" class="headerlink" title="利用 AST 作源码转换"></a>利用 AST 作源码转换</h3><p><code>markdown-ast</code>是将markdown文件里的content转成数组形式的抽象语法树节点，操作 AST 语法树远比操作字符串要简单、方便得多：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> md = <span class="built_in">require</span>(<span class="string">'markdown-ast'</span>);<span class="comment">//通过正则的方法把字符串处理成直观的AST语法树</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>{</span><br><span class="line">    <span class="keyword">this</span>.cacheable && <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(md(content))</span><br><span class="line">      <span class="keyword">const</span> parser = <span class="keyword">new</span> MdParser(content);</span><br><span class="line">      <span class="keyword">return</span> parser.data</span><br><span class="line">    } <span class="keyword">catch</span> (err) {</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>md通过正则切割的方法转成抽象语树</strong><br><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718d06de31d81b5?w=1084&h=1156&f=jpeg&s=245056" alt="md-ast"></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> md = <span class="built_in">require</span>(<span class="string">'markdown-ast'</span>);<span class="comment">//md通过正则匹配的方法把buffer转抽象语法树</span></span><br><span class="line"><span class="keyword">const</span> hljs = <span class="built_in">require</span>(<span class="string">'highlight.js'</span>);<span class="comment">//代码高亮插件</span></span><br><span class="line"><span class="comment">// 利用 AST 作源码转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MdParser</span> </span>{</span><br><span class="line"><span class="keyword">constructor</span>(content) {</span><br><span class="line">    <span class="keyword">this</span>.data = md(content);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data)</span><br><span class="line"><span class="keyword">this</span>.parse()</span><br><span class="line">}</span><br><span class="line">parse() {</span><br><span class="line"><span class="keyword">this</span>.data = <span class="keyword">this</span>.traverse(<span class="keyword">this</span>.data);</span><br><span class="line">}</span><br><span class="line">traverse(ast) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"md转抽象语法树操作"</span>,ast)</span><br><span class="line">     <span class="keyword">let</span> body = <span class="string">''</span>;</span><br><span class="line">    ast.map(<span class="function"><span class="params">item</span> =></span> {</span><br><span class="line">      <span class="keyword">switch</span> (item.type) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"bold"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"break"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"codeBlock"</span>:</span><br><span class="line">          <span class="keyword">const</span> highlightedCode = hljs.highlight(item.syntax, item.code).value</span><br><span class="line">          body += highlightedCode</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"codeSpan"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"image"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"italic"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"link"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">          item.type = (item.bullet === <span class="string">'-'</span>) ? <span class="string">'ul'</span> : <span class="string">'ol'</span></span><br><span class="line">          <span class="keyword">if</span> (item.type !== <span class="string">'-'</span>) {</span><br><span class="line">            item.startatt = (<span class="string">` start=<span class="subst">${item.indent.length}</span>`</span>)</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            item.startatt = <span class="string">''</span></span><br><span class="line">          }</span><br><span class="line">          body += <span class="string">'<'</span> + item.type + item.startatt + <span class="string">'>\n'</span> + <span class="keyword">this</span>.traverse(item.block) + <span class="string">'</'</span> + item.type + <span class="string">'>\n'</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"quote"</span>:</span><br><span class="line">          <span class="keyword">let</span> quoteString = <span class="keyword">this</span>.traverse(item.block)</span><br><span class="line">          body += <span class="string">'<blockquote>\n'</span> + quoteString + <span class="string">'</blockquote>\n'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"strike"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"text"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"title"</span>:</span><br><span class="line">          body += <span class="string">`<h<span class="subst">${item.rank}</span>><span class="subst">${item.text}</span></h<span class="subst">${item.rank}</span>>`</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"error"</span>, <span class="string">`No corresponding treatment when item.type equal<span class="subst">${item.type}</span>`</span>);</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://github.com/6fedcom/fe-blog/blob/master/webpack-loader/loaders/md-loader.js" target="_blank" rel="noopener">完整的代码参考这里</a></p><p><strong>ast抽象语法数转成html字符串</strong><br><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718d06cd7ec6746?w=1764&h=772&f=png&s=199593" alt="md-ast-string"></p><h3 id="loader的一些开发技巧"><a href="#loader的一些开发技巧" class="headerlink" title="loader的一些开发技巧"></a>loader的一些开发技巧</h3><ol><li>尽量保证一个loader去做一件事情，然后可以用不同的loader组合不同的场景需求</li><li>开发的时候不应该在 loader 中保留状态。loader必须是一个无任何副作用的纯函数，loader支持异步，因此是可以在 loader 中有 I/O 操作的。</li><li>模块化：保证 loader 是模块化的。loader 生成模块需要遵循和普通模块一样的设计原则。</li><li><p>合理的使用缓存<br>合理的缓存能够降低重复编译带来的成本。loader 执行时默认是开启缓存的，这样一来， webpack 在编译过程中执行到判断是否需要重编译 loader 实例的时候，会直接跳过 rebuild 环节，节省不必要重建带来的开销。<br>但是当且仅当有你的 loader 有其他不稳定的外部依赖（如 I/O 接口依赖）时，可以关闭缓存：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.cacheable&&<span class="keyword">this</span>.cacheable(<span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>loader-runner</code> 是一个非常实用的工具，用来开发、调试loader,它允许你不依靠 webpack 单独运行 loader</p></li></ol><figure class="highlight plain"><figcaption><span>install loader-runner --save-dev```</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```js</span><br><span class="line">// 创建 run-loader.js</span><br><span class="line">const fs = require("fs");</span><br><span class="line">const path = require("path");</span><br><span class="line">const { runLoaders } = require("loader-runner");</span><br><span class="line"></span><br><span class="line">runLoaders(</span><br><span class="line">  {</span><br><span class="line">    resource: "./readme.md",</span><br><span class="line">    loaders: [path.resolve(__dirname, "./loaders/md-loader")],</span><br><span class="line">    readResource: fs.readFile.bind(fs),</span><br><span class="line">  },</span><br><span class="line">  (err, result) => </span><br><span class="line">    (err ? console.error(err) : console.log(result))</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>执行 <code>node run-loader</code></p><h3 id="认识更多的loader"><a href="#认识更多的loader" class="headerlink" title="认识更多的loader"></a>认识更多的loader</h3><h5 id="style-loader源码简析"><a href="#style-loader源码简析" class="headerlink" title="style-loader源码简析"></a>style-loader源码简析</h5><p>作用：把样式插入到DOM中，方法是在head中插入一个style标签，并把样式写入到这个标签的 innerHTML 里<br>看下源码。</p><p>先去掉option处理代码，这样就比较清晰明了了<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/1718e5c999a6691f?w=1654&h=1464&f=png&s=474579" alt="style-loader"><br>返回一段js代码，通过require来获取css内容，再通过addStyle的方法把css插入到dom里<br>自己实现一个简陋的<code>style-loader.js</code><br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span> (<span class="params">request</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> {stringifyRequest}=loaderUtils</span><br><span class="line">  <span class="keyword">var</span> result = [</span><br><span class="line">    <span class="comment">//1. 获取css内容。2.// 调用addStyle把CSS内容插入到DOM中（locals为true，默认导出css）</span></span><br><span class="line">    <span class="string">'var content=require('</span> + stringifyRequest(<span class="keyword">this</span>, <span class="string">'!!'</span> + request) + <span class="string">')’, </span></span><br><span class="line"><span class="string">    '</span><span class="built_in">require</span>(<span class="string">' + stringifyRequest(this, '</span>!<span class="string">' + path.join(__dirname, "addstyle.js")) + '</span>)(content)’, </span><br><span class="line">    <span class="string">'if(content.locals) module.exports = content.locals’ </span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">  return result.join('</span>;<span class="string">')</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>需要说明的是，正常我们都会用default的方法，这里用到pitch方法。pitch 方法有一个官方的解释在这里 pitching loader。简单的解释一下就是，默认的loader都是从右向左执行，用 <code>pitching loader</code> 是从左到右执行的。<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    { <span class="attr">loader</span>: <span class="string">"style-loader"</span> },</span><br><span class="line">    { <span class="attr">loader</span>: <span class="string">"css-loader"</span> }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>为什么要先执行<code>style-loader</code>呢，因为我们要把<code>css-loader</code>拿到的内容最终输出成CSS样式中可以用的代码而不是字符串。</p><p><code>addstyle.js</code><br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>)</span><br><span class="line">  style.innerHTML = content</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(style)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="babel-loader源码简析"><a href="#babel-loader源码简析" class="headerlink" title="babel-loader源码简析"></a>babel-loader源码简析</h5><p>首先看下跳过loader的配置处理，看下babel-loader输出<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/1718e5c99b0cb186?w=682&h=314&f=png&s=55853" alt="babel-loader-console"><br>上图我们可以看到是输出<code>transpile(source, options)</code>的code和map<br>再来看下<code>transpile</code>方法做了啥<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/1718e5c99b6a3b0f?w=1174&h=1162&f=png&s=168221" alt="babel-loader-transpile"><br>babel-loader是通过babel.transform来实现对代码的编译的，<br>这么看来，所以我们只需要几行代码就可以实现一个简单的babel-loader<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">"babel-core"</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> babelOptions = {</span><br><span class="line">    presets: [<span class="string">'env'</span>]</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> babel.transform(source, babelOptions).code</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="vue-loader源码简析"><a href="#vue-loader源码简析" class="headerlink" title="vue-loader源码简析"></a>vue-loader源码简析</h5><p>vue单文件组件（简称sfc）<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><template></span><br><span class="line">  <div class="text"></span><br><span class="line">    {{a}}</span><br><span class="line">  </div></span><br><span class="line"></template></span><br><span class="line"><script></span><br><span class="line">export default {</span><br><span class="line">  data () {</span><br><span class="line">    return {</span><br><span class="line">      a: "vue demo"</span><br><span class="line">    };</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></script></span><br><span class="line"><style lang="scss" scope></span><br><span class="line">.text {</span><br><span class="line">  color: red;</span><br><span class="line">}</span><br><span class="line"></style></span><br></pre></td></tr></tbody></table></figure><p></p><p>webpack配置<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueloaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span></span><br><span class="line">      }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueloaderPlugin()</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>VueLoaderPlugin</strong><br>作用：将在webpack.config定义过的其它规则复制并应用到 .vue 文件里相应语言的块中。</p><p><code>plugin-webpack4.js</code><br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vueLoaderUse = vueUse[vueLoaderUseIndex]</span><br><span class="line">   vueLoaderUse.ident = <span class="string">'vue-loader-options'</span></span><br><span class="line">   vueLoaderUse.options = vueLoaderUse.options || {}</span><br><span class="line">   <span class="comment">// cloneRule会修改原始rule的resource和resourceQuery配置，</span></span><br><span class="line">   <span class="comment">// 携带特殊query的文件路径将被应用对应rule</span></span><br><span class="line">   <span class="keyword">const</span> clonedRules = rules</span><br><span class="line">     .filter(<span class="function"><span class="params">r</span> =></span> r !== vueRule)</span><br><span class="line">     .map(cloneRule)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// global pitcher (responsible for injecting template compiler loader & CSS</span></span><br><span class="line">   <span class="comment">// post loader)</span></span><br><span class="line">   <span class="keyword">const</span> pitcher = {</span><br><span class="line">     loader: <span class="built_in">require</span>.resolve(<span class="string">'./loaders/pitcher'</span>),</span><br><span class="line">     resourceQuery: <span class="function"><span class="params">query</span> =></span> {</span><br><span class="line">       <span class="keyword">const</span> parsed = qs.parse(query.slice(<span class="number">1</span>))</span><br><span class="line">       <span class="keyword">return</span> parsed.vue != <span class="literal">null</span></span><br><span class="line">     },</span><br><span class="line">     options: {</span><br><span class="line">       cacheDirectory: vueLoaderUse.options.cacheDirectory,</span><br><span class="line">       cacheIdentifier: vueLoaderUse.options.cacheIdentifier</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新webpack的rules配置，这样vue单文件中的各个标签可以应用clonedRules相关的配置</span></span><br><span class="line">   compiler.options.module.rules = [</span><br><span class="line">     pitcher,</span><br><span class="line">     ...clonedRules,</span><br><span class="line">     ...rules</span><br><span class="line">   ]</span><br></pre></td></tr></tbody></table></figure><p></p><p>获取<code>webpack.config.js</code>的rules项，然后复制rules，为携带了<code>?vue&lang=xx...query</code>参数的文件依赖配置xx后缀文件同样的loader<br>为Vue文件配置一个公共的loader：pitcher<br>将<code>[pitchLoder, ...clonedRules, ...rules]</code>作为webapck新的rules。</p><p>再看一下<code>vue-loader</code>结果的输出<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/17191d9dd1fe72bc?w=1698&h=1066&f=png&s=226397" alt="vue-loader-result"><br>当引入一个vue文件后，vue-loader是将vue单文件组件进行parse，获取每个 block 的相关内容，将不同类型的 block 组件的 Vue SFC 转化成 js module 字符串。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue-loader使用`@vue/component-compiler-utils`将SFC源码解析成SFC描述符,,根据不同 module path 的类型(query 参数上的 type 字段)来抽离 SFC 当中不同类型的 block。</span></span><br><span class="line"><span class="keyword">const</span> { parse } = <span class="built_in">require</span>(<span class="string">'@vue/component-compiler-utils'</span>)</span><br><span class="line"><span class="comment">// 将单个*.vue文件内容解析成一个descriptor对象，也称为SFC（Single-File Components）对象</span></span><br><span class="line"><span class="comment">// descriptor包含template、script、style等标签的属性和内容，方便为每种标签做对应处理</span></span><br><span class="line"><span class="keyword">const</span> descriptor = parse({</span><br><span class="line">  source,</span><br><span class="line">  compiler: options.compiler || loadTemplateCompiler(loaderContext),</span><br><span class="line">  filename,</span><br><span class="line">  sourceRoot,</span><br><span class="line">  needMap: sourceMap</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为单文件组件生成唯一哈希id</span></span><br><span class="line"><span class="keyword">const</span> id = hash(</span><br><span class="line">  isProduction</span><br><span class="line">  ? (shortFilePath + <span class="string">'\n'</span> + source)</span><br><span class="line">  : shortFilePath</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 如果某个style标签包含scoped属性，则需要进行CSS Scoped处理</span></span><br><span class="line"><span class="keyword">const</span> hasScoped = descriptor.styles.some(<span class="function"><span class="params">s</span> =></span> s.scoped)</span><br></pre></td></tr></tbody></table></figure><p>然后下一步将新生成的 js module 加入到 webpack 的编译环节，即对这个 js module 进行 AST 的解析以及相关依赖的收集过程。</p><p>来看下源码是怎么操作不同type类型（<code>template/script/style</code>）的，selectBlock 方法内部主要就是根据不同的 type 类型，来获取 descriptor 上对应类型的 content 内容并传入到下一个 loader 处理<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/17191d9dc73e31ee?w=1460&h=1410&f=png&s=333873" alt="vue-loader源码"><br>这三段代码可以把不同type解析成一个import的字符串<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { render, staticRenderFns } <span class="keyword">from</span> <span class="string">"./App.vue?vue&type=template&id=7ba5bd90&"</span></span><br><span class="line"><span class="keyword">import</span> script <span class="keyword">from</span> <span class="string">"./App.vue?vue&type=script&lang=js&"</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./App.vue?vue&type=script&lang=js&"</span></span><br><span class="line"><span class="keyword">import</span> style0 <span class="keyword">from</span> <span class="string">"./App.vue?vue&type=style&index=0&lang=scss&scope=true&"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>总结一下vue-loader的工作流程</strong></p><ol><li>注册<code>VueLoaderPlugin</code><br>在插件中，会复制当前项目webpack配置中的rules项，当资源路径包含query.lang时通过resourceQuery匹配相同的rules并执行对应loader时<br>插入一个公共的loader，并在pitch阶段根据query.type插入对应的自定义loader</li><li>加载*.vue时会调用<code>vue-loader</code>,.vue文件被解析成一个<code>descriptor</code>对象，包含<code>template、script、styles</code>等属性对应各个标签，<br>对于每个标签，会根据标签属性拼接<code>src?vue&query</code>引用代码，其中src为单页面组件路径，query为一些特性的参数，比较重要的有lang、type和scoped<br>如果包含lang属性，会匹配与该后缀相同的rules并应用对应的loaders<br>根据type执行对应的自定义loader，<code>template</code>将执行<code>templateLoader</code>、<code>style</code>将执行<code>stylePostLoader</code></li><li>在<code>templateLoader</code>中，会通过<code>vue-template-compiler</code>将template转换为render函数，在此过程中，<br>会将传入的<code>scopeId</code>追加到每个标签的上，最后作为vnode的配置属性传递给<code>createElemenet</code>方法，<br>在render函数调用并渲染页面时，会将<code>scopeId</code>属性作为原始属性渲染到页面上</li><li>在<code>stylePostLoader</code>中，通过PostCSS解析style标签内容</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.webpackjs.com/api/loaders/" target="_blank" rel="noopener">webpack官网loader api</a></li><li><a href="https://mp.weixin.qq.com/s/gTAq5K5pziPT4tmiGqw5_w" target="_blank" rel="noopener">手把手教你写webpack yaml-loader</a></li><li><a href="https://github.com/lihongxun945/diving-into-webpack" target="_blank" rel="noopener">言川-webpack 源码解析系列</a></li><li><a href="https://juejin.im/post/5d8627355188253f3a70c22c" target="_blank" rel="noopener">从vue-loader源码分析CSS Scoped的实现</a></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本文会带你简单的认识一下webpack的loader，动手实现一个利用md转成抽象语法树，再转成html字符串的loader。顺便简单的了解一下几个style-loader，vue-loader，babel-loader的源
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="webpack" scheme="https://ru23.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>taro在mac安装的坑 bash： taro： command not found</title>
    <link href="https://ru23.com/note/66fc267.html"/>
    <id>https://ru23.com/note/66fc267.html</id>
    <published>2019-10-08T01:55:52.000Z</published>
    <updated>2020-05-09T08:50:37.482Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>首先安装脚手架cli：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 npm 安装 CLI</span><br><span class="line">$ npm install -g @tarojs/cli</span><br></pre></td></tr></tbody></table></figure><p></p><p>在windows系统，就可以初始化项目了，但是在mac会出现问题：</p><p><strong>-bash: taro: command not found</strong>  – 没有配置环境变量</p><p>解决教程：</p><ol><li>先找到taro安装的路径，如果忘了重新跑一遍 – <strong>npm install -g @tarojs/cli</strong></li></ol><p><img src="//cdn.ru23.com/img/2019/10/taro1.1.jpg" alt="找到taro安装的路径"></p><p>红框内为安装路径，注意：位置指向<strong>bin</strong>目录，没有taro目录</p><ol start="2"><li>open -e .bash_profile – 配置环境变量<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># taro add</span><br><span class="line">export TARO=/Users/XXXXXX/.npm-global/lib/node_modules/@tarojs/cli/bin</span><br><span class="line">export PATH=$TARO:$PATH</span><br></pre></td></tr></tbody></table></figure></li></ol><p>3、保存配置，关闭，最后读取文件并执行，就会立刻生效。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></tbody></table></figure><p></p><p>4、问题解决</p><p><img src="//cdn.ru23.com/img/2019/10/taro2.1.jpg" alt="问题解决"></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;首先安装脚手架cli：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="小程序" scheme="https://ru23.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>react常见api以及原理解析</title>
    <link href="https://ru23.com/note/55bd244d.html"/>
    <id>https://ru23.com/note/55bd244d.html</id>
    <published>2019-09-01T01:55:52.000Z</published>
    <updated>2020-04-11T11:59:26.171Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="React16常用api解析以及原理剖析"><a href="#React16常用api解析以及原理剖析" class="headerlink" title="React16常用api解析以及原理剖析"></a><a href="https://ru23.github.io/react-ppt/" target="_blank" rel="noopener"><code>React16</code>常用<code>api</code>解析以及原理剖析</a></h3><ver><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li><code>Vue</code> 与 <code>React</code> 两个框架的粗略区别对比</li><li><code>react 16</code> 版本常见 <code>api</code></li><li><code>react</code> 生命周期</li><li><code>react</code> 事件机制</li><li><code>react.Component</code> 如何实现组件化以及高阶组件的应用</li><li><code>setState</code> 异步队列数据管理</li><li><code>react Fiber</code> 架构分析</li><li><code>react hooks</code></li><li><code>dom</code> 的 <code>diff</code> 算法</li><li><code>snabbdom</code> 源码，是怎样实现精简的 <code>Virtual DOM</code> 的</li><li><code>redux</code>单向数据流架构如何设计</li></ol><ver><h3 id="Vue-与-React-两个框架的粗略区别对比"><a href="#Vue-与-React-两个框架的粗略区别对比" class="headerlink" title="Vue 与 React 两个框架的粗略区别对比"></a><code>Vue</code> 与 <code>React</code> 两个框架的粗略区别对比</h3><p>Vue 的优势包括：</p><ol><li>模板和渲染函数的弹性选择</li><li>简单的语法及项目创建</li><li>更快的渲染速度和更小的体积</li></ol><p>React 的优势包括：</p><ol><li>更适用于大型应用和更好的可测试性</li><li>同时适用于 Web 端和原生 App</li><li>更大的生态圈带来的更多支持和工具</li></ol><ver><h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><p>React 与 Vue 有很多相似之处，React 和 Vue 都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：如他们都是 JavaScript 的 UI 框架，专注于创造前端的富应用。不同于早期的 JavaScript 框架“功能齐全”，Reat 与 Vue 只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。</p><ver><ul><li>两者都是用于创建 UI 的 JavaScript 库；</li><li>两者都快速轻便；</li><li>都有基于组件的架构；</li><li>都是用虚拟 DOM；</li><li>都可放入单个 HTML 文件中，或者成为更复杂 webpack 设置中的模块；</li><li>都有独立但常用的路由器和状态管理库；</li><li>它们之间的最大区别是 Vue 通常使用 HTML 模板文件，而 React 则完全是 JavaScript。Vue 有双向绑定语法糖。</li></ul><ver><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li>Vue 组件分为全局注册和局部注册，在 react 中都是通过 import 相应组件，然后模版中引用；</li><li>props 是可以动态变化的，子组件也实时更新，在 react 中官方建议 props 要像纯函数那样，输入输出一致对应，而且不太建议通过 props 来更改视图；</li><li>子组件一般要显示地调用 props 选项来声明它期待获得的数据。而在 react 中不必需，另两者都有 props 校验机制；</li></ul><ver><ul><li>每个 Vue 实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而 react 必需自己实现；</li><li>使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；</li><li>多了指令系统，让模版可以实现更丰富的功能，而 React 只能使用 JSX 语法；</li><li>Vue 增加的语法糖 computed 和 watch，而在 React 中需要自己写一套逻辑来实现；</li></ul><ver><ul><li>react 的思路是 all in js，通过 js 来生成 html，所以设计了 jsx，还有通过 js 来操作 css，社区的 styled-component、jss 等；而 vue 是把 html，css，js 组合到一起，用各自的处理方式，vue 有单文件组件，可以把 html、css、js 写到一个文件中，html 提供了模板引擎来处理。</li></ul><ver><ul><li>react 做的事情很少，很多都交给社区去做，vue 很多东西都是内置的，写起来确实方便一些， 比如 redux 的 combineReducer 就对应 vuex 的 modules， 比如 reselect 就对应 vuex 的 getter 和 vue 组件的 computed， vuex 的 mutation 是直接改变的原始数据，而 redux 的 reducer 是返回一个全新的 state，所以 redux 结合 immutable 来优化性能，vue 不需要。</li></ul><ver><ul><li>react 是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合 redux-form，组件的横向拆分一般是通过高阶组件。而 vue 是数据可变的，双向绑定，声明式的写法，vue 组件的横向拆分很多情况下用 mixin。</li></ul><hor><h4 id="社区活跃度"><a href="#社区活跃度" class="headerlink" title="社区活跃度"></a>社区活跃度</h4><ver><p>从两者的 github 表现来看（数据取于 2019-09-16）</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/16/16d38db48fc07ab0?w=999&h=574&f=jpeg&s=107298" alt="react"></p><ver><p><img src="https://user-gold-cdn.xitu.io/2019/9/16/16d38db490ba4e1c?w=1012&h=566&f=jpeg&s=95105" alt="react"></p><ver><p>可以看出 vue 的 star 数量已经是前端框架中最火爆的。从维护上来看，react 是 facebook 在维护，而 vue 现阶段虽然也有了团队，但主要还是尤雨溪在维护贡献代码，并且阿里巴巴开源的混合式框架 weex 也是基于 vue 的，所以我们相信 vue 未来将会得到更多的人和团队维护。</p><p>根据不完全统计，包括饿了么、简书、高德、稀土掘金、苏宁易购、美团、天猫、荔枝 FM、房多多、Laravel、htmlBurger 等国内外知名大公司都在使用 vue 进行新项目的开发和旧项目的前端重构工作。</p><p>使用 React 的公司 facebook、Twitter、INS、Airbnb、Yahoo、ThoughtWorks、蚂蚁金服、阿里巴巴、腾讯、百度、口碑、美团、滴滴出行、饿了么、京东、网易等。</p><ver><h4 id="UI-生态"><a href="#UI-生态" class="headerlink" title="UI 生态"></a>UI 生态</h4><table><thead><tr><th></th><th style="text-align:right">vue</th><th style="text-align:center">react</th></tr></thead><tbody><tr><td>pc 端</td><td style="text-align:right">iview、element 等</td><td style="text-align:center">Ant Design、Materal-UI 等</td></tr><tr><td>h5 端</td><td style="text-align:right">有赞 vant、mintui 等</td><td style="text-align:center">Ant Design Mobile、weui</td></tr><tr><td>混合开发</td><td style="text-align:right">weexui、bui-weex</td><td style="text-align:center">teaset、react-native-elements</td></tr><tr><td>微信小程序</td><td style="text-align:right">iview、Weapp、zanui</td><td style="text-align:center">iView Weapp、Taro UI</td></tr></tbody></table><ver><p>无论您选择 React.js 还是 Vue.js，两个框架都没有相当大的差异，根据您的要求，这个决定是非常主观的。如果您想将前端 JavaScript 框架集成到现有应用程序中，Vue.js 是更好的选择，如果您想使用 JavaScript 构建移动应用程序，React 绝对是您的选择。</p><hor><h3 id="react16-版本常见-api"><a href="#react16-版本常见-api" class="headerlink" title="react16 版本常见 api"></a><code>react16</code> 版本常见 <code>api</code></h3><ver><p>先来看一下 react 暴露出来的 API</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> React = {</span><br><span class="line">  Children: {</span><br><span class="line">    map,</span><br><span class="line">    forEach,</span><br><span class="line">    count,</span><br><span class="line">    toArray,</span><br><span class="line">    only</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  createRef,</span><br><span class="line">  Component,</span><br><span class="line">  PureComponent,</span><br><span class="line"></span><br><span class="line">  createContext,</span><br><span class="line">  forwardRef,</span><br><span class="line"></span><br><span class="line">  Fragment: REACT_FRAGMENT_TYPE,</span><br><span class="line">  StrictMode: REACT_STRICT_MODE_TYPE,</span><br><span class="line">  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,</span><br><span class="line">  unstable_Profiler: REACT_PROFILER_TYPE,</span><br><span class="line"></span><br><span class="line">  createElement: __DEV__ ? createElementWithValidation : createElement,</span><br><span class="line">  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,</span><br><span class="line">  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,</span><br><span class="line">  isValidElement: isValidElement,</span><br><span class="line"></span><br><span class="line">  version: ReactVersion,</span><br><span class="line"></span><br><span class="line">  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ver><h4 id="Children"><a href="#Children" class="headerlink" title="Children"></a><code>Children</code></h4><p>这个对象提供了一堆帮你处理 props.children 的方法，因为 children 是一个类似数组但是不是数组的数据结构，如果你要对其进行处理可以用 React.Children 外挂的方法。</p><ver><h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a><code>createRef</code></h4><p>新的 ref 用法，React 即将抛弃<code><div ref="myDiv" /></code>这种 string ref 的用法，将来你只能使用两种方式来使用 ref</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>() {</span><br><span class="line">    <span class="keyword">this</span>.ref = React.createRef()</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">div</span> <span class="attr">ref</span>=<span class="string">{this.ref}</span> /></span></span></span><br><span class="line"><span class="xml">    // or</span></span><br><span class="line">    return <div ref={node => (this.funRef = node)} /></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ver><h4 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a><code>createContext</code></h4><p><code>createContext</code> 是官方定稿的 context 方案，在这之前我们一直在用的老的 context API 都是 React 不推荐的 API，现在新的 API 释出，官方也已经确定在 17 大版本会把老 API 去除(老 API 的性能不是一般的差)。</p><p>新 API 的使用方法：</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> { Provider, Consumer } = React.createContext(<span class="string">'defaultValue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ProviderComp = <span class="function">(<span class="params">props</span>) =></span> (</span><br><span class="line">  <Provider value={<span class="string">'realValue'</span>}></span><br><span class="line">    {props.children}</span><br><span class="line">  <<span class="regexp">/Provider></span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const ConsumerComp = () => (</span></span><br><span class="line"><span class="regexp">  <Consumer></span></span><br><span class="line"><span class="regexp">    {(value) => <p>{value}</</span>p>}</span><br><span class="line">  <<span class="regexp">/Consumber></span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></tbody></table></figure><hor><h3 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h3><ver><p>目前 react 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p><ul><li>挂载阶段：<br><code>constructor(props)</code>: 实例化。<br><br><code>static getDerivedStateFromProps</code> 从 <code>props</code> 中获取 <code>state</code>。<br><br><code>render</code> 渲染。<br><br><code>componentDidMount</code>: 完成挂载。</li></ul><ver><ul><li>更新阶段：<br><code>static getDerivedStateFromProps</code> 从 props 中获取 state。<br><br><code>shouldComponentUpdate</code> 判断是否需要重绘。<br><br><code>render</code> 渲染。<br><br><code>getSnapshotBeforeUpdate</code> 获取快照。<br><br><code>componentDidUpdate</code> 渲染完成后回调。</li><li>卸载阶段：<br><code>componentWillUnmount</code> 即将卸载。</li><li>错误处理：<br><code>static getDerivedStateFromError</code> 从错误中获取 <code>state</code>。<br><br><code>componentDidCatch</code> 捕获错误并进行处理。</li></ul><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="comment">// 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this</span></span><br><span class="line">  <span class="keyword">constructor</span>() {}</span><br><span class="line">  <span class="comment">//getDerivedStateFromProps(nextProps, prevState)用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用</span></span><br><span class="line">  <span class="comment">// 这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps</span></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) {</span><br><span class="line">    <span class="comment">// 新的钩子 getDerivedStateFromProps() 更加纯粹, 它做的事情是将新传进来的属性和当前的状态值进行对比, 若不一致则更新当前的状态。</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.riderId !== prevState.riderId) {</span><br><span class="line">      <span class="keyword">return</span> {</span><br><span class="line">        riderId: nextProps.riderId</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回 null 则表示 state 不用作更新</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化react程序性能</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) {</span><br><span class="line">    <span class="keyword">return</span> nextProps.id !== <span class="keyword">this</span>.props.id</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 组件挂载后调用</span></span><br><span class="line">  <span class="comment">// 可以在该函数中进行请求或者订阅</span></span><br><span class="line">  componentDidMount() {}</span><br><span class="line">  <span class="comment">// getSnapshotBeforeUpdate(prevProps, prevState):这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用</span></span><br><span class="line">  getSnapshotBeforeUpdate() {}</span><br><span class="line">  <span class="comment">// 组件即将销毁</span></span><br><span class="line">  <span class="comment">// 可以在此处移除订阅，定时器等等</span></span><br><span class="line">  componentWillUnmount() {}</span><br><span class="line">  <span class="comment">// 组件销毁后调用</span></span><br><span class="line">  componentDidUnMount() {}</span><br><span class="line">  <span class="comment">// componentDidUpdate(prevProps, prevState, snapshot):该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。</span></span><br><span class="line">  componentDidUpdate() {}</span><br><span class="line">  <span class="comment">// 渲染组件函数</span></span><br><span class="line">  render() {}</span><br><span class="line">  <span class="comment">// 以下函数不建议使用</span></span><br><span class="line">  UNSAFE_componentWillMount() {}</span><br><span class="line">  UNSAFE_componentWillUpdate(nextProps, nextState) {}</span><br><span class="line">  UNSAFE_componentWillReceiveProps(nextProps) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ver><p>react 版本 17 将弃用几个类组件 API 生命周期：<code>componentWillMount</code>，<code>componentWillReceiveProps</code>和<code>componentWillUpdate</code>。</p><hor><h3 id="react-事件机制"><a href="#react-事件机制" class="headerlink" title="react 事件机制"></a>react 事件机制</h3><p><ver><br>简单的理解 react 如何处理事件的，React 在组件加载(mount)和更新(update)时，将事件通过 addEventListener  统一注册到 document 上，然后会有一个事件池存储了所有的事件，当事件触发的时候，通过 dispatchEvent 进行事件分发。</ver></p><p>引用<a href="https://juejin.im/post/5d6f127bf265da03cf7aab6d" target="_blank" rel="noopener">新手学习 react 迷惑的点(二)</a></p><ul><li>react 里面绑定事件的方式和在 HTML 中绑定事件类似，使用驼峰式命名指定要绑定的 onClick 属性为组件定义的一个方法{this.handleClick.bind(this)}。</li><li>由于类的方法默认不会绑定 this，因此在调用的时候如果忘记绑定，this 的值将会是 undefined。 通常如果不是直接调用，应该为方法绑定 this，将事件函数上下文绑定要组件实例上。<ver></ver></li></ul><h4 id="绑定事件的四种方式"><a href="#绑定事件的四种方式" class="headerlink" title="绑定事件的四种方式"></a>绑定事件的四种方式</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(props) {</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.handleClick1 = <span class="keyword">this</span>.handleClick1.bind(<span class="keyword">this</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//方式1：在构造函数中使用bind绑定this，官方推荐的绑定方式，也是性能最好的方式</span></span><br><span class="line">  handleClick1() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//方式2：在调用的时候使用bind绑定this</span></span><br><span class="line">  handleClick2() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//方式3：在调用的时候使用箭头函数绑定this</span></span><br><span class="line">  <span class="comment">// 方式2和方式3会有性能影响并且当方法作为属性传递给子组件的时候会引起重渲问题</span></span><br><span class="line">  handleClick3() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//方式4：使用属性初始化器语法绑定this，需要babel转义</span></span><br><span class="line">  handleClick4 = <span class="function"><span class="params">()</span> =></span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>)</span><br><span class="line">  }</span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <div></span><br><span class="line">        <button onClick={<span class="keyword">this</span>.handleClick1}>Click me<<span class="regexp">/button></span></span><br><span class="line"><span class="regexp">        <button onClick={this.handleClick2.bind(this)}>Click me</</span>button></span><br><span class="line">        <button onClick={() => <span class="keyword">this</span>.handleClick3}>Click me<<span class="regexp">/button></span></span><br><span class="line"><span class="regexp">        <button onClick={this.handleClick4}>Click me</</span>button></span><br><span class="line">      <<span class="regexp">/div></span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><ver><p>为什么直接调用方法会报错</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  handleClick() {</span><br><span class="line">    <span class="keyword">this</span>.setState({ <span class="attr">xxx</span>: aaa })</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">{this.handleClick.bind(this)}</span>></span>Click me<span class="tag"></<span class="name">button</span>></span></span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>会被 babel 转化成</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'button'</span>,</span><br><span class="line">  {</span><br><span class="line">    onClick: <span class="keyword">this</span>.handleClick</span><br><span class="line">  },</span><br><span class="line">  <span class="string">'Click me'</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><ver><h4 id="“合成事件”和“原生事件”"><a href="#“合成事件”和“原生事件”" class="headerlink" title="“合成事件”和“原生事件”"></a>“合成事件”和“原生事件”</h4><p>react 实现了一个“合成事件”层（<code>synthetic event system</code>），这抹平了各个浏览器的事件兼容性问题。所有事件均注册到了元素的最顶层-document 上，“合成事件”会以事件委托（<code>event delegation</code>）的方式绑定到组件最上层，并且在组件卸载（<code>unmount</code>）的时候自动销毁绑定的事件。</p><hor><h3 id="react-组件开发"><a href="#react-组件开发" class="headerlink" title="react 组件开发"></a>react 组件开发</h3><ver><h4 id="react-组件化思想"><a href="#react-组件化思想" class="headerlink" title="react 组件化思想"></a>react 组件化思想</h4><h5 id="一个-UI-组件的完整模板"><a href="#一个-UI-组件的完整模板" class="headerlink" title="一个 UI 组件的完整模板"></a>一个 UI 组件的完整模板</h5><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="comment">//参数传参与校验</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = {</span><br><span class="line">    type: PropTypes.oneOf([<span class="string">'success'</span>, <span class="string">'normal'</span>]),</span><br><span class="line">    onClick: PropTypes.func</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">static</span> defaultProps = {</span><br><span class="line">    type: <span class="string">'normal'</span></span><br><span class="line">  }</span><br><span class="line">  handleClick() {}</span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">let</span> { className, type, children, ...other } = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> classes = classNames(</span><br><span class="line">      className,</span><br><span class="line">      <span class="string">'prefix-button'</span>,</span><br><span class="line">      <span class="string">'prefix-button-'</span> + type</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span className={classes} {...other} onClick={() => <span class="keyword">this</span>.handleClick}></span><br><span class="line">        {children}</span><br><span class="line">      <<span class="regexp">/span></span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><ver><h4 id="函数定义组件（Function-Component）"><a href="#函数定义组件（Function-Component）" class="headerlink" title="函数定义组件（Function Component）"></a>函数定义组件（Function Component）</h4><p>纯展示型的，不需要维护 state 和生命周期，则优先使用 <code>Function Component</code></p><ol><li>代码更简洁，一看就知道是纯展示型的，没有复杂的业务逻辑</li><li>更好的复用性。只要传入相同结构的 props，就能展示相同的界面，不需要考虑副作用。</li><li>打包体积小，执行效率高</li></ol><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> { firstName, lastName } = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <div></span><br><span class="line">      <img src=<span class="string">"avatar.png"</span> className=<span class="string">"profile"</span> /></span><br><span class="line">      <h3>{[firstName, lastName].join(<span class="string">' '</span>)}<<span class="regexp">/h3></span></span><br><span class="line"><span class="regexp">    </</span>div></span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>会被 babel 转义成</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  React.createElement(<span class="string">'img'</span>, { <span class="attr">src</span>: <span class="string">'avatar.png'</span>, <span class="attr">className</span>: <span class="string">'profile'</span> }),</span><br><span class="line">  React.createElement(<span class="string">'h3'</span>, <span class="literal">null</span>, [firstName, lastName].join(<span class="string">' '</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><ver><p>那么，<code>React.createElement</code> 是在做什么？看下相关部分代码：</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> element = {</span><br><span class="line">    <span class="comment">// This tag allow us to uniquely identify this as a React Element</span></span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">    _owner: owner</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ReactElement.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, config, children</span>) </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props</span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>React.createElement()来构建 React 元素的。它接受三个参数，第一个参数 type 可以是一个标签名。如 div、span，或者 React 组件。第二个参数 props 为传入的属性。第三个以及之后的参数 children，皆作为组件的子组件。</p><p><code>createElement</code> 函数对 key 和 ref 等特殊的 props 进行处理，并获取 <code>defaultProps</code> 对默认 props 进行赋值，并且对传入的孩子节点进行处理，最终构造成一个 <code>reactElement</code> 对象（所谓的虚拟 DOM）。<br><code>reactDOM.render</code> 将生成好的虚拟 DOM 渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实 DOM。</p><ver><h4 id="ES6-class-定义一个纯组件（PureComponent）"><a href="#ES6-class-定义一个纯组件（PureComponent）" class="headerlink" title="ES6 class 定义一个纯组件（PureComponent）"></a><code>ES6 class</code> 定义一个纯组件（<code>PureComponent</code>）</h4><p>组件需要维护 state 或使用生命周期方法，则优先使用 <code>PureComponent</code></p><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">let</span> { name } = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">h1</span>></span>Hello, {name}<span class="tag"></<span class="name">h1</span>></span></span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ver><h5 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a><code>PureComponent</code></h5><p><code>Component</code> & <code>PureComponent</code> 这两个类基本相同，唯一的区别是 <code>PureComponent</code> 的原型上多了一个标识，<code>shallowEqual</code>（浅比较），来决定是否更新组件，浅比较类似于浅复制，只会比较第一层。使用 <code>PureComponent</code> 相当于省去了写 <code>shouldComponentUpdate</code> 函数</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctor.prototype && ctor.prototype.isPureReactComponent) {</span><br><span class="line">  <span class="keyword">return</span> !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是检查组件是否需要更新的一个判断，ctor 就是你声明的继承自 <code>Component</code> or <code>PureComponent</code> 的类，他会判断你是否继承自 <code>PureComponent，如果是的话就</code> <code>shallowEqual</code> 比较 state 和 props。</p><p>React 中对比一个 <code>ClassComponent</code> 是否需要更新，只有两个地方。一是看有没有 <code>shouldComponentUpdate</code> 方法，二就是这里的 <code>PureComponent</code> 判断</p><hor><h3 id="使用不可变数据结构-Immutablejs"><a href="#使用不可变数据结构-Immutablejs" class="headerlink" title="使用不可变数据结构 Immutablejs"></a>使用不可变数据结构 <code>Immutablejs</code></h3><ver><p><code>Immutable.js</code> 是 Facebook 在 2014 年出的持久性数据结构的库，持久性指的是数据一旦创建，就不能再被更改，任何修改或添加删除操作都会返回一个新的 <code>Immutable</code> 对象。可以让我们更容易的去处理缓存、回退、数据变化检测等问题，简化开发。并且提供了大量的类似原生 JS 的方法，还有 <code>Lazy Operation</code> 的特性，完全的函数式编程。</p><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { <span class="built_in">Map</span> } <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="built_in">Map</span>({ <span class="attr">a</span>: { <span class="attr">aa</span>: <span class="number">1</span> }, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> })</span><br><span class="line"><span class="keyword">const</span> map2 = map1.set(<span class="string">'b'</span>, <span class="number">50</span>)</span><br><span class="line">map1 !== map2 <span class="comment">// true</span></span><br><span class="line">map1.get(<span class="string">'b'</span>) <span class="comment">// 2</span></span><br><span class="line">map2.get(<span class="string">'b'</span>) <span class="comment">// 50</span></span><br><span class="line">map1.get(<span class="string">'a'</span>) === map2.get(<span class="string">'a'</span>) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，修改 map1 的属性返回 map2，他们并不是指向同一存储空间，map1 声明了只有，所有的操作都不会改变它。</p><ver><p><code>ImmutableJS</code>提供了大量的方法去更新、删除、添加数据，极大的方便了我们操纵数据。除此之外，还提供了原生类型与 <code>ImmutableJS</code> 类型判断与转换方法：</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { fromJS, isImmutable } <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"><span class="keyword">const</span> obj = fromJS({</span><br><span class="line">  a: <span class="string">'test'</span>,</span><br><span class="line">  b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">}) <span class="comment">// 支持混合类型</span></span><br><span class="line">isImmutable(obj) <span class="comment">// true</span></span><br><span class="line">obj.size() <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">const</span> obj1 = obj.toJS() <span class="comment">// 转换成原生 `js` 类型</span></span><br></pre></td></tr></tbody></table></figure><ver><p><code>ImmutableJS</code> 最大的两个特性就是： <code>immutable data structures</code>（持久性数据结构）与 <code>structural sharing</code>（结构共享），持久性数据结构保证数据一旦创建就不能修改，使用旧数据创建新数据时，旧数据也不会改变，不会像原生 js 那样新数据的操作会影响旧数据。而结构共享是指没有改变的数据共用一个引用，这样既减少了深拷贝的性能消耗，也减少了内存。</p><p><ver><br>比如下图：<br></ver></p><p><img src="https://user-gold-cdn.xitu.io/2019/9/16/16d38db482ead4cd?w=715&h=324&f=png&s=36981" alt="react-tree"></p><ver><p>左边是旧值，右边是新值，我需要改变左边红色节点的值，生成的新值改变了红色节点到根节点路径之间的所有节点，也就是所有青色节点的值，旧值没有任何改变，其他使用它的地方并不会受影响，而超过一大半的蓝色节点还是和旧值共享的。在 <code>ImmutableJS</code> 内部，构造了一种特殊的数据结构，把原生的值结合一系列的私有属性，创建成 <code>ImmutableJS</code> 类型，每次改变值，先会通过私有属性的辅助检测，然后改变对应的需要改变的私有属性和真实值，最后生成一个新的值，中间会有很多的优化，所以性能会很高。</p><ver><h3 id="高阶组件-higher-order-component"><a href="#高阶组件-higher-order-component" class="headerlink" title="高阶组件(higher order component)"></a>高阶组件(<code>higher order component</code>)</h3><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。</p><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visible</span>(<span class="params">WrappedComponent</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{</span><br><span class="line">    render() {</span><br><span class="line">      <span class="keyword">const</span> { visible, ...props } = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">WrappedComponent</span> {<span class="attr">...props</span>} /></span></span></span><br><span class="line"><span class="xml">    }</span></span><br><span class="line"><span class="xml">  }</span></span><br><span class="line"><span class="xml">}</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码就是一个 HOC 的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个 visible props，根据 visible 的值来判断是否渲染 Visible。</p><p><ver><br>最常见的还有 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 react 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。<br>下面就是一个简化版的 connect 实现：</ver></p><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = (</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">) => <span class="function"><span class="params">WrappedComponent</span> =></span> {</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> contextTypes = {</span><br><span class="line">      store: PropTypes.object</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() {</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = {</span><br><span class="line">        allProps: {}</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    componentWillMount() {</span><br><span class="line">      <span class="keyword">const</span> { store } = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">this</span>._updateProps()</span><br><span class="line">      store.subscribe(<span class="function"><span class="params">()</span> =></span> <span class="keyword">this</span>._updateProps())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _updateProps() {</span><br><span class="line">      <span class="keyword">const</span> { store } = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps</span><br><span class="line">        ? mapStateToProps(store.getState(), <span class="keyword">this</span>.props)</span><br><span class="line">        : {}</span><br><span class="line">      <span class="keyword">let</span> dispatchProps = mapDispatchToProps</span><br><span class="line">        ? mapDispatchToProps(store.dispatch, <span class="keyword">this</span>.props)</span><br><span class="line">        : {}</span><br><span class="line">      <span class="keyword">this</span>.setState({</span><br><span class="line">        allProps: {</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...this.props</span><br><span class="line">        }</span><br><span class="line">      })</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    render() {</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">WrappedComponent</span> {<span class="attr">...this.state.allProps</span>} /></span></span></span><br><span class="line"><span class="xml">    }</span></span><br><span class="line"><span class="xml">  }</span></span><br><span class="line"><span class="xml">  return Connect</span></span><br><span class="line"><span class="xml">}</span></span><br></pre></td></tr></tbody></table></figure><p>代码非常清晰，connect 函数其实就做了一件事，将 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 分别解构后传给原组件，这样我们在原组件内就可以直接用 <code>props</code> 获取 <code>state</code> 以及 <code>dispatch</code> 函数了。</p><ver><h4 id="高阶组件的应用"><a href="#高阶组件的应用" class="headerlink" title="高阶组件的应用"></a>高阶组件的应用</h4><p>某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。</p><ver><h5 id="日志打点"><a href="#日志打点" class="headerlink" title="日志打点"></a>日志打点</h5><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logHoc</span>(<span class="params">WrappedComponent</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{</span><br><span class="line">    componentWillMount() {</span><br><span class="line">      <span class="keyword">this</span>.start = <span class="built_in">Date</span>.now()</span><br><span class="line">    }</span><br><span class="line">    componentDidMount() {</span><br><span class="line">      <span class="keyword">this</span>.end = <span class="built_in">Date</span>.now()</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`<span class="subst">${WrappedComponent.dispalyName}</span> 渲染时间：<span class="subst">${<span class="keyword">this</span>.end - <span class="keyword">this</span>.start}</span> ms`</span></span><br><span class="line">      )</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${user}</span>进入<span class="subst">${WrappedComponent.dispalyName}</span>`</span>)</span><br><span class="line">    }</span><br><span class="line">    componentWillUnmount() {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${user}</span>退出<span class="subst">${WrappedComponent.dispalyName}</span>`</span>)</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">WrappedComponent</span> {<span class="attr">...this.props</span>} /></span></span></span><br><span class="line"><span class="xml">    }</span></span><br><span class="line"><span class="xml">  }</span></span><br><span class="line"><span class="xml">}</span></span><br></pre></td></tr></tbody></table></figure><ver><h5 id="可用、权限控制"><a href="#可用、权限控制" class="headerlink" title="可用、权限控制"></a>可用、权限控制</h5><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">WrappedComponent</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{</span><br><span class="line">    render() {</span><br><span class="line">      <span class="keyword">const</span> { visible, auth, display = <span class="literal">null</span>, ...props } = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span> || (auth && authList.indexOf(auth) === <span class="number">-1</span>)) {</span><br><span class="line">        <span class="keyword">return</span> display</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">WrappedComponent</span> {<span class="attr">...props</span>} /></span></span></span><br><span class="line"><span class="xml">    }</span></span><br><span class="line"><span class="xml">  }</span></span><br><span class="line"><span class="xml">}</span></span><br></pre></td></tr></tbody></table></figure><ver><h5 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h5><p>基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息：</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateHoc</span>(<span class="params">WrappedComponent</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{</span><br><span class="line">    <span class="keyword">constructor</span>(props) {</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = { <span class="attr">error</span>: <span class="string">''</span> }</span><br><span class="line">    }</span><br><span class="line">    onChange = <span class="function"><span class="params">event</span> =></span> {</span><br><span class="line">      <span class="keyword">const</span> { validator } = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="keyword">if</span> (validator && <span class="keyword">typeof</span> validator.func === <span class="string">'function'</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!validator.func(event.target.value)) {</span><br><span class="line">          <span class="keyword">this</span>.setState({ <span class="attr">error</span>: validator.msg })</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">this</span>.setState({ <span class="attr">error</span>: <span class="string">''</span> })</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <div></span><br><span class="line">          <WrappedComponent onChange={<span class="keyword">this</span>.onChange} {...this.props} /></span><br><span class="line">          <div>{<span class="keyword">this</span>.state.error || <span class="string">''</span>}<<span class="regexp">/div></span></span><br><span class="line"><span class="regexp">        </</span>div></span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> validatorName = {</span><br><span class="line">  func: <span class="function">(<span class="params">val</span>) =></span> val && !<span class="built_in">isNaN</span>(val),</span><br><span class="line">  msg: <span class="string">'请输入数字'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> validatorPwd = {</span><br><span class="line">  func: <span class="function">(<span class="params">val</span>) =></span> val && val.length > <span class="number">6</span>,</span><br><span class="line">  msg: <span class="string">'密码必须大于6位'</span></span><br><span class="line">}</span><br><span class="line"><HOCInput validator={validatorName} v_model=<span class="string">"name"</span>><span class="xml"><span class="tag"></<span class="name">HOCInput</span>></span></span></span><br><span class="line"><HOCInput validator={validatorPwd} v_model=<span class="string">"pwd"</span>><span class="xml"><span class="tag"></<span class="name">HOCInput</span>></span></span></span><br></pre></td></tr></tbody></table></figure><ver><h4 id="HOC-的缺陷"><a href="#HOC-的缺陷" class="headerlink" title="HOC 的缺陷"></a>HOC 的缺陷</h4><ul><li>HOC 需要在原组件上进行包裹或者嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难。</li><li>HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突。</li></ul><ver><h4 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a><code>render props</code></h4><p>一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术<br>具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑。</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><DataProvider render={data => <span class="xml"><span class="tag"><<span class="name">h1</span>></span>Hello {data.target}<span class="tag"></<span class="name">h1</span>></span></span>} /></span><br></pre></td></tr></tbody></table></figure><hor><h3 id="setState-数据管理"><a href="#setState-数据管理" class="headerlink" title="setState 数据管理"></a><code>setState</code> 数据管理</h3><p><ver><br><strong>不要直接更新状态</strong></ver></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong 此代码不会重新渲染组件,构造函数是唯一能够初始化 this.state 的地方。</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span></span><br><span class="line"><span class="comment">// Correct 应当使用 setState():</span></span><br><span class="line"><span class="keyword">this</span>.setState({ <span class="attr">comment</span>: <span class="string">'Hello'</span> })</span><br></pre></td></tr></tbody></table></figure><p><ver><br>组件生命周期中或者 react 事件绑定中，setState 是通过异步更新的，在延时的回调或者原生事件绑定的回调中调用 setState 不一定是异步的。</ver></p><ul><li>多个 setState() 调用合并成一个调用来提高性能。</li><li>this.props 和 this.state 可能是异步更新的，不应该依靠它们的值来计算下一个状态。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState({</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment</span><br><span class="line">})</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =></span> ({</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">}))</span><br></pre></td></tr></tbody></table></figure><p><ver><br>原生事件绑定不会通过合成事件的方式处理，会进入更新事务的处理流程。<code>setTimeout</code> 也一样，在 <code>setTimeout</code> 回调执行时已经完成了原更新组件流程，不会放入 <code>dirtyComponent</code> 进行异步更新，其结果自然是同步的。</ver></p><ver><h4 id="setState-原理"><a href="#setState-原理" class="headerlink" title="setState 原理"></a><code>setState</code> 原理</h4><p>setState 并没有直接操作去渲染，而是执行了一个 <code>updateQueue</code>（异步 updater 队列），</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setState( stateChange ) {</span><br><span class="line">    <span class="built_in">Object</span>.assign( <span class="keyword">this</span>.state, stateChange );</span><br><span class="line">    <span class="comment">//合并接收到的state||stateChange改变的state（setState接收到的参数）</span></span><br><span class="line">    renderComponent( <span class="keyword">this</span> );<span class="comment">//调用render渲染组件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种实现，每次调用 <code>setState</code> 都会更新 state 并马上渲染一次（不符合其更新优化机制），所以我们要合并 <code>setState</code>。</p><p>具体可以阅读源码<br><a href="https://github.com/facebook/react/blob/03944bfb0bdacfe35b2a1722426ff744ae47d018/packages/react-reconciler/src/ReactUpdateQueue.js" target="_blank" rel="noopener"><code>ReactUpdateQueue.js</code></a></p><hor><h3 id="react-中的事务实现"><a href="#react-中的事务实现" class="headerlink" title="react 中的事务实现"></a><code>react</code> 中的事务实现</h3><p>待完善<br>这块看的还有点懵圈<br><a href="https://juejin.im/post/59cc4c4bf265da0648446ce0" target="_blank" rel="noopener">React 源码解析(三):详解事务与更新队列</a><br><a href="https://oychao.github.io/2017/09/25/react/16_transaction/" target="_blank" rel="noopener">React 中的 Transaction</a><br><a href="https://zhuanlan.zhihu.com/p/61367775" target="_blank" rel="noopener">React 的事务机制</a></p><h4 id="transaction-事务"><a href="#transaction-事务" class="headerlink" title="transaction 事务"></a>transaction 事务</h4><hor><h3 id="ErrorBoundary、Suspense-和-Fragment"><a href="#ErrorBoundary、Suspense-和-Fragment" class="headerlink" title="ErrorBoundary、Suspense 和 Fragment"></a><code>ErrorBoundary</code>、<code>Suspense</code> 和 <code>Fragment</code></h3><ver><h4 id="Error-Boundaries"><a href="#Error-Boundaries" class="headerlink" title="Error Boundaries"></a><code>Error Boundaries</code></h4><p>react 16 提供了一个新的错误捕获钩子 <code>componentDidCatch(error, errorInfo)</code>, 它能将子组件生命周期里所抛出的错误捕获, 防止页面全局崩溃。demo<br><code>componentDidCatch</code> 并不会捕获以下几种错误</p><ul><li>事件机制抛出的错误(事件里的错误并不会影响渲染)</li><li>Error Boundaries 自身抛出的错误</li><li>异步产生的错误</li><li>服务端渲染<ver></ver></li></ul><h4 id="lazy、Suspence-延迟加载组件"><a href="#lazy、Suspence-延迟加载组件" class="headerlink" title="lazy、Suspence 延迟加载组件"></a><code>lazy、Suspence</code> 延迟加载组件</h4><p><code>lazy</code> 需要跟 <code>Suspence</code> 配合使用，否则会报错。</p><p><code>lazy</code> 实际上是帮助我们实现代码分割 ，类似 webpack 的 <code>splitchunk</code> 的功能。</p><p><code>Suspense</code> 意思是能暂停当前组件的渲染, 当完成某件事以后再继续渲染。简单来说就是减少首屏代码的体积，提升性能。</p><ver><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> react, { lazy, Suspense } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = lazy(<span class="function"><span class="params">()</span> =></span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <Suspense fallback={<div>loading...<<span class="regexp">/div>}></span></span><br><span class="line"><span class="regexp">      <OtherComponent /</span>></span><br><span class="line">    <<span class="regexp">/Suspense></span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><ver><p>一种简单的预加载思路, 可参考 preload</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponentPromise = <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>)</span><br><span class="line"><span class="keyword">const</span> OtherComponent = react.lazy(<span class="function"><span class="params">()</span> =></span> OtherComponentPromise)</span><br></pre></td></tr></tbody></table></figure><ver><h4 id="Fragments（v16-2-0"><a href="#Fragments（v16-2-0" class="headerlink" title="Fragments（v16.2.0)"></a><code>Fragments（v16.2.0)</code></h4><p>Fragments 允许你将子列表分组，避免向 DOM 添加额外的节点。</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <></span><br><span class="line">      <ChildA /></span><br><span class="line">      <ChildB /></span><br><span class="line">      <ChildC /></span><br><span class="line">    <<span class="regexp">/></span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><hor><h3 id="react-Fiber-架构分析"><a href="#react-Fiber-架构分析" class="headerlink" title="react Fiber 架构分析"></a><code>react Fiber</code> 架构分析</h3><p><code>react-fiber</code>是为了增强动画、布局、移动端手势领域的适用性，最重要的特性是对页面渲染的优化: 允许将渲染方面的工作拆分为多段进行。</p><ver><h4 id="react-Fiber-架构解决了什么问题"><a href="#react-Fiber-架构解决了什么问题" class="headerlink" title="react Fiber 架构解决了什么问题"></a><code>react Fiber</code> 架构解决了什么问题</h4><p><code>react-fiber</code> 可以为我们提供如下几个功能：</p><ul><li>设置渲染任务的优先</li><li>采用新的 Diff 算法</li><li>采用虚拟栈设计允许当优先级更高的渲染任务和较低优先的任务之间来回切换</li></ul><ver><h4 id="Fiber-如何做到异步渲染-Virtual-Dom-和-Diff-算法"><a href="#Fiber-如何做到异步渲染-Virtual-Dom-和-Diff-算法" class="headerlink" title="Fiber 如何做到异步渲染 Virtual Dom 和 Diff 算法"></a><code>Fiber</code> 如何做到异步渲染 <code>Virtual Dom</code> 和 <code>Diff</code> 算法</h4><p>众所周知，画面每秒钟更新 60 次，页面在人眼中显得流畅，无明显卡顿。每秒 60 次，即 16ms 要更新一次页面，如果更新页面消耗的时间不到 16ms，那么在下一次更新时机来到之前会剩下一点时间执行其他的任务，只要保证及时在 16ms 的间隔下更新界面就完全不会影响到页面的流畅程度。fiber 的核心正是利用了 60 帧原则，实现了一个基于优先级和 requestIdleCallback 的循环任务调度算法。</p><ver><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fiber</span>(<span class="params">剩余时间</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (剩余时间 > 任务所需时间) {</span><br><span class="line">    做任务</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    requestIdleCallback(fiber)</span><br><span class="line">    <span class="comment">// requestIdleCallback 是浏览器提供的一个 api，可以让浏览器在空闲的时候执行回调，</span></span><br><span class="line">    <span class="comment">// 在回调参数中可以获取到当前帧剩余的时间，fiber 利用了这个参数，</span></span><br><span class="line">    <span class="comment">// 判断当前剩下的时间是否足够继续执行任务，</span></span><br><span class="line">    <span class="comment">// 如果足够则继续执行，否则暂停任务，</span></span><br><span class="line">    <span class="comment">// 并调用 requestIdleCallback 通知浏览器空闲的时候继续执行当前的任务</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hor><h3 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a><code>react hooks</code></h3><p>在 react 16.7 之前, react 有两种形式的组件, 有状态组件(类)和无状态组件(函数)。<br>官方解释： hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>个人理解：让传统的函数组件 function component 有内部状态 state 的函数 function,简单来说就是 hooks 让函数组件有了状态，可以完全替代 class。</p><p>接下来梳理 Hooks 中最核心的 2 个 api, <code>useState</code> 和 <code>useEffect</code></p><ver><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a><code>useState</code></h4><p>useState 是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(initialState)</span><br></pre></td></tr></tbody></table></figure><p>使用 Hooks 相比之前用 class 的写法最直观的感受是更为简洁</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <div></span><br><span class="line">      <p>You clicked {count} times<<span class="regexp">/p></span></span><br><span class="line"><span class="regexp">      <button onClick={() => setCount(count + 1)}>Click me</</span>button></span><br><span class="line">    <<span class="regexp">/div></span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><ver><h4 id="useEffect-fn"><a href="#useEffect-fn" class="headerlink" title="useEffect(fn)"></a><code>useEffect(fn)</code></h4><p>在每次 render 后都会执行这个钩子。可以将它当成是 <code>componentDidMount</code>、<code>componentDidUpdate`</code>、componentWillUnmount <code>的合集。因此使用</code>useEffect` 比之前优越的地方在于:</p><p>可以避免在 <code>componentDidMount</code>、<code>componentDidUpdate</code> 书写重复的代码;<br>可以将关联逻辑写进一个 <code>useEffect</code>(在以前得写进不同生命周期里);</p><hor><h3 id="深入理解-react-原理"><a href="#深入理解-react-原理" class="headerlink" title="深入理解 react 原理"></a>深入理解 react 原理</h3><ver><h4 id="react-虚拟-dom-原理剖析"><a href="#react-虚拟-dom-原理剖析" class="headerlink" title="react 虚拟 dom 原理剖析"></a>react 虚拟 dom 原理剖析</h4><ver><h5 id="react-组件的渲染流程"><a href="#react-组件的渲染流程" class="headerlink" title="react 组件的渲染流程"></a>react 组件的渲染流程</h5><p>使用 <code>react.createElement</code> 或 JSX 编写 react 组件，实际上所有的 JSX 代码最后都会转换成 <code>react.createElement(...)</code>，Babel 帮助我们完成了这个转换的过程。</p><p>createElement 函数对 key 和 ref 等特殊的 props 进行处理，并获取 <code>defaultProps</code> 对默认 props 进行赋值，并且对传入的孩子节点进行处理，最终构造成一个 <code>reactElement</code> 对象（所谓的虚拟 DOM）。</p><p><code>reactDOM.render</code> 将生成好的虚拟 DOM 渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实 DOM。</p><ver><h5 id="虚拟-DOM-的组成"><a href="#虚拟-DOM-的组成" class="headerlink" title="虚拟 DOM 的组成"></a>虚拟 DOM 的组成</h5><p>即 <code>reactElementelement</code> 对象，我们的组件最终会被渲染成下面的结构：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`type`：元素的类型，可以是原生 html 类型（字符串），或者自定义组件（函数或 class）</span><br><span class="line">`key`：组件的唯一标识，用于 Diff 算法，下面会详细介绍</span><br><span class="line">`ref`：用于访问原生 dom 节点</span><br><span class="line">`props`：传入组件的 props，chidren 是 props 中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</span><br><span class="line">`owner`：当前正在构建的 Component 所属的 Component</span><br><span class="line">`self`：（非生产环境）指定当前位于哪个组件实例</span><br><span class="line">`_source`：（非生产环境）指定调试代码来自的文件(fileName)和代码行数(lineNumber)</span><br></pre></td></tr></tbody></table></figure><ver><p>当组件状态 state 有更改的时候，react 会自动调用组件的 render 方法重新渲染整个组件的 UI。<br>当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 react 实现了一个 <code>Virtual DOM</code>，组件 DOM 结构就是映射到这个 <code>Virtual DOM</code>上，react 在这个 <code>Virtual DOM</code> 上实现了一个 diff 算法，当要重新渲染组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个 <code>Virtual DOM</code> 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。</p><ver><h5 id="react-是如何防止-XSS-的"><a href="#react-是如何防止-XSS-的" class="headerlink" title="react 是如何防止 XSS 的"></a><code>react</code> 是如何防止 <code>XSS</code> 的</h5><p><code>reactElement</code> 对象还有一个<code>$$typeof</code>属性，它是一个 Symbol 类型的变量<code>Symbol.for('react.element')</code>，当环境不支持 Symbol 时，<code>$$typeof</code> 被赋值为 <code>0xeac7</code>。<br>这个变量可以防止 XSS。如果你的服务器有一个漏洞，允许用户存储任意 JSON 对象， 而客户端代码需要一个字符串，这可能为你的应用程序带来风险。JSON 中不能存储 <code>Symbol</code> 类型的变量，而 react 渲染时会把没有<code>\$\$typeof</code> 标识的组件过滤掉。</p><hor><h4 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a><code>diff</code> 算法</h4><p>传统的 <code>diff</code> 算法通过循环递归对节点一次对比，效率很低，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数,React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。</p><ver><p><strong><code>diff</code> 策略:</strong></p><ol><li>web ui 中 Dom 节点跨层级的移动操作很少,<code>diff</code> 算法比较新旧节点的时候，比较只会在同层级比较，不会跨层级比较</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li><li>对于同一层级的一组子节点，他们可以通过唯一 key 进行区分</li></ol><p>基于以上三个前提策略，React 分别对 <code>tree diff</code>、<code>component diff</code> 以及 <code>element diff</code> 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。<br>简单的讲就是：</p><p>具体可以参考<a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">React 源码剖析系列 － 不可思议的 react diff</a></p><ver><ul><li>React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</li><li>React 通过分层求异的策略，对 <code>tree diff</code> 进行算法优化；</li><li>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 <code>component diff</code> 进行算法优化；</li><li>React 通过设置唯一 key 的策略，对 <code>element diff</code> 进行算法优化；</li></ul><p>建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；<br>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p><hor><h4 id="snabbdom-源码，是怎样实现精简的-Virtual-DOM-的"><a href="#snabbdom-源码，是怎样实现精简的-Virtual-DOM-的" class="headerlink" title="snabbdom 源码，是怎样实现精简的 Virtual DOM 的"></a>snabbdom 源码，是怎样实现精简的 Virtual DOM 的</h4><p>待补充</p><h3 id="react-性能分析与优化"><a href="#react-性能分析与优化" class="headerlink" title="react 性能分析与优化"></a>react 性能分析与优化</h3><ver><h4 id="减少不必要的渲染"><a href="#减少不必要的渲染" class="headerlink" title="减少不必要的渲染"></a>减少不必要的渲染</h4><p>在使用 <code>class Component</code> 进行开发的时候，我们可以使用 <code>shouldComponentUpdate</code> 来减少不必要的渲染，那么在使用 <code>react hooks</code> 后，我们如何实现这样的功能呢？</p><p>解决方案：<code>React.memo</code>和<code>useMemo</code><br>对于这种情况，react 当然也给出了官方的解决方案，就是使用 React.memo 和 useMemo。</p><ver><h5 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a><code>React.memo</code></h5><p>React.momo 其实并不是一个 hook，它其实等价于 PureComponent，但是它只会对比 props。使用方式如下(用上面的例子):</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { useState } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Count = React.memo(<span class="function"><span class="params">props</span> =></span> {</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState({</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    name: <span class="string">'cjg'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =></span> {</span><br><span class="line">    <span class="keyword">const</span> { count } = data</span><br><span class="line">    setData({</span><br><span class="line">      ...data,</span><br><span class="line">      count: count + <span class="number">1</span></span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">{handleClick}</span>></span>count:{data.count}<span class="tag"></<span class="name">button</span>></span></span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ver><h5 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h5><p>useMemo 它的用法其实跟 useEffects 有点像，我们直接看官方给的例子</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">{ a, b }</span>) </span>{</span><br><span class="line">  <span class="comment">// Only re-rendered if `a` changes:</span></span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function"><span class="params">()</span> =></span> <Child1 a={a} />, [a])</span><br><span class="line">  <span class="comment">// Only re-rendered if `b` changes:</span></span><br><span class="line">  <span class="keyword">const</span> child2 = useMemo(<span class="function"><span class="params">()</span> =></span> <Child2 b={b} />, [b])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <></span><br><span class="line">      {child1}</span><br><span class="line">      {child2}</span><br><span class="line">    <<span class="regexp">/></span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><p>从例子可以看出来，它的第二个参数和 useEffect 的第二个参数是一样的，只有在第二个参数数组的值发生变化时，才会触发子组件的更新。</p><p>引用<a href="https://github.com/chenjigeng/blog/blob/master/React%20hooks%E5%AE%9E%E8%B7%B5.md" target="_blank" rel="noopener">React hooks 实践</a></p><h5 id="使用-shouldComponentUpdate-防止不必要的重新渲染"><a href="#使用-shouldComponentUpdate-防止不必要的重新渲染" class="headerlink" title="使用 shouldComponentUpdate() 防止不必要的重新渲染"></a>使用 shouldComponentUpdate() 防止不必要的重新渲染</h5><p>当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM，当它们不相同时 React 会更新该 DOM。</p><p>即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，但是如果渲染的组件非常多时，就会浮现性能上的问题，我们可以通过覆盖生命周期方法 shouldComponentUpdate 来进行提速。</p><p>shouldComponentUpdate 方法会在重新渲染前被触发。其默认实现总是返回 true，如果组件不需要更新，可以在 shouldComponentUpdate 中返回 false 来跳过整个渲染过程。其包括该组件的 render 调用以及之后的操作。</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) {</span><br><span class="line">   <span class="keyword">return</span> nextProps.next !== <span class="keyword">this</span>.props.next</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="React-性能分析器"><a href="#React-性能分析器" class="headerlink" title="React 性能分析器"></a>React 性能分析器</h4><p>React 16.5 增加了对新的开发者工具 DevTools 性能分析插件的支持。 此插件使用 React 实验性的 Profiler API 来收集有关每个组件渲染的用时信息，以便识别 React 应用程序中的性能瓶颈。 它将与我们即将推出的 time slicing（时间分片） 和 suspense（悬停） 功能完全兼容。</p><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p><code>Store</code>：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个 <code>Store</code>。</p><p><code>State</code>：<code>Store</code> 对象包含所有数据，如果想得到某个时点的数据，就要对 <code>Store</code> 生成快照，这种时点的数据集合，就叫做 <code>State</code>。</p><p><code>Action</code>：<code>State</code> 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p><p><code>Action Creator</code>：View 要发送多少种消息，就会有多少种 <code>Action</code>。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 <code>Action Creator</code>。</p><p><code>Reducer</code>：<code>Store</code> 收到 <code>Action</code> 以后，必须给出一个新的 <code>State</code>，这样 View 才会发生变化。这种 <code>State</code> 的计算过程就叫做 <code>Reducer</code>。<code>Reducer</code> 是一个函数，它接受 Action 和当前 <code>State</code> 作为参数，返回一个新的 <code>State</code>。</p><p><code>dispatch</code>：是 <code>View</code> 发出 <code>Action</code> 的唯一方法。</p><ver><h4 id="redux-的基本原理"><a href="#redux-的基本原理" class="headerlink" title="redux 的基本原理"></a>redux 的基本原理</h4><p>然后我们过下整个工作流程：</p><p>首先，用户（通过 <code>View</code>）发出 <code>Action</code>，发出方式就用到了 <code>dispatch</code> 方法。</p><p>然后，<code>Store</code> 自动调用 <code>Reducer</code>，并且传入两个参数：当前 <code>State</code> 和收到的 <code>Action</code>，<code>Reducer</code> 会返回新的 <code>State</code></p><p><code>State</code> 一旦有变化，<code>Store</code> 就会调用监听函数，来更新 <code>View</code>。</p><p>到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。</p><ver><h4 id="redux-单向数据流架构如何设计"><a href="#redux-单向数据流架构如何设计" class="headerlink" title="redux 单向数据流架构如何设计"></a><code>redux</code> 单向数据流架构如何设计</h4><p>待完善</p><ver><h4 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a><code>redux</code> 中间件</h4><p>Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -> action -> reducer -> store 的数据流加上中间件后变成了 view -> action -> middleware -> reducer -> store ，在这一环节我们可以做一些 “副作用” 的操作，如 异步请求、打印日志等。</p><p>redux 中间件通过改写 store.dispatch 方法实现了 action -> reducer 的拦截，从上面的描述中可以更加清晰地理解 redux 中间件的洋葱圈模型：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中间件A -> 中间件B-> 中间件C-> 原始 dispatch -> 中间件C -> 中间件B ->  中间件A</span><br></pre></td></tr></tbody></table></figure><p>这也就提醒我们使用中间件时需要注意这个中间件是在什么时候 “搞事情” 的，比如 redux-thunk 在执行 next(action) 前就拦截了类型为 function 的 action，而 redux-saga 就在 next(action) 才会触发监听 sagaEmitter.emit(action), 并不会拦截已有 action 到达 reducer。</p><hor><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="https://juejin.im/post/5cb66fdaf265da0384128445" target="_blank" rel="noopener">深入分析虚拟 DOM 的渲染原理和特性</a></li><li><a href="http://www.conardli.top/blog/article/react%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/react%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6.html" target="_blank" rel="noopener">react 事件机制</a></li><li><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a" target="_blank" rel="noopener">从 Mixin 到 HOC 再到 Hook</a></li><li><a href="https://tech.meituan.com/2017/07/14/redux-design-code.html" target="_blank" rel="noopener">美团技术团队-Redux 从设计到源码</a></li><li><a href="https://github.com/creeperyang/blog/issues/33" target="_blank" rel="noopener">解析 snabbdom 源码，教你实现精简的 Virtual DOM 库</a></li><li><a href="https://react.jokcy.me" target="_blank" rel="noopener">react 源码解析</a></li><li><a href="https://segmentfault.com/a/1190000017414633" target="_blank" rel="noopener">Vue 与 React 两个框架的粗略区别对比</a></li></ol></hor></ver></ver></ver></ver></ver></ver></hor></ver></ver></hor></ver></ver></ver></ver></ver></hor></ver></ver></hor></ver></ver></ver></hor></ver></ver></ver></ver></hor></hor></ver></hor></ver></ver></ver></ver></ver></ver></ver></ver></ver></ver></ver></ver></ver></ver></ver></hor></ver></ver></ver></ver></ver></ver></ver></hor></ver></ver></hor></ver></ver></ver></ver></hor></ver></ver></ver></ver></hor></ver></ver></ver></ver></ver></hor></ver></ver></ver></ver></ver></ver></ver></ver></ver></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;React16常用api解析以及原理剖析&quot;&gt;&lt;a href=&quot;#React16常用api解析以及原理剖析&quot; class=&quot;headerlink&quot; title=&quot;React16常用api解析以及原理剖析&quot;&gt;&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="react" scheme="https://ru23.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Weex Flutter Hybrid</title>
    <link href="https://ru23.com/note/567b2f52.html"/>
    <id>https://ru23.com/note/567b2f52.html</id>
    <published>2019-04-21T09:29:11.000Z</published>
    <updated>2020-04-11T11:59:26.128Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="聊一聊-Weex-Flutter-Hybrid"><a href="#聊一聊-Weex-Flutter-Hybrid" class="headerlink" title="聊一聊 Weex Flutter Hybrid"></a>聊一聊 Weex Flutter Hybrid</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着移动互联网的兴起，移动端被各类原生应用所占据，而这些应用依托于应用市场进行更新，每次更新，必须依赖用户的主动更新，从而造成了一定的用户成本，不利于产品的快速迭代，在这个时间就是金钱，效率至上的时代，而且现在很多互联网公司都在搞敏捷开发，这显然是不符合大家的目标。因此移动端动态化方案也逐渐走进大众的视野，并被广泛关注。</p><p>说道这里要顺便插一句，原生开发就不能支持动态化吗？答案肯定是可以的。Android 一直都有成熟的动态化方案，Google 在 2018 年还提供了 <strong>Android App Bundles</strong>让开发者们可以更好的支持动态化。反观 IOS，如果你做过游戏开发，想必对 JSPatch 这项技术一点也陌生，JSPatch 是腾讯开源的针对 IOS 的热更新技术，不过 Apple 官方对动态化是不带支持的，原因就是担忧动态化的风险，所以在 2017 年还大肆封杀了一波 JSPathc 等热更新技术的应用。因此在 IOS 平台是没有比较通用的动态化方案，只有每个大厂各自实现的一些框架。</p><p>说回正题，既然前面说到动态化已经越来越被大众关注，那么因此各类框架就层出不穷，下面我们就来聊一聊几个备受业界关注的明星框架。</p><p>##Hybrid<br><strong>Hybrid</strong>顾名思义，就是结合 Web 和 Native 两个技术各自的优势，例如 Web 的跨平台特性和 Native 的功能和性能等。其实后面要讲的 Weex，Flutter 都是属于 Hybrid 的范畴，但是大多时候圈内人谈到 Hybrid 技术的时候，一般是指移动端内嵌 WebView 的开发方案。下面我们主要聊一聊这个方向的 Hybrid。</p><p>Hybrid App 最核心的点就是 Native 端和 H5 端之间的双向通讯层，其实我们可以理解为我们需要一套<strong>跨语言解决方案</strong>，来完成 Native 和 JS 之间的通讯，这就是我们经常提起的 JSBridge，而实现的关键便是作为容器的 Webview。</p><h4 id="1-JS-通知-Native"><a href="#1-JS-通知-Native" class="headerlink" title="1.JS 通知 Native"></a>1.JS 通知 Native</h4><p>一般有三种解决方案</p><ul><li><p><strong>API 注入</strong> Native 获取 JS 环境上下文，并直接在上面挂载对象或者方法，使 JS 可以直接调用，Android 与 IOS 分别拥有对应的挂载方式。</p></li><li><p><strong>WebView 中的 prompt/console/alert 拦截</strong> 通常使用 prompt，因为这个方法在前端中使用频率低，比较不会出现冲突。</p></li><li><p><strong>WebView URL Scheme 跳转拦截</strong></p></li></ul><h4 id="2-Native-通知-JS"><a href="#2-Native-通知-JS" class="headerlink" title="2.Native 通知 JS"></a>2.Native 通知 JS</h4><p>由于 Native 可以算作 H5 的宿主，因此拥有更大的权限，上面也提到了<strong>Native 可以通过 WebView API 直接执行 JS 代码</strong>。这样的权限也就让这个方向的通讯变得十分的便捷。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IOS</span></span><br><span class="line">webview.stringByEvaluatingJavaScriptFromString(<span class="string">"alert('NativeCall')"</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android(4.4-)</span></span><br><span class="line">webView.loadUrl(<span class="string">"javascript:JSBridge.trigger('NativeCall')"</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android(4.4+)</span></span><br><span class="line">mWebView.evaluateJavascript（<span class="string">"javascript:JSBridge.trigger('NativeCall')"</span>,</span><br><span class="line"><span class="keyword">new</span> ValueCallback<<span class="built_in">String</span>>() {</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> onReceiveValue(<span class="built_in">String</span> value) {</span><br><span class="line">        <span class="comment">//此处为 js 返回的结果</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>当 Android 系统低于 4.4 时，evaluateJavascript 是无法使用的，因此单纯的使用 loadUrl 无法获取 JS 返回值，这时我们需要使用前面提到的 prompt 的方法进行兼容，让 H5 端 通过 prompt 进行数据的发送，客户端进行拦截并获取数据。</p><p>基于上面的知识，我们已经大致明白 JSBridge 的原理了。</p><h4 id="App-中-H5-的接入方式"><a href="#App-中-H5-的接入方式" class="headerlink" title="App 中 H5 的接入方式"></a>App 中 H5 的接入方式</h4><ul><li><p><strong>在线 H5</strong> 这是最常见的一种方式。只需将 H5 代码部署到服务器上。把对应的 URL 给到客户端，用 WebView 打开该 URL，即可嵌入。其优点是：</p><ol><li>独立性强，有非常独立的开发/调试/更新/上线能力；</li><li>资源放在服务器上，完全不会影响客户端的包体积；</li><li>接入成本很低，完全的热更新机制；</li></ol><p>缺点:</p><ol><li>完全的网络依赖，在离线的情况下无法打开页面</li><li>首屏加载速度依赖于网络，网络较慢时，首屏加载也较慢；</li></ol></li></ul><ul><li><p><strong>离线 H5</strong> 这是一种本地化的嵌入方式，我们需要将代码进行打包后下发到客户端，并由客户端直接解压到本地储存中。其优点是：</p><ol><li>由于其本地化，首屏加载速度快</li><li>可以不依赖网络，离线运行</li></ol><p>缺点：</p><ol><li>开发流程/更新机制复杂化，需要客户端，甚至服务端的共同协作</li><li>会相应的增加 App 包体积</li></ol></li></ul><h2 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h2><p>Weex 是阿里在 2016 年 6 月开源的一种用于构建移动跨平台的 UI 框架，在 2017 年托管在 Apache 基金会上。</p><p><strong>“Write once, run everywhere”</strong> 这是 Weex 倡导的思想，借鉴如今大火的 FaceBook 开源的 React Native 的思想，选择使用 Vue.js 框架的语法开发 weex 代码，也可以使用 Rax，无论是哪种语法，经过编译都可以被 app 中的 weex sdk 所解析，并在底层以 Native 的形式渲染。</p><ul><li>Weex 的开发和 web 开发体验可以说是几乎一样。包括语法设计和工程链路等。</li><li>Weex 的组件、模块设计都是 iOS、Android、Web 的开发者共同讨论出来的，有一定的通用性和普遍性。</li><li>Weex 开发同一份代码，可以在不同的端上分别执行，避免了多端的重复研发成本。</li></ul><p>在同构这条路上，Weex 比 React Native 做得更彻底，几乎做到了<strong>你来使用 vue 写一个 webapp，我顺便给你编译成了 ios 和 android 的原生 app</strong></p><p>至于为什么要造这个轮子，官方给了以下说法：</p><p><code>1、今天在技术社区有大量的 web 开发者，Weex 可以赋能更多的 web 开发者构建高性能和高体验的移动应用。 2、Web 开发本身具有非常强的高效率和灵活性，这和 Weex 想解决的移动端动态性问题不谋而合。 3、Web 标准和开发体验是很多顶尖而优秀的科技公司共同讨论和建设的结果，本身的设计和理念都有极高的品质保障 4、同时 Weex 也希望可以借此机会努力为标准贡献一点自己的微薄之力。 5、Web 是一种标准化的技术，标准本身就是一种力量，基于标准、尊重标准、贴近标准都意味着拥有更多的可能性。 6、Web 今天的生态和社区是非常繁荣的，有很多成熟的工具、库、工程体系、最佳实践可以使用、引入和借鉴。</code></p><h3 id="Vue-在-Weex-中的不同"><a href="#Vue-在-Weex-中的不同" class="headerlink" title="Vue 在 Weex 中的不同"></a>Vue 在 Weex 中的不同</h3><p><strong>1.Weex 环境中没有 DOM</strong><br>因为 Weex 解析 vue 得到的并不是 dom，而是原生布局树</p><p><strong>2.支持有限的事件</strong><br>并不支持 Web 中所有的事件类型，详情请参考<a href="http://weex.apache.org/cn/wiki/common-events.html" target="_blank" rel="noopener">通用事件</a></p><p><strong>3.没有 BOM 但可以调用原生 API</strong><br>在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。<br>为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考<a href="http://weex.apache.org/cn/guide/extend-ios.html" target="_blank" rel="noopener">iOS 扩展</a>和<a href="http://weex.apache.org/cn/guide/extend-android.html" target="_blank" rel="noopener">Android 扩展</a>。</p><h3 id="样式差异"><a href="#样式差异" class="headerlink" title="样式差异"></a>样式差异</h3><p>Weex 中的样式是由原生渲染器解析的，出于性能和功能复杂度的考虑，Weex 对 CSS 的特性做了一些取舍</p><p><strong>1.Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。</strong><br><strong>2.组件级别的作用域，为了保持 web 和 Native 的一致性，需要<code><style scoped></code>写法。</strong><br><strong>3、支持了基本的盒模型和 flexbox 布局，详情可参考<a href="http://weex.apache.org/cn/wiki/common-styles.html" target="_blank" rel="noopener">Weex 通用样式文档</a>。但是需要注意的是</strong> 1.不支持<code>display: none;</code>可用<code>opacity: 0;</code>代替 (<code>opacity<=0.01</code>时，元素可点透） 2.样式属性暂不支持简写（提高解析效率）<br>3.flex 布局需要注意 web 的兼容<br>4.css 不支持 3D 变换</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>熟悉 React Native 的人都知道， React Native 的发布实际上就是发布一个 JSBundle，Weex 也是这样，但不同的是，Weex 将工程进行分包，发布多个 JSBundle。因为 Weex 是单页独立开发的，每个页面都将通过 Weex 打包器将 vue/we 页面打包成一个单独的 JSBundle，这样的好处在于减少单个 bundle 包的大小，使其变的足够小巧轻量，提高增量更新的效率。</p><p>打包后的 JSBundle 有两种格式</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 由.vue文件打包出来的包格式（简写），使用 vue 2.0 语法编写</span><br><span class="line"><span class="comment">// { "framework": "Vue"}</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>{</span><br><span class="line">          .......</span><br><span class="line"><span class="comment">/******/</span> })</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 由.we文件打包出来的包格式（简写），使用 weex 语法编写</span><br><span class="line">// { "framework": "Weex" }</span><br><span class="line">/******/ (function(modules) {</span><br><span class="line">          .......</span><br><span class="line">/******/ })</span><br></pre></td></tr></tbody></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>Weex 的 iOS 和 Android 客户端的【JSFramework】中都会运行一个 JavaScript 引擎，来执行 JS bundle，同时向各端的渲染层发送规范化的指令，调度客户端的渲染和其它各种能力。iOS 下选择了 JavaScriptCore 内核，而在 Android 下选择了 UC 提供的 v8 内核（RN 两端都是 JavaScriptCore 内核）。</p><p>JSBundle 被 push 到客户端后就会在 JSFramework 中执行，最终输出三端可读性的 VNode 节点，数据结构简化如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  tag: 'div',</span><br><span class="line">  data: {</span><br><span class="line">    staticStyle: { justifyContent: 'center' }</span><br><span class="line">  },</span><br><span class="line">  children: [{</span><br><span class="line">    tag: 'text',</span><br><span class="line">    data: {</span><br><span class="line">      staticClass: 'txt'</span><br><span class="line">    },</span><br><span class="line">    context: {</span><br><span class="line">      $options: {</span><br><span class="line">        style: {</span><br><span class="line">          freestyle: {</span><br><span class="line">            textAlign: 'center',</span><br><span class="line">            fontSize: 200</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    children: [{</span><br><span class="line">      tag: '',</span><br><span class="line">      text: '文字'</span><br><span class="line">    }]</span><br><span class="line">  }]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有了统一的 VNode 节点，各端即可根据自己的方法解析渲染原生 UI 了，之前的所有操作都是一致的，包括文件格式、打包编译过程、模板指令、组件的生命周期、数据绑定等。</p><p>官方配图：</p><center><img src="../../../../img/201901/weex1.png"></center><br>扩展配图：<br><center><img src="../../../../img/201901/weex2.jpeg"></center><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>我们先看看官方对它的定义：<br><code>Flutter 是 Google 用以帮助开发者在 iOS 和 Android 两个平台开发高质量原生 UI 的移动 SDK。Flutter 兼容现有的代码，免费并且开源，在全球开发者中广泛被使用。</code><br>看上去好像还不错，但 Flutter 究竟有哪些与众不同呢？我们按照官方描述的四个方面，分别来说说：</p><ul><li>Beautiful - Flutter 允许你控制屏幕上的每一寸像素，这让「设计」不用再对「实现」妥协；</li><li>Fast - 一个应用不卡顿的标准是什么，你可能会说 16ms 抑或是 60fps，这对桌面端应用或者移动端应用来说已足够，但当面对广阔的 AR/VR 领域，60fps 仍然会成为使人脑产生眩晕的瓶颈，而 Flutter 的目标远不止 60fps；借助 Dart 支持的 AOT 编译以及 Skia 的绘制，Flutter 可以运行的很快；</li><li>Productive - 前端开发可能已经习惯的开发中 hot reload 模式，但这一特性在移动开发中还算是个新鲜事。Flutter 提供有状态的 hot reload 开发模式，并允许一套 codebase 运行于多端；其他的，再比如开发采用 JIT 编译与发布的 AOT 编译，都使得开发者在开发应用时可以更加高效；</li><li>Open - Dart / Skia / Flutter (Framework)，这些都是开源的，Flutter 与 Dart 团队也对包括 Web 在内的多种技术持开放态度，只要是优秀的他们都愿意借鉴吸收。而在生态建设上，Flutter 回应 GitHub Issue 的速度更是让人惊叹，因为是真的快（closed 状态的 issue 平均解决时间为 0.29 天）；</li></ul><p>下面我们来看一下 Flutter 的架构图：</p><center><img src="../../../../img/201901/weex3.jpg"></center><p>从上至下分别为 Framework，Engine 和 EmEmbedder：</p><ul><li>Framework 层是框架使用者需要直接面对的，包含文本/图片/按钮等基础 Widgets、渲染、动画、手势等。如果你写 Flutter 应用，那么大致可以理解为调用这些 package 然后再用 Dart 「拼装」些自己的代码。</li><li>Engine 层使用 C++ 实现，这一层包含 Skia，Dart 和 Text。后两个不太熟，说说 Skia。这是一个二维图形库，提供了适用于多种软/硬件平台的通用 API，既是 Chrome，Chrome OS，Android，Firefox，Firefox OS 等产品的图形引擎，也支持 Windows 7+，macOS 10.10.5+，iOS8+，Android4.1+，Ubuntu14.04+ 等平台；Dart 可能包含 Dart Runtime 等（JIT/AOT），Text 则负责文字渲染部分。</li><li>Embedder 是一个嵌入层，做的事情是 Flutter to Platforms。比如渲染 Surface，线程设置，插件等。Flutter 的平台层很低，比如 iOS 只是提供一个画布，剩余的所有渲染相关的逻辑都在 Flutter 内部，而这就是 Flutter 所宣传的可以精准控制每一个像素的原因；但不可否认，对于插件部分，还是需要特定操作系统底层的建设（比如支付、地图等）。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;聊一聊-Weex-Flutter-Hybrid&quot;&gt;&lt;a href=&quot;#聊一聊-Weex-Flutter-Hybrid&quot; class=&quot;headerlink&quot; title=&quot;聊一聊 Weex Flutter Hybr
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://ru23.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>移动前端常见兼容处理</title>
    <link href="https://ru23.com/note/5d938461.html"/>
    <id>https://ru23.com/note/5d938461.html</id>
    <published>2019-04-15T09:29:11.000Z</published>
    <updated>2020-04-11T11:59:26.128Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="IOS-click-事件-300ms-延迟问题"><a href="#IOS-click-事件-300ms-延迟问题" class="headerlink" title="IOS click 事件 300ms 延迟问题"></a>IOS click 事件 300ms 延迟问题</h2><p>这个起因是由于区分单击和双击的历史原因造成的。</p><p>解决方案：</p><ul><li>引入 fastclick</li><li>触摸事件的响应顺序为 touchstart –> touchmove –> touchend –> click,也可以通过绑定 ontouchstart 事件，加快对事件的响应</li></ul><h2 id="Android4-4-以下图片无法使用-base64"><a href="#Android4-4-以下图片无法使用-base64" class="headerlink" title="Android4.4 以下图片无法使用 base64"></a>Android4.4 以下图片无法使用 base64</h2><h2 id="1px-问题"><a href="#1px-问题" class="headerlink" title="1px 问题"></a>1px 问题</h2><p>这个问题基本上是个老生常谈的问题，可以看下我的博客详细描述了如何解决 1px 的问题 <a href="https://invictusnightmares.github.io/2017/07/14/css-1px/" target="_blank" rel="noopener">1px</a></p><h2 id="兼容刘海屏"><a href="#兼容刘海屏" class="headerlink" title="兼容刘海屏"></a>兼容刘海屏</h2><p>可以看下这篇文章 <a href="https://imweb.io/topic/5baa38c279ddc80f36592efb" target="_blank" rel="noopener">兼容 iphone x * 刘海的正确姿势</a></p><h2 id="css-动画卡顿"><a href="#css-动画卡顿" class="headerlink" title="css 动画卡顿"></a>css 动画卡顿</h2><ul><li>尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用 position 的 left 和 top 来定位</li><li>开启硬件加速</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> {</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="requestAnimate-兼容"><a href="#requestAnimate-兼容" class="headerlink" title="requestAnimate 兼容"></a>requestAnimate 兼容</h2><p>在日常开发中如果遇到 CSS 无法完成的动画（比如页面滚动），通常的解决方案就是使用<strong>setInterval</strong>设置定时器来实现动画特效，但是定时器不是那么可靠，存在误差。</p><p>一般情况下，每秒平均刷新次数能够达到 60 帧，就能够给人流畅的体验，即每过 1000/60 毫秒渲染新一帧即可，光靠定时器是无法保证的。<strong>requestAnimationFrame</strong>就是解决这个问题的。在日常开发中，这个 api 是个很有用的帮手。关于它的兼容引入这段代码就可以了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> vendors = [<span class="string">'ms'</span>, <span class="string">'moz'</span>, <span class="string">'webkit'</span>, <span class="string">'o'</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x < vendors.length && !<span class="built_in">window</span>.requestAnimationFrame; ++x) {</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>]</span><br><span class="line">    <span class="built_in">window</span>.cancelAnimationFrame =</span><br><span class="line">      <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelAnimationFrame'</span>] ||</span><br><span class="line">      <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelRequestAnimationFrame'</span>]</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.requestAnimationFrame)</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>{</span><br><span class="line">      <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">      <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime))</span><br><span class="line">      <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        callback(currTime + timeToCall)</span><br><span class="line">      }, timeToCall)</span><br><span class="line">      lastTime = currTime + timeToCall</span><br><span class="line">      <span class="keyword">return</span> id</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.cancelAnimationFrame)</span><br><span class="line">    <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>{</span><br><span class="line">      clearTimeout(id)</span><br><span class="line">    }</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><h2 id="fixed-定位问题"><a href="#fixed-定位问题" class="headerlink" title="fixed 定位问题"></a>fixed 定位问题</h2><p>IOS 下 fixed 元素容易定位出错，软键盘弹出时，影响 fixed 元素定位。这里引用一下这篇经典文章<br><a href="https://efe.baidu.com/blog/mobile-fixed-layout/" target="_blank" rel="noopener">移动端 Fixed 布局的解决方案</a></p><h2 id="Input-的-placeholder-会出现文本位置偏上的情况"><a href="#Input-的-placeholder-会出现文本位置偏上的情况" class="headerlink" title="Input 的 placeholder 会出现文本位置偏上的情况"></a>Input 的 placeholder 会出现文本位置偏上的情况</h2><p>设置 <strong>line-height：normal</strong></p><h2 id="禁止长按复制和缩放"><a href="#禁止长按复制和缩放" class="headerlink" title="禁止长按复制和缩放"></a>禁止长按复制和缩放</h2><p>在 app 里内嵌的一些网页有时候我们是不需要长按复制这些功能的，可以这样禁止：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.no-touch</span> {</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-khtml-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>缩放可以这样禁止：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1, user-scalable=no"</span><br><span class="line">/></span><br></pre></td></tr></tbody></table></figure><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><p>可以参考一下淘宝团队出的 Flexible 方案，接触了几个大厂，基本是比较主流的适配方案：<br><a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">使用 Flexible 实现手淘 H5 页面的终端适配</a></p><h2 id="部分-Android-系统中元素被点击会产生边框"><a href="#部分-Android-系统中元素被点击会产生边框" class="headerlink" title="部分 Android 系统中元素被点击会产生边框"></a>部分 Android 系统中元素被点击会产生边框</h2><p>解决方案：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>{</span><br><span class="line"><span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0,0,0,0;)</span><br><span class="line">-webkit-user-modify:read-write-plaintext-only;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="audio-问题"><a href="#audio-问题" class="headerlink" title="audio 问题"></a>audio 问题</h2><p>这块不经常接触，但是 IOS 下考虑到用户体验问题，限制 audio 必须在用户主动交互之后才能够播放。</p><p>解决方案：提前创建 audio 标签，用户交互之后触发自动播放</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;IOS-click-事件-300ms-延迟问题&quot;&gt;&lt;a href=&quot;#IOS-click-事件-300ms-延迟问题&quot; class=&quot;headerlink&quot; title=&quot;IOS click 事件 300ms 延迟
      
    
    </summary>
    
    
      <category term="front-end" scheme="https://ru23.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Virtual Dom 算法</title>
    <link href="https://ru23.com/note/7cca498.html"/>
    <id>https://ru23.com/note/7cca498.html</id>
    <published>2019-04-05T09:29:11.000Z</published>
    <updated>2020-04-11T11:59:26.128Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="1-Virtual-Dom-算法"><a href="#1-Virtual-Dom-算法" class="headerlink" title="1.Virtual Dom 算法"></a>1.Virtual Dom 算法</h3><p>DOM 是慢的，我在控制台把一个简单的 div 属性打印出来见下图:</p><center><img src="../../../../img/0405/vd2.png"></center><br>这仅仅是第一层，真正的DOM元素非常庞大，我们在操作的DOM的时候都是小心翼翼的，轻微的改变可能就会引起浏览器重排，这可是杀死性能的罪魁祸首。<br><br>相比于 DOM 对象，原生的 JS 对象处理起来的更快更简单，DOM 树的结构和属性信息我们可以很简单的用 JS 对象标识：<br><br><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = {</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  props: { <span class="attr">id</span>: <span class="string">'list'</span> }, <span class="comment">// DOM的属性</span></span><br><span class="line">  children: [</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    { <span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: { <span class="attr">class</span>: <span class="string">'item'</span> }, <span class="attr">children</span>: [<span class="string">'Item 1'</span>] },</span><br><span class="line">    { <span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: { <span class="attr">class</span>: <span class="string">'item'</span> }, <span class="attr">children</span>: [<span class="string">'Item 1'</span>] },</span><br><span class="line">    { <span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: { <span class="attr">class</span>: <span class="string">'item'</span> }, <span class="attr">children</span>: [<span class="string">'Item 1'</span>] }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br>对应的 HTML：<br><br><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>></span>Item 1<span class="tag"></<span class="name">li</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>></span>Item 2<span class="tag"></<span class="name">li</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>></span>Item 3<span class="tag"></<span class="name">li</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ul</span>></span></span><br></pre></td></tr></tbody></table></figure><br><br>既然可以用 JS 对象可以表示 DOM 树，那么之前说的状态变更->重新渲染整个视图的方式可以稍微修改一下：当状态变更的时候，重新渲染这个 JS 的对象结构，然后用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作 DOM 的时候确实只变更有不同的地方。<br><br>简要概括为以下三个步骤：<br><br>1. 用 JS 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中。<br>2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。<br>3. 把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。<br><br><code>Virtual DOM</code> 的本质其实是在 JS 和 DOM 之间做了一个缓存，可以类比 CPU 和硬盘，硬盘这么慢，就在它们之间加了一个缓存。CPU（JS）只操作内存（<code>Virtual DOM</code>），最后再把变更写入硬盘（DOM）。<br><br>### 2.算法实现<br><br>上面说了 <code>Virtual Dom</code> 主要有三个步骤，那么下面就简述一下三个步骤的具体实现：<br><br>#### 2.1 用 JS 对象模拟 DOM 树<br><br>用 JS 表示一个 DOM 节点很简单，只需要记录它的节点类型、属性，还有子节点：<br>element.js<br><br><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">tagName, props, children</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.tagName = tagName</span><br><span class="line">  <span class="keyword">this</span>.props = props</span><br><span class="line">  <span class="keyword">this</span>.children = children</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">tagName, props, children</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br>那么 2 里面的 DOM 结构我们可以这样表示：<br><br><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">require</span>(<span class="string">'./element'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ul = el(<span class="string">'ul'</span>, { <span class="attr">id</span>: <span class="string">'list'</span> }, [</span><br><span class="line">  el(<span class="string">'li'</span>, { <span class="attr">class</span>: <span class="string">'item'</span> }, [<span class="string">'Item 1'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, { <span class="attr">class</span>: <span class="string">'item'</span> }, [<span class="string">'Item 2'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, { <span class="attr">class</span>: <span class="string">'item'</span> }, [<span class="string">'Item 3'</span>])</span><br><span class="line">])</span><br></pre></td></tr></tbody></table></figure><br><br>现在 ul 只是一个 JS 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个 ul 构建真正的 ul：<br><br><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName) <span class="comment">// 根据tagName构建</span></span><br><span class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> props) {</span><br><span class="line">    <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">const</span> propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> children = <span class="keyword">this</span>.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>{</span><br><span class="line">    <span class="keyword">const</span> childEl =</span><br><span class="line">      child <span class="keyword">instanceof</span> Element</span><br><span class="line">        ? child.render() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">        : <span class="built_in">document</span>.createTextNode(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br>render 方法会根据 tagName 构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要：<br><br><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ulRoot = ul.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ulRoot)</span><br></pre></td></tr></tbody></table></figure><br><br>上面的 ulRoot 是真正的 DOM 节点，把它塞入文档中，这样 body 里面就有了真正的 ul 的 DOM 结构：<br><br><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>></span>Item 1<span class="tag"></<span class="name">li</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>></span>Item 2<span class="tag"></<span class="name">li</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>></span>Item 3<span class="tag"></<span class="name">li</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ul</span>></span></span><br></pre></td></tr></tbody></table></figure><br><br>#### 2.2 比较两棵虚拟 DOM 树的差异<br><br>比较两棵 DOM 树的差异是 Virtual DOM 算法最核心的部分，也就是所谓的 Virtual Dom 的 diff 算法，两个树的完全的 diff 算法是一个时间复杂度为 O(n ^ 3)的问题。但是在前端实际操作中很少会跨越层级地移动 DOM 元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：<br><br><center><img src="../../../../img/0405/vd3.png"></center><p>上面的 div 只会跟同一层级的 div 进行对比，第二层级只会跟第二层级对比，这样的话算法的时间复杂度可以降到 O(n)。</p><p><strong>2.2.1 深度优先遍历，记录差异</strong></p><p>对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p><center><img src="../../../../img/0405/vd4.png"></center><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span> (<span class="params">oldTree, newTree</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> index = <span class="number">0</span>; <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">const</span> patches = {}; <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches);</span><br><span class="line">  <span class="keyword">return</span> patches;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">oldNode, newNode, index, patches</span>) </span>{</span><br><span class="line">  <span class="comment">// 对比oldNode和newNode的不同，记录下来</span></span><br><span class="line">  patches[index] = [...];</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span> (<span class="params">oldChildren, newChildren, index, patches</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> leftNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> currentNodeIndex = index;</span><br><span class="line">  oldChildren.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child, i</span>) </span>{</span><br><span class="line">    <span class="keyword">const</span> newChild = newChildren[i];</span><br><span class="line">    currentNodeIndex = (leftNode && leftNode.count) <span class="comment">// 计算节点的标识</span></span><br><span class="line">      ? currentNodeIndex + leftNode.count + <span class="number">1</span></span><br><span class="line">      : currentNodeIndex + <span class="number">1</span>;</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches); <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    leftNode = child;</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例如，上面的 div 和新的 div 有差异，当前的标记是 0，那么：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [{difference}, {difference}, ...] <span class="comment">// 用数组存储新旧节点的不同</span></span><br></pre></td></tr></tbody></table></figure><p>那么以此类推,p 就是 patches[1]，ul 就是 patches[2]。</p><p><strong>2.2.2 差异类型</strong></p><p>上面说的节点差异指什么？对 DOM 的操作可能会： 1.替换掉原来的节点。 2.移动、删除、新增子节点。 3.修改了节点的属性。 4.对于文本节点，文本内容可能会改变。</p><p>所以定义了几个类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REPLACE = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> REORDER = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> PROPS = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> TEXT = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>针对第一点，判断新旧节点的 tagName 和是不是一样的，如果不一样的说明需要替换掉：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [</span><br><span class="line">  {</span><br><span class="line">    type: REPALCE,</span><br><span class="line">    node: newNode</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>针对第三点，如果新增了属性 id 为 container：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [</span><br><span class="line">  {</span><br><span class="line">    type: PROPS,</span><br><span class="line">    props: {</span><br><span class="line">      id: <span class="string">'container'</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>针对第四点，记录为文本节点：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [</span><br><span class="line">  {</span><br><span class="line">    type: TEXT,</span><br><span class="line">    content: <span class="string">'NEW TEXT'</span></span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>第二点的排序：<br>例如 p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到。这个问题抽象出来其实是字符串的最小编辑距离问题，然后可以这样记录：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [{</span><br><span class="line">  type: REORDER,</span><br><span class="line">  moves: [{remove or insert}, {remove or insert}, ...]</span><br><span class="line">}]</span><br></pre></td></tr></tbody></table></figure><p>是要注意的是，因为 tagName 是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识 key，列表对比的时候，使用 key 进行对比，这样才能复用老的 DOM 树上的节点。</p><p>这样，我们就可以通过深度优先遍历两棵树，对每层的节点进行对比，记录下每个节点的差异了。</p><h4 id="2-3-把差异应用到真正的-DOM-树上："><a href="#2-3-把差异应用到真正的-DOM-树上：" class="headerlink" title="2.3 把差异应用到真正的 DOM 树上："></a>2.3 把差异应用到真正的 DOM 树上：</h4><p>因为步骤一所构建的 JS 对象树和 render 出来真正的 DOM 树的信息、结构是一样的。所以我们可以对那棵 DOM 树也进行深度优先的遍历，遍历的时候从步骤二生成的 patches 对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node, patches</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> walker = { <span class="attr">index</span>: <span class="number">0</span> }</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span>(<span class="params">node, walker, patches</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> currentPatches = patches[walker.index] <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> len = node.childNodes ? node.childNodes.length : <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line">    <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    <span class="keyword">const</span> child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) {</span><br><span class="line">    applyPatches(node, currentPatches) <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>applyPatches</code>，根据不同类型的差异对当前节点进行 DOM 操作：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span>(<span class="params">node, currentPatches</span>) </span>{</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentPatch</span>) </span>{</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) {</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown patch type '</span> + currentPatch.type)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><p>Virtual Dom 算法主要分为三个步骤：</p><p>1.create element</p><p>2.diff</p><p>3.patch</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构建虚拟DOM</span></span><br><span class="line"><span class="keyword">var</span> tree = el(<span class="string">'div'</span>, {<span class="string">'id'</span>: <span class="string">'container'</span>}, [</span><br><span class="line">  el(<span class="string">'h1'</span>, {<span class="attr">style</span>: <span class="string">'color: blue'</span>}, [<span class="string">'simple virtal dom'</span>]),</span><br><span class="line">  el(<span class="string">'p'</span>, [<span class="string">'Hello, virtual-dom'</span>]),</span><br><span class="line">  el(<span class="string">'ul'</span>, [el(<span class="string">'li'</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过虚拟DOM构建真正的DOM</span></span><br><span class="line"><span class="keyword">const</span> root = tree.render()；</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(root)；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 生成新的虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> newTree = el(<span class="string">'div'</span>, {<span class="string">'id'</span>: <span class="string">'container'</span>}, [</span><br><span class="line">  el(<span class="string">'h1'</span>, {<span class="attr">style</span>: <span class="string">'color: red'</span>}, [<span class="string">'simple virtal dom'</span>]),</span><br><span class="line">  el(<span class="string">'p'</span>, [<span class="string">'Hello, virtual-dom'</span>]),</span><br><span class="line">  el(<span class="string">'ul'</span>, [el(<span class="string">'li'</span>), el(<span class="string">'li'</span>)])</span><br><span class="line">])；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 比较两棵虚拟DOM树的不同</span></span><br><span class="line"><span class="keyword">const</span> patches = diff(tree, newTree)；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 在真正的DOM元素上应用变更</span></span><br><span class="line">patch(root, patches)；</span><br></pre></td></tr></tbody></table></figure><h3 id="6-Vue-Virtual-Dom-VS-React-Virtual-Dom"><a href="#6-Vue-Virtual-Dom-VS-React-Virtual-Dom" class="headerlink" title="6.Vue Virtual Dom VS React Virtual Dom"></a>6.Vue Virtual Dom VS React Virtual Dom</h3><p>Vue 官网上贴了这样一段话：</p><center><img src="../../../../img/0405/vd5.png"></center><p>尤大也在知乎上给出了答案：</p><center><img src="../../../../img/0405/vd6.png"></center><p>Vue 和 React 的 diff 算法几乎一样，每 state 改变时，Vue 会根据依赖找到最上层的 vdom 并以该组件为根，重新渲染整个 VDom 树而 React 会根据调用 setState 这个方法的这个组件， 以该组件为根重新渲染整个 VDom 树。</p><p>当项目比较小的时候，Vue 的依赖追踪可以比 React 做更少的工作，而 React 要达到相同的效果需要在每个组件内用 <code>shouldComponentUpdate</code> 或者是使用 <code>PureComponent</code> 因此相比 Vue 比较繁复。</p><p>当项目变得庞大的时候，Vue 的 re-render 相比 React 可以利用 <code>PureComponent</code> 或者 <code>shouldComponentUpdate</code> 方法优化的情况下，将变得重复且多余。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;1-Virtual-Dom-算法&quot;&gt;&lt;a href=&quot;#1-Virtual-Dom-算法&quot; class=&quot;headerlink&quot; title=&quot;1.Virtual Dom 算法&quot;&gt;&lt;/a&gt;1.Virtual Dom
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://ru23.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>2019年1月前端文章分享</title>
    <link href="https://ru23.com/note/9dcfd273.html"/>
    <id>https://ru23.com/note/9dcfd273.html</id>
    <published>2019-01-06T14:39:47.000Z</published>
    <updated>2020-04-11T11:59:26.127Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>vue按需加载组件-webpack require.ensure ：<a href="https://blog.csdn.net/qq_27626333/article/details/76228578" target="_blank" rel="noopener">https://blog.csdn.net/qq_27626333/article/details/76228578</a><br>代码分割 - 使用 require.ensure： <a href="https://www.css88.com/doc/webpack2/guides/code-splitting-require/" target="_blank" rel="noopener">https://www.css88.com/doc/webpack2/guides/code-splitting-require/</a><br>Tree shaking：<a href="https://www.css88.com/doc/webpack2/guides/tree-shaking/" target="_blank" rel="noopener">https://www.css88.com/doc/webpack2/guides/tree-shaking/</a><br>路由懒加载：<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a><br>利用函数式编程封装节流和防抖函数：<a href="https://www.jianshu.com/p/c8dcc0afbd1b" target="_blank" rel="noopener">https://www.jianshu.com/p/c8dcc0afbd1b</a><br>【HTTP】HTTPS 原理详解：<a href="https://baijiahao.baidu.com/s?id=1570143475599137&wfr=spider&for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1570143475599137&wfr=spider&for=pc</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;vue按需加载组件-webpack require.ensure ：&lt;a href=&quot;https://blog.csdn.net/qq_27626333/article/details/76228578&quot; target=&quot;_
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年1月todolist</title>
    <link href="https://ru23.com/note/5ab64037.html"/>
    <id>https://ru23.com/note/5ab64037.html</id>
    <published>2019-01-05T02:39:38.000Z</published>
    <updated>2020-04-11T11:59:26.127Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>1月份学习计划整理</p><p>防抖、节流<br>函数柯里化<br>路由懒加载的写法 webpack的require.ensure<br>webpack的去除无用代码 tree shakings<br>javascript异步编程整理<br>rem flex gird vw vh<br>webpack编译性能优化<br>vue的MVVM原理<br>Router的原理<br>虚拟DOM diff<br>vuex状态管理<br>react性能优化，高阶组件<br>浏览器缓存机制<br>事件机制，事件循环，<br>TCP传输的三次握手四次挥手策略<br>函数式编程思想<br>HTTP1.0 HTTP1.1 HTTP2.0 特性，以及HTTPS协议以及加密原理。<br>前端性能优化，<br>前端代码异常监控<br>常见web安全及防护原理</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;1月份学习计划整理&lt;/p&gt;
&lt;p&gt;防抖、节流&lt;br&gt;函数柯里化&lt;br&gt;路由懒加载的写法 webpack的require.ensure&lt;br&gt;webpack的去除无用代码 tree shakings&lt;br&gt;javascript
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="todolist" scheme="https://ru23.com/tags/todolist/"/>
    
  </entry>
  
  <entry>
    <title>vue双向绑定原理解析</title>
    <link href="https://ru23.com/note/a8fcf354.html"/>
    <id>https://ru23.com/note/a8fcf354.html</id>
    <published>2018-12-28T01:55:52.000Z</published>
    <updated>2020-04-11T11:59:26.126Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="1-vue的实现原理"><a href="#1-vue的实现原理" class="headerlink" title="1.vue的实现原理"></a>1.vue的实现原理</h3><p>vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的，那么什么是数据劫持？<br>vue是如何进行数据劫持的？说白了就是通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情．<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({</span><br><span class="line">    data: {</span><br><span class="line">        test : {</span><br><span class="line">            a: <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.test);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p></p><p>get和set.为什么会有这两个方法呢，这正是vue通过<code>Object.defineProperty()</code>进行数据劫持的．</p><p>语法  <code>Object.defineProperty(obj, prop, descriptor)</code><br>参数<br>obj<br>要在其上定义属性的对象。<br>prop<br>要定义或修改的属性的名称。<br>descriptor<br>将被定义或修改的属性描述符。<br>返回值节<br>    被传递给函数的对象。</p><p>在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。</p><p>简单的说，他可以控制一个对象属性的一些特有操作，比如读写权，是否可枚举，这里我们主要研究它的get和set方法</p><p>我们可以很轻松的打印出一个对象的属性数据：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = {</span><br><span class="line">  name: <span class="string">'张三'</span></span><br><span class="line">};</span><br><span class="line"><span class="built_in">console</span>.log(Person.name);  <span class="comment">// 张三</span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = {};</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person,<span class="string">'name'</span>,{</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{</span><br><span class="line">        name = value;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'他的名字:'</span>+value);</span><br><span class="line">    },</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get方法被监听到'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`他的名字叫`</span>${name};</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">Person.name = <span class="string">'张三'</span>;  <span class="comment">//他的名字：张三</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name);　<span class="comment">//张三</span></span><br></pre></td></tr></tbody></table></figure><p>通过<code>Object.defineProperty( )</code>这个方法设置了Person对象的name属性，对其get和set方法进行重写操作，get方法在获得name属性时被调用，set方法在设置name属性时被触发．所以在执行Person.name=’张三’　这个语句时调用set方法，输出你取了一个书名叫：张三．当调用console.log(Person.name)时触发get方法，输出他的名字叫张三</p><p>订阅者和发布者模式，通常用于消息队列中．一般有两种形式来实现消息队列，一是使用生产者和消费者来实现，二是使用订阅者－发布者模式来实现，其中订阅者和发布者实现消息队列的方式，就会用订阅者模式．</p><p>所谓的订阅者，就像我们在日常生活中，订阅报纸一样。我们订阅报纸的时候，通常都得需要在报社或者一些中介机构进行注册。当有新版的报纸发刊的时候，邮递员就需要向订阅该报纸的人，依次发放报纸。</p><p>所有如果用代码实现该模式，需要进行两个步骤：</p><p>1、初始化发布者、订阅者。<br>2、订阅者需要注册到发布者，发布者发布消息时，依次向订阅者发布消息。<br>那么接下来我们将通过vue原理实现一个简单的mvvm双向绑定的demo</p><p>思路分析</p><p>要想实现mvvm，主要包含两个方面，视图变化更新数据，数据变化更新视图．</p><p>view变化更新data其实可以通过事件监听实现，比如input标签监听input事件，所有我们着重分析data变化更新view.</p><p>data变化更新view的重点是如何知道view什么时候变化了，只要知道什么时候view变化了，那么接下来的就好处理了．这个时候我们上文提到的<code>Object.defineProperty( )</code>就起作用了．通过<code>Object.defineProperty( )</code>对属性设置一个set函数，当属性变化时就会触发这个函数，所以我们只需要将一些更新的方法放在set函数中就可以实现data变化更新view了．</p><p>实现过程</p><p>我们已经知道如何实现数据的双向绑定了，　那么首先要对数据进行劫持监听，所以我们首先要设置一个监听器Observer,用来监听所有的属性，当属性变化时，就需要通知订阅者Watcher,看是否需要更新．因为属性可能是多个，所以会有多个订阅者，故我们需要一个消息订阅器Dep来专门收集这些订阅者，并在监听器Observer和订阅者Watcher之间进行统一的管理．以为在节点元素上可能存在一些指令，所以我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令初始化成一个订阅者Watcher，并替换模板数据并绑定相应的函数，这时候当订阅者Watcher接受到相应属性的变化，就会执行相对应的更新函数，从而更新视图．</p><p>整理上面的思路，我们需要实现三个步骤，来完成双向绑定：</p><p>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p><p>2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><p>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p><h3 id="1-实现一个监听器Observer"><a href="#1-实现一个监听器Observer" class="headerlink" title="1.实现一个监听器Observer"></a>1.实现一个监听器Observer</h3><p>数据监听器的核心方法就是<code>Object.defineProperty( )</code>，通过遍历循环对所有属性值进行监听，并对其进行<code>Object.defineProperty( )</code>处理，那么代码可以这样写：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对所有属性都要监听,递归遍历所有属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,val</span>) </span>{</span><br><span class="line">    observe(val);  <span class="comment">//递归遍历所有的属性</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data,key,{</span><br><span class="line">        enumerable:<span class="literal">true</span>,         <span class="comment">//当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。</span></span><br><span class="line">        configurable:<span class="literal">true</span>,       <span class="comment">//当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中</span></span><br><span class="line">        get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        },</span><br><span class="line">        set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>{</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'属性'</span>+key+<span class="string">'已经被监听,现在值为:"'</span>+newVal.toString()+<span class="string">'"'</span>);</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span>(!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>{</span><br><span class="line">        defineReactive(data,key,data[key]);</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> library = {</span><br><span class="line">    book1: {</span><br><span class="line">        name: <span class="string">''</span></span><br><span class="line">    },</span><br><span class="line">    book2: <span class="string">''</span></span><br><span class="line">};</span><br><span class="line">observe(library);</span><br><span class="line">library.book1.name = <span class="string">'vue权威指南'</span>; <span class="comment">// 属性name已经被监听了，现在值为：“vue权威指南”</span></span><br><span class="line">library.book2 = <span class="string">'没有此书籍'</span>;  <span class="comment">// 属性book2已经被监听了，现在值为：“没有此书籍”</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>通过<code>observe()</code>方法进行遍历向下找到所有的属性，并通过<code>defineReactive()</code>方法进行数据劫持监听．</p><p>在上面的思路中，我们需要一个可以容纳消息订阅者的消息订阅器Dep，订阅器主要收集消息订阅者，然后在属性变化时执行相应订阅者的更新函数，那么消息订阅器Dep需要有一个容器，用来存放消息订阅者．我们将上面的监听器Observer稍微修改一下：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,val</span>) </span>{</span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, {</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">            <span class="keyword">if</span> (是否需要添加订阅者) {    <span class="comment">//Watcher初始化触发</span></span><br><span class="line">                dep.addSub(watcher); <span class="comment">// 在这里添加一个订阅者</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        },</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>{</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'属性'</span> + key + <span class="string">'已经被监听了，现在值为：“'</span> + newVal.toString() + <span class="string">'”'</span>);</span><br><span class="line">            dep.notify(); <span class="comment">// 如果数据变化，通知所有订阅者</span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span>(!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>{</span><br><span class="line">        defineReactive(data,key,data[key]);</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//prototype 属性使您有能力向对象添加属性和方法</span></span><br><span class="line"><span class="comment">//prototype这个属性只有函数对象才有，具体的说就是构造函数具有.只要你声明定义了一个函数对象，这个prototype就会存在</span></span><br><span class="line"><span class="comment">//对象实例是没有这个属性</span></span><br><span class="line">Dep.prototype = {                        </span><br><span class="line">    addSub:<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>{</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    },</span><br><span class="line">    notify:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>{</span><br><span class="line">            sub.update();        <span class="comment">//通知每个订阅者检查更新</span></span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>在代码中，我们将订阅器Dep添加一个订阅者设计在get里面，这是为了让Watcher在初始化时触发，因此判断是否需要需要添加订阅者，至于具体实现的方法，我们在下文中深究．在set方法中，如果函数变化，就会通知所有的订阅者，订阅者们将会执行相对应的更新函数，到目前为止，一个比较完善的Observer已经成型了，下面我们要写订阅者Watcher.</p><h3 id="2-实现订阅者Watcher"><a href="#2-实现订阅者Watcher" class="headerlink" title="2. 实现订阅者Watcher"></a>2. 实现订阅者Watcher</h3><p>根据我们的思路，订阅者Wahcher在初始化时要将自己添加到订阅器Dep中，那么如何进行添加呢？</p><p>我们已经知道监听器Observer是在get函数中执行了添加订阅者的操作的，所以我们只需要在订阅者Watcher在初始化时触发相对应的get函数来执行添加订阅者的操作即可．那么怎么触发对应的get函数呢？我们只需要获取对应的属性值，就可以通过Object.defineProperty( )触发对应的get了．</p><p>在这里需要注意一个细节，我们只需要在订阅者初始化时才执行添加订阅者，所以我们需要一个判断，在Dep.target上缓存一下订阅者，添加成功后去除就行了，代码如下：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm,exp,cb</span>) </span>{</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;    <span class="comment">//指向SelfVue的作用域</span></span><br><span class="line">    <span class="keyword">this</span>.exp = exp;  <span class="comment">//绑定属性的key值</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb;    <span class="comment">//闭包</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Watcher.prototype = {</span><br><span class="line">    update:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">    },</span><br><span class="line">    run:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">var</span> value = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp];</span><br><span class="line">        <span class="keyword">var</span> oldVal = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span>(value !== oldVal) {</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm,value,oldVal);</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        Dep.target = <span class="keyword">this</span>;                   <span class="comment">// 缓存自己</span></span><br><span class="line">        <span class="keyword">var</span> value = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp];  <span class="comment">// 强制执行监听器里的get函数</span></span><br><span class="line">        Dep.target = <span class="literal">null</span>;                   <span class="comment">// 释放自己</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个时候我们需要对监听器Observer中的<code>defineReactive()</code>做稍微的调整：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,val</span>) </span>{</span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, {</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">            <span class="keyword">if</span>(Dep.target) {   <span class="comment">//判断是否需要添加订阅者</span></span><br><span class="line">                 dep.addSub(Dep.target);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        },</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>{</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'属性'</span> + key + <span class="string">'已经被监听了，现在值为：“'</span> + newVal.toString() + <span class="string">'”'</span>);</span><br><span class="line">            dep.notify(); <span class="comment">// 如果数据变化，通知所有订阅者</span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到目前为止，一个简易版的Watcher已经成型了，我们只需要将订阅者Watcher和监听器Observer关联起来，就可以实现一个简单的双向绑定．因为这里还没有设计指令解析器，所以对于模板数据我们都进行写死处理，假设模板上有一个节点元素，且id为＇name＇,并且双向绑定的绑定变量也是’name’，且是通过两个大双括号包起来（暂时没有什么用处），模板代码如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"name"</span>></span>{{name}}<span class="tag"></<span class="name">h1</span>></span></span><br><span class="line"><span class="tag"></<span class="name">body</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Observer和Watcher关联起来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelfVue</span>(<span class="params">data,el,exp</span>) </span>{</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    observe(data);</span><br><span class="line">    el.innerHTML = <span class="keyword">this</span>.data[exp];</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>,exp,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{</span><br><span class="line">        el.innerHTML = value;</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"name"</span>></span>{{name}}<span class="tag"></<span class="name">h1</span>></span></span><br><span class="line"><span class="tag"></<span class="name">body</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/observer.js"</span>></span><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/Watcher.js"</span>></span><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/SelfVue.js"</span>></span><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span><span class="undefined"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'#name'</span>);</span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> selfVue = <span class="keyword">new</span> SelfVue({</span></span><br><span class="line"><span class="javascript">         name:<span class="string">'hello world'</span></span></span><br><span class="line"><span class="javascript">     },ele,<span class="string">'name'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">         <span class="built_in">console</span>.log(<span class="string">'name值改变了'</span>);</span></span><br><span class="line"><span class="javascript">         selfVue.name = <span class="string">'byebye world'</span>;</span></span><br><span class="line"><span class="undefined">     },2000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>这时我们打开页面，显示的是’hello world’,２s后变成了’byebye world’,一个简单的双向绑定实现了．</p><p>对比vue,我们发现了有一个问题，我们在为属性赋值的时候形式是： ‘selfVue.data.name = ‘byebye world’  ‘,而我们理想的形式是：’  selfVue.name = ‘byebye world’  ‘，那么怎么实现这种形式呢，只需要在new SelfVue时做一个代理处理，让访问SelfVue的属性代理为访问selfVue.data的属性，原理还是使用Object.defineProperty( )对属性在包装一层．代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelfVue</span>(<span class="params">data,el,exp</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="comment">//Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>{</span><br><span class="line">        self.proxyKeys(key);     <span class="comment">//绑定代理属性</span></span><br><span class="line">    });</span><br><span class="line">    observe(data);</span><br><span class="line">    el.innerHTML = <span class="keyword">this</span>.data[exp];   <span class="comment">// 初始化模板数据的值</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>,exp,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{</span><br><span class="line">        el.innerHTML = value;</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SelfVue.prototype = {</span><br><span class="line">    proxyKeys:<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>{</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,key,{</span><br><span class="line">            enumerable:<span class="literal">false</span>,</span><br><span class="line">            configurable:<span class="literal">true</span>,</span><br><span class="line">            get:<span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>{</span><br><span class="line">                <span class="keyword">return</span> self.data[key];</span><br><span class="line">            },</span><br><span class="line">            set:<span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">newVal</span>) </span>{</span><br><span class="line">                self.data[key] = newVal;</span><br><span class="line">            } </span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就可以用理想的形式改变模板数据了．</p><h3 id="3．实现指令解析器Compile"><a href="#3．实现指令解析器Compile" class="headerlink" title="3．实现指令解析器Compile"></a>3．实现指令解析器Compile</h3><p>再上面的双向绑定demo中，我们发现整个过程都没有解析dom节点，而是固定某个节点进行替换数据，所以接下来我们要实现一个解析器Compile来解析和绑定工作，分析解析器的作用，实现步骤如下：</p><p>1.解析模板指令，并替换模板数据，初始化视图</p><p>2.将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器<br>为了解析模板，首先要获得dom元素，然后对含有dom元素上含有指令的节点进行处理，这个过程对dom元素的操作比较繁琐，所以我们可以先建一个fragment片段，将需要解析的dom元素存到fragment片段中在做处理：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nodeToFragment:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();   <span class="comment">//createdocumentfragment()方法创建了一虚拟的节点对象，节点对象包含所有属性和方法。</span></span><br><span class="line">    <span class="keyword">var</span> child = el.firstChild;</span><br><span class="line">    <span class="keyword">while</span>(child) {</span><br><span class="line">        <span class="comment">// 将Dom元素移入fragment中</span></span><br><span class="line">        fragment.appendChild(child);</span><br><span class="line">        child = el.firstChild;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来需要遍历所有节点，对含有指令的节点进行特殊的处理，这里我们先处理最简单的情况，只对带有  这种形式的指令进行处理，代码如下：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历各个节点,对含有相关指定的节点进行特殊处理</span></span><br><span class="line">compileElement:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> childNodes = el.childNodes;   <span class="comment">//childNodes属性返回节点的子节点集合，以 NodeList 对象。</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//slice() 方法可从已有的数组中返回选定的元素。</span></span><br><span class="line">    [].slice.call(childNodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>{</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/\{\{(.*)\}\}/</span>;</span><br><span class="line">        <span class="keyword">var</span> text = node.textContent;  <span class="comment">//textContent 属性设置或返回指定节点的文本内容</span></span><br><span class="line">        <span class="keyword">if</span>(self.isTextNode(node) && reg.test(text)) {      <span class="comment">//判断是否符合 的指令</span></span><br><span class="line">            <span class="comment">//exec() 方法用于检索字符串中的正则表达式的匹配。</span></span><br><span class="line">            <span class="comment">//返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</span></span><br><span class="line">            self.compileText(node,reg.exec(text)[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(node.childNodes && node.childNodes.length) {</span><br><span class="line">            self.compileElement(node);    <span class="comment">//继续递归遍历子节点</span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">},</span><br><span class="line">compileText:<span class="function"><span class="keyword">function</span>(<span class="params">node,exp</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> initText = <span class="keyword">this</span>.vm[exp];</span><br><span class="line">    <span class="keyword">this</span>.updateText(node,initText);    <span class="comment">// 将初始化的数据初始化到视图中</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm,exp,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{</span><br><span class="line">        self.updateText(node,value);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">},</span><br><span class="line">updateText:<span class="function"><span class="keyword">function</span>(<span class="params">node,value</span>) </span>{</span><br><span class="line">    node.textContent = <span class="keyword">typeof</span> value == <span class="string">'undefined'</span> ? <span class="string">''</span>: value;</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p></p><p>获取到最外层节点后，调用compileElement函数，对所有子节点进行判断，如果节点是文本节点且匹配 这种形式指令的节点就开始进行编译处理，编译处理首先需要初始化视图数据，对应上面所说的步骤1，接下去需要生成一个并绑定更新函数的订阅器，对应上面所说的步骤2。这样就完成指令的解析、初始化、编译三个过程，一个解析器Compile也就可以正常的工作了。</p><p>为了将解析器Compile与监听器Observer和订阅者Watcher关联起来，我们需要再修改一下类SelfVue函数：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelfVue</span>(<span class="params">options</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = options.data;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>{</span><br><span class="line">        self.proxyKeys(key);     <span class="comment">//绑定代理属性</span></span><br><span class="line">    });</span><br><span class="line">    observe(options.data);</span><br><span class="line">    <span class="keyword">new</span> Compile(options.el,<span class="keyword">this</span>.vm);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，可以随便命名各种变量进行双向绑定了：<br></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">h1</span>></span>{{title}}<span class="tag"></<span class="name">h1</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">h2</span>></span>{{name}}<span class="tag"></<span class="name">h2</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">h3</span>></span>{{content}}<span class="tag"></<span class="name">h3</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">body</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/observer2.js"</span>></span><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/Watcher1.js"</span>></span><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/compile1.js"</span>></span><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/index3.js"</span>></span><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> selfVue = <span class="keyword">new</span> SelfVue({</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data:{</span></span><br><span class="line"><span class="javascript">            title:<span class="string">'aaa'</span>,</span></span><br><span class="line"><span class="javascript">            name:<span class="string">'bbb'</span>,</span></span><br><span class="line"><span class="javascript">            content:<span class="string">'ccc'</span></span></span><br><span class="line"><span class="undefined">        }</span></span><br><span class="line"><span class="undefined">    });</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        selfVue.title = <span class="string">'ddd'</span>;</span></span><br><span class="line"><span class="javascript">        selfVue.name = <span class="string">'eee'</span>;</span></span><br><span class="line"><span class="javascript">        selfVue.content = <span class="string">'fff'</span></span></span><br><span class="line"><span class="undefined">    },2000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>到这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译，在哪里进行更多指令的处理呢？答案很明显，只要在上文说的compileElement函数加上对其他指令节点进行判断，然后遍历其所有属性，看是否有匹配的指令的属性，如果有的话，就对其进行解析编译。这里我们再添加一个v-model指令和事件指令的解析编译，对于这些节点我们使用函数compile进行解析处理：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">compile:<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> nodeAttrs = node.attributes;   <span class="comment">//attributes 属性返回指定节点的属性集合，即 NamedNodeMap。</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//Array.prototype属性表示Array构造函数的原型，并允许为所有Array对象添加新的属性和方法。</span></span><br><span class="line">    <span class="comment">//Array.prototype本身就是一个Array</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.forEach.call(nodeAttrs,<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>{</span><br><span class="line">        <span class="keyword">var</span> attrName = attr.name;      <span class="comment">//添加事件的方法名和前缀:v-on:click="onClick" ,则attrName = 'v-on:click' id="app" attrname= 'id'</span></span><br><span class="line">        <span class="keyword">if</span>(self.isDirective(attrName)) {     </span><br><span class="line">            <span class="keyword">var</span> exp = attr.value;      <span class="comment">//添加事件的方法名和前缀:v-on:click="onClick" ,exp = 'onClick'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//substring() 方法用于提取字符串中介于两个指定下标之间的字符。返回值为一个新的字符串</span></span><br><span class="line">            <span class="comment">//dir = 'on:click'</span></span><br><span class="line">            <span class="keyword">var</span> dir = attrName.substring(<span class="number">2</span>);  </span><br><span class="line">            <span class="keyword">if</span>(self.isEventDirective(dir)) {   <span class="comment">//事件指令</span></span><br><span class="line">                self.compileEvent(node,self.vm,exp,dir);</span><br><span class="line">            }<span class="keyword">else</span> {          <span class="comment">//v-model指令</span></span><br><span class="line">                    self.compileModel(node,self.vm,exp,dir);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            node.removeAttribute(attrName);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>上面的compile函数是挂载Compile原型上的，它首先遍历所有节点属性，然后再判断属性是否是指令属性，如果是的话再区分是哪种指令，再进行相应的处理.</p><p>最后我们再次改造一下SelfVue，是它的格式看上去更像vue:<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelfVue</span>(<span class="params">options</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = options.data;</span><br><span class="line">    <span class="keyword">this</span>.methods = options.methods;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>{</span><br><span class="line">        self.proxyKeys(key);    </span><br><span class="line">    });</span><br><span class="line">    observe(options.data);</span><br><span class="line">    <span class="keyword">new</span> Compile(options.el,<span class="keyword">this</span>);</span><br><span class="line">    options.mounted.call(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>demo见 vue双向绑定源码.html</p><p>完工！</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;1-vue的实现原理&quot;&gt;&lt;a href=&quot;#1-vue的实现原理&quot; class=&quot;headerlink&quot; title=&quot;1.vue的实现原理&quot;&gt;&lt;/a&gt;1.vue的实现原理&lt;/h3&gt;&lt;p&gt;vue的双向绑定是由数据劫
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="vue" scheme="https://ru23.com/tags/vue/"/>
    
      <category term="mvvm" scheme="https://ru23.com/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>前端基础知识点</title>
    <link href="https://ru23.com/note/7e86d7fb.html"/>
    <id>https://ru23.com/note/7e86d7fb.html</id>
    <published>2018-12-22T06:32:25.000Z</published>
    <updated>2020-04-11T11:59:26.126Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="JsonP原理："><a href="#JsonP原理：" class="headerlink" title="JsonP原理："></a>JsonP原理：</h3><p>原理：动态插入script标签，通过script标签引入js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且把我们需要的json数据作为参数传入。<br>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名，协议，端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出Json数据并执行回调函数，从而解决了跨域的数据请求。<br>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持get请求。<br>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>{</span><br><span class="line">    <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    oScript.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    oScript.src = sUrl;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">createJs(<span class="string">'jsonp.js'</span>);</span><br><span class="line"></span><br><span class="line">box({</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'test'</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>{</span><br><span class="line">    alert(json.name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="nginx实现跨域的原理及运行流程"><a href="#nginx实现跨域的原理及运行流程" class="headerlink" title="nginx实现跨域的原理及运行流程"></a>nginx实现跨域的原理及运行流程</h3><p>原理：<br>首先，直接在浏览器地址栏中，输入某接口地址。是不会产生跨域问题的。<br>只有当在某域名的页面中，由该页面发起的接口请求。才可能会跨域。<br>nginx就类似于这个浏览器，它接收到外部对它的请求（ 注意，nginx只会接收别人对它的请求，而不会拦截浏览器的请求 ），再类似浏览器地址栏一样去请求某个接口。最后将请求到的内容返回回去</p><p>前端利用host结合nginx实现跨域的运行流程：<br>Brower =》 host =》 nginx =》 目标地址<br>服务器数据 =》 nginx =》 Brower<br>也就是说，nginx并不是通过监听brower的请求。<br>而是作为一个服务器，接收外部对本机的请求。<br>所以是先通过host，让请求指向本机，才会经过nginx。才能进行转发。</p><h3 id="TCP传输的三次握手四次挥手策略"><a href="#TCP传输的三次握手四次挥手策略" class="headerlink" title="TCP传输的三次握手四次挥手策略"></a>TCP传输的三次握手四次挥手策略</h3><p><strong>先了解几个概念</strong><br>ACK 确认序列编号<br>（表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0）<br>SYN 同步序列编号<br>(在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。)<br>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。<br><strong>TCP协议采用了三次握手策略。</strong><br>用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。</p><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。<br>最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。<br>TCP三次握手的的好处在于：发送方可以确认接收方仍然在线，不会因为白发送而浪费资源。<br><strong>断开一个TCP连接则需要“四次握手”：</strong></p><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP （Transmission Control Protocol,传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须与对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。<br>UDP （User Data Protocol,用户数据协议）是与TCP相对应的协议。它是基于面向非连接的协议，他不与对方建立连接，而是直接把数据包发过去！</p><h3 id="常见web安全及防护原理"><a href="#常见web安全及防护原理" class="headerlink" title="常见web安全及防护原理"></a>常见web安全及防护原理</h3><p><strong>XSS原理及防范</strong><br>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者在论坛中放一个<br>看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，<br>当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。<br><strong>XSS防范方法</strong><br>首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。</p><p>首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。</p><p>其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。</p><p>如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。</p><p>尽量采用POST 而非GET 提交表单</p><p><strong>XSS与CSRF有什么区别吗？</strong><br>XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。<br>要完成一次CSRF攻击，受害者必须依次完成两个步骤：<br>登录受信任网站A，并在本地生成Cookie。<br>在不登出A的情况下，访问危险网站B。</p><p><strong>CSRF的防御</strong><br>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p><ol><li><p>提交验证码<br>在表单中添加一个随机的数字或字母验证码。通过强制用户和应用进行交互。来有效地遏制CSRF攻击。</p></li><li><p>Referer Check<br>检查假设是非正常页面过来的请求，则极有可能是CSRF攻击。</p></li><li><p>token验证</p></li></ol><p>在 HTTP 请求中以參数的形式添加一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，假设请求中没有<br>token 或者 token 内容不对，则觉得可能是 CSRF 攻击而拒绝该请求。<br>token须要足够随机<br>敏感的操作应该使用POST。而不是GET，以form表单的形式提交。能够避免token泄露。</p><ol start="4"><li>在 HTTP 头中自己定义属性并验证<br>这样的方法也是使用 token 并进行验证。这里并非把 token 以參数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自己定义的属性里。通过 XMLHttpRequest 这个类，能够一次性给全部该类请求加上 csrftoken 这个 HTTP 头属性。并把 token 值放入当中。这样攻克了上种方法在请求中添加 token 的不便。同一时候，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用操心 token 会透过 Referer 泄露到其它站点中去。</li></ol><h3 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h3><p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</p><p>队列先进先出，栈先进后出。</p><p>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</p><h3 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h3><p>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。<br>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。</p><h3 id="http1-0和http1-1的区别"><a href="#http1-0和http1-1的区别" class="headerlink" title="http1.0和http1.1的区别"></a>http1.0和http1.1的区别</h3><p>主要区别主要体现在：</p><ol><li>缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li>Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li>长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><h3 id="http2-0与http1-x的区别"><a href="#http2-0与http1-x的区别" class="headerlink" title="http2.0与http1.x的区别"></a>http2.0与http1.x的区别</h3><p>1，新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。<br>2，多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里<br>3，header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。<br>4，服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p><h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><p>defer并行加载js文件，会按照页面上script标签的顺序执行<br>async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</p><h3 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对闭包的理解</h3><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p><p>闭包有三个特性：<br>1.函数嵌套函数<br>2.函数内部可以引用外部的参数和变量<br>3.参数和变量不会被垃圾回收机制回收  </p><h3 id="介绍一下box-sizing属性？"><a href="#介绍一下box-sizing属性？" class="headerlink" title="介绍一下box-sizing属性？"></a>介绍一下box-sizing属性？</h3><p>box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。<br>content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高<br>border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content</p><p>CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下：</p><p>content-box（默认）<br>布局所占宽度Width：</p><p>css<br>Width = width + padding-left + padding-right + border-left + border-right<br>布局所占高度Height:</p><p>css<br>Height = height + padding-top + padding-bottom + border-top + border-bottom<br>padding-box<br>布局所占宽度Width：</p><p>css<br>Width = width(包含padding-left + padding-right) + border-top + border-bottom<br>布局所占高度Height:</p><p>css<br>Height = height(包含padding-top + padding-bottom) + border-top + border-bottom<br>border-box<br>布局所占宽度Width：</p><p>css<br>Width = width(包含padding-left + padding-right + border-left + border-right)<br>布局所占高度Height:</p><p>css<br>Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</p><h3 id="对BFC规范的理解？"><a href="#对BFC规范的理解？" class="headerlink" title="对BFC规范的理解？"></a>对BFC规范的理解？</h3><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。  </p><h3 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h3><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p><h3 id="讲讲304缓存的原理"><a href="#讲讲304缓存的原理" class="headerlink" title="讲讲304缓存的原理"></a>讲讲304缓存的原理</h3><p>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。<br>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件<br>客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>冒泡排序</strong><br>每次比较相邻的两个数，如果后一个比前一个小，换位置。<br>时间复杂度：O(n^2)<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = len; i >= <span class="number">2</span>; --i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j < i - <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] < arr[j]) {</span><br><span class="line">                <span class="keyword">var</span> temp;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort2</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i <= len - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j <= len - i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] < arr[j]) {</span><br><span class="line">                <span class="keyword">var</span> temp;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr));</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort2(arr));</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>快速排序</strong><br>采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边。<br>时间复杂度：O(nlog2(n))<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> [];  <span class="comment">// 返回空数组</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> c = arr.splice(cIndex, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> l = [];</span><br><span class="line">    <span class="keyword">var</span> r = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < arr.length; i++) {</span><br><span class="line">        <span class="keyword">if</span>(arr[i] < c) {</span><br><span class="line">            l.push(arr[i]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            r.push(arr[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(l).concat(c, quickSort(r));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></tbody></table></figure><p></p><p>1.一次完整的HTTP请求所经历的7个步骤<br>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤： </p><ol><li>建立TCP连接<br>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</li><li>Web浏览器向Web服务器发送请求命令<br>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</li><li>Web浏览器发送请求头信息<br>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 </li><li>Web服务器应答<br>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</li><li>Web服务器发送应答头信息<br>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 </li><li>Web服务器向浏览器发送数据<br>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</li><li>Web服务器关闭TCP连接<br>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：<br>Connection:keep-alive<br>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ol><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>可以让this指向固定化，这种特性很有利于封装回调函数<br>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。<br>async/await 是写异步代码的新方式，以前的方法有回调函数和Promise。<br>async/await是基于Promise实现的，它不能用于普通的回调函数。async/await与Promise一样，是非阻塞的。<br>async/await使得异步代码看起来像同步代码，这正是它的魔力所在。</p><p>http2.0和http1.1的区别</p><p>多路复用<br>多路复用允许单一的http2连接同时发起多重的请求-响应信息<br>http性能优化的关键并不在于高带宽，而是低延迟，TCP连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度，这种调谐则称之为TCP慢启动，由于这种原因，让原本就具有突发性和短时性的http连接变得十分低效<br>http2通过让所有数据流共用同一个连接，可以更有效的使用TCP连接，让高带宽也能真正服务于http的性能提升<br>小总结：多路复用技术，单连接多资源的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大，由于减少TCP慢启动时间，提高传输的速度<br>因为所有的http2的请求都在一个TCP连接上，所以在http1中的自动化合并文件和Sprite合图等资源合并减少请求的优化手段对于http2来说是没有效果的</p><p>二进制分帧<br>http2在应用层和传输层之间增加一个二进制分帧层，http2会将所有传输的信息分割成更小的消息和帧，并对他们采用二进制格式的编码，其中http1的首部信息会被封装成Headers帧，而我们的request body则封装到Data帧里面</p><p>首部压缩<br>http请求和响应都是由状态行，请求／响应头部，消息主题三部分组成，一般而言，消息主题都会经过gzip压缩，或者本身传输的就是压缩后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输，浪费流量资源<br>原理：头部压缩需要在支持http2的浏览器和服务端之间，维护一份相同的静态字典，包含常见的头部名称与值的组合，维护一份相同的动态字典，可以动态的添加内容，支持基于静态哈夫曼码表的哈夫曼编码</p><p>http2支持服务器推送<br>服务端推送是一种在客户端请求之前发送数据的机制，当代网页使用了许多资源：html，样式表，脚本等，在http1.x中这些资源每一个都必须明确的请求，这可能是一个很慢的过程，因为服务器必须等待浏览器做的每一个请求，网络经常是空闲和未充分使用的<br>为了改善延迟，http2引入了server push，它允许服务端推送资源给浏览器，在浏览器明确请求之前，一个服务器经常知道一个页面需要更多的附加资源，在他响应浏览器第一个请求时，可以开始推送这些资源，这允许服务端去完全充分利用一个可能空闲的网络，改善页面加载的时间<br>有了http2的服务端推送，http1时代的内嵌资源的优化手段也变得没有意义了，使用服务端推送更高效，因为客户端可以缓存起来，甚至可以不同页面之间共享</p><p>并行双向字节流的请求和响应<br>在http2上，客户端和服务端可以把http消息分解成回不依赖的帧，然后乱序发送，最后再在另一端把她们重新组合起来，同一链接上可以有多个不同方向上的数据在传输，客户端可以一边乱序发送stream，也可以一边接收着服务端的响应，在服务端同理<br>把http消息分解为独立的帧，交错发送，然后在另一端重新组装是http2最重要的一项增强，这个机制会在整个web技术栈中引发一系列的连锁反应，从而带来巨大的性能提升，因为</p><p>可以并行交错的发送请求，请求之间互不影响<br>可以并行交错的发送响应，响应之间互不干扰<br>只使用同一个连接即可并行的发送多个请求和响应<br>消除不必要的延迟，从而减少页面加载的时间<br>也就是说‘域名分区’的优化手段对于http2来说是无用的，因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载<br>http2的请求优先级<br>每个http2流里面有个优先值，这个优先值确定着客户端和服务端处理不同的流采取不同的优先级策略，高优先级的流应该优先发送，但又不是绝对的准守，可能又会引入首队阻塞的问题，高优先级的请求慢导致阻塞其他文件的交付，分配处理资源和客户端与服务器间的带宽，不同优先级的混合是必须的</p><p>https<br>http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL协议用于对http协议传输的数据进行加密，从而诞生了https，现在的https使用的都是TSL协议</p><p>https在传输数据之前需要客户端和服务端之间进行一次握手，在握手的过程中将确立双方加密传输数据的密码信息，TSL／SSL协议不仅仅是一套加密传输的协议，TSL/SSL中使用了非对称加密，对称加密以及hash算法</p><p>握手过程：</p><p>浏览器将自己支持的一套加密规则发送给网站</p><p>网站从中选出一组加密算法和hash算法，并将自己的身份信息以证书的形式发回给浏览器，证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息</p><p>获得网站证书后浏览器要做以下工作</p><p>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致）如果证书受信任，则浏览器栏里会显示一个小锁头，否则会给出证书不受信的提示<br>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密<br>使用约定好的hash计算握手信息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站<br>网站接收浏览器发来的数据之后要做以下工作</p><p>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手信息，并验证hash是否与浏览器发来的一致<br>使用密码加密一段握手信息，发送给浏览器<br>浏览器解密并计算握手信息的hash，如果与服务端发来的hash一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密</p><p>这里浏览器与网站互相发送加密的握手信息并验证，目的是为了保证双发都获得了一致的密码，并且可以正常的加密解密数据</p><p>其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而hash算法用于验证数据的完整性</p><p>由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其进行加密，非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏</p><p>TSL握手的过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私数据的传输，正是由于https非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文信息</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;JsonP原理：&quot;&gt;&lt;a href=&quot;#JsonP原理：&quot; class=&quot;headerlink&quot; title=&quot;JsonP原理：&quot;&gt;&lt;/a&gt;JsonP原理：&lt;/h3&gt;&lt;p&gt;原理：动态插入script标签，通过scr
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="知识点" scheme="https://ru23.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>合理利用前端缓存优化性能</title>
    <link href="https://ru23.com/note/a1bbed4a.html"/>
    <id>https://ru23.com/note/a1bbed4a.html</id>
    <published>2018-12-17T12:47:27.000Z</published>
    <updated>2020-04-11T11:59:26.126Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="合理利用缓存"><a href="#合理利用缓存" class="headerlink" title="合理利用缓存:"></a>合理利用缓存:</h3><p>对于web应用来说，缓存是提升页面性能同时减少服务器压力的利器。</p><p>浏览器缓存类型<br>1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；</p><p>相关的header:<br>Expires ：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。它的值为一个绝对时间的GMT格式的时间字符串， 比如Expires:Thu,21 Jan 2018 23:39:02 GMT</p><p>Cache-Control ：这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。比如Cache-Control:max-age=300，</p><p>简单概括：其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容较客户端是否已经发生了更新呢？此时我们需要协商缓存策略。</p><p>2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用。</p><p>相关的header:<br>①Last-Modified和If-Modified-Since：当第一次请求资源时，服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p><p>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT<br>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。<br>但last-modified 存在一些缺点：</p><p>Ⅰ.某些服务端不能获取精确的修改时间</p><p>Ⅱ.文件修改时间改了，但文件内容却没有变</p><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？—-ETag和If-None-Match</p><p>②ETag和If-None-Match：Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><p>两者之间对比：<br>首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。<br>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>第三在优先级上，服务器校验优先考虑Etag</p><p>缓存的机制<br>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;合理利用缓存&quot;&gt;&lt;a href=&quot;#合理利用缓存&quot; class=&quot;headerlink&quot; title=&quot;合理利用缓存:&quot;&gt;&lt;/a&gt;合理利用缓存:&lt;/h3&gt;&lt;p&gt;对于web应用来说，缓存是提升页面性能同时减少服务器压
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="缓存" scheme="https://ru23.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>http请求报文介绍</title>
    <link href="https://ru23.com/note/ef1b6cee.html"/>
    <id>https://ru23.com/note/ef1b6cee.html</id>
    <published>2018-12-06T06:11:28.000Z</published>
    <updated>2020-04-11T11:59:26.125Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p><h3 id="一、一个HTTP请求报文由请求行（request-line）、请求头部（header）、空行和请求数据4个部分组成"><a href="#一、一个HTTP请求报文由请求行（request-line）、请求头部（header）、空行和请求数据4个部分组成" class="headerlink" title="一、一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成"></a>一、一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成</h3><p>下图给出了请求报文的一般格式。<br><img src="https://cdn.ru23.com/img/2018/12/http-message.png" alt="HTTP请求报文1"><br><img src="https://cdn.ru23.com/img/2018/12/http-message2.jpg" alt="HTTP请求报文-详解"></p><p>以下逐步分析各个数据部分的作用。</p><p>1、请求行</p><p>　　　　请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。</p><p>　　　　例如打开路径<a href="http://www.baidu.com/index.php，用火狐浏览器可以查看到请求报文为：" target="_blank" rel="noopener">http://www.baidu.com/index.php，用火狐浏览器可以查看到请求报文为：</a></p><p>　　　　GET /index.php HTTP/1.1</p><p>　　　　因此用空格分隔之后得到的信息为</p><p>　　　　(1)请求方法:  GET</p><p>　　　　(2)URL信息:  /index.php</p><p>　　　　(3)HTTP协议版本:  HTTP/1.1　　<br>2、请求头部<br>　　　　User-Agent：浏览器的具体类型　　如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0</p><p> 　　　  Accept：浏览器支持哪些数据类型　　如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p><p>　　　　Accept-Charset：浏览器采用的是哪种编码　　如：Accept-Charset: ISO-8859-1</p><p>　　　　Accept-Encoding：浏览器支持解码的数据压缩格式　　如：Accept-Encoding: gzip, deflate</p><p>　　　　Accept-Language：浏览器的语言环境　　如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3</p><p> 　　　  Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>　　　   Connection：表示是否需要持久连接。Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-Alive</p><p>　　　　Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。</p><p>　　　　Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’</p><p>　　　　Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p><p>　　　　Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。</p><p>　　　　Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。</p><p> 　　　  Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。Referer: <a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a></p><p> 3.空行<br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p>4.请求数据</p><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h3 id="二、HTTP响应报文"><a href="#二、HTTP响应报文" class="headerlink" title="二、HTTP响应报文"></a>二、HTTP响应报文</h3><p> 　HTTP响应报文与HTTP请求报文是对应的，也是分为三个部分。</p><p>　　1、响应行</p><p>　　2、响应头</p><p>　　3、响应体</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK　　//响应行</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Content-Type: text/html;charset=ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜/title＞</span><br><span class="line">＜/head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜/body＞</span><br><span class="line">＜/html＞</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.ru23.com/img/2018/12/xiangying.jpg" alt="HTTP响应报文"><br><img src="https://cdn.ru23.com/img/2018/12/xiangying2.jpg" alt="HTTP响应报文-详解"></p><p>HTTP响应报文常用属性：</p><p>Cache-Control<br>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。<br>下面，的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。</p><p>Cache-Control: max-age=3600</p><p>ETag</p><p>一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。</p><p>ETag: “737060cd8c284d8af7ad3082f209582d”</p><p>Location</p><p>我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：</p><p>Location: <a href="http://www.google.com.hk" target="_blank" rel="noopener">http://www.google.com.hk</a></p><p>Set-Cookie</p><p>服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。</p><p>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</p><p>HTTP响应体：如果请求的是HTML页面，那么返回的就是HTML代码。如果是JS就是JS代码。</p><p>HTTP响应头：而设置Cookie，缓存等信息就是在响应头属性设置的。</p><p>HTTP响应行：主要是设置响应状态等信息。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。&lt;/p&gt;
&lt;h3 id=&quot;一、一个HTTP请求报文由请求行（request-line）、请
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="http" scheme="https://ru23.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>2018年12月前端文章分享</title>
    <link href="https://ru23.com/note/f04f102c.html"/>
    <id>https://ru23.com/note/f04f102c.html</id>
    <published>2018-12-05T10:10:17.000Z</published>
    <updated>2020-04-11T11:59:26.125Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>实现简单的MVVM：<a href="https://github.com/louzhedong/blog/issues/4" target="_blank" rel="noopener">https://github.com/louzhedong/blog/issues/4</a></p><p>手写实现bind，call，apply：<a href="https://www.jianshu.com/p/539064c644bb" target="_blank" rel="noopener">https://www.jianshu.com/p/539064c644bb</a></p><p>this、apply、call、bind:<a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">https://juejin.im/post/59bfe84351882531b730bac2</a></p><p>深入详解函数的柯里化：<a href="https://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">https://www.jianshu.com/p/5e1899fe7d6b</a></p><p>webpack4.0性能优化：<a href="https://juejin.im/post/5bf511eae51d454e243dbe55" target="_blank" rel="noopener">https://juejin.im/post/5bf511eae51d454e243dbe55</a></p><p>vue3.0尝鲜 – 摒弃Object.defineProperty，基于 Proxy 的观察者机制探索：<a href="https://juejin.im/post/5bf3e632e51d452baa5f7375" target="_blank" rel="noopener">https://juejin.im/post/5bf3e632e51d452baa5f7375</a></p><p>彻底弄懂原型和原型链：<a href="https://juejin.im/post/5bf3d8936fb9a04a072ffba1" target="_blank" rel="noopener">https://juejin.im/post/5bf3d8936fb9a04a072ffba1</a></p><p>BFC是什么以及BFC的常见用途：<a href="https://www.cnblogs.com/libin-1/p/7098468.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/7098468.html</a></p><p>关于JSON.parse(JSON.stringify(obj))实现深拷贝应该注意的坑 ：<a href="https://www.jianshu.com/p/b084dfaad501" target="_blank" rel="noopener">https://www.jianshu.com/p/b084dfaad501</a></p><p>css margin重叠问题及解决方法（BFC）：<a href="https://github.com/aermin/blog/issues/40" target="_blank" rel="noopener">https://github.com/aermin/blog/issues/40</a></p><p>前端代码异常监控实战：<a href="http://web.jobbole.com/93684/" target="_blank" rel="noopener">http://web.jobbole.com/93684/</a></p><p>深入解析Javascript异步编程：<a href="https://www.cnblogs.com/nullcc/p/5841182.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullcc/p/5841182.html</a></p><p>vue源码解析：<a href="https://jiongks.name/blog/vue-code-review/" target="_blank" rel="noopener">https://jiongks.name/blog/vue-code-review/</a></p><p>https加密原理：<a href="https://www.cnblogs.com/Yfling/p/6670495.html" target="_blank" rel="noopener">https://www.cnblogs.com/Yfling/p/6670495.html</a></p><p>学习底层的虚拟DOM原理：<a href="https://nicebluejs.com/2018/09/19/%E8%99%9A%E6%8B%9FDOM/" target="_blank" rel="noopener">https://nicebluejs.com/2018/09/19/%E8%99%9A%E6%8B%9FDOM/</a></p><p>防抖节流：<a href="https://www.cnblogs.com/ytg-share/p/8794341.html" target="_blank" rel="noopener">https://www.cnblogs.com/ytg-share/p/8794341.html</a></p><p>js中arguments的用法: <a href="https://www.cnblogs.com/LMJBlogs/p/6024148.html" target="_blank" rel="noopener">https://www.cnblogs.com/LMJBlogs/p/6024148.html</a></p><p>深入学习async/await: <a href="http://www.cnblogs.com/qcloud1001/p/10151294.html" target="_blank" rel="noopener">http://www.cnblogs.com/qcloud1001/p/10151294.html</a></p><p>入门Webpack: <a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a></p><p>css_tricks: <a href="https://qishaoxuan.github.io/css_tricks/" target="_blank" rel="noopener">https://qishaoxuan.github.io/css_tricks/</a></p><p>防抖节流：<a href="https://blog.csdn.net/hupian1989/article/details/80920324" target="_blank" rel="noopener">https://blog.csdn.net/hupian1989/article/details/80920324</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;实现简单的MVVM：&lt;a href=&quot;https://github.com/louzhedong/blog/issues/4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.co
      
    
    </summary>
    
      <category term="fed-shared" scheme="https://ru23.com/categories/fed-shared/"/>
    
    
      <category term="fed-shared" scheme="https://ru23.com/tags/fed-shared/"/>
    
  </entry>
  
  <entry>
    <title>12月份知识点总结</title>
    <link href="https://ru23.com/note/8b81e52c.html"/>
    <id>https://ru23.com/note/8b81e52c.html</id>
    <published>2018-12-03T12:04:57.000Z</published>
    <updated>2020-04-11T11:59:26.125Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="JS基础数据类型"><a href="#JS基础数据类型" class="headerlink" title="JS基础数据类型"></a>JS基础数据类型</h3><p>Number String Null Undefined Boolean, Symbol都属于础数据类型，往往都保存在栈内存中，栈空间先进后出，后进先出<br>引用数据类型：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等。<br>引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在堆内存中访问到的具体对象实际上是同一个</p><h3 id="HTTP三次握手以及原因"><a href="#HTTP三次握手以及原因" class="headerlink" title="HTTP三次握手以及原因"></a>HTTP三次握手以及原因</h3><p>ACK 确认序列编号<br>（表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0）<br>SYN 同步序列编号<br>(在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。)<br>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p><p>第一次握手：建立连接。<br>客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；<br>第二次握手：服务端收到SYN报文段。<br>服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK报文段。<br>然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。</p><p>为什么要三次握手<br>两次握手的问题在于服务器端不知道一个SYN是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果Client端向Server写数据，Server端将以RST包响应，这时便感知到Server的错误<br>防止了服务器端的一直等待而浪费资源</p><p>四次分手<br>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p>为什么要四次分手<br>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h3 id="AMD，CMD规范"><a href="#AMD，CMD规范" class="headerlink" title="AMD，CMD规范"></a>AMD，CMD规范</h3><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<br>define(id?, dependencies?, factory)</p><ul><li>id:字符串，模块名称(可选)</li><li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li><li>factory: 工厂方法，返回一个模块函数</li></ul><p>CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。<br>CMD与AMD一样，也是采用特定的define()函数来定义,用require方式来引用模块<br>define(id?, dependencies?, factory)</p><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>webSocket和http一样，同属于应用层协议。它最重要的用途是实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。<br>除此之外，它与http协议不同的地方还有：<br>http只能由客户端发起，而webSocket是双向的。<br>webSocket传输的数据包相对于http而言很小，很适合移动端使用<br>没有同源限制，可以跨域共享资源</p><p>WebSocket握手的过程。<br>当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。</p><ol><li>Browser与WebSocket服务器通过TCP三次握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。</li><li>在TCP建立连接成功后，Browser/UA通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。</li><li>WebSocket服务器收到Browser/UA发送来的握手请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。</li><li>Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口想服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。<br><strong>(一)socket和http区别</strong><br> 1,传输层的TCP是基于网络层的IP协议的，<br> 2,而应用层的HTTP协议又是基于传输层的TCP协议的，<br> 3,而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口.<br><strong>(二)websocket 和socket区别</strong><br> 1,websocket是应用层的协议,而socket是传输控制层的协议.<br><strong>(三)websocket和http区别</strong><br>相同点:<br> 1,都是应用层的协议<br> 2,都是基于tcp,并且都是可靠的协议<br>不同点:<br> 1,websocket是持久连接的协议,而http是非持久连接的协议.<br> 2,websocket是双向通信协议,模拟socket协议,可以双向发送消息,而http是单向的.<br> 3,websocket的服务端可以主动向客服端发送信息,而http的服务端只有在客户端发起请求时才能发送数据,无法主动向客户端发送信息.<br><strong>(四)HTTPS和HTTP的区别主要为以下四点：</strong><br> 1、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br> 2、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br> 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br> 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><h3 id="js原型链"><a href="#js原型链" class="headerlink" title="js原型链"></a>js原型链</h3><p><a href="https://juejin.im/post/58f94c9bb123db411953691b" target="_blank" rel="noopener">https://juejin.im/post/58f94c9bb123db411953691b</a><br><a href="http://yujiangshui.com/javascript-prototype-and-create-object/" target="_blank" rel="noopener">http://yujiangshui.com/javascript-prototype-and-create-object/</a></p><h3 id="继承（http-yujiangshui-com-javascript-inheritance-）"><a href="#继承（http-yujiangshui-com-javascript-inheritance-）" class="headerlink" title="继承（http://yujiangshui.com/javascript-inheritance/）"></a>继承（<a href="http://yujiangshui.com/javascript-inheritance/）" target="_blank" rel="noopener">http://yujiangshui.com/javascript-inheritance/）</a></h3><p><strong>1.原型链继承</strong></p><h3 id="对闭包的理解以及应用场景"><a href="#对闭包的理解以及应用场景" class="headerlink" title="对闭包的理解以及应用场景"></a>对闭包的理解以及应用场景</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> secret = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    get_secret : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      <span class="comment">// 通过定义的接口来访问secret</span></span><br><span class="line">      <span class="keyword">return</span> secret;</span><br><span class="line">    },</span><br><span class="line">    new_secret: <span class="function"><span class="keyword">function</span> (<span class="params">new_secret</span>) </span>{</span><br><span class="line">      <span class="comment">// 通过定义的接口来修改secret</span></span><br><span class="line">      secret = new_secret;</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">})();</span><br><span class="line"><span class="built_in">console</span>.log(foo.get_secret());</span><br><span class="line"><span class="built_in">console</span>.log(foo.secret)</span><br><span class="line">foo.get_secret();<span class="comment">//secret</span></span><br><span class="line">foo.secret;<span class="comment">//Type error</span></span><br><span class="line">foo.new_secret(<span class="string">'a new secret'</span>);</span><br><span class="line">foo.get_secret()<span class="comment">//a new secret</span></span><br></pre></td></tr></tbody></table></figure><h3 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h3><h3 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h3><p>important>内联(1000)>id(100>class(10)>标签（1）  数字表示权重</p><h3 id="js里事件的三个阶段"><a href="#js里事件的三个阶段" class="headerlink" title="js里事件的三个阶段"></a>js里事件的三个阶段</h3><p>事件流被分为三个阶段捕获过程、目标过程、冒泡过程<br>冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。<br>捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。<br><strong>事件代理：</strong><br>原理：靠事件冒泡实现的<br>优点：<br>大量减少内存占用，减少事件注册<br>新增子对象时无需再次对其绑定事件，对于动态内容不符尤其适用<br>缺点：<br>适用于表格/列表等重复性dom元素,事件代理用不好可能出现事件误判，即本不应该触发事件的元素被绑定了事件<br><strong>e.target和e.currentTarget</strong><br>　target和currentTarget都是event上面的属性，target是真正发生事件的DOM元素，而currentTarget是当前事件发生在哪个DOM元素上。<br>　目标阶段也就是 target == currentTarget的时候。</p><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><ol><li>js是单线程，js解析方法时，将同步任务排队到执行栈中，异步任务排队到事件队列中。</li><li>事件队列分为:<br>宏任务：setTimeout，setInterval，setImmediate，I/O，UI交互事件<br>微任务：process.nextTick，Promise.then</li><li>浏览器环境中执行方法时，先将执行栈中的任务清空，再将微任务推到执行栈中并清空，之后检查是否存在宏任务，若存在则取出一个宏任务，执行完成检查是否有微任务，以此循环…</li></ol><h3 id="vue-router原理（还需要整理一下）"><a href="#vue-router原理（还需要整理一下）" class="headerlink" title="vue-router原理（还需要整理一下）"></a>vue-router原理（还需要整理一下）</h3><p>1、Hash模式：<br>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。hash 模式的原理是 onhashchange 事件(监测hash值变化)，可以在 window 对象上监听这个事件。</p><p>2、History模式：<br>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用了html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求。</p><p>重点说其中的两个新增的API history.pushState 和 history.replaceState<br>状态对象（state object） — 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。<br>标题（title） — FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。<br>地址（URL） — 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。</p><h3 id="html的缓存机制-（2个缓存的属性总结一下）"><a href="#html的缓存机制-（2个缓存的属性总结一下）" class="headerlink" title="html的缓存机制 （2个缓存的属性总结一下）"></a>html的缓存机制 （2个缓存的属性总结一下）</h3><p>Etag首部怎么产生的</p><h3 id="webpack的loader"><a href="#webpack的loader" class="headerlink" title="webpack的loader"></a>webpack的loader</h3><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h3 id="输入url发生了什么"><a href="#输入url发生了什么" class="headerlink" title="输入url发生了什么"></a>输入url发生了什么</h3><h3 id="js作用域的理解"><a href="#js作用域的理解" class="headerlink" title="js作用域的理解"></a>js作用域的理解</h3><h3 id="with在项目中的应用"><a href="#with在项目中的应用" class="headerlink" title="with在项目中的应用"></a>with在项目中的应用</h3><h3 id="web安全以及怎么防范"><a href="#web安全以及怎么防范" class="headerlink" title="web安全以及怎么防范"></a>web安全以及怎么防范</h3><p>csrf xxs验证码好处</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h3><h3 id="页面渲染过程"><a href="#页面渲染过程" class="headerlink" title="页面渲染过程"></a>页面渲染过程</h3><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><h3 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h3><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>   考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>   考虑到减轻服务器性能方面，应当使用COOKIE。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、所以个人建议：<br>   将登陆信息等重要信息存放为SESSION<br>   其他信息如果需要保留，可以放在COOKIE中</p><h3 id="localStorage和sessionStorage的区别"><a href="#localStorage和sessionStorage的区别" class="headerlink" title="localStorage和sessionStorage的区别"></a>localStorage和sessionStorage的区别</h3><p>特性    Cookie    localStorage    sessionStorage<br>数据的生命期    一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效    除非被清除，否则永久保存    仅在当前会话下有效，关闭页面或浏览器后被清除<br>存放数据大小    4K左右    一般为5MB<br>与服务器端通信    每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题    仅在客户端（即浏览器）中保存，不参与和服务器的通信<br>易用性    需要程序员自己封装，源生的Cookie接口不友好    源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p><h3 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h3><p>GET和POST的重大区别是，GET产生一个TCP数据包，POST产生两个数据包，对于GET请求，浏览器会把header与data一起发送出去，服务端响应200的状态码，但是POST首先会发送一个header，服务端响应100 continue，然后在发送data到服务端，所以产生两个数据包，并不是所有的浏览器都发送两次数据包，例如，Firefox只发送一次。</p><h3 id="为什么需要虚拟DOM"><a href="#为什么需要虚拟DOM" class="headerlink" title="为什么需要虚拟DOM"></a>为什么需要虚拟DOM</h3><p>浏览器的引擎工作流程<br>创建DOM tree –> 创建Style Rules -> 构建Render tree -> 布局Layout –> 绘制Painting<br>第一步，用HTML分析器，分析HTML元素，构建一颗DOM树。<br>第二步：用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。<br>第三步：将上面的DOM树和样式表，关联起来，构建一颗Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又名renderer）。这些render对象最终会被构建成一颗Render树。<br>第四步：有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值。<br>第五步：Render数有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>css里面的定位：absolute ，relative，fixed，分别相对于什么进行定位<br>css引入样式的方式，优先级，性能最好；外部文件的样式覆盖标签的样式<br>JS对象原型链，检测对象,数组的数据类型Object.prototype.toString()<br>apply()，call()，区别，this指向了谁，<br>闭包是什么，函数作为返回值用来干什么（难道不是调用另一个函数的作用域）<br>JS中this的指向，最普通的指向（没有环境，没有方法）——>指向全局；在函数中的this指向调用这个函数的对象；箭头函数的this指向定义它的对象；<br>Object中定义了一个方法，方法中this指向了谁？ 不是箭头函数的时候，this指向调用这个函数的对象；箭头函数中指向这个Object<br>Ajax的了解<br>Promise的了解<br>DOM选择一个元素有哪些方法？（getElementById,getElementByClassName;getElementByTagName,querySelected）<br>http状态码，常用的（200，204，301，302，304，404,500，502）<br>进程，线程区别；<br>数据结构Set，Map<br>map的实现，红黑树了解吗？哈希表？<br>linux的了解？基本命令应该知道吧？（no）</p><h3 id="vue底层怎么实现双向数据绑定"><a href="#vue底层怎么实现双向数据绑定" class="headerlink" title="vue底层怎么实现双向数据绑定"></a>vue底层怎么实现双向数据绑定</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!DOCTYPE html></span></span><br><span class="line"><span class="tag"><<span class="name">head</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">title</span>></span>myVue<span class="tag"></<span class="name">title</span>></span></span><br><span class="line"><span class="tag"></<span class="name">head</span>></span></span><br><span class="line"><span class="tag"><<span class="name">style</span>></span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#app</span> {</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span><span class="tag"></<span class="name">style</span>></span></span><br><span class="line"><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">form</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">v-model</span>=<span class="string">"number"</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-click</span>=<span class="string">"increment"</span>></span>增加<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">form</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">h3</span> <span class="attr">v-bind</span>=<span class="string">"number"</span>></span><span class="tag"></<span class="name">h3</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">form</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">v-model</span>=<span class="string">"count"</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-click</span>=<span class="string">"incre"</span>></span>增加<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">form</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">h3</span> <span class="attr">v-bind</span>=<span class="string">"count"</span>></span><span class="tag"></<span class="name">h3</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">body</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">myVue</span>(<span class="params">options</span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._init(options);</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  myVue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$options = options;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$data = options.data;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$methods = options.methods;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._binding = {};</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._obverse(<span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._complie(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="javascript">  myVue.prototype._obverse = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>{</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) {</span></span><br><span class="line"><span class="undefined">        _this._binding[key] = {                                                                                                                                                          </span></span><br><span class="line"><span class="undefined">          _directives: []</span></span><br><span class="line"><span class="undefined">        };</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(_this._binding[key])</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> value = obj[key];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span>) {</span></span><br><span class="line"><span class="undefined">          _this._obverse(value);</span></span><br><span class="line"><span class="undefined">        }</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> binding = _this._binding[key];</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(_this.$data, key, {</span></span><br><span class="line"><span class="javascript">          enumerable: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">          configurable: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">          get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${key}</span>获取<span class="subst">${value}</span>`</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> value;</span></span><br><span class="line"><span class="undefined">          },</span></span><br><span class="line"><span class="javascript">          set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>{</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${key}</span>更新<span class="subst">${newVal}</span>`</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (value !== newVal) {</span></span><br><span class="line"><span class="undefined">              value = newVal;</span></span><br><span class="line"><span class="javascript">              binding._directives.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>{</span></span><br><span class="line"><span class="undefined">                item.update();</span></span><br><span class="line"><span class="undefined">              })</span></span><br><span class="line"><span class="undefined">            }</span></span><br><span class="line"><span class="undefined">          }</span></span><br><span class="line"><span class="undefined">        })</span></span><br><span class="line"><span class="undefined">      }</span></span><br><span class="line"><span class="undefined">    })</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  myVue.prototype._complie = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> nodes = root.children;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < nodes.length; i++) {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> node = nodes[i];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.children.length) {</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>._complie(node);</span></span><br><span class="line"><span class="undefined">      }</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-click'</span>)) {</span></span><br><span class="line"><span class="javascript">        node.onclick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> attrVal = nodes[i].getAttribute(<span class="string">'v-click'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> _this.$methods[attrVal].bind(_this.$data);</span></span><br><span class="line"><span class="undefined">        })();</span></span><br><span class="line"><span class="undefined">      }</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-model'</span>) && (node.tagName == <span class="string">'INPUT'</span> || node.tagName == <span class="string">'TEXTAREA'</span>)) {</span></span><br><span class="line"><span class="javascript">        node.addEventListener(<span class="string">'input'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>{</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-model'</span>);</span></span><br><span class="line"><span class="javascript">          _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span></span><br><span class="line"><span class="javascript">            <span class="string">'input'</span>,</span></span><br><span class="line"><span class="undefined">            node,</span></span><br><span class="line"><span class="undefined">            _this,</span></span><br><span class="line"><span class="undefined">            attrVal,</span></span><br><span class="line"><span class="javascript">            <span class="string">'value'</span></span></span><br><span class="line"><span class="undefined">          ))</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="undefined">            _this.$data[attrVal] =  nodes[key].value;</span></span><br><span class="line"><span class="undefined">          }</span></span><br><span class="line"><span class="undefined">        })(i));</span></span><br><span class="line"><span class="undefined">      } </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-bind'</span>)) {</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-bind'</span>);</span></span><br><span class="line"><span class="javascript">        _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span></span><br><span class="line"><span class="javascript">          <span class="string">'text'</span>,</span></span><br><span class="line"><span class="undefined">          node,</span></span><br><span class="line"><span class="undefined">          _this,</span></span><br><span class="line"><span class="undefined">          attrVal,</span></span><br><span class="line"><span class="javascript">          <span class="string">'innerHTML'</span></span></span><br><span class="line"><span class="undefined">        ))</span></span><br><span class="line"><span class="undefined">      }</span></span><br><span class="line"><span class="undefined">    }</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">name, el, vm, exp, attr</span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.name = name;         <span class="comment">//指令名称，例如文本节点，该值设为"text"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.el = el;             <span class="comment">//指令对应的DOM元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.vm = vm;             <span class="comment">//指令所属myVue实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.exp = exp;           <span class="comment">//指令对应的值，本例如"number"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.attr = attr;         <span class="comment">//绑定的属性值，本例为"innerHTML"</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.update();</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Watcher.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.exp];</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> myVue({</span></span><br><span class="line"><span class="javascript">      el:<span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: {</span></span><br><span class="line"><span class="undefined">        number: 0,</span></span><br><span class="line"><span class="undefined">        count: 0,</span></span><br><span class="line"><span class="undefined">      },</span></span><br><span class="line"><span class="undefined">      methods: {</span></span><br><span class="line"><span class="javascript">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.number ++;</span></span><br><span class="line"><span class="undefined">        },</span></span><br><span class="line"><span class="javascript">        incre: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count ++;</span></span><br><span class="line"><span class="undefined">        }</span></span><br><span class="line"><span class="undefined">      }</span></span><br><span class="line"><span class="undefined">    })</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>手写bind call aplly</p><p>原型链</p><p>js的设计模式</p><p>http协议</p><p>三次握手</p><p>cookie 和session 的区别：<br>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>   考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>   考虑到减轻服务器性能方面，应当使用COOKIE。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、所以个人建议：<br>   将登陆信息等重要信息存放为SESSION<br>   其他信息如果需要保留，可以放在COOKIE中</p><p>闭包</p><p>javascript中的this</p><p>new 一个对象的时候底层发生了什么</p><h3 id="合理利用缓存"><a href="#合理利用缓存" class="headerlink" title="合理利用缓存:"></a>合理利用缓存:</h3><p>对于web应用来说，缓存是提升页面性能同时减少服务器压力的利器。</p><p>浏览器缓存类型<br>1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；</p><p>相关的header:<br>Expires ：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。它的值为一个绝对时间的GMT格式的时间字符串， 比如Expires:Thu,21 Jan 2018 23:39:02 GMT</p><p>Cache-Control ：这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。比如Cache-Control:max-age=300，</p><p>简单概括：其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容较客户端是否已经发生了更新呢？此时我们需要协商缓存策略。</p><p>2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用。</p><p>相关的header:<br>①Last-Modified和If-Modified-Since：当第一次请求资源时，服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p><p>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT<br>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。<br>但last-modified 存在一些缺点：</p><p>Ⅰ.某些服务端不能获取精确的修改时间</p><p>Ⅱ.文件修改时间改了，但文件内容却没有变</p><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？—-ETag和If-None-Match</p><p>②ETag和If-None-Match：Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><p>两者之间对比：<br>首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。<br>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>第三在优先级上，服务器校验优先考虑Etag</p><p>缓存的机制<br>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;JS基础数据类型&quot;&gt;&lt;a href=&quot;#JS基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS基础数据类型&quot;&gt;&lt;/a&gt;JS基础数据类型&lt;/h3&gt;&lt;p&gt;Number String Null Un
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="ms" scheme="https://ru23.com/tags/ms/"/>
    
  </entry>
  
  <entry>
    <title>对css重绘和重排的理解，两个有什么不同</title>
    <link href="https://ru23.com/note/8463a2db.html"/>
    <id>https://ru23.com/note/8463a2db.html</id>
    <published>2018-12-01T13:49:16.000Z</published>
    <updated>2020-04-11T11:59:26.126Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>这一题考的其实是网页性能的问题，我们先理解下对网页性能产生影响到因素，了解下网页是怎么生成的</p><p>网页生成的过程，大致可以分为五步：</p><ol><li>html代码转化为dom</li><li>css代码转化为cssom</li><li>结合dom和cssom，生成一颗渲染树（包含每个节点的视觉信息）</li><li>生成布局layout，即将所有的渲染树的节点进行平面合成</li><li>将布局绘制paint在屏幕上</li></ol><p>重绘和重排</p><p>网页生成的时候，至少会渲染一次，用户访问的过程中，还会不断的重新渲染<br>以下三种情况会导致页面重新渲染<br>修改dom<br>修改样式表<br>用户事件<br>重新渲染，就需要重新生成布局和重新绘制，前者叫重排reflow，后者叫重绘repaint<br>需要注意的是重绘不一定需要重排，比如改变网页元素的颜色，就会只发生重绘，不会发生重排，因为布局没有改变，但是重排一定会导致重绘，如何改变一个网页元素的位置，就会同时触发重排和重绘，因为布局改变了</p><p>对于性能的影响<br>重绘和重排会不断触发，这是不可避免的，但是，他们是非常耗费资源的，是导致网页性能低下根本原因<br>要提高网页性能，就是要降低重排和重绘的频率和成本，尽量少触发重新渲染</p><p>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetTop/offsetLeft/offsetWidth/offsetHeight</span><br><span class="line">scrollTop/scrollLeft/scrollWidth/scrollHeight</span><br><span class="line">clientTop/clientLeft/clientWidth/clientHeight</span><br><span class="line">getComputeStyle()</span><br></pre></td></tr></tbody></table></figure><p></p><p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里，一般的规则是<br>样式表越简单，重绘和重排就越快<br>重排和重绘的dom层级越高，成本就越高<br>table元素的重绘和重排成本，要高于div元素</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这一题考的其实是网页性能的问题，我们先理解下对网页性能产生影响到因素，了解下网页是怎么生成的&lt;/p&gt;
&lt;p&gt;网页生成的过程，大致可以分为五步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;html代码转化为dom&lt;/li&gt;
&lt;li&gt;css代码
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="css" scheme="https://ru23.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期以及注意事项</title>
    <link href="https://ru23.com/note/9a17caa7.html"/>
    <id>https://ru23.com/note/9a17caa7.html</id>
    <published>2018-11-29T03:36:28.000Z</published>
    <updated>2020-04-11T11:59:26.120Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>react快速入门</p><h3 id="react组件的生命周期"><a href="#react组件的生命周期" class="headerlink" title="react组件的生命周期"></a>react组件的生命周期</h3><p>在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化 </p><blockquote><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。<br>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p></blockquote><p>组件的生命主要包括3个阶段： 挂载、更新、卸载，React 16开始还添加了错误处理。</p><p>韦博青少微信端用的是react15版本的，先简述下15版本的生命周期，react16的生命周期也是基于15上修改</p><p><img src="https://cdn.ru23.com/img/2018/12/react-life-cycle.png" alt="react生命周期"></p><h3 id="第一个是组件初始化-initialization-阶段"><a href="#第一个是组件初始化-initialization-阶段" class="headerlink" title="第一个是组件初始化(initialization)阶段"></a>第一个是组件初始化(initialization)阶段</h3><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { Component } <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(props) {</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>构造方法(<code>constructor()</code> ),Test类继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用<br>super(props)用来调用基类的构造方法( <code>constructor()</code> ), 也将父组件的props注入给子组件，供子组件读取(组件中props只读不可变，state可变)<br>而<code>constructor()</code>用来做一些组件的初始化工作，如定义this.state的初始内容。</p><h3 id="第二个是组件的挂载-Mounting-阶段"><a href="#第二个是组件的挂载-Mounting-阶段" class="headerlink" title="第二个是组件的挂载(Mounting)阶段"></a>第二个是组件的挂载(Mounting)阶段</h3><p><strong>此阶段分为componentWillMount，render，componentDidMount三个时期</strong><br><code>componentWillMount</code>:<br>在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到<code>constructor()</code>中，所以项目中很少用。<br><code>render</code>:<br>根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。</p><p><code>componentDidMount</code>:<br>组件挂载到DOM后调用，且只会被调用一次<br>1.在<code>componentDidMount</code>请求异步加载的数据<br>2.添加事件监听 — Adding event listeners (or subscriptions)</p><h3 id="第三个是组件的更新-update-阶段"><a href="#第三个是组件的更新-update-阶段" class="headerlink" title="第三个是组件的更新(update)阶段"></a>第三个是组件的更新(update)阶段</h3><p>在讲述此阶段前需要先明确下<strong>react组件更新机制</strong>。</p><ol><li>父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render</li><li>setState引起的state更新,可通过<code>shouldComponentUpdate</code>方法优化。<figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{</span><br><span class="line">   <span class="keyword">constructor</span>(props) {</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = {</span><br><span class="line">          someThings:<span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   handleClick = <span class="function"><span class="params">()</span> =></span> { <span class="comment">// 虽然调用了setState ，但state并无变化</span></span><br><span class="line">        <span class="keyword">const</span> preSomeThings = <span class="keyword">this</span>.state.someThings</span><br><span class="line">         <span class="keyword">this</span>.setState({</span><br><span class="line">            someThings: preSomeThings</span><br><span class="line">         })</span><br><span class="line">   }</span><br><span class="line">   shouldComponentUpdate(nextStates){ <span class="comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span></span><br><span class="line">        <span class="keyword">if</span>(nextStates.someThings === <span class="keyword">this</span>.state.someThings){</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">div</span> <span class="attr">onClick</span> = <span class="string">{this.handleClick}</span>></span>{this.state.someThings}<span class="tag"></<span class="name">div</span>></span></span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">`</span>componentWillReceiveProps(nextProps)<span class="string">`</span></span><br><span class="line"><span class="string">此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>shouldComponentUpdate(nextProps, nextState)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</span></span><br><span class="line"><span class="string">ps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前（如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState及当前组件的this.state的对比就一直是true了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>componentWillUpdate(nextProps, nextState)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>render<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">render方法在上文讲过，这边只是重新调用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>componentDidUpdate(prevProps, prevState)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 卸载阶段</span></span><br><span class="line"><span class="string">此阶段只有一个生命周期方法：`</span>componentWillUnmount<span class="string">`</span></span><br><span class="line"><span class="string">`</span>componentWillUnmount<span class="string">`</span></span><br><span class="line"><span class="string">此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清除定时器，清除componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">### react16 生命周期函数做的更改</span></span><br><span class="line"><span class="string">旧的生命周期十分完整，基本可以捕捉到组件更新的每一个state/props/ref，没有什么逻辑上的毛病。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是架不住官方自己搞事情，react打算在17版本推出新的Async Rendering，提出一种可被打断的生命周期，而可以被打断的阶段正是实际dom挂载之前的虚拟dom构建阶段，也就是要被去掉的三个生命周期。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生命周期一旦被打断，下次恢复的时候又会再跑一次之前的生命周期，</span></span><br><span class="line"><span class="string">因此componentWillMount，componentWillReceiveProps， componentWillUpdate都不能保证只在挂载/拿到props/状态变化的时候刷新一次了，所以这三个方法被标记为不安全。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 两个新生命周期</span></span><br><span class="line"><span class="string">`</span><span class="keyword">static</span> getDerivedStateFromProps<span class="string">`</span></span><br><span class="line"><span class="string">触发时间：在组件构建之后(虚拟dom之后，实际dom挂载之前) ，以及每次获取新的props之后。</span></span><br><span class="line"><span class="string">每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state.</span></span><br><span class="line"><span class="string">配合componentDidUpdate，可以覆盖componentWillReceiveProps的所有用法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>jsx</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) {</span><br><span class="line">    <span class="comment">// 没错，这是一个static</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p><code>getSnapshotBeforeUpdate</code><br>触发时间: update发生的时候，在render之后，在组件dom渲染之前。<br>返回一个值，作为componentDidUpdate的第三个参数。<br>配合componentDidUpdate, 可以覆盖componentWillUpdate的所有用法。</p><h5 id="react错误处理"><a href="#react错误处理" class="headerlink" title="react错误处理"></a>react错误处理</h5><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(props) {</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = { <span class="attr">hasError</span>: <span class="literal">false</span> };</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) {</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState({ <span class="attr">hasError</span>: <span class="literal">true</span> });</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) {</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag"><<span class="name">h1</span>></span>Something went wrong.<span class="tag"></<span class="name">h1</span>></span></span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="setState方法可能是同步的，也可能是异步的"><a href="#setState方法可能是同步的，也可能是异步的" class="headerlink" title="setState方法可能是同步的，也可能是异步的"></a>setState方法可能是同步的，也可能是异步的</h3><p>由 React 控制的事件处理过程 setState 不会同步更新 this.state</p><p>基于性能考虑，React 通常是批量合并更新，调用 setState() 之后，this.state 并没有马上修改，而是创建了一个中间态作为过渡。</p><p>但是有些例外情况，它是同步执行的，比如：eventListeners，Ajax，setTimeout 等。<br>原因是这些 JS 原生的 API 不在 React 的上下文控制范围，无法进行优化。</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  { <span class="attr">count</span>: <span class="number">1</span> }, () => {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)<span class="comment">//输出count=1</span></span><br><span class="line">  }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h3 id="react事件绑定"><a href="#react事件绑定" class="headerlink" title="react事件绑定"></a>react事件绑定</h3><p>由于类的方法默认不会绑定this，因此在调用的时候如果忘记绑定，this的值将会是undefined。<br>通常如果不是直接调用，应该为方法绑定this。绑定方式有以下几种：</p><ol><li><p>在构造函数中使用bind绑定this</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line"><span class="keyword">constructor</span>(props) {</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">  handleClick(){</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <button onClick={<span class="keyword">this</span>.handleClick}></span><br><span class="line">        Click me</span><br><span class="line">      <<span class="regexp">/button></span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在调用的时候使用bind绑定this</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  handleClick(){</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <button onClick={<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)}></span><br><span class="line">        Click me</span><br><span class="line">      <<span class="regexp">/button></span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在调用的时候使用箭头函数绑定this</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  handleClick(){</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <button onClick={()=><span class="keyword">this</span>.handleClick()}></span><br><span class="line">        Click me</span><br><span class="line">      <<span class="regexp">/button></span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>使用属性初始化器语法绑定this(实验性)</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{</span><br><span class="line">  handleClick=<span class="function"><span class="params">()</span>=></span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">  render() {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <button onClick={<span class="keyword">this</span>.handleClick}></span><br><span class="line">        Click me</span><br><span class="line">      <<span class="regexp">/button></span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure></li></ol><p>方式1是官方推荐的绑定方式，也是性能最好的方式。方式2和方式3会有性能影响并且当方法作为属性传递给子组件的时候会引起重渲问题。方式4目前属于实验性语法，但是是最好的绑定方式，需要结合bable转译</p><h3 id="react列表渲染时为什么尽量不要把索引设置为key值"><a href="#react列表渲染时为什么尽量不要把索引设置为key值" class="headerlink" title="react列表渲染时为什么尽量不要把索引设置为key值"></a>react列表渲染时为什么尽量不要把索引设置为key值</h3><p>使用数组下标做key是不被推荐的，如果遇到数组排序的情况下，将降低渲染性能。</p><h3 id="React中的核心概念"><a href="#React中的核心概念" class="headerlink" title="React中的核心概念"></a>React中的核心概念</h3><ol><li><p>虚拟DOM（Virtual DOM）<br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/13</a></p></li><li><p>Diff算法（虚拟DOM的加速器，提升React性能的法宝）<br><a href="https://github.com/zmmbreeze/blog/issues/9" target="_blank" rel="noopener">https://github.com/zmmbreeze/blog/issues/9</a></p></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;react快速入门&lt;/p&gt;
&lt;h3 id=&quot;react组件的生命周期&quot;&gt;&lt;a href=&quot;#react组件的生命周期&quot; class=&quot;headerlink&quot; title=&quot;react组件的生命周期&quot;&gt;&lt;/a&gt;react组件的
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="react" scheme="https://ru23.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>12月份todolist</title>
    <link href="https://ru23.com/note/4bf41c9b.html"/>
    <id>https://ru23.com/note/4bf41c9b.html</id>
    <published>2018-11-28T14:45:45.000Z</published>
    <updated>2020-05-09T08:50:37.478Z</updated>
    
    <content type="html"><![CDATA[<html><head><script src="/crypto-js.js"></script><script src="/mcommon.js"></script></head><body><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div></body></html>]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="hide" scheme="https://ru23.com/tags/hide/"/>
    
      <category term="todo" scheme="https://ru23.com/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>手写一个promise，彻底掌握它的原理</title>
    <link href="https://ru23.com/note/e5037e31.html"/>
    <id>https://ru23.com/note/e5037e31.html</id>
    <published>2018-11-27T14:35:58.000Z</published>
    <updated>2020-04-11T11:59:26.122Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>Promise 是异步编程的一种解决方案,解决传统的回调嵌套问题</p><p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。<br>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><!-- ### 首先，我们先搭建好代码的骨架： --><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">callback</span>) </span>{</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">self.status = <span class="string">'pending'</span>;</span><br><span class="line">self.data = <span class="literal">undefined</span>;</span><br><span class="line">self.onResolvedCallback = [];</span><br><span class="line">self.onRejectedCallback = [];</span><br><span class="line">callback(resolve, reject);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>{</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) {</span><br><span class="line">self.status == <span class="string">'fulfilled'</span>;</span><br><span class="line">self.data = value;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < self.onResolvedCallback.length; i++) {</span><br><span class="line">self.onResolvedCallBack[i].value</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>{</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) {</span><br><span class="line">self.status == <span class="string">'rejected'</span>;</span><br><span class="line">self.data = error;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < self.onRejectedCallback.length; i++) {</span><br><span class="line">self.onResolvedCallback[i].value</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>{</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> promise2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved === <span class="string">'function'</span>) {</span><br><span class="line">onResolved = onResolved</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">onResolved = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected === <span class="string">'function'</span>) {</span><br><span class="line">onResolved = onResolved</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">onResolved = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (self.status == <span class="string">'resolved'</span>) {</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) {</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">}</span><br><span class="line">resolve(x)</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">reject(e)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (self.status == <span class="string">'rejected'</span>) {</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) {</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">}</span><br><span class="line">resolve(x)</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">reject(e)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (self.status == <span class="string">'pending'</span>) {</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) {</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">reject(e)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">self.onRejected.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) {</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">catch</span> (e) {</span><br><span class="line">reject(e)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">})</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.</span><br><span class="line"><span class="keyword">catch</span> = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- ES6实现Promise```jsclass  Promise{    constructor(fn)} --></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Promise 是异步编程的一种解决方案,解决传统的回调嵌套问题&lt;/p&gt;
&lt;p&gt;（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejec
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="promise" scheme="https://ru23.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>How to resolve iOS 11 Safari getUserMedia “Invalid constraint” issue</title>
    <link href="https://ru23.com/note/e4a16398.html"/>
    <id>https://ru23.com/note/e4a16398.html</id>
    <published>2018-11-26T05:01:05.000Z</published>
    <updated>2020-04-11T11:59:26.119Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>I’m attempting to run the following code in Safari in iOS 11. It should prompt the user to give access to their devices camera and then display it in my <video autoplay id="video"></video> element. However, when running in iOS 11, it results in an OverconstrainedError to be thrown:<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">message</span>: <span class="string">"Invalid constraint"</span>, <span class="attr">constraint</span>: <span class="string">"width"</span>}</span><br></pre></td></tr></tbody></table></figure><p></p><p>The code runs fine in Chorme and successfully opens the camera.<br>I’ve attempted multiple valid configurations with no luck.</p><p><strong>Code</strong><br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>);</span><br><span class="line"><span class="keyword">if</span>(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {</span><br><span class="line">     navigator.mediaDevices.getUserMedia({<span class="attr">video</span>: <span class="literal">true</span>})</span><br><span class="line">         .then(<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>{</span><br><span class="line">             video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</span><br><span class="line">             video.play();</span><br><span class="line">         })</span><br><span class="line">         .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{</span><br><span class="line">             <span class="built_in">console</span>.log(err);</span><br><span class="line">         });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>The invalid constraint error in safari is because the browser expects that you pass a correct width, one of:</p><ul><li>320</li><li>640</li><li><p>1280<br>the height is auto calculate in an aspect ratio of 4:3 for 320 or 640, and 16:9 for 1280, then if you pass a width of 320, you video stream is set in:</p></li><li><p>320x240<br>if you set a width of 640, you video stream is set in:</p></li><li><p>640x480<br>And if you set a width of 1280, then you video stream is set in:</p></li><li><p>1280x720<br>In any other case you got a error “InvalidConstrain” for width value.</p></li></ul><p>Also you can use a min, max, exact or ideal constrains for width, please check the MDN documentation</p><p>Here an example in this codepen<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = { <span class="attr">video</span>: { <span class="attr">width</span>: <span class="number">320</span><span class="comment">/*320-640-1280*/</span> } };</span><br><span class="line"><span class="keyword">var</span> start = <span class="function"><span class="params">()</span> =></span> navigator.mediaDevices.getUserMedia(config)</span><br><span class="line">  .then(<span class="function"><span class="params">stream</span> =></span> v.srcObject = stream)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =></span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =></span> v.onloadedmetadata = resolve))</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =></span> log(<span class="string">"Success: "</span> + v.videoWidth + <span class="string">"x"</span> + v.videoHeight))</span><br><span class="line">  .catch(log);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="params">msg</span> =></span> div.innerHTML += <span class="string">"<p>"</span> + msg + <span class="string">"</p>"</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>PD: In chrome you can set a width of height and the video stream is set in these sizes, Firefox do a fitness distance, and Safari expect a exact match.</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;I’m attempting to run the following code in Safari in iOS 11. It should prompt the user to give access to their 
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="踩过的坑" scheme="https://ru23.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <link href="https://ru23.com/note/e277deca.html"/>
    <id>https://ru23.com/note/e277deca.html</id>
    <published>2018-11-23T15:14:05.000Z</published>
    <updated>2020-04-11T11:59:26.121Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>眼过千遍，不如手敲一遍。<br>文章参考：<a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理HTTP请求</li><li>页面渲染</li><li>断开TCP连接</li></ol><p>仔细思考这个问题，发现确实很深，这个过程涉及到的东西很多。这个问题的回答真的能够很好的考验一个web工程师的水平<br>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，<br>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、<br>到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS查询顺序如下，若其中一步成功则直接跳到建立链接部分：</p><ul><li>浏览器自身DNS</li><li>操作系统DNS</li><li>本地hosts文件</li><li>向域名服务器发送请求</li></ul><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP三次握手(three-way handshaking)</p><ul><li>发送方:SYN(synchronize)</li><li>接收方:SYN/ACK(acknowledgement),确认信息传达</li><li>发送方:ACK - 确认接收方在线可收消息，握手结束</li><li>Accept</li></ul><p><img src="https://cdn.ru23.com/img/2018/11/three-way-handshaking.jpg" alt="TCP三次握手"></p><p>（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p><p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p><p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p><p>TCP三次握手的的好处在于：发送方可以确认接收方仍然在线，不会因为白发送而浪费资源。</p><h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><p>为什么要把HTTPS协议放在这里讲呢？</p><ul><li>因为HTTP报文是包裹在TCP报文中发送的，服务端收到TCP报文时候会解包提取出HTTP报文。</li><li>但是这个过程中存在一定的风险。HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的危险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)</li></ul><p><img src="https://cdn.ru23.com/img/2018/11/https.jpg" alt="HTTPS"></p><h4 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h4><p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。<br>HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，<br><strong>是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡</strong>。</p><h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。<br>HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。</p><p><strong>请求行：</strong><br>Method Request-URL HTTP-Version CRLF</p><p><strong>请求报头</strong><br>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</p><h4 id="事件循环-Event-loop"><a href="#事件循环-Event-loop" class="headerlink" title="事件循环(Event loop)"></a>事件循环(Event loop)</h4><ol><li>js是单线程，js解析方法时，将同步任务排队到执行栈中，异步任务排队到事件队列中。</li><li>事件队列分为:<br>宏任务：setTimeout，setInterval，setImmediate，I/O，UI交互事件<br>微任务：process.nextTick，Promise.then</li><li>浏览器环境中执行方法时，先将执行栈中的任务清空，再将微任务推到执行栈中并清空，之后检查是否存在宏任务，若存在则取出一个宏任务，执行完成检查是否有微任务，以此循环…</li></ol><h3 id="4-服务器处理HTTP请求并返回HTTP报文"><a href="#4-服务器处理HTTP请求并返回HTTP报文" class="headerlink" title="4. 服务器处理HTTP请求并返回HTTP报文"></a>4. 服务器处理HTTP请求并返回HTTP报文</h3><p>HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。</p><h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><p>强缓存和协商缓存</p><h3 id="5-浏览器解析渲染页面"><a href="#5-浏览器解析渲染页面" class="headerlink" title="5.浏览器解析渲染页面"></a>5.浏览器解析渲染页面</h3><p>使用HTML创建文件对象类型（DOM）<br>使用CSS创建CSS对象类型（CSSOM）<br>基于DOM和CSSOM执行脚本（Scripts）<br>合并DOM和CSSOM形成渲染树（Render Tree)<br>使用渲染布局（Layout）所有元素渲染（Paint）所有元素</p><h3 id="6-断开TCP连接（4次挥手）"><a href="#6-断开TCP连接（4次挥手）" class="headerlink" title="6.断开TCP连接（4次挥手）"></a>6.断开TCP连接（4次挥手）</h3><p>(<a href="https://cdn.ru23.com/img/2018/12/tcp4次挥手.png" target="_blank" rel="noopener">https://cdn.ru23.com/img/2018/12/tcp4次挥手.png</a>)<br>四次分手<br>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p>为什么要四次分手<br>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;眼过千遍，不如手敲一遍。&lt;br&gt;文章参考：&lt;a href=&quot;https://segmentfault.com/a/1190000006879700&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
  </entry>
  
</feed>
