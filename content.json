{"meta":{"title":"前端迷 (front-end fan)","subtitle":"欢迎投稿，投稿QQ：188105274(微信，邮箱同Q)","description":"前端开发爱好者frank的工作笔记","author":"frank","url":"http://ru23.github.io"},"pages":[{"title":"前端资讯分享","date":"2018-09-04T11:52:49.000Z","updated":"2018-09-20T03:46:25.556Z","comments":true,"path":"share/index.html","permalink":"http://ru23.github.io/share/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-08-27T11:47:23.000Z","updated":"2018-09-20T05:15:47.221Z","comments":true,"path":"categories/index.html","permalink":"http://ru23.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-27T11:26:57.000Z","updated":"2018-09-20T03:30:42.162Z","comments":false,"path":"tags/index.html","permalink":"http://ru23.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redux入门","slug":"redux入门","date":"2018-09-28T11:43:17.000Z","updated":"2018-09-28T11:46:34.287Z","comments":true,"path":"2018/09/28/redux入门/","link":"","permalink":"http://ru23.github.io/2018/09/28/redux入门/","excerpt":"","text":"Redux由Flux演变而来，提供几个简单的API来实现状态管理，所谓状态指的是应用数据，所以，Redux本质上是用来管理数据的。进一步，Redux配合支持数据绑定的视图库使用，就可以将应用状态和视图一一对应，开发者不需要再去关心DOM操作，只关心如何组织数据即可。 由于Redux对于数据的管理拆分很细，一时间会有很多概念，并且Redux有自己丰富的生态，所以容易眼花缭乱。所以强烈建议从头开始一步一步的来，深入体验并理解Redux的思想，不要步子迈太大。✦ 不要一开始过多的纠结代码放在哪个目录✦ 不要一开始就想对action和reducer的代码做精简✦ 不要一开始就考虑数据缓存，离线数据等问题✦ 不要一开始就过度设计数据，考虑数据扁平化的问题反正一句话，饭要一口一口的吃，路要一步一步的走，Redux对于状态管理的东西拆得太细，需要多花一些时间去体会。 Redux是什么？Redux其实很简单，总结起来就三句话：✦ 将整个应用的state储存在唯一的store对象中。✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。✦ 使用reducer来描述action如何改变state。 是的，简而言之就是：Redux让应用的数据被集中管理，并且只能通过触发action的方式来修改，而具体如何修改state，是由reducer来决定的。 那么问题来了：✦ store是什么鬼？✦ action是什么鬼？✦ reducer是什么鬼?✦ 最重要的是，为啥要使用Redux，它能给我们带什么什么好处？或者说，引入这么一个状态理器到底有啥用？ 接下来，我们先捉这三只鬼。 store是什么鬼？前面提过，Redux的目的就是为了对应用数据进行集中管理，也就是state，而state是个普通对象。为了防止state被不小心更新，Redux创建了store对象，专门用来管理state数据。 所以，store就是state的守门员，管理并维护应用数据。 创建store我们通过createStore(reducer, [initialState], enhancer)的方式来创建store。需要注意的是，应用中应该有且只有一个store。12345678910111213141516171819202122232425262728293031import &#123; createStore &#125; from 'redux'// 这是reducer，后文会详细介绍function todos(state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([ action.text ]) default: return state &#125;&#125;// 创建store，并且给state一个初始值['HTML']let store = createStore(todos, [ 'HTML' ])// state.dispatch()，最常用的API// 修改state的唯一方式就是调用store.dispatch()方法// 显然，其中的描述性对象// &#123;// type: 'ADD_TODO',// text: 'CSS'// &#125;// 就是actionstore.dispatch(&#123; type: 'ADD_TODO', text: 'CSS'&#125;)// store.getState()，另一个常用的API// 用来获取state的值console.log(store.getState()); // [ 'HTML', 'CSS' ] store的API们store的API很简单，这儿我按重要顺序列出所有的API，主要记住前两个。✦ dispatch(action)：触发action，再次声明，这是改变state的唯一方式，请默念两次✦ getState()：获取当前的state✦ subscribe(listener)：注册一个监听函数，state发生变化时触发✦ replaceReducer(nextReducer)：替换reducer，用得较少 总结一下，store提供了简单的API，用来管理应用内的数据，它限制了只能通过dispatch(action)来修改state，那么这个action是什么呢？ action是什么鬼？前文提过，action就是一个描述性的普通对象，所以它非常简单！说白了，就是一坨数据，然后这坨数据有名字。 actionaction是一个描述性的普通对象。推荐如下的action结构，type是action的名称，payload是附带的数据。12345678&#123; // 显然，这个名字取得很浅显易懂 type: UPDATE_ARTICLES_LIST, payload: &#123; articles: articles, lastkey: lastkey &#125;&#125; 值得注意的是：实际项目中，我们应该尽量减少action中附带的数据，比如想要更新某篇文章的标题，我们只需要携带文章id和文章新标题即可，而不需要携带整个新文章字段。为了让action更便于维护，我们通常使用action creator而不是action。 action creatoraction create就是一个简单的函数，直接将action作为返回值。12345678910111213141516171819202122232425262728// action creator，返回一个action// 除此之外，没有其他的动作function updateArticlesList(normalizeData, lastkey) &#123; return &#123; type: UPDATE_ARTICLES_LIST, payload: &#123; normalizeData: normalizeData, listLastkey: lastkey &#125; &#125;&#125;// 通过dispatch触发一个action，这是我们修改state的唯一方式dispatch(updateArticlesList( normalizeData, lastkey));// 将dispatch(action)整个动作取个别名，方便调用const updatePosts = (normalizeData, lastkey) =&gt; &#123; return dispatch(updateArticlesList( normalizeData, lastkey ));&#125;updatePosts(...); 那么为什么需要action creatore呢？试想一个场景，我们有好几处dispatch(action)，现在突然想要修改这个action的定义，那么我们需要修改所有地方，代码也比较冗余!而使用action creator，相当于对action做了简单的封装，避免了这些问题。既灵活又便于维护！ 异步action creator我们已经知道，修改state的唯一方式就是触发action，也就是dispatch(action)。但是如果是异步操作，比如一个网络请求，我们需要等到请求返回之后才会返回action，怎么办呢？123456789function updateArticlesList() &#123; return GET(url).then(function(res) &#123; // 难道直接return action？ // 显然是不行的，这儿的返回值并不是updateArticlesList函数的返回值 return action; &#125;).catch(function(err) &#123; console.log(err); &#125;);&#125; 对于异步场景，我们的解决方案是返回函数而不是直接返回action。就像下面这样。为了让dispatch方法可以接受函数作为参数，我们需要使用redux-thunk这个中间件。 1234567import thunk from 'redux-thunk';import &#123; rootReducer &#125; from './reducer.js';const store = createStore( rootReducer, applyMiddleware(thunk)); 然后你就可以dispatch一个函数了12345678910111213function fetchArticlesList() &#123; // 传入dispatch/getstate，当然是为了获取state以及更新state return (dispatch, getState) =&gt; &#123; return GET(url).then(function(res) &#123; dispatch(updateArticlesList( normalizeData, lastkey )); &#125;).catch(function(err) &#123; console.log(err); &#125;); &#125;&#125; 看起来有点迷糊？其实就是把异步请求抽象成action creator，然后放到了redux的代码中。试想一下，如果没有这种方式，你会怎么去处理异步请求？是不是会在组件或者页面中去发异步请求，然后在回调函数中dispatch(action)更新state。本质上也没太大区别。但是好处却是很明显的。 稍微提一下，如果我们可以使用async/await的话，异步action creator可以长得和同步action creator差不多。 action就是一坨数据，它并没有告诉Redux应该怎么去更新state，接下来介绍的reducer就是负责如何更新state这个工作的。 reducer是什么鬼？action本身没有任何意义，就是一个描述性的普通对象。它并没有说明这个数据应该如何更新state。具体如何更新state，是由reducer决定的。reducer的核心就一行代码：(state, action) =&gt; newstate12345678910111213141516171819202122232425262728293031// ------------------------------------// Action Handlers// ------------------------------------const ACTION_HANDLERS = &#123; [UPDATE_ARTICLES_DETAIL]: (articles, action) =&gt; articles, [UPDATE_ARTICLES_LIST]: (articles, action) =&gt; &#123; let payload = action.payload, normalizeData = payload.normalizeData, list = articles.list.concat(normalizeData.result), listLastkey = payload.listLastkey; // 更新articles.list字段和articles.lastkey字段 // 这儿为什么不是state，而是articles呢？留着后文介绍 return updateObject(articles, &#123; list, listLastkey &#125;); &#125;&#125;// ------------------------------------// Reducer// ------------------------------------export function articlesReducer(articles = &#123; list: [], listLastkey: 0&#125;, action) &#123; const handler = ACTION_HANDLERS[action.type] return handler ? handler(articles, action) : articles&#125; reducer函数应该是纯函数，它要保证：只要传入参数相同，那么返回的新state就一定相同。所以永远不要再reducer中做如下操作：✦ 修改传入的state参数✦ 执行有副作用的操作，比如API请求，路由跳转等✦ 调用非纯函数，比如Math.random()或Date.now() 而一旦state变得复杂、层级较多的时候，如何设计reducer就是一个比较复杂的话题了。关于如何设计state？如何分拆reducer？reducer之间如何共享数据？以及如何重构reducer的代码？可以移步另一篇博客：如何最佳实践的设计reducer。 那么，回到最初的话题，引入Redux到我们的应用中，到底有什么好处？我们为什么需要一个专门的状态管理器？ 为啥要使用redux？早些时候，前端并没有这么复杂，几乎不怎么涉及数据管理。随着前端的发展，前端也开始引入MVC之类的架构，对数据、视图、逻辑进行拆分处理。为了保持数据和视图的同步，我们会频繁的操作DOM元素。简直是噩梦。而后KnockoutJS，angularJS等出现了，他们都支持数据绑定，终于让开发可以不在频繁的操作DOM，而是仅仅修改数据，然后自动同步到view。但这还不够彻底，数据仍然是分散的。我们会在controller中写很多操作数据、操作视图的代码，甚至存在冗余数据，想要修改、更新、同步的话，有很大的隐患。Redux的出现，提供了对数据的集中管理，让单向数据流成为了可能。另外，Redux还让前后端彻底分离变成了可能，这一点也有极大的意义。 Redux的数据流Redux通过一些限制告诉你：数据只能保存在我这儿，别想太分散！想要修改数据？告诉我一个带新数据的action，我会通过reducer自动修改，然后返回修改后的数据给你！是的，redux很想“数据库”，数据被集中存储，并且只能通过“预先定义的action操作”来修改。 更厉害的是，配上支持数据绑定的视图库，你会发现一个神奇的事情：之前我们是面向view和controller编程，随着项目的复杂，代码会彼此影响而且数据会分散到各处。而引入redux之后，我们单纯的面向数据编程即可，我们在Redux中统一的管理数据，然后数据变换会反映到view上，而数据上的交互，本质上也是触发了Redux中的action。如下图 Redux数据流所以，设计redux程序的时候，提前想清楚state的结构尤其重要，就好比设计数据库表结构之于后台。 服务器渲染让前后端彻底分离成为了可能上图也可以看出，Redux构建出一份单向数据流。这让服务端渲染变成了可能，而这个特性，让前后端彻底分离变成了可能，还不用担心SEO的问题。想当初，为了解决前后端分离的问题，大家费尽心思，奈何进展甚微，淘宝甚至提出中途岛midway项目，通过中间搭建由前端维护的Nodejs服务器来实现简单的渲染然后返回HTML，但其实这个Nodejs服务器一点都不简单，需要考虑太多东西，比如安全、性能、缓存等。 总结Redux主要用于对数据进行集中管理，并且让整个应用的数据流变得清晰。让应用开发更流畅，数据管理更有效。有了Redux，开发者们慢慢的转化为面向数据编程，而不再是频繁的操作DOM，维护越来越复杂的controller逻辑。简单来说，Redux的东西不多，更重要的是理解它的思路：✦ 将整个应用的state储存在唯一的store对象中。✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。✦ 使用reducer来描述action如何改变state。✦ Redux的单向数据流，可以实现服务端渲染，让前后端彻底分离成为可能，这个有里程碑的意义。✦ Redux非常适合复杂的应用，尤其是多交互、多数据源的应用。 还是那句话，Redux将数据管理拆得很细，所以会有很多新东西去了解，但其实只要了解它的思想，其他的就很顺其自然了。 作者：齐修_qixiuss链接：https://www.jianshu.com/p/d296a8c34936來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"前端","slug":"前端","permalink":"http://ru23.github.io/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://ru23.github.io/tags/react/"}]},{"title":"JS 数组克隆方法总结","slug":"JS 数组克隆方法总结","date":"2018-09-21T11:22:37.000Z","updated":"2018-09-21T08:14:01.372Z","comments":true,"path":"2018/09/21/JS 数组克隆方法总结/","link":"","permalink":"http://ru23.github.io/2018/09/21/JS 数组克隆方法总结/","excerpt":"","text":"ES5 方法总结slice12345let arr = [2,4,434,43]let arr1= arr.slice()arr[0] = 'a'console.log(arr,arr1) // [ 2, 4, 434, 43 ]console.log(arr1 === arr) // false 遍历数组1234567891011Array.prototype.clone = function()&#123; let a=[]; for(let i=0,l=this.length;i&lt;l;i++) &#123; a.push(this[i]); &#125; return a;&#125;let arr = ['aaa','bbb','ccc','wwwww','ddd']let arr2 = arr.clone()console.log(arr2)console.log( arr2 === arr ) concat()12345678Array.prototype.clone=function()&#123; return [].concat(this); //或者 return this.concat();&#125;let arr = ['aaa','asss']let arr1 = arr.clone()arr[0] = 123console.log(arr,arr1) ES6 方法总结Object.assign() 浅复制，也可以实现数组的克隆12345let arr = ['sdsd',123,123,123]let arr1 = []Object.assign(arr1,arr)arr[1] = 'aaaa'console.log(arr,arr1) // [ 'sdsd', 'aaaa', 123, 123 ] [ 'sdsd', 123, 123, 123 ] 扩展运算符12345const a1 = [1, 2];// 写法一const a2 = [...a1];a1[0] = 'aaa'console.log(a1,a2)","categories":[{"name":"前端","slug":"前端","permalink":"http://ru23.github.io/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"http://ru23.github.io/tags/js代码片段/"}]},{"title":"前端周刊-2018年09月第3周","slug":"前端周刊-2018年09月第3周","date":"2018-09-21T08:24:00.000Z","updated":"2018-09-21T08:28:08.082Z","comments":true,"path":"2018/09/21/前端周刊-2018年09月第3周/","link":"","permalink":"http://ru23.github.io/2018/09/21/前端周刊-2018年09月第3周/","excerpt":"","text":"编写「可读」代码的实践链接:http://taobaofed.org/blog/2017/01/05/writing-readable-code/ 摘要伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复打磨自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。 React + Redux 组件化方案链接:http://imweb.io/topic/57c531bc6227a4f55a8872c2 摘要组件化方案:理想中的组件化，第一步应该就是组件的标签化， 例如有一个 Header 组件，无需关注组件内部的实现，我们只需要使用一个 标签就能调用它，通过设置属性的方式，来控制它的显示的内容，和对应的事件。借助 jsx 语法，React 已经实现上述想法。但是由于 React 的数据流向是单向的， 子组件的数据和方法只能由父级组件赋予，一旦组件嵌套层次变深，传递数据将会变得非常复杂。redux 框架解决了这个问题，简单来说，它将 react 由父级传递数据，变为了由一个统一的数据源 store 单向地向各个组件传递数据。所有数据都存放在 store 中，组件内部不维护任何数据。 store 提供了 dispatch 方法来触发改变 store 中数据。 dispatch 传入的值被称作 action。 dispatch(action) 之后，会进入到 store 中称为 reducer 的处理函数，这些 reducer 会依据不同的 action 的类型，进行不同的处理，reducer 返回的值就会作为 store 中新的数据，一个 reducer 对应的是 store 中一个数据字段，每多一个reducer， store 中就多一个数据字段。数据发生改变后， store 就会通知对应的组件重新渲染。 通过 redux 框架提供的 connect 高阶函数， 直接从 store 选取需要的数据和申明需要使用的方法传入组件中，这些申明的方法是组件事件具体的逻辑的实现，例如发送请求，上报逻辑等等，所以通常调用 dispatch(action) 的逻辑也会包含在里面。 ANT DESIGN PRO-开箱即用的中台前端/设计解决方案链接:https://github.com/ant-design/ant-design-pro?utm_source=gold_browser_extension 摘要💎 优雅美观：基于 Ant Design 体系精心设计；📐 常见设计模式：提炼自中后台应用的典型页面和场景；🚀 最新技术栈：使用 React/dva/antd 等前端前沿技术开发；📱 响应式：针对不同屏幕大小设计；🎨 主题：可配置的主题满足多样化的品牌诉求；🌐 国际化：内建业界通用的国际化方案；⚙️ 最佳实践：良好的工程实践助您持续产出高质量代码；🔢 Mock 数据：实用的本地数据调试方案；✅ UI 测试：自动化测试保障前端产品质量； 实现一个完美符合Promise/A+规范的Promise链接:https://github.com/forthealllight/blog/issues/4 摘要Promise允许我们通过链式调用的方式来解决“回调地狱”的问题，特别是在异步过程中，通过Promise可以保证代码的整洁性和可读性。本文主要解读Promise/A+规范，并在此规范的基础上，自己实现一个Promise. Vue知识点整理链接https://segmentfault.com/a/1190000016344599 对于MVVM的理解？ Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View 代表UI 组件，它负责将数据模型转化成UI 展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Vue的生命周期（8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后) Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。beforeCreate（创建前） 在数据观测和初始化事件还未开始created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vue实现数据双向绑定的原理：Object.defineProperty（） Vue组件间的参数传递1.父组件与子组件传值父组件传给子组件：子组件通过props方法接受数据;子组件传给父组件：$emit方法传递参数2.非父子组件间的数据传递，兄弟组件传值eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适 vue路由的钩子函数 首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next： to：route即将进入的目标路由对象， from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 vuex是什么？怎么使用？哪种功能场景使用它只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车","categories":[],"tags":[]},{"title":"前端开发规范-used by frank","slug":"前端开发规范-used-by-frank","date":"2018-09-21T08:20:34.000Z","updated":"2018-09-21T08:27:45.129Z","comments":true,"path":"2018/09/21/前端开发规范-used-by-frank/","link":"","permalink":"http://ru23.github.io/2018/09/21/前端开发规范-used-by-frank/","excerpt":"","text":"js方法注释规范规范的注释很重要代码是写给人看的，顺便给机器运行，多谢注释可以增加代码的可读性 123456789101112131415161718/** ************** * @func 教师端请假功能 ; * @param &#123;String&#125; token 教师端头部的token; * @param &#123;string&#125; a - 参数a; * @param &#123;number&#125; b=1 - 参数b默认值为1; * @param &#123;string&#125; c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx; * @param &#123;object&#125; d - 参数d为一个对象; * @param &#123;string&#125; d.e - 参数d的e属性; * @param &#123;string&#125; d.f - 参数d的f属性; * @param &#123;object[]&#125; g - 参数g为一个对象数组; * @param &#123;string&#125; g.h - 参数g数组中一项的h属性; * @param &#123;string&#125; g.i - 参数g数组中一项的i属性; * @param &#123;string&#125; [j] - 参数j是一个可选参数; * @description 2018年4月19日被frank开发于dev_sprint65分支， * XX年XX月被XX在xx分支修改（原因或者修改的功能）; ****************/ 变量命名规范1.标准变量命名使用驼峰式命名 eg. let thisIsMyName;2.常量全部大写，并使用下划线连接 eg. const MAX_COUNT = 10; 项目规范变量声明尽量提在函数首部，用一个var声明，不允许出现连着的两个var声明(也包括let，const) 1234567891011function doSomethingWithItems(items) &#123; // use one var var value = 10, result = value + 10, i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; result += 10; &#125;&#125; undefind使用规范（永远不要直接使用undefined进行变量判断，使用typeof和字符串’undefined’对变量进行判断。） 123456789// not goodif (person === undefined) &#123; ...&#125;// goodif (typeof person === 'undefined') &#123; ...&#125; 用’===’和’!==’代替’==’, ‘!=’使用对象的属性简写123456789const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 使用拓展运算符 … 复制数组1234567891011// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] render使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051render: (h, params) =&gt; &#123; return h('div', [ h('span', &#123; attrs: &#123; class: \"table_details\" &#125;, on: &#123; click: () =&gt; &#123; this.edit(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_continue\" &#125;, on: &#123; click: () =&gt; &#123; this.show(params.index) &#125; &#125; &#125;,), h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125;, on: &#123; click: () =&gt; &#123; this.remove(params.row.id) &#125; &#125; &#125;,), h('Poptip', &#123; props: &#123; title:\"项目变更\", content:\"项目迁出\", placement:\"bottom-end\" &#125;, on: &#123; 'on-ok': () =&gt; &#123; &#125; &#125; &#125;, [ h('span', &#123; attrs: &#123; class: \"table_more no_border_right\" &#125; &#125;) ]) ])&#125; 文档：有时间整理一下http://taobaofed.org/blog/2017/01/05/writing-readable-code/","categories":[{"name":"前端","slug":"前端","permalink":"http://ru23.github.io/categories/前端/"}],"tags":[{"name":"前端自动化","slug":"前端自动化","permalink":"http://ru23.github.io/tags/前端自动化/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-20T03:30:45.449Z","updated":"2018-09-20T05:15:46.691Z","comments":true,"path":"2018/09/20/hello-world/","link":"","permalink":"http://ru23.github.io/2018/09/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"VsCode读取项目文件的Eslint规则 保存时自动修复格式错误","slug":"VsCode读取项目文件的Eslint规则-保存时自动修复格式错误","date":"2018-09-17T08:29:10.000Z","updated":"2018-09-21T08:29:31.094Z","comments":true,"path":"2018/09/17/VsCode读取项目文件的Eslint规则-保存时自动修复格式错误/","link":"","permalink":"http://ru23.github.io/2018/09/17/VsCode读取项目文件的Eslint规则-保存时自动修复格式错误/","excerpt":"","text":"配置：安装VsCode的EsLint和vetur插件为项目安装EsLint包注意要安装在开发环境上，还有就是如果你使用的是脚手架的话，选了Eslint选项，会自带这些包。 在项目的根目录下添加.eslintrc.js用于校验代码格式，根据项目情况，可自行编写校验规则：123module.exports = &#123; // Eslint规则&#125; 首选项设置：将下面这部分放入首选项设置中： \"eslint.autoFixOnSave\": true, // 启用保存时自动修复,默认只支持.js文件 \"eslint.validate\": [ \"javascript\", // 用eslint的规则检测js文件 { \"language\": \"vue\", // 检测vue文件 \"autoFix\": true // 为vue文件开启保存自动修复的功能 }, { \"language\": \"html\", \"autoFix\": true }, ], 大功告成：点开文件，你可能会看到如下报错，无需一个一个去改，只要保存一下文件，就可以自动修复这些代码格式上的问题了。 注意：如果整个文件都飘红的话，不会一次性修改如果的格式问题，会一下改一部分，你可能需要多按几次保存。","categories":[{"name":"前端","slug":"前端","permalink":"http://ru23.github.io/categories/前端/"}],"tags":[]},{"title":"前端周刊-2018年09月第2周","slug":"前端周刊-2018年09月第2周","date":"2018-09-11T08:18:25.000Z","updated":"2018-09-21T08:30:20.882Z","comments":true,"path":"2018/09/11/前端周刊-2018年09月第2周/","link":"","permalink":"http://ru23.github.io/2018/09/11/前端周刊-2018年09月第2周/","excerpt":"","text":"es6常用基础合集url:https://www.jianshu.com/p/cfb0893c34f1知识点:let,const箭头函数模板字符串解析结构函数默认参数展开运算符对象字面量与classPromise ES6新特性概览url： http://www.cnblogs.com/Wayou/p/es6_new_features.html知识点:箭头操作符类的支持增强的对象字面量字符串模板解构参数默认值，不定参数，拓展参数let与const 关键字for of 值遍历iterator, generator模块Map，Set 和 WeakMap，WeakSetProxiesSymbolsMath，Number，String，Object 的新API 透彻掌握Promise的使用，读这篇就够了url：https://www.jianshu.com/p/fe5f173276bd知识点：实现方法1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。2.resolve。成功的执行方法3.reject。失败的执行方法4.catch。失败的捕获。5.then。链式调用下一步。原理：内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行123456789101112131415161718192021class Promise &#123; result: any; callbacks = []; failbacks = []; constructor(fn) &#123; fn(this.resolve.bind(this), this.reject.bind(this)); &#125; resolve(res) &#123; if (this.callbacks.length &gt; 0) this.callbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; reject(res) &#123; this.callbacks = []; if (this.failbacks.length &gt; 0) this.failbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; catch (fn) &#123; this.failbacks.push(fn); &#125; then(fn) &#123; this.callbacks.push(fn); return this; &#125;&#125; 调用示例：1234567891011var a = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(\"成功\"); &#125;, 1000);&#125;).then(function(result, resolve, reject) &#123; console.log(result) reject(\"失败\")&#125;).catch (function(err) &#123; console.log(err);&#125;); es6写法：1234567891011121314151617//创建promisevar promise = new Promise(function(resolve, reject) &#123; // 进行一些异步或耗时操作 if ( /*如果成功 */ ) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;);//绑定处理程序promise.then(function(result) &#123; //promise成功的话会执行这里 console.log(result); // \"Stuff worked!\"&#125;, function(err) &#123; //promise失败会执行这里 console.log(err); // Error: \"It broke\"&#125;); 4.前端算法相关url:https://github.com/qianbin01/frontend_train#sort知识点冒泡排序 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样 快速排序: 1) 首先，在数组中选择一个中间项作为主元2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成 选择排序: 大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2) 归并排序: 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 堆排序： 堆排序把数组当中二叉树来排序而得名。1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2L；4）节点R的右子节点为2R + 1本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 5.javaScript常用知识点url: https://github.com/qianbin01/frontend_train#javascript知识点map,reduce,filter的用法js数据类型(7种) 1.number;2.string;3.boolean;4.undefined;5.null;6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。7.Object.（包括Object，Array，Function）闭包12345678function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10); 结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011//常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） async/await 语法深浅拷贝数组去重思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 set12let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); JS原型","categories":[{"name":"前端周刊","slug":"前端周刊","permalink":"http://ru23.github.io/categories/前端周刊/"}],"tags":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"http://ru23.github.io/tags/优质文章分享/"}]},{"title":"reactjs中事件传参(关于event)","slug":"reactjs中事件传参-关于event","date":"2018-09-10T07:06:44.000Z","updated":"2018-09-20T03:46:25.540Z","comments":true,"path":"2018/09/10/reactjs中事件传参-关于event/","link":"","permalink":"http://ru23.github.io/2018/09/10/reactjs中事件传参-关于event/","excerpt":"","text":"问题描述我们在事件中通常需要获取控件的值，通常通过event.target.value的方式来取值，在绑定事件时，event参数也不需要传递，在方法中直接使用即可。但是，有些时候需要传入一些其他的参数，比如需要循环绑定一些输入框，在绑定onChange事件时，需要传入索引index和数据源的索引进行对应1234567891011121314151617181920212223242526onHandleChange(index,event)&#123; let val=event.target.value&#125;//关键代码source.map((item,index)=&gt;&#123; return &lt;input type=\"text\" value=&#123;item.name&#125; onChange=&#123;this.onHandleChange.bind(this,index)&#125; /&gt;&#125;);``` #### 代码解释有的同学应该已经看出区别了，onHandleChange在声明时有两个参数，但在调用时却只传递了一个参数，这就是今天要讲的:&gt; **在给方法传递新参数时，方法原有的参数会排在新参数之后**做过reactjs的同学都知道，event这个参数是不需要手动传递的，直接在方法中声明就可以使用，如下代码：```jsxonChangeHandle(event)&#123; let val=event.target.value;&#125;render()&#123; return (&lt;div&gt; &lt;input type=\"text\" onChange=&#123;this.onChangeHandle.bind(this)&#125; /&gt;&lt;/div&gt;)&#125; 摘自 作者：不将就人生链接：https://www.jianshu.com/p/1026d71d04d6來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://ru23.github.io/tags/react/"}]},{"title":"前端开发周刊-(2018年09月第2周)","slug":"ES6-基础-【好文分享】","date":"2018-09-10T03:48:21.000Z","updated":"2018-09-20T03:46:25.524Z","comments":true,"path":"2018/09/10/ES6-基础-【好文分享】/","link":"","permalink":"http://ru23.github.io/2018/09/10/ES6-基础-【好文分享】/","excerpt":"","text":"es6常用基础合集url:https://www.jianshu.com/p/cfb0893c34f1知识点:let,const箭头函数模板字符串解析结构函数默认参数展开运算符对象字面量与classPromise ES6新特性概览url： http://www.cnblogs.com/Wayou/p/es6_new_features.html知识点:箭头操作符类的支持增强的对象字面量字符串模板解构参数默认值，不定参数，拓展参数let与const 关键字for of 值遍历iterator, generator模块Map，Set 和 WeakMap，WeakSetProxiesSymbolsMath，Number，String，Object 的新API 透彻掌握Promise的使用，读这篇就够了url：https://www.jianshu.com/p/fe5f173276bd知识点：实现方法1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。2.resolve。成功的执行方法3.reject。失败的执行方法4.catch。失败的捕获。5.then。链式调用下一步。原理：内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行123456789101112131415161718192021class Promise &#123; result: any; callbacks = []; failbacks = []; constructor(fn) &#123; fn(this.resolve.bind(this), this.reject.bind(this)); &#125; resolve(res) &#123; if (this.callbacks.length &gt; 0) this.callbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; reject(res) &#123; this.callbacks = []; if (this.failbacks.length &gt; 0) this.failbacks.shift()(res, this.resolve.bind(this), this.reject.bind(this)); &#125; catch (fn) &#123; this.failbacks.push(fn); &#125; then(fn) &#123; this.callbacks.push(fn); return this; &#125;&#125; 调用示例：1234567891011var a = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(\"成功\"); &#125;, 1000);&#125;).then(function(result, resolve, reject) &#123; console.log(result) reject(\"失败\")&#125;).catch (function(err) &#123; console.log(err);&#125;); es6写法：1234567891011121314151617//创建promisevar promise = new Promise(function(resolve, reject) &#123; // 进行一些异步或耗时操作 if ( /*如果成功 */ ) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;);//绑定处理程序promise.then(function(result) &#123; //promise成功的话会执行这里 console.log(result); // \"Stuff worked!\"&#125;, function(err) &#123; //promise失败会执行这里 console.log(err); // Error: \"It broke\"&#125;); 4.前端算法相关url:https://github.com/qianbin01/frontend_train#sort知识点冒泡排序 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样 快速排序: 1) 首先，在数组中选择一个中间项作为主元2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成 选择排序: 大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2) 归并排序: 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 堆排序： 堆排序把数组当中二叉树来排序而得名。1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2L；4）节点R的右子节点为2R + 1本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 5.javaScript常用知识点url: https://github.com/qianbin01/frontend_train#javascript知识点map,reduce,filter的用法js数据类型(7种) 1.number;2.string;3.boolean;4.undefined;5.null;6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。7.Object.（包括Object，Array，Function）闭包12345678function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10); 结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011//常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)） async/await 语法深浅拷贝数组去重思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 set12let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]); JS原型","categories":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"http://ru23.github.io/categories/优质文章分享/"}],"tags":[{"name":"优质文章分享","slug":"优质文章分享","permalink":"http://ru23.github.io/tags/优质文章分享/"}]},{"title":"NodeJS连接MySQL时遇到的问题 Error Connection lost The server closed the connection.","slug":"NodeJS连接MySQL时遇到的问题 Error Connection lost The server closed the connection","date":"2018-09-07T07:54:30.000Z","updated":"2018-09-20T03:46:25.524Z","comments":true,"path":"2018/09/07/NodeJS连接MySQL时遇到的问题 Error Connection lost The server closed the connection/","link":"","permalink":"http://ru23.github.io/2018/09/07/NodeJS连接MySQL时遇到的问题 Error Connection lost The server closed the connection/","excerpt":"","text":"今天用NodeJS连接Mysql时遇到点折磨人的问题，记录下解决方法。 NodeJS和Mysql都已经正确安装了，但是NodeJS和Mysql的连接出现问题，查找网上一些解决办法都不能解决问题。报错如下： image 经过查找定位，在mysql官网找到了解决方案： 官网链接 》》MySQL Connector/Node.jsMySql 针对node的连接器对mysql的版本有要求，且需要另外的插件： image 然后下载的最新版的mysql mysql-installer-community-5.7.20.0.msi 执行 :123npm install mysqlnpm install @mysql/xdevapi 运行官方示例，成功。","categories":[{"name":"前端","slug":"前端","permalink":"http://ru23.github.io/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"http://ru23.github.io/tags/node/"}]},{"title":"使用hexo搭建github.io博客","slug":"使用hexo搭建github-io博客","date":"2018-09-07T02:57:11.000Z","updated":"2018-09-20T03:46:25.540Z","comments":true,"path":"2018/09/07/使用hexo搭建github-io博客/","link":"","permalink":"http://ru23.github.io/2018/09/07/使用hexo搭建github-io博客/","excerpt":"","text":"Introduction 回顾一下我三年搭建博客的历程，最初是选择wordpress，Wordpress全部由php编写，数组库采用MySQL。优点：用户只需要将Wordpress的源代码复制到网站根目录下，然后访问网站，之后的安装操作全部在浏览器上完成。即使不是软件行业的人，也可以在几分钟之内完成安装工作。甚至很多虚拟主机供应商都提供了Wordpress的一键式安装工具。用户连上传文件的步骤都省了。缺点：项目太臃肿了，Wordpress耗损CPU严重，不容易操作，运行稍慢。尤其是后期文章数目较多的时候，想要登陆下网站的管理后台，心态简直是抓狂的。loading了好久，有时候还会失败，发一篇文章也很费劲，索性就不维护了。后来在github网站上找到一个vue模板：github地址和demo预览二次开发了一下，的确是实现了很多功能，也挺轻便的，样式也可以自定义，博客可以直接写在github的issue，很方便，用了三个月后才发现百度的搜索引擎居然只收录了首页，搜索引擎的基础爬虫的原理就是抓取你的url，然后获取你的html源代码并解析。 而你的页面通常用了vue等js的数据绑定机制来展示页面数据，爬虫获取到的html是你的模型页面而不是最终数据的渲染页面，所以说用js来渲染数据对seo并不友好。而且github api在国内访问速度也没有想象中那么快，可能是github的CDN被墙屏了。 使用github.io可以搭建一个自己的博客,把静态文件项目托管到github上,可以写博客,可以使用markdown语法,也可以展示作品.灵活性高.但是有较大的难度,但是这对于一个熟悉git操作的前端开发工程师来说，都不算什么的。重点是hexo和github.io的域名和服务器都是免费的。当然也可以选择用自己的服务器和域名。 Quick Start安装 node,git，注册好github账号 (网站有很多教程，安装方法这里就不详细展开了，注意:github账号用户名一定不能有大写.) 安装hexo: 1npm install -g hexo 创建hexo文件夹:cmd窗口切换到对应的目录下,然后执行: hexo init也可以在 E:\\hexo 下右键,选择git bash,在窗口中执行hexo init自动安装了需要的文件. 安装依赖:继续执行: npm install 完成本地安装:继续在 E:\\hexo 下执行: hexo generate 继续执行: hexo server 然后在打开浏览器 localhost:4000 ,就可以看到,本地已经安装好了. 在github上创建博客仓库: image 跳转的后如下填写:(其中Repository name的格式是 ‘用户名’.github.io ),然后点创建仓库，Repository name必须和用户名（Owner）一致，不能有大写字母 image image 创建SSH keys监测是否有已经存在的SSH keys:打开 git bash 终端(可以在 E:\\hexo 下右键打开,也可以直接在开始菜单里打开) 执行: $ ls -al ~/.ssh image 如果没有的话,就生成一个SSH keys: 写自己的邮箱$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 然后会出现:12Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): 就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了.输入一个密码,这个密码后面会用到,所以要记住咯 保存SSH keys:创建成功后,他会提示你SSH keys保存在哪里:1234567Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 找到SSH keys:根据上一步里告诉你的路径,找到保存SSH keys的地方,我的是在 C:\\Users\\2000104591.ssh 其中 id_rsa.pub 就是SSH keys 如果为了防止以后找不到,可以把他们自己另存到其它地方 为github仓库添加SSH keys然后把创建的id_rsa.pub里的内容复制到Key里去,Title部分随便填. 点击’Add key’ 添加的过程中,还要再输入一次github的密码 image 配置_config.yml文件并发布:在 E:\\hexo(文件根目录下) 下,有一个文件叫 _config.yml ,打开它,拉到最底下,做如下修改: 然后再执行: hexo generate hexo deploy 然后访问: https://ye63.github.io/ (用户名改成自己的),就可以看到了. 快捷命令hexo 新建一篇文章给它添加分类和标签:1hexo new &quot;移动端限制input框只能输入数字&quot; 通过mou编辑器打开：添加tags和categories123456789---title: title #文章標題date: 2016-06-01 23:47:44 #文章生成時間categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略tags: #文章标签 可以省略 - 标签1 - 标签2description: #你對本頁的描述 可以省略--- 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 创建新页面1hexo new page &quot;about&quot;","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"http://ru23.github.io/categories/Hexo教程/"}],"tags":[]},{"title":"javascript截取文件名的后缀","slug":"javascript截取文件名的后缀","date":"2018-09-06T11:22:37.000Z","updated":"2018-09-20T03:46:25.524Z","comments":true,"path":"2018/09/06/javascript截取文件名的后缀/","link":"","permalink":"http://ru23.github.io/2018/09/06/javascript截取文件名的后缀/","excerpt":"","text":"12345678const fileName=\"text.png\";//带.的格式let fileFormat=fileName.substring(fileName.lastIndexOf('.'))// 不带.的格式let fileFormat2=fileName.substring(fileName.lastIndexOf('.')+1);console.log(fileFormat,fileFormat2) image","categories":[{"name":"前端","slug":"前端","permalink":"http://ru23.github.io/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"http://ru23.github.io/tags/js代码片段/"}]},{"title":"移动端限制input框只能输入数字","slug":"移动端限制input框只能输入数字","date":"2018-09-03T08:56:58.000Z","updated":"2018-09-20T05:15:47.021Z","comments":true,"path":"2018/09/03/移动端限制input框只能输入数字/","link":"","permalink":"http://ru23.github.io/2018/09/03/移动端限制input框只能输入数字/","excerpt":"","text":"html5 中，input 的 type 属性规定 input 元素的类型。1&lt;input type=\"value\"&gt; 有很多选项，详细可以参考HTML 5 type 属性 但是在移动端，还要区分是安卓用户，还是ios用户，所以这样写： 1&lt;input class=\"num_input\" type='number' pattern=\"[0-9]*\"/&gt; 在安卓端设置input类型为number，可限制键盘只输入数字，在ios端，要加入pattern验证输入字段的模式，才能限制数字输入。 另： autofocus=&quot;autofocus&quot;可以自动对焦。","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://ru23.github.io/tags/html5/"}]},{"title":"React Js 微信分享封装","slug":"React-Js-微信分享封装","date":"2018-09-03T07:17:54.000Z","updated":"2018-09-21T08:08:07.449Z","comments":true,"path":"2018/09/03/React-Js-微信分享封装/","link":"","permalink":"http://ru23.github.io/2018/09/03/React-Js-微信分享封装/","excerpt":"","text":"本篇文章给大家分享的内容是代码详解React Js 微信分享封装，有着一定的参考价值，有需要的朋友可以参考一下 话不多说，直接上源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import Fetch from './FetchIt';import API_URL from './url';import Share from './Share';let wxUtils = &#123;&#125;;////////////////////////////////////////////////////////////////////////////////////////// 分享/////////////////////////////////////////////////////////////////////////////////////////** getshareinfo?type= type :goods 课程详情 team 团详情 id 课程id tid 团ID * @param config * @param shareInfo &#123;imgUrl,title,description,link&#125; */function share2wx(config, shareInfo) &#123; const share = new Share(&#123; appid: config.appid, // 必填，公众号的唯一标识 timestamp: config.timestamp, // 必填，生成签名的时间戳 nonceStr: config.nonceStr, // 必填，生成签名的随机串 signature: config.signature, // 必填，签名 &#125;); share.init(Object.assign(&#123;&#125;, shareInfo));&#125;function getConfig(shareInfo) &#123; let href = window.location.href.split('#')[0]; const url = encodeURIComponent(href /*window.location.href*/); Fetch.get(`$&#123;API_URL.mobile.signature_path&#125;?url=$&#123;url&#125;`).then(data =&gt; &#123; share2wx(data, shareInfo); &#125;);&#125;/** * @param shareInfo */wxUtils.share = function (shareInfo) &#123; getConfig(shareInfo);&#125;;////////////////////////////////////////////////////////////////////////////////////////// 分享结束/////////////////////////////////////////////////////////////////////////////////////////** * 是否开启右上角Menu * @param open */wxUtils.optionMenu = function (open = true) &#123; if (open) &#123; openOptionMenu(); &#125; else &#123; disabledOptionMenu(); &#125;&#125;;/** * 是否禁用右上角 */function disabledOptionMenu() &#123; if (typeof WeixinJSBridge === \"undefined\") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady(true), false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady(true)); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady(true)); &#125; &#125; else &#123; onBridgeReady(true); &#125;&#125;/** * 开启menu */function openOptionMenu() &#123; if (typeof WeixinJSBridge === \"undefined\") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady(false), false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady(false)); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady(false)); &#125; &#125; else &#123; onBridgeReady(false); &#125;&#125;function onBridgeReady(disable = true) &#123; if (typeof WeixinJSBridge !== \"undefined\") WeixinJSBridge.call(disable ? 'hideOptionMenu' : 'showOptionMenu');&#125;/** * 隐藏微信网页底部的导航栏 * @param disable */wxUtils.disabledToolbar = function (disable = true) &#123; document.addEventListener('WeixinJSBridgeReady', function onBridgeReady() &#123; // 通过下面这个API隐藏底部导航栏 WeixinJSBridge.call(disable ? 'hideToolbar' : 'showToolbar'); &#125;);&#125;;export default wxUtils; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 分享function Share(config) &#123; wx.config(&#123; debug: false, // 开启调试模式 appId: config.appid, // 必填，公众号的唯一标识 timestamp: config.timestamp, // 必填，生成签名的时间戳 nonceStr: config.nonceStr, // 必填，生成签名的随机串 signature: config.signature, // 必填，签名，见附录1 jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage', 'onMenuShareWeibo'], // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 &#125;);&#125;Share.prototype = &#123; constructor: Share, init(config) &#123; this.imgUrl = config.imgUrl; this.link = config.link; // this.musicPath = config.musicPath; this.description = config.description; this.title = config.title; wx.ready(() =&gt; &#123; // if (this.musicPath) &#123; // document.getElementById('musicIcon').play(); // &#125; this.toFriend(); this.toTimeline(); &#125;); wx.error(res =&gt; &#123; console.log(`$&#123;res&#125;`); &#125;); &#125;, toFriend() &#123; wx.onMenuShareAppMessage(&#123; imgUrl: this.imgUrl, link: this.link, title: this.title, desc: this.description, success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, &#125;); &#125;, toTimeline() &#123; wx.onMenuShareTimeline(&#123; imgUrl: this.imgUrl, link: this.link, title: this.title, desc: this.description, success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, &#125;); &#125;,&#125;;export default Share; 12345678//开启分享BaseComponent.wxUtils.optionMenu(true);BaseComponent.wxUtils.share(&#123; imgUrl: activityData.sharePicUrl, title: activityData.shareTitle, description: activityData.shareContent, link: url,&#125;);","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://ru23.github.io/tags/react/"}]},{"title":"错误码：events.js:183 throw er; // Unhandled 'error' event—解决办法","slug":"错误码：events-js-183-throw-er-Unhandled-error-event—解决办法","date":"2018-08-30T14:48:30.000Z","updated":"2018-09-20T03:46:25.540Z","comments":true,"path":"2018/08/30/错误码：events-js-183-throw-er-Unhandled-error-event—解决办法/","link":"","permalink":"http://ru23.github.io/2018/08/30/错误码：events-js-183-throw-er-Unhandled-error-event—解决办法/","excerpt":"","text":"控制台报错：12345678910111213141516171819202122232425Hash: 78f0873c3eb47a64bfaeVersion: webpack 1.14.0Time: 16mswebpack: Compiled successfully.events.js:183 throw er; // Unhandled &apos;error&apos; event ^Error: listen EADDRINUSE 127.0.0.1:8080 at Object._errnoException (util.js:1022:11) at _exceptionWithHostPort (util.js:1044:20) at Server.setupListenHandle [as _listen2] (net.js:1367:14) at listenInCluster (net.js:1408:12) at GetAddrInfoReqWrap.doListen [as callback] (net.js:1517:7) at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:97:10)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! webpack-demos@1.0.0 dev: `webpack-dev-server --devtool eval --progress --colors`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the webpack-demos@1.0.0 dev script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\qian\\AppData\\Roaming\\npm-cache\\_logs\\2018-08-30T14_46_37_546Z-debug.log 错误原因：端口号被占用 解决方案1.Win+R,cmd查询使用的端口号是否被占用：netstat -aon|findstr “8080”按回车显示占用8080端口对应的程序的PID号；2.根据PID号找到对应的程序：继续输入命令：tasklist|findstr “15008”按回车后显示出占用该端口的程序；3.按快捷键“Ctrl+Shift+Esc”调出Windows任务管理器，根据PID/程序对应名称结束该程序进程即可。","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://ru23.github.io/tags/npm/"}]},{"title":"合并数组的相同的key值，并且计算相同key值的个数","slug":"合并数组的相同的key值，并且计算相同key值的个数","date":"2018-08-30T07:33:19.000Z","updated":"2018-09-20T03:46:25.540Z","comments":true,"path":"2018/08/30/合并数组的相同的key值，并且计算相同key值的个数/","link":"","permalink":"http://ru23.github.io/2018/08/30/合并数组的相同的key值，并且计算相同key值的个数/","excerpt":"","text":"需求：合并数组的相同的key值，并且计算相同key值的个数 场景：根据list数组的每一项的key值coupon_sn合并数组，并且计数 js代码json数组：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364let list = [&#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"1\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;, &#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"2\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;, &#123; \"id\": 5899, \"is_use\": 0, \"use_time\": null, \"expired_time\": \"2018-12-31 00:00:00\", \"coupon\": &#123; \"coupon_sn\": \"2\", \"name\": \"满减\", \"type\": 2, \"count\": 99993, \"receive_count\": 6, \"is_fare\": 0, \"available_money\": \"2000.00\", \"reduce_money\": \"100.00\", \"discount\": \"1.000\", \"receive_start_time\": \"2018-07-27 00:00:00\", \"receive_end_time\": \"2020-12-31 00:00:00\", \"info\": \"\", \"created_at\": \"2018-07-27 21:22:51\", \"restriction_description\": \"仅限非板材使用\" &#125;&#125;] js代码12345678910111213141516171819202122 let hash = &#123; coupon: &#123;&#125;,&#125;, i = 0, res = [];list.forEach(function(item ) &#123; let coupon_sn = item.coupon.coupon_sn; if (hash[coupon_sn]) &#123; if (!res[hash[coupon_sn] - 1].count) &#123; res[hash[coupon_sn] - 1].count = 1 &#125; res[hash[coupon_sn] - 1].count += 1 &#125; else &#123; hash[coupon_sn] = ++i &amp;&amp; res.push(&#123; \"count\": 1, \"id\": item.id, \"is_use\": item.is_use, \"use_time\": item.use_time, \"expired_time\": item.expired_time, \"coupon\": item.coupon &#125;) &#125;&#125;);console.log(res);","categories":[{"name":"前端","slug":"前端","permalink":"http://ru23.github.io/categories/前端/"}],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"http://ru23.github.io/tags/js代码片段/"}]},{"title":"怎么把数组倒置，又不影响原来数组，reverse不行","slug":"怎么把数组倒置，又不影响原来数组，reverse不行","date":"2018-08-18T15:33:00.000Z","updated":"2018-09-20T03:46:25.540Z","comments":true,"path":"2018/08/18/怎么把数组倒置，又不影响原来数组，reverse不行/","link":"","permalink":"http://ru23.github.io/2018/08/18/怎么把数组倒置，又不影响原来数组，reverse不行/","excerpt":"","text":"情景：怎么把数组倒置，又不影响原来数组，reverse不行，会把原数组也给反过来。1234var arr = [\"1\",\"2\",\"3\",\"4\"];var bbb = arr.reverse()console.log(arr); //[\"4\", \"3\", \"2\", \"1\"]console.log(bbb); //[\"4\", \"3\", \"2\", \"1\"] 直接改的话bbb和arr指向是同一个数组对象。reverse改变的是数组对象，a指向它，所以改变了，要改变就要让其指向不同 解决方案12345678var arr = [\"1\",\"2\",\"3\",\"4\"];//列举4个解决方案var bbb = [...arr].reverse() //方法1var bbb = [].concat(arr).reverse() //方法2var bbb = Object.assign([],arr).reverse()//方法3var bbb = arr.slice().reverse()//方法4console.log(arr); console.log(bbb); ES6语法很方便~","categories":[],"tags":[{"name":"js代码片段","slug":"js代码片段","permalink":"http://ru23.github.io/tags/js代码片段/"}]}]}