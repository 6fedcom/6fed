<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端迷 (front-end fan)</title>
  
  <subtitle>欢迎投稿、合作，交流QQ：188105274(微信，邮箱同Q)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ru23.com/"/>
  <updated>2018-10-22T09:42:51.476Z</updated>
  <id>https://ru23.com/</id>
  
  <author>
    <name>frank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>输入框input类型为number时，去掉上下箭头方式</title>
    <link href="https://ru23.com//note/20181022/cjnk45si40034s8a1mtl0pwo6/"/>
    <id>https://ru23.com//note/20181022/cjnk45si40034s8a1mtl0pwo6/</id>
    <published>2018-10-22T08:57:28.000Z</published>
    <updated>2018-10-22T09:42:51.476Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-outer-spin-button</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-inner-spin-button</span> &#123;</span></span><br><span class="line"><span class="undefined">        -webkit-appearance: none;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">input</span><span class="selector-attr">[type="number"]</span>&#123;</span></span><br><span class="line"><span class="undefined">        -moz-appearance: textfield;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="html5" scheme="https://ru23.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>开发者工具调试网页授权 确认按钮点击无任何反应</title>
    <link href="https://ru23.com//note/20181002/cjnk45si0002zs8a1d83vv16o/"/>
    <id>https://ru23.com//note/20181002/cjnk45si0002zs8a1d83vv16o/</id>
    <published>2018-10-02T11:07:15.000Z</published>
    <updated>2018-10-22T09:43:04.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/46324116-7347ae80-c624-11e8-9150-286a68773715.png" alt="qq 20181002084610" title="">                </div>                <div class="image-caption">qq 20181002084610</div>            </figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>开发者工具调试网页授权 确认按钮点击无任何反应！！！<br>V1以上就会有这个问题 很迷 我看其他社区的回答 说的是 点击“获得你的公开信息”那行字大概就可以，应该是显示屏分辨率的问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;场景：&quot;&gt;&lt;a href=&quot;#场景：&quot; class=&quot;headerlink&quot; title=&quot;场景：&quot;&gt;&lt;/a&gt;场景：&lt;/h3&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbo
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="微信开发" scheme="https://ru23.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>前端开发最全面试题</title>
    <link href="https://ru23.com//note/20180930/cjnk45sht002ss8a14qmye67f/"/>
    <id>https://ru23.com//note/20180930/cjnk45sht002ss8a14qmye67f/</id>
    <published>2018-09-30T10:13:33.000Z</published>
    <updated>2018-10-22T09:40:51.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端问题记录"><a href="#前端问题记录" class="headerlink" title="前端问题记录"></a>前端问题记录</h3><ol><li><a href="#html">HTML相关</a></li><li><a href="#css">CSS相关</a></li><li><a href="#javascript">JAVASCRIPT相关</a></li><li><a href="#dom">DOM相关</a></li><li><a href="#http">HTTP相关</a></li><li><a href="#vue">VUE相关</a></li><li><a href="#sort">算法相关</a></li><li><a href="#web">网络安全相关</a></li><li><a href="#webpack">webpack相关</a></li><li><a href="#other">其他</a><h4 id="Html相关"><a href="#Html相关" class="headerlink" title="Html相关"></a>Html相关</h4><h5 id="1-html语义化"><a href="#1-html语义化" class="headerlink" title="1 html语义化"></a><div id="html">1 html语义化</div></h5>意义：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。<br>注意：<br>1.尽可能少的使用无语义的标签div和span；<br>2.在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；<br>3.不要使用纯样式标签，如：b、font、u等，改用css设置。<br>4.需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；<br>5.使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；<br>6.表单域要用fieldset标签包起来，并用legend标签说明表单的用途；<br>7.每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li></ol><p>新标签：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/h5%E6%96%B0%E5%85%83%E7%B4%A0.png" alt="h5新元素" title="">                </div>                <div class="image-caption">h5新元素</div>            </figure></p><h5 id="2-meta-viewport相关"><a href="#2-meta-viewport相关" class="headerlink" title="2 meta viewport相关"></a>2 meta viewport相关</h5><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE html&gt;</span>  H5标准声明，使用 HTML5 doctype，不区分大小写</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">”en”</span>&gt;</span> 标准的 lang 属性写法</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">’utf-8′</span>&gt;</span>    声明文档使用的字符编码</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”X-UA-Compatible”</span> <span class="attr">content</span>=<span class="string">”IE</span>=<span class="string">edge,chrome</span>=<span class="string">1″/</span>&gt;</span>   优先使用 IE 最新版本和 Chrome</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”description”</span> <span class="attr">content</span>=<span class="string">”不超过150个字符”/</span>&gt;</span>       页面描述</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”keywords”</span> <span class="attr">content</span>=<span class="string">””/</span>&gt;</span>      页面关键词</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”author”</span> <span class="attr">content</span>=<span class="string">”name,</span> <span class="attr">email</span>@<span class="attr">gmail.com</span>”/&gt;</span>    网页作者</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”robots”</span> <span class="attr">content</span>=<span class="string">”index,follow”/</span>&gt;</span>      搜索引擎抓取</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”viewport”</span> <span class="attr">content</span>=<span class="string">”initial-scale</span>=<span class="string">1,</span> <span class="attr">maximum-scale</span>=<span class="string">3,</span> <span class="attr">minimum-scale</span>=<span class="string">1,</span> <span class="attr">user-scalable</span>=<span class="string">no”</span>&gt;</span> 为移动设备添加 viewport</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”apple-mobile-web-app-title”</span> <span class="attr">content</span>=<span class="string">”标题”</span>&gt;</span> iOS 设备 begin</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”apple-mobile-web-app-capable”</span> <span class="attr">content</span>=<span class="string">”yes”/</span>&gt;</span>  添加到主屏后的标题（iOS 6 新增）</span></span><br><span class="line"><span class="xml">是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”apple-itunes-app”</span> <span class="attr">content</span>=<span class="string">”app-id</span>=<span class="string">myAppStoreID,</span> <span class="attr">affiliate-data</span>=<span class="string">myAffiliateData,</span> <span class="attr">app-argument</span>=<span class="string">myURL”</span>&gt;</span></span></span><br><span class="line"><span class="xml">添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”apple-mobile-web-app-status-bar-style”</span> <span class="attr">content</span>=<span class="string">”black”/</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”format-detection”</span> <span class="attr">content</span>=<span class="string">”telphone</span>=<span class="string">no,</span> <span class="attr">email</span>=<span class="string">no”/</span>&gt;</span>  设置苹果工具栏颜色</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”renderer”</span> <span class="attr">content</span>=<span class="string">”webkit”</span>&gt;</span>  启用360浏览器的极速模式(webkit)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”X-UA-Compatible”</span> <span class="attr">content</span>=<span class="string">”IE</span>=<span class="string">edge”</span>&gt;</span>     避免IE使用兼容模式</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”Cache-Control”</span> <span class="attr">content</span>=<span class="string">”no-siteapp”</span> /&gt;</span>    不让百度转码</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”HandheldFriendly”</span> <span class="attr">content</span>=<span class="string">”true”</span>&gt;</span>     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”MobileOptimized”</span> <span class="attr">content</span>=<span class="string">”320″</span>&gt;</span>   微软的老式浏览器</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”screen-orientation”</span> <span class="attr">content</span>=<span class="string">”portrait”</span>&gt;</span>   uc强制竖屏</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”x5-orientation”</span> <span class="attr">content</span>=<span class="string">”portrait”</span>&gt;</span>    QQ强制竖屏</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”full-screen”</span> <span class="attr">content</span>=<span class="string">”yes”</span>&gt;</span>              UC强制全屏</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”x5-fullscreen”</span> <span class="attr">content</span>=<span class="string">”true”</span>&gt;</span>       QQ强制全屏</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”browsermode”</span> <span class="attr">content</span>=<span class="string">”application”</span>&gt;</span>   UC应用模式</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”x5-page-mode”</span> <span class="attr">content</span>=<span class="string">”app”</span>&gt;</span>    QQ应用模式</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”msapplication-tap-highlight”</span> <span class="attr">content</span>=<span class="string">”no”</span>&gt;</span>    windows phone 点击无高光</span></span><br><span class="line"><span class="xml">设置页面不缓存</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”pragma”</span> <span class="attr">content</span>=<span class="string">”no-cache”</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”cache-control”</span> <span class="attr">content</span>=<span class="string">”no-cache”</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”expires”</span> <span class="attr">content</span>=<span class="string">”0″</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="3-canvas-相关"><a href="#3-canvas-相关" class="headerlink" title="3 canvas 相关"></a>3 canvas 相关</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用前需要获得上下文环境，暂不支持<span class="number">3</span>d</span><br><span class="line">常用api:</span><br><span class="line"><span class="number">1.</span>fillRect(x,y,width,height)实心矩形</span><br><span class="line"><span class="number">2.</span>strokeRect(x,y,width,height)空心矩形</span><br><span class="line"><span class="number">3.</span>fillText(<span class="string">"Hello world"</span>,<span class="number">200</span>,<span class="number">200</span>);实心文字</span><br><span class="line">    <span class="number">4.</span>strokeText(<span class="string">"Hello world"</span>,<span class="number">200</span>,<span class="number">300</span>)空心文字</span><br><span class="line">各种东西！！！</span><br></pre></td></tr></table></figure><h5 id="新标签兼容低版本"><a href="#新标签兼容低版本" class="headerlink" title="新标签兼容低版本"></a>新标签兼容低版本</h5><ol><li>ie9之前版本通过createElement创建html5新标签</li><li>引入html5shiv.js<h4 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a><div id="css">CSS相关</div></h4><h5 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h5>1.ie盒模型算上border、padding及自身（不算margin），标准的只算上自身窗体的大小<br>css设置方法如下<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标准模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span><span class="selector-pseudo">:content-box</span>;</span><br><span class="line"> <span class="comment">/*IE模型*/</span></span><br><span class="line"><span class="selector-tag">box-sizing</span><span class="selector-pseudo">:border-box</span>;</span><br></pre></td></tr></table></figure></li></ol><p>2.margin、border、padding、content由外到里<br>3.几种获得宽高的方式</p><ul><li>dom.style.width/height<br>　　这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。</li><li>dom.currentStyle.width/height<br>　　这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持。</li><li>window.getComputedStyle(dom).width/height<br>　　这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。</li><li>dom.getBoundingClientRect().width/height<br>　　这种方式是根据元素在视窗中的绝对位置来获取宽高的</li><li>dom.offsetWidth/offsetHeight<br>　　这个就没什么好说的了，最常用的，也是兼容最好的。</li></ul><p>4.拓展 各种获得宽高的方式</p><ul><li>获取屏幕的高度和宽度（屏幕分辨率）：<br>window.screen.height/width</li><li>获取屏幕工作区域的高度和宽度（去掉状态栏）：<br>window.screen.availHeight/availWidth</li><li>网页全文的高度和宽度：<br>document.body.scrollHeight/Width</li><li>滚动条卷上去的高度和向右卷的宽度：<br>document.body.scrollTop/scrollLeft</li><li>网页可见区域的高度和宽度（不加边线）：<br>document.body.clientHeight/clientWidth</li><li>网页可见区域的高度和宽度（加边线）：<br>document.body.offsetHeight/offsetWidth</li></ul><p>5.边距重叠解决方案(BFC)<br>BFC原理</p><ul><li>内部的box会在垂直方向，一个接一个的放置<br>每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反）</li><li>box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠</li><li>bfc的区域不会与浮动区域的box重叠</li><li>bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的</li><li>计算bfc高度的时候，浮动元素也会参与计算<br>创建bfc</li><li>float属性不为none（脱离文档流）</li><li>position为absolute或fixed</li><li>display为inline-block,table-cell,table-caption,flex,inine-flex</li><li>overflow不为visible</li><li>根元素<br>demo<figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>上<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">这块margin-bottom:30px;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 给下面这个块添加一个父元素，在父元素上创建bfc --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow:hidden"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>下<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">这块margin-top:50px;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="css-reset-和-normalize-css-有什么区别"><a href="#css-reset-和-normalize-css-有什么区别" class="headerlink" title="css reset 和 normalize.css 有什么区别"></a>css reset 和 normalize.css 有什么区别</h5><ul><li>两者都是通过重置样式，保持浏览器样式的一致性</li><li>前者几乎为所有标签添加了样式，后者保持了许多浏览器样式，保持尽可能的一致</li><li>后者修复了常见的桌面端和移动端浏览器的bug：包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。</li><li>前者中含有大段的继承链</li><li>后者模块化，文档较前者来说丰富<h5 id="居中方法"><a href="#居中方法" class="headerlink" title="居中方法"></a>居中方法</h5>水平方向上<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">针对<span class="selector-tag">inline</span>, 内联块<span class="selector-tag">inline-block</span>, 内联表<span class="selector-tag">inline-table</span>, <span class="selector-tag">inline-flex</span>元素及<span class="selector-tag">img</span>,<span class="selector-tag">span</span>,<span class="selector-tag">button</span>等元素</span><br><span class="line"><span class="selector-class">.text_div</span>&#123;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不定宽块状元素居中</span><br><span class="line"><span class="selector-class">.text_div</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过给父元素设置 <span class="selector-tag">float</span>，然后给父元素设置 <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span> 和 <span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%，子元素设置 <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span> 和 <span class="selector-tag">left</span>: <span class="selector-tag">-50</span>% 来实现水平居中。</span><br><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap-center</span>&#123;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垂直居中<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单行内联(<span class="selector-tag">inline-</span>)元素垂直居中 </span><br><span class="line">通过设置内联元素的高度(<span class="selector-tag">height</span>)和行高(<span class="selector-tag">line-height</span>)相等，从而使元素垂直居中。</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text_div</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">利用表布局</span><br><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>布局</span><br><span class="line"><span class="selector-class">.center-flex</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    flex-direction: column;//上下排列</span><br><span class="line">    <span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">绝对布局方式</span><br><span class="line">已知高度</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>; </span><br><span class="line">&#125;</span><br><span class="line">未知高度</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垂直水平居中根据上方结合<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>方式</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">grid</span>方式</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">140px</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123; </span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="css优先级确定"><a href="#css优先级确定" class="headerlink" title="css优先级确定"></a>css优先级确定</h5><ul><li>每个选择器都有权值，权值越大越优先</li><li>继承的样式优先级低于自身指定样式</li><li>！important优先级最高 js也无法修改</li><li>权值相同时，靠近元素的样式优先级高  顺序为内联样式表（标签内部）&gt; 内部样式表（当前文件中）&gt; 外部样式表（外部文件中）<h5 id="bfc内容见盒模型"><a href="#bfc内容见盒模型" class="headerlink" title="bfc内容见盒模型"></a>bfc内容见盒模型</h5><h5 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动"></a>如何清除浮动</h5>不清楚浮动会发生高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷）</li><li>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式：   {clear:both;height:0;overflow:hidden;}</li><li>给浮动元素父级设置高度</li><li>父级同时浮动（需要给父级同级元素添加浮动）</li><li>父级设置成inline-block，其margin: 0 auto居中方式失效</li><li>利用br标签的clear属性</li><li>给父级添加overflow:hidden 清除浮动方法</li><li>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float_div</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">"."</span>;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br><span class="line"><span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float_div</span>&#123;</span><br><span class="line"><span class="attribute">zoom</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h5><p>思路：</p><ol><li>左侧浮动或者绝对定位，然后右侧margin撑开</li><li>使用div包含，然后靠负margin形成bfc</li><li>使用flex<h5 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#item</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line"><span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="link-import导入css"><a href="#link-import导入css" class="headerlink" title="link @import导入css"></a>link @import导入css</h5><ol><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>ink支持使用Javascript控制DOM去改变样式；而@import不支持。<h5 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/animation.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="长宽比方案"><a href="#长宽比方案" class="headerlink" title="长宽比方案"></a>长宽比方案</h5></li><li>使用padding方式结合calc实现</li><li>长宽一项设置百分比另一项aspect-ratio实现（需借助插件实现）<h5 id="display相关"><a href="#display相关" class="headerlink" title="display相关"></a>display相关</h5></li><li>block:div等容器类型</li><li>inline:img span等行内类型</li><li>table系列：将样式变成table类型</li><li>flex:重点把握，非常强大</li><li>grid:同上</li><li>inline-block:可设置宽度，两者间有一点间隙</li><li>inherit:继承父级<h4 id="JavaScript相关"><a href="#JavaScript相关" class="headerlink" title="JavaScript相关"></a><div id="javascript">JavaScript相关</div></h4><h5 id="1-“1”-“2”-“3”-map-parseInt"><a href="#1-“1”-“2”-“3”-map-parseInt" class="headerlink" title="1 [“1”, “2”, “3”].map(parseInt)"></a>1 [“1”, “2”, “3”].map(parseInt)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的<span class="keyword">this</span>值</span><br><span class="line"></span><br><span class="line">其中回调函数接受三个参数 currentValue, index, arrary;</span><br><span class="line"></span><br><span class="line">而题目中, map只传入了回调函数--<span class="built_in">parseInt</span>.</span><br><span class="line"></span><br><span class="line">其次, <span class="built_in">parseInt</span> 只接受两个两个参数 string, radix(基数).  </span><br><span class="line">本题理解来说也就是key与 index </span><br><span class="line"></span><br><span class="line">所以本题即问</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(string, radix)</span><br><span class="line">string必需。要被解析的字符串。</span><br><span class="line">radix 可选。表示要解析的数字的基数。该值介于 <span class="number">2</span> ~ <span class="number">36</span> 之间。</span><br><span class="line">如果省略该参数或其值为 <span class="number">0</span>，则数字将以 <span class="number">10</span> 为基础来解析。如果它以 “<span class="number">0</span>x” 或 “<span class="number">0</span>X” 开头，将以 <span class="number">16</span> 为基数。</span><br></pre></td></tr></table></figure></li></ol><h5 id="2-3-2-1-reduce-Math-pow-reduce-Math-pow"><a href="#2-3-2-1-reduce-Math-pow-reduce-Math-pow" class="headerlink" title="2 [[3,2,1].reduce(Math.pow), [].reduce(Math.pow)]"></a>2 [[3,2,1].reduce(Math.pow), [].reduce(Math.pow)]</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback[, initialValue])</span><br><span class="line">reduce接受两个参数, 一个回调, 一个初始值.</span><br><span class="line">回调函数接受四个参数 previousValue, currentValue, currentIndex, array</span><br><span class="line">需要注意的是 If the array is empty and no initialValue was provided, <span class="built_in">TypeError</span> would be thrown.</span><br><span class="line">所以第二个表达式会报异常. 第一个表达式等价于 <span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">2</span>) =&gt; <span class="number">9</span>; <span class="built_in">Math</span>.pow(<span class="number">9</span>, <span class="number">1</span>) =&gt;<span class="number">9</span></span><br></pre></td></tr></table></figure><h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">ary[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">ary.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x === <span class="literal">undefined</span>;&#125;);</span><br><span class="line">我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> ary; =&gt; <span class="literal">true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> ary; =&gt; <span class="literal">false</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">in</span> ary; =&gt; <span class="literal">true</span></span><br><span class="line">也就是说 从 <span class="number">3</span> - <span class="number">9</span> 都是没有初始化的bug !, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些坑的.</span><br></pre></td></tr></table></figure><h5 id="4-typeof-null-null-instanceof-Object"><a href="#4-typeof-null-null-instanceof-Object" class="headerlink" title="4 [typeof null, null instanceof Object]"></a>4 [typeof null, null instanceof Object]</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> 返回一个表示类型的字符串.</span><br><span class="line"><span class="keyword">instanceof</span> 运算符用来检测 <span class="keyword">constructor</span>.prototype 是否存在于参数 object 的原型链上.</span><br><span class="line">type         result</span><br><span class="line">Undefined   "undefined"</span><br><span class="line">Null        "object"</span><br><span class="line">Boolean     "boolean"</span><br><span class="line">Number      "number"</span><br><span class="line">String      "string"</span><br><span class="line">Symbol      "symbol"</span><br><span class="line">Host object Implementation-dependent</span><br><span class="line">Function    "function"</span><br><span class="line">Object      "object"</span><br></pre></td></tr></table></figure><h5 id="5-js数据类型"><a href="#5-js数据类型" class="headerlink" title="5 js数据类型"></a>5 js数据类型</h5><p>1.number; </p><p>2.string;</p><p>3.boolean;</p><p>4.undefined;</p><p>5.null;</p><p>6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。</p><p>7.Object.（包括Object，Array，Function）</p><h5 id="6-promise-用法"><a href="#6-promise-用法" class="headerlink" title="6 promise 用法"></a>6 promise 用法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">使用</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="7-es6-promise-ajax"><a href="#7-es6-promise-ajax" class="headerlink" title="7 es6 promise ajax"></a>7 es6 promise ajax</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line"><span class="keyword">const</span> myHttpClient = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">使用</span><br><span class="line">myHttpClient(<span class="string">'https://www.baidu.com'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="8闭包"><a href="#8闭包" class="headerlink" title="8闭包"></a>8闭包</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        alert(x + y + (++tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo(<span class="number">2</span>); <span class="comment">// bar 现在是一个闭包</span></span><br><span class="line">bar(<span class="number">10</span>);</span><br><span class="line">结果是<span class="number">16</span></span><br><span class="line">es6通常用<span class="keyword">let</span> <span class="keyword">const</span>块级作用域代替，</span><br><span class="line">闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题</span><br></pre></td></tr></table></figure><h5 id="9-什么是立即执行函数？使用立即执行函数的目的是什么？"><a href="#9-什么是立即执行函数？使用立即执行函数的目的是什么？" class="headerlink" title="9 什么是立即执行函数？使用立即执行函数的目的是什么？"></a>9 什么是立即执行函数？使用立即执行函数的目的是什么？</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见两种方式</span><br><span class="line"><span class="number">1.</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)()</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;)(<span class="number">12345</span>)</span><br><span class="line"><span class="number">2.</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;())</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;(<span class="number">12345</span>))</span><br><span class="line">作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如</span><br><span class="line">（<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;...&#125;(<span class="built_in">window</span>)）</span><br></pre></td></tr></table></figure><h5 id="10-async-await-语法"><a href="#10-async-await-语法" class="headerlink" title="10 async/await 语法"></a>10 async/await 语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">作用：异步代码的新方式</span><br><span class="line">promise示例</span><br><span class="line"><span class="keyword">const</span> makeRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON()</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.needsAnotherRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> makeAnotherRequest(data)</span><br><span class="line">          .then(<span class="function"><span class="params">moreData</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(moreData)</span><br><span class="line">            <span class="keyword">return</span> moreData</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span>/<span class="keyword">await</span>示例</span><br><span class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getJSON()</span><br><span class="line">  <span class="keyword">if</span> (data.needsAnotherRequest) &#123;</span><br><span class="line">    <span class="keyword">const</span> moreData = <span class="keyword">await</span> makeAnotherRequest(data);</span><br><span class="line">    <span class="built_in">console</span>.log(moreData)</span><br><span class="line">    <span class="keyword">return</span> moreData</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> data    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">函数前面多了一个aync关键字。<span class="keyword">await</span>关键字只能用在aync定义的函数内。<span class="keyword">async</span>函数会隐式地返回一个promise，该promise的reosolve值就是函数<span class="keyword">return</span>的值。(示例中reosolve值就是字符串<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure><h5 id="11-深浅拷贝"><a href="#11-深浅拷贝" class="headerlink" title="11 深浅拷贝"></a>11 深浅拷贝</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  aa: <span class="number">1</span>,</span><br><span class="line">  bb: <span class="number">2</span>,</span><br><span class="line">  cc: <span class="number">3</span>,</span><br><span class="line">  dd: &#123;</span><br><span class="line">    ee: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ff: &#123;</span><br><span class="line">    gg: <span class="number">6</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));<span class="comment">//深复制包含子对象</span></span><br><span class="line"><span class="keyword">let</span> c = &#123;...a&#125;;<span class="comment">//深拷贝单不包含子对象</span></span><br><span class="line"><span class="keyword">let</span> b = a;<span class="comment">//浅拷贝</span></span><br><span class="line">b.bb = <span class="number">22</span>;</span><br><span class="line">c.cc = <span class="number">33</span>;</span><br><span class="line">c.dd.ee = <span class="number">55</span>;</span><br><span class="line">d.ff.gg = <span class="number">66</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure><h5 id="12数组去重"><a href="#12数组去重" class="headerlink" title="12数组去重"></a>12数组去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路<span class="number">1</span>：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中</span><br><span class="line">思路<span class="number">2</span>：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</span><br><span class="line">思路<span class="number">3</span>：利用对象属性存在的特性，如果没有该属性则存入新数组。</span><br><span class="line">思路<span class="number">4</span>（最常用）：使用es6 set</span><br><span class="line"><span class="keyword">let</span> arr= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)]);</span><br></pre></td></tr></table></figure><h5 id="13正则实现trim-功能"><a href="#13正则实现trim-功能" class="headerlink" title="13正则实现trim()功能"></a>13正则实现trim()功能</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTrim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/^\s+|\s+$/g</span>;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myTrim(<span class="string">'    asdf    '</span>));</span><br></pre></td></tr></table></figure><h5 id="14-JS原型"><a href="#14-JS原型" class="headerlink" title="14 JS原型"></a>14 JS原型</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line"><span class="number">2.</span>个人粗略理解与python的类方法静态方法实例方法差不多</span><br></pre></td></tr></table></figure><p>#####15 es6 class<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象，java中类</span><br></pre></td></tr></table></figure></p><h5 id="16-JS-如何实现继承"><a href="#16-JS-如何实现继承" class="headerlink" title="16 JS 如何实现继承"></a>16 JS 如何实现继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用原型继承（既继承了父类的模板，又继承了父类的原型对象。优点是继承了父类的模板，又继承了父类的原型对象，缺点就是父类实例传参，不是子类实例化传参，不符合常规语言的写法）</span><br><span class="line"><span class="number">2.</span>使用call的方式（继承了父类的模板，不继承了父类的原型对象。优点是方便了子类实例传参，缺点就是不继承了父类的原型对象）</span><br></pre></td></tr></table></figure><h5 id="17-手写jquery插件"><a href="#17-手写jquery插件" class="headerlink" title="17 手写jquery插件"></a>17 手写jquery插件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">$.fn.myPlugins = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//参数赋值</span></span><br><span class="line">  options = $.extend(defaults, options);<span class="comment">//对象合并</span></span><br><span class="line">  <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//执行代码逻辑</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line"></span><br><span class="line">$(selector).myPlugins(&#123;参数&#125;);</span><br></pre></td></tr></table></figure><h5 id="18-数组合并去重排序"><a href="#18-数组合并去重排序" class="headerlink" title="18 数组合并去重排序"></a>18 数组合并去重排序</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">1234</span>, <span class="number">6</span>, <span class="number">213</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">6</span>, <span class="number">2134</span>, <span class="number">6</span>, <span class="number">31</span>, <span class="number">623</span>];</span><br><span class="line"><span class="keyword">let</span> c = [...new <span class="built_in">Set</span>([...arr1, ...arr2])].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="19-call-apply"><a href="#19-call-apply" class="headerlink" title="19 call apply"></a>19 call apply</h5><p>作用：在函数调用时改变函数的执行上下文也就是this的值<br>区别：call采用不定长的参数列表，而apply使用一个参数数组。<br>性能优化图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.jpg" alt="性能优化" title="">                </div>                <div class="image-caption">性能优化</div>            </figure></p><h5 id="20-for-中setTimeOut"><a href="#20-for-中setTimeOut" class="headerlink" title="20 for 中setTimeOut"></a>20 for 中setTimeOut</h5><p>要为循环题创建不同的循环副本</p><h5 id="21-sort函数"><a href="#21-sort函数" class="headerlink" title="21 sort函数"></a>21 sort函数</h5><p>V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 插入，比10大的数组则使用 快排。</p><h5 id="22-navigator"><a href="#22-navigator" class="headerlink" title="22 navigator"></a>22 navigator</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/Navigator.png" alt="Navigator" title="">                </div>                <div class="image-caption">Navigator</div>            </figure><h5 id="23-jquery绑定方式"><a href="#23-jquery绑定方式" class="headerlink" title="23 jquery绑定方式"></a>23 jquery绑定方式</h5><ol><li>click后者覆盖</li><li>bind后者覆盖</li><li>on(jquery&gt;=1.7)</li><li>live</li><li>delegate<h5 id="24-事件流向"><a href="#24-事件流向" class="headerlink" title="24 事件流向"></a>24 事件流向</h5></li><li>冒泡：子节点一层层冒泡到根节点</li><li>捕获顺序与冒泡相反</li><li>addEventListener最后个参数true代表捕获反之代表冒泡</li><li>阻止冒泡不停止父节点捕获<h5 id="25原生操作class"><a href="#25原生操作class" class="headerlink" title="25原生操作class"></a>25原生操作class</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断有无</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClass</span>(<span class="params">ele, cls</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ele.className.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(\\s|^)"</span> + cls + <span class="string">"(\\s|$)"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">ele, cls</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.hasClass(ele, cls)) ele.className += <span class="string">" "</span> + cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeClass</span>(<span class="params">ele, cls</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasClass(ele, cls)) &#123;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(\\s|^)"</span> + cls + <span class="string">"(\\s|$)"</span>);</span><br><span class="line">ele.className = ele.className.replace(reg, <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html5中加入classList </span><br><span class="line">一系列操作</span><br><span class="line">兼容至IE10</span><br></pre></td></tr></table></figure></li></ol><h4 id="DOM相关"><a href="#DOM相关" class="headerlink" title="DOM相关"></a><div id="dom">DOM相关</div></h4><h5 id="dom事件模型"><a href="#dom事件模型" class="headerlink" title="dom事件模型"></a>dom事件模型</h5><p>DOM之事件模型分脚本模型、内联模型(同类一个，后者覆盖)、动态绑定(同类多个)<br>demo<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--行内绑定：脚本模型--&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"javascrpt:alert('Hello')"</span>&gt;Hello1&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;!--内联模型--&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onclick="showHello()"&gt;Hello2&lt;/</span>button&gt;</span><br><span class="line">&lt;!--动态绑定--&gt;</span><br><span class="line">&lt;button id=<span class="string">"btn3"</span>&gt;Hello3&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/*DOM0：同一个元素，同类事件只能添加一个，如果添加多个，</span></span><br><span class="line"><span class="comment">* 后面添加的会覆盖之前添加的*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shoeHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn3 = <span class="built_in">document</span>.getElementById(<span class="string">"btn3"</span>);</span><br><span class="line">btn3.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*DOM2:可以给同一个元素添加多个同类事件*/</span></span><br><span class="line">btn3.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"hello1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn3.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"hello2"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (btn3.attachEvent)&#123;</span><br><span class="line"><span class="comment">/*IE*/</span></span><br><span class="line">btn3.attachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"IE Hello1"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*W3C*/</span></span><br><span class="line">btn3.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"W3C Hello"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>冒泡解释：当点击一个元素触发事件时. 事件会先从元素的最外层父元素一层一层进入到触发的元素, 然后在从触发元素一层一层返回到最外层父元素, 从最外层一层一层进入的阶段叫事件捕获阶段, 从最里层一层一层往外的阶段叫事件冒泡,</p><h5 id="移动端触摸事件"><a href="#移动端触摸事件" class="headerlink" title="移动端触摸事件"></a>移动端触摸事件</h5><p>①touchstart：当手指触碰到屏幕的时候触发<br>②touchmove：当手指在屏幕上滑动的时候触发<br>③touchend：当手指离开屏幕的时候时候触发<br>④touchcancel事件：当系统停止跟踪触摸的时候触发(这个事件很少会用，一般不做深入研究)。 电话接入或者弹出信息等其他事件切入<br>event： </p><ol><li>touches：表示当前跟踪的触摸操作的touch对象的数组。 </li><li>targetTouches：特定于事件目标的Touch对象的数组。 </li><li>changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 </li></ol><p>每个touch对象包含的属性 </p><ol><li>clientX：触摸目标在视口中的x坐标。 </li><li>clientY：触摸目标在视口中的y坐标。 </li><li>identifier：标识触摸的唯一ID。 </li><li>pageX：触摸目标在页面中的x坐标。 </li><li>pageY：触摸目标在页面中的y坐标。 </li><li>screenX：触摸目标在屏幕中的x坐标。 </li><li>screenY：触摸目标在屏幕中的y坐标。 </li><li>target：触目的DOM节点目标。 </li></ol><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>参考定义：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件<br>好处：给重复的节点添加相同操作，减少dom交互，提高性能<br>实现思路：给父组件添加事件，通过事件冒泡，排查元素是否为指定元素，并进行系列操作</p><h4 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a><div id="http">HTTP相关</div></h4><h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h5><p><b>2开头 （请求成功）表示成功处理了请求的状态代码。</b></p><p>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求。</p><p><b>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</b></p><p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p><b>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</b></p><p>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><p><b>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</b></p><p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ol><li>Expires在http1.0中使用，与服务器时间有误差，在1.1中由Cache-control替代<br><meta http-equiv="Cache-Control" content="max-age=7200"><meta http-equiv="Expires" content="Mon, 20 Jul 2009 23:00:00 GMT"></li><li>cdn</li></ol><h5 id="Cache-Control-和-Etag-的区别"><a href="#Cache-Control-和-Etag-的区别" class="headerlink" title="Cache-Control 和 Etag 的区别"></a>Cache-Control 和 Etag 的区别</h5><p>如下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/%E5%8C%BA%E5%88%AB%E5%9B%BE.png" alt="区别图" title="">                </div>                <div class="image-caption">区别图</div>            </figure></p><h5 id="Cookie-sessionStorage-localStorage"><a href="#Cookie-sessionStorage-localStorage" class="headerlink" title="Cookie sessionStorage  localStorage"></a>Cookie sessionStorage  localStorage</h5><p>共同点：都是保存在浏览器端，且同源的。<br>区别：cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据不能超过4k(适合保存小数据)。<br>sessionStorage和localStorage容量较大，数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效。localStorage：始终有效，窗口或浏览器关闭也一直保存，需手动清楚；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同。<br>sessionStorage不在不同的浏览器窗口中共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</p><p>应用场景：localStorage：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage ：敏感账号一次性登录； cookies与服务器交互。</p><h5 id="GET-POST区别"><a href="#GET-POST区别" class="headerlink" title="GET POST区别"></a>GET POST区别</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/get_post.png" alt="get_post" title="">                </div>                <div class="image-caption">get_post</div>            </figure><h5 id="请求行，请求头，请求体详解"><a href="#请求行，请求头，请求体详解" class="headerlink" title="请求行，请求头，请求体详解"></a>请求行，请求头，请求体详解</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/http%E8%AF%B7%E6%B1%82%E4%B8%80%E4%BD%93.jpg" alt="如图" title="">                </div>                <div class="image-caption">如图</div>            </figure><p>1,2,3请求行，4请求体，5请求体</p><h5 id="跨域、JSONP-、CORS、postMessage"><a href="#跨域、JSONP-、CORS、postMessage" class="headerlink" title="跨域、JSONP 、CORS、postMessage"></a>跨域、JSONP 、CORS、postMessage</h5><p>跨域概念解释：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。<br>如下表<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/%E8%B7%A8%E5%9F%9F%E6%83%85%E5%86%B5%E6%A0%87%E8%AF%86.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure></p><p>jsoup实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">原生</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">    script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 回调执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">jquery</span></span><br><span class="line"><span class="regexp">$.ajax(&#123;</span></span><br><span class="line"><span class="regexp">    url: 'http:/</span><span class="regexp">/www.domain2.com:8080/</span>login<span class="string">',</span></span><br><span class="line"><span class="string">    type: '</span>get<span class="string">',</span></span><br><span class="line"><span class="string">    dataType: '</span>jsonp<span class="string">',  // 请求方式为jsonp</span></span><br><span class="line"><span class="string">    jsonpCallback: "onBack",    // 自定义回调函数名</span></span><br><span class="line"><span class="string">    data: &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vue</span></span><br><span class="line"><span class="string">this.$http.jsonp('</span>http:<span class="comment">//www.domain2.com:8080/login', &#123;</span></span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">'onBack'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">配合的后端node实现,其他服务器语言也可以</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">')'</span>);</span><br><span class="line"> </span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"></span><br><span class="line">jsoup缺点只能实现get请求</span><br></pre></td></tr></table></figure></p><p>CORS：跨源资源共享 Cross-Origin Resource Sharing(CORS)，通常服务器设置，若带cookie请求，则前后端都需要设置<br>后端常见设置<br>response.setHeader(“Access-Control-Allow-Origin”, “<a href="http://www.domain1.com&quot;)" target="_blank" rel="noopener">http://www.domain1.com&quot;)</a>;  // 若有端口需写全（协议+域名+端口），允许那些外源请求<br>response.setHeader(“Access-Control-Allow-Credentials”, “true”); //是否需要验证</p><p>前端示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">原生</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.domain2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"> </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">jquery</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">postMessage(data,origin)方法接受两个参数</span><br><span class="line">demo</span><br><span class="line"></span><br><span class="line">a.html</span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;</span><br><span class="line">            name: <span class="string">'aym'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 向domain2传送跨域数据</span></span><br><span class="line">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain2.com'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 接受domain2返回数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'data from domain2 ---&gt; '</span> + e.data);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">b.html  与a.html不同源</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 接收domain1的数据</span></span><br><span class="line"><span class="regexp">    window.addEventListener('message', function(e) &#123;</span></span><br><span class="line"><span class="regexp">        alert('data from domain1 ---&gt; ' + e.data);</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">        var data = JSON.parse(e.data);</span></span><br><span class="line"><span class="regexp">        if (data) &#123;</span></span><br><span class="line"><span class="regexp">            data.number = 16;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 处理后再发回domain1</span></span><br><span class="line"><span class="regexp">            window.parent.postMessage(JSON.stringify(data), 'http:/</span><span class="regexp">/www.domain1.com');</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;, false);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h5 id="osi模型"><a href="#osi模型" class="headerlink" title="osi模型"></a>osi模型</h5><p>七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>tcp ucp属于传输层；http属于应用层</p><h5 id="http2-0-http1"><a href="#http2-0-http1" class="headerlink" title="http2.0 http1"></a>http2.0 http1</h5><ol><li>HTTP2.0的基本单位为二进制帧</li><li>HTTP2.0中帧具有优先级</li><li>HTTP2.0的多路复用（ 1次连接）</li><li>HTTP2.0压缩消息头</li><li>HTTP2.0服务端推送</li><li>HTTP2.0只适用于HTTPS的场景<h4 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a><div id="vue">Vue相关</div></h4></li></ol><h5 id="生命周期顺序"><a href="#生命周期顺序" class="headerlink" title="生命周期顺序"></a>生命周期顺序</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pd4ar0u4q.bkt.clouddn.com/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期" title="">                </div>                <div class="image-caption">生命周期</div>            </figure><h5 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h5><p>1.父传子用props,父用子用ref 子调父用$emit,无关系用Bus</p><h5 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h5><p>组件通信库，可以避免子组件无法改变props的弊端等<br>mutations 同步操作， 用于改变状态 官方不推荐异步<br>action 执行多个mutaions，官方推荐异步操作<br>mapState、mapGetters、mapActions使用示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dialog :visible.sync=<span class="string">"show"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的三点叫做 : 扩展运算符</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      show:<span class="function"><span class="params">state</span>=&gt;</span>state.dialog.show</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">后两者类似</span></span><br></pre></td></tr></table></figure></p><h5 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line"><span class="keyword">var</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path:<span class="string">"/one"</span>,</span><br><span class="line"></span><br><span class="line">        component:导入的组件<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path:<span class="string">"/two"</span>,</span><br><span class="line">        component:导入的组件<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 定义路由组件</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义路由</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#box"</span>,</span><br><span class="line">    router</span><br><span class="line">&#125;);</span><br><span class="line"> 访问设定的路由后 会将&lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>替换成相应的模版</span></span><br><span class="line"> html访问方式 &lt;router-link to="/one"&gt;One&lt;/router-link&gt;(类似a标签)</span><br><span class="line"> js访问方式 this.$router.push('/one'); </span><br><span class="line"> replace方式 替换当前页面</span><br><span class="line"> 携带的参数 可以通过this.$route.query.xxxx来获取</span><br><span class="line">``` </span><br><span class="line">##### Vue双向绑定</span><br><span class="line">原理：利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。</span><br><span class="line">缺点：双向数据流是自动管理状态的, 但是在实际应用中会有很多不得不手动处理状态变化的逻辑, 使得程序复杂度上升, 难以调试。</span><br><span class="line">##### computed  watch methods</span><br><span class="line">用法：</span><br><span class="line">区别：</span><br><span class="line">1. 前两者自动追踪数据，执行相关函数，最后一个手动调用；</span><br><span class="line">2. computed是计算属性，用法与data一致</span><br><span class="line">3. watch像事件监听，对象发生变化时，执行相关操作</span><br><span class="line">4. methods与js中执行方法类似</span><br><span class="line">5. computed通常只有get属性</span><br><span class="line">6. 数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择</span><br><span class="line">7. watch的对象必须事先声明</span><br><span class="line">#### &lt;div id="sort"&gt;算法相关&lt;/div&gt;</span><br><span class="line">##### 各种排序实现</span><br><span class="line">相关数据</span><br><span class="line">![表格](http://pd4ar0u4q.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AD%89%E7%AD%89.png)</span><br><span class="line">```javascript</span><br><span class="line">// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样</span><br><span class="line">冒泡demo:</span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比</span><br><span class="line">                [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">// 1) 首先，在数组中选择一个中间项作为主元</span><br><span class="line">// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到</span><br><span class="line">// 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作</span><br><span class="line">// 3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成</span><br><span class="line">快排demo:</span><br><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    let partitionIndex;</span><br><span class="line">    left = typeof left !== 'number' ? 0 : left;</span><br><span class="line">    right = typeof right !== 'number' ? len - 1 : right;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex - 1);</span><br><span class="line">        quickSort(arr, partitionIndex + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function partition(arr, left, right) &#123;     //分区操作</span><br><span class="line">    let pivot = left;                      //设定基准值（pivot）</span><br><span class="line">    let index = pivot + 1;</span><br><span class="line">    for (let i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            [arr[i], arr[index]] = [arr[index], arr[i]];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[pivot], arr[index - 1]] = [arr[index - 1], arr[pivot]];</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br><span class="line">// 选择排序：大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)</span><br><span class="line">选择demo:</span><br><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">let len = arr.length;</span><br><span class="line">let minIndex;</span><br><span class="line">for (let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">minIndex = i;</span><br><span class="line">for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class="line">    minIndex = j;                 //将最小数的索引保存</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">// 插入排序：每次排一个数组项，假设数组的第一项已经排序，接着，把第二项与第一项进行对比，第二项是该插入到第一项之前还是之后，第三项是该插入到第一项之前还是第一项之后还是第三项</span><br><span class="line">插入demo:</span><br><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">let len = arr.length;</span><br><span class="line">let preIndex, current;</span><br><span class="line">for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line">    preIndex = i - 1;</span><br><span class="line">    current = arr[i];</span><br><span class="line">    while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">    arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">    preIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[preIndex + 1] = current;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">// 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)</span><br><span class="line">// 归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组</span><br><span class="line">归并demo:</span><br><span class="line">function mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    if(len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    let middle = Math.floor(len / 2),</span><br><span class="line">    left = arr.slice(0, middle),</span><br><span class="line">    right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(...left);</span><br><span class="line">    result.push(...right);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">//堆排序：堆排序把数组当中二叉树来排序而得名。</span><br><span class="line">// 1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2*L；4）节点R的右子节点为2*R + 1</span><br><span class="line">// 本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个</span><br><span class="line">堆demo:</span><br><span class="line">var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"></span><br><span class="line">function buildMaxHeap(arr) &#123;   //建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (let i = Math.floor(len / 2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapify(arr, i) &#123;     //堆调整</span><br><span class="line">    let left = 2 * i + 1;</span><br><span class="line">    let right = 2 * i + 2;</span><br><span class="line">    let largest = i;</span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    if (largest !== i) &#123;</span><br><span class="line">        [arr[i], arr[largest]] = [arr[largest], arr[i]];</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    for (let i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        [arr[0],arr[i]]=[arr[i],arr[0]];</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>思路<br>（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。<br>（2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。<br>（3）如果某一步数组为空，则表示找不到目标元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((high + low) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(key === arr[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span>  mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; arr[mid])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; arr[mid])&#123;</span><br><span class="line">            high = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params">arr,low, high, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((high + low) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] === key)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)&#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key)&#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="二叉树相关"><a href="#二叉树相关" class="headerlink" title="二叉树相关"></a>二叉树相关</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">创建</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data,left,right</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;<span class="comment">//数值</span></span><br><span class="line"><span class="keyword">this</span>.left = left;<span class="comment">//左节点</span></span><br><span class="line"><span class="keyword">this</span>.right = right;<span class="comment">//右节点</span></span><br><span class="line">&#125;;</span><br><span class="line">插入二叉树</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">node,data</span>)</span>&#123;</span><br><span class="line"><span class="comment">//创建一个新的节点</span></span><br><span class="line"><span class="keyword">let</span> newNode  = <span class="keyword">new</span> Node(data,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//判断是否存在根节点，没有将新节点存入</span></span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">node = newNode;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//获取根节点</span></span><br><span class="line"><span class="keyword">let</span> current = node;</span><br><span class="line"><span class="keyword">let</span> parent;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//将当前节点保存为父节点</span></span><br><span class="line">parent = current;</span><br><span class="line"><span class="comment">//将小的数据放在左节点</span></span><br><span class="line"><span class="keyword">if</span>(data &lt; current.data)&#123;</span><br><span class="line"><span class="comment">//获取当前节点的左节点</span></span><br><span class="line"><span class="comment">//判断当前节点下的左节点是否有数据</span></span><br><span class="line">current = current.left;</span><br><span class="line"><span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//如果没有数据将新节点存入当前节点下的左节点</span></span><br><span class="line">parent.left = newNode;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">current = current.right;</span><br><span class="line"><span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;</span><br><span class="line">parent.right = newNode;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">翻转二叉树</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertTree</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">node.left, node.right = node.left, node.right;</span><br><span class="line">invertTree(node.left);</span><br><span class="line">invertTree(node.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查找链表中倒数第k个结点</span><br><span class="line"><span class="number">2</span>个思路</span><br><span class="line"><span class="number">1</span>：先遍历出长度，然后查找长度-k+<span class="number">1</span>的值</span><br><span class="line"><span class="number">2</span>：<span class="number">2</span>个指针，一个指针先走k<span class="number">-1</span>，然后两个一起走到底部，后者就是结果</span><br></pre></td></tr></table></figure><h4 id="网络安全相关"><a href="#网络安全相关" class="headerlink" title="网络安全相关"></a><div id="web">网络安全相关</div></h4><h5 id="XSS-CSRF"><a href="#XSS-CSRF" class="headerlink" title="XSS CSRF"></a>XSS CSRF</h5><p>XSS(跨站脚本攻击)，恶意的注入html代码，其他用户访问时，会被执行<br>特点：能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击<br>防御手段：</p><ul><li>浏览器禁止页面的JS访问带有HttpOnly属性的Cookie</li><li>两端进行输入格式检查</li><li>通过编码转义的方式进行输出检查<br>CSRF(攻击跨站请求伪造)<br>特点：重要操作的所有参数都是可以被攻击者猜测到的。攻击者预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求。<br>防御手段：</li><li>token验证机制，比如请求数据字段中添加一个token，响应请求时校验其有效性</li><li>用户操作限制，比如验证码（繁琐，用户体验差）</li><li>请求来源限制，比如限制HTTP Referer才能完成操作（防御效果相比较差）<br>实践中常用第一种<h4 id="webpack相关"><a href="#webpack相关" class="headerlink" title=" webpack相关"></a><div id="webpack"> webpack相关</div></h4>#####打包体积<br>优化思路</li></ul><ol><li>提取第三方库或通过引用外部文件的方式引入第三方库</li><li>代码压缩插件UglifyJsPlugin</li><li>服务器启用gzip压缩</li><li>按需加载资源文件 require.ensure</li><li>优化devtool中的source-map</li><li>剥离css文件，单独打包</li><li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致<br>#####打包效率</li><li>开发环境采用增量构建，启用热更新</li><li>开发环境不做无意义的工作如提取css计算文件hash等</li><li>配置devtool</li><li>选择合适的loader</li><li>个别loader开启cache 如babel-loader</li><li>第三方库采用引入方式</li><li>提取公共代码</li><li>优化构建时的搜索路径 指明需要构建目录及不需要构建目录</li><li>模块化引入需要的部分<h5 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h5>编写一个loader<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">loader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的<span class="keyword">this</span>上下文访问Loader API。</span><br><span class="line">reverse-txt-loader</span><br><span class="line">定义</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//src是原文件内容（abcde），下面对内容进行处理，这里是反转</span></span><br><span class="line">  <span class="keyword">var</span> result = src.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>); </span><br><span class="line">  <span class="comment">//返回JavaScript源码，必须是String或者Buffer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports = '<span class="subst">$&#123;result&#125;</span>'`</span>;</span><br><span class="line">&#125;</span><br><span class="line">使用</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.txt$/</span>,</span><br><span class="line">use: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">'./path/reverse-txt-loader'</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ol><h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5><p>使用范围更广，通常只需要require()然后添加到plugins数组中，且需要new一个</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a><div id="other">其他</div></h4><h5 id="URL到界面显示发生了什么"><a href="#URL到界面显示发生了什么" class="headerlink" title="URL到界面显示发生了什么"></a>URL到界面显示发生了什么</h5><ol><li>DNS解析<br>先本地缓存找，在一层层找<br>将常见的地址解析成唯一对应的ip地址基本顺序为：本地域名服务器-&gt;根域名服务器-&gt;com顶级域名服务器依次类推下去,找到后记录并缓存下来如<a href="http://www.google.com为" target="_blank" rel="noopener">www.google.com为</a><br><b>. -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>.</b></li><li>TCP连接<br>三次握手，只要没收到确认消息就要重新发<ol><li>主机向服务器发送一个建立连接的请求（您好，我想认识您）；</li><li>服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；</li><li>主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。</li></ol></li><li>发送HTTP请求<br>浏览器会分析这个url，并设置好请求报文发出。请求报文中包括请求行、请求头、空行、请求主体。https默认请求端口443， http默认80。<br>常见的http请求如下<figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">POST / HTTP1.1</span></span><br><span class="line"><span class="xml">Host:www.wrox.com</span></span><br><span class="line"><span class="xml">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span></span><br><span class="line"><span class="xml">Content-Type:application/x-www-form-urlencoded</span></span><br><span class="line"><span class="xml">Content-Length:40</span></span><br><span class="line"><span class="xml">Connection: Keep-Alive</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">name=Professional%20Ajax&amp;publisher=Wiley</span></span><br><span class="line"><span class="xml">第一部分：请求行，第一行说明是post请求，以及http1.1版本。</span></span><br><span class="line"><span class="xml">第二部分：请求头部，第二行至第六行。</span></span><br><span class="line"><span class="xml">第三部分：空行，第七行的空行。</span></span><br><span class="line"><span class="xml">第四部分：请求数据，第八行。</span></span><br><span class="line"><span class="xml">4. 服务器处理请求并返回HTTP报文</span></span><br><span class="line"><span class="xml">后端处理返回http报文如下</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">HTTP/1.1 200 OK</span></span><br><span class="line"><span class="xml">Date: Fri, 22 May 2009 06:07:21 GMT</span></span><br><span class="line"><span class="xml">Content-Type: text/html; charset=UTF-8</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--body goes here--&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</span></span><br><span class="line"><span class="xml">第二行和第三行为消息报头，</span></span><br><span class="line"><span class="xml">Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</span></span><br><span class="line"><span class="xml">第三部分：空行，消息报头后面的空行是必须的</span></span><br><span class="line"><span class="xml">第四部分：响应正文，服务器返回给客户端的文本信息。</span></span><br><span class="line"><span class="xml">空行后面的html部分为响应正文。</span></span><br></pre></td></tr></table></figure><ol start="5"><li>浏览器解析渲染页面</li></ol><ul><li>通过HTML解析器解析HTML文档，构建一个DOM Tree，同时通过CSS解析器解析HTML中存在的CSS，构建Style Rules，两者结合形成一个Attachment。</li><li>通过Attachment构造出一个呈现树（Render Tree）</li><li>Render Tree构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。</li><li>最后将全部的节点遍历绘制出来后，一个页面就展现出来了。<br>遇到script会停下来执行，所以通常把script放在底部</li></ul><ol start="6"><li>连接结束</li></ol><h5 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h5><p>目的：为了重用，提高开发效率和代码质量<br>注意：低耦合，单一职责，可复用性，可维护性<br>常用操作：</p><ol><li>分析布局</li><li>初步开发</li><li>化繁为简</li><li>组件抽象</li></ol><h5 id="JS异步加载"><a href="#JS异步加载" class="headerlink" title="JS异步加载"></a>JS异步加载</h5><ol><li>动态生成script标签</li><li>添加h5的async defer属性，前者乱序不适合依赖性加载</li><li>async 是“下载完就执行”， defer 是“渲染完再执行”</li></ol><h5 id="css与js动画差异"><a href="#css与js动画差异" class="headerlink" title="css与js动画差异"></a>css与js动画差异</h5><ol><li>css性能好</li><li>css代码逻辑相对简单</li><li>js动画控制好</li><li>js兼容性好</li><li>js可实现的动画多</li><li>js可以添加事件</li></ol><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用</p><ol><li>http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器</li><li>dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱）</li><li>反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量</li></ol><h5 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h5><p>内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p>定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题<br>js中可能出现的内存泄漏情况<br>结果：变慢，崩溃，延迟大等<br>原因：</p><ol><li>全局变量</li><li>dom清空时，还存在引用</li><li>ie中使用闭包</li><li>定时器未清理</li><li>子元素存在引起的内存泄露</li></ol><p>避免策略：</p><ol><li>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</li><li>注意程序逻辑，避免“死循环”之类的 ；</li><li>避免创建过多的对象  原则：不用了的东西要及时归还。 </li><li>减少层级过多的引用<h5 id="babel原理"><a href="#babel原理" class="headerlink" title="babel原理"></a>babel原理</h5>ES6、7代码输入 -&gt; babylon进行解析 -&gt; 得到AST（抽象语法树）-&gt; plugin用babel-traverse对AST树进行遍历转译 -&gt;得到新的AST树-&gt;用babel-generator通过AST树生成ES5代码、</li></ol><h5 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h5><p>特性：Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获</p><h5 id="js自定义事件"><a href="#js自定义事件" class="headerlink" title="js自定义事件"></a>js自定义事件</h5><p>三要素：<br>document.createEvent()<br>event.initEvent()<br>element.dispatchEvent()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">demo:</span><br><span class="line">(en:自定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加自定义事件，triggerEvent:触发自定义事件)</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> demo = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);</span><br><span class="line">    demo.addEvent(<span class="string">"test"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"handler1"</span>)&#125;);</span><br><span class="line">    demo.addEvent(<span class="string">"test"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"handler2"</span>)&#125;);</span><br><span class="line">    demo.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.triggerEvent(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Element.prototype.addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">en,fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pools = <span class="keyword">this</span>.pools || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(en <span class="keyword">in</span> <span class="keyword">this</span>.pools)&#123;</span><br><span class="line">        <span class="keyword">this</span>.pools[en].push(fn);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pools[en] = [];</span><br><span class="line">        <span class="keyword">this</span>.pools[en].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Element.prototype.triggerEvent  = <span class="function"><span class="keyword">function</span>(<span class="params">en</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(en <span class="keyword">in</span> <span class="keyword">this</span>.pools)&#123;</span><br><span class="line">        <span class="keyword">var</span> fns = <span class="keyword">this</span>.pools[en];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,il=fns.length;i&lt;il;i++)&#123;</span><br><span class="line">            fns[i]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="es6模块-commonjs-amd-cmd"><a href="#es6模块-commonjs-amd-cmd" class="headerlink" title="es6模块 commonjs  amd cmd"></a>es6模块 commonjs  amd cmd</h5><ol><li>CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</li><li>CommonJS是同步加载模块,在浏览器中会出现堵塞情况，所以不适用</li><li>AMD 异步，需要定义回调define方式</li><li>es6 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量</li><li>es6还可以导出类、方法，自动适用严格模式</li></ol><h5 id="前后端路由差别"><a href="#前后端路由差别" class="headerlink" title="前后端路由差别"></a>前后端路由差别</h5><p>1.后端每次路由请求都是重新访问服务器<br>2.前端路由实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前端问题记录&quot;&gt;&lt;a href=&quot;#前端问题记录&quot; class=&quot;headerlink&quot; title=&quot;前端问题记录&quot;&gt;&lt;/a&gt;前端问题记录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#html&quot;&gt;HTML相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cs
      
    
    </summary>
    
      <category term="前端周刊" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="分享" scheme="https://ru23.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>redux入门</title>
    <link href="https://ru23.com//note/20180928/cjnk45shd002as8a195dgngol/"/>
    <id>https://ru23.com//note/20180928/cjnk45shd002as8a195dgngol/</id>
    <published>2018-09-28T11:43:17.000Z</published>
    <updated>2018-10-22T09:39:52.201Z</updated>
    
    <content type="html"><![CDATA[<p>Redux由Flux演变而来，提供几个简单的API来实现状态管理，所谓状态指的是应用数据，所以，Redux本质上是用来管理数据的。<br>进一步，Redux配合支持数据绑定的视图库使用，就可以将应用状态和视图一一对应，开发者不需要再去关心DOM操作，只关心如何组织数据即可。</p><blockquote><p>由于Redux对于数据的管理拆分很细，一时间会有很多概念，并且Redux有自己丰富的生态，所以容易眼花缭乱。<br>所以强烈建议从头开始一步一步的来，深入体验并理解Redux的思想，不要步子迈太大。<br>✦ 不要一开始过多的纠结代码放在哪个目录<br>✦ 不要一开始就想对action和reducer的代码做精简<br>✦ 不要一开始就考虑数据缓存，离线数据等问题<br>✦ 不要一开始就过度设计数据，考虑数据扁平化的问题<br>反正一句话，饭要一口一口的吃，路要一步一步的走，Redux对于状态管理的东西拆得太细，需要多花一些时间去体会。</p></blockquote><h2 id="Redux是什么？"><a href="#Redux是什么？" class="headerlink" title="Redux是什么？"></a>Redux是什么？</h2><p>Redux其实很简单，总结起来就三句话：<br>✦ 将整个应用的state储存在唯一的store对象中。<br>✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。<br>✦ 使用reducer来描述action如何改变state。</p><p>是的，简而言之就是：Redux让应用的数据被集中管理，并且只能通过触发action的方式来修改，而具体如何修改state，是由reducer来决定的。</p><p>那么问题来了：<br>✦ store是什么鬼？<br>✦ action是什么鬼？<br>✦ reducer是什么鬼?<br>✦ 最重要的是，为啥要使用Redux，它能给我们带什么什么好处？或者说，引入这么一个状态理器到底有啥用？</p><p>接下来，我们先捉这三只鬼。</p><p>store是什么鬼？<br>前面提过，Redux的目的就是为了对应用数据进行集中管理，也就是state，而state是个普通对象。为了防止state被不小心更新，Redux创建了store对象，专门用来管理state数据。</p><p>所以，store就是state的守门员，管理并维护应用数据。</p><h3 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h3><p>我们通过createStore(reducer, [initialState], enhancer)的方式来创建store。需要注意的是，应用中应该有且只有一个store。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是reducer，后文会详细介绍</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> state.concat([ action.text ])</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建store，并且给state一个初始值['HTML']</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(todos, [ <span class="string">'HTML'</span> ])</span><br><span class="line"></span><br><span class="line"><span class="comment">// state.dispatch()，最常用的API</span></span><br><span class="line"><span class="comment">// 修改state的唯一方式就是调用store.dispatch()方法</span></span><br><span class="line"><span class="comment">// 显然，其中的描述性对象</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  type: 'ADD_TODO',</span></span><br><span class="line"><span class="comment">//  text: 'CSS'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 就是action</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  text: <span class="string">'CSS'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.getState()，另一个常用的API</span></span><br><span class="line"><span class="comment">// 用来获取state的值</span></span><br><span class="line"><span class="built_in">console</span>.log(store.getState());  <span class="comment">// [ 'HTML', 'CSS' ]</span></span><br></pre></td></tr></table></figure></p><h3 id="store的API们"><a href="#store的API们" class="headerlink" title="store的API们"></a>store的API们</h3><p>store的API很简单，这儿我按重要顺序列出所有的API，主要记住前两个。<br>✦ dispatch(action)：触发action，再次声明，这是改变state的唯一方式，请默念两次<br>✦ getState()：获取当前的state<br>✦ subscribe(listener)：注册一个监听函数，state发生变化时触发<br>✦ replaceReducer(nextReducer)：替换reducer，用得较少</p><p>总结一下，store提供了简单的API，用来管理应用内的数据，它限制了只能通过dispatch(action)来修改state，那么这个action是什么呢？</p><h3 id="action是什么鬼？"><a href="#action是什么鬼？" class="headerlink" title="action是什么鬼？"></a>action是什么鬼？</h3><p>前文提过，action就是一个描述性的普通对象，所以它非常简单！说白了，就是一坨数据，然后这坨数据有名字。</p><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><p>action是一个描述性的普通对象。推荐如下的action结构，type是action的名称，payload是附带的数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显然，这个名字取得很浅显易懂</span></span><br><span class="line">    type: UPDATE_ARTICLES_LIST,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        articles: articles,</span><br><span class="line">        lastkey: lastkey</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是：实际项目中，我们应该尽量减少action中附带的数据，比如想要更新某篇文章的标题，我们只需要携带文章id和文章新标题即可，而不需要携带整个新文章字段。<br>为了让action更便于维护，我们通常使用action creator而不是action。</p><h5 id="action-creator"><a href="#action-creator" class="headerlink" title="action creator"></a>action creator</h5><p>action create就是一个简单的函数，直接将action作为返回值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action creator，返回一个action</span></span><br><span class="line"><span class="comment">// 除此之外，没有其他的动作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateArticlesList</span>(<span class="params">normalizeData, lastkey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: UPDATE_ARTICLES_LIST,</span><br><span class="line">        payload: &#123;</span><br><span class="line">            normalizeData: normalizeData,</span><br><span class="line">            listLastkey: lastkey</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过dispatch触发一个action，这是我们修改state的唯一方式</span></span><br><span class="line">dispatch(updateArticlesList(</span><br><span class="line">    normalizeData,</span><br><span class="line">    lastkey</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dispatch(action)整个动作取个别名，方便调用</span></span><br><span class="line"><span class="keyword">const</span> updatePosts = <span class="function">(<span class="params">normalizeData, lastkey</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(updateArticlesList(</span><br><span class="line">        normalizeData,</span><br><span class="line">        lastkey</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updatePosts(...);</span><br></pre></td></tr></table></figure></p><h3 id="那么为什么需要action-creatore呢？"><a href="#那么为什么需要action-creatore呢？" class="headerlink" title="那么为什么需要action creatore呢？"></a>那么为什么需要action creatore呢？</h3><p>试想一个场景，我们有好几处dispatch(action)，现在突然想要修改这个action的定义，那么我们需要修改所有地方，代码也比较冗余!<br>而使用action creator，相当于对action做了简单的封装，避免了这些问题。既灵活又便于维护！</p><h5 id="异步action-creator"><a href="#异步action-creator" class="headerlink" title="异步action creator"></a>异步action creator</h5><p>我们已经知道，修改state的唯一方式就是触发action，也就是dispatch(action)。<br>但是如果是异步操作，比如一个网络请求，我们需要等到请求返回之后才会返回action，怎么办呢？<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateArticlesList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GET(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 难道直接return action？</span></span><br><span class="line">        <span class="comment">// 显然是不行的，这儿的返回值并不是updateArticlesList函数的返回值</span></span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于异步场景，我们的解决方案是返回函数而不是直接返回action。就像下面这样。<br>为了让dispatch方法可以接受函数作为参数，我们需要使用redux-thunk这个中间件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; rootReducer &#125; <span class="keyword">from</span> <span class="string">'./reducer.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    rootReducer,</span><br><span class="line">    applyMiddleware(thunk)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后你就可以dispatch一个函数了<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchArticlesList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 传入dispatch/getstate，当然是为了获取state以及更新state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GET(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            dispatch(updateArticlesList(</span><br><span class="line">                normalizeData,</span><br><span class="line">                lastkey</span><br><span class="line">            ));</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来有点迷糊？其实就是把异步请求抽象成action creator，然后放到了redux的代码中。<br>试想一下，如果没有这种方式，你会怎么去处理异步请求？<br>是不是会在组件或者页面中去发异步请求，然后在回调函数中dispatch(action)更新state。本质上也没太大区别。但是好处却是很明显的。</p><p>稍微提一下，如果我们可以使用async/await的话，异步action creator可以长得和同步action creator差不多。</p><p>action就是一坨数据，它并没有告诉Redux应该怎么去更新state，接下来介绍的reducer就是负责如何更新state这个工作的。</p><h5 id="reducer是什么鬼？"><a href="#reducer是什么鬼？" class="headerlink" title="reducer是什么鬼？"></a>reducer是什么鬼？</h5><p>action本身没有任何意义，就是一个描述性的普通对象。它并没有说明这个数据应该如何更新state。<br>具体如何更新state，是由reducer决定的。reducer的核心就一行代码：(state, action) =&gt; newstate<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="comment">// Action Handlers</span></span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="keyword">const</span> ACTION_HANDLERS = &#123;</span><br><span class="line">    [UPDATE_ARTICLES_DETAIL]: <span class="function">(<span class="params">articles, action</span>) =&gt;</span> articles,</span><br><span class="line">    [UPDATE_ARTICLES_LIST]: <span class="function">(<span class="params">articles, action</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> payload = action.payload,</span><br><span class="line">            normalizeData = payload.normalizeData,</span><br><span class="line">            list = articles.list.concat(normalizeData.result),</span><br><span class="line">            listLastkey = payload.listLastkey;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新articles.list字段和articles.lastkey字段</span></span><br><span class="line">        <span class="comment">// 这儿为什么不是state，而是articles呢？留着后文介绍</span></span><br><span class="line">        <span class="keyword">return</span> updateObject(articles, &#123;</span><br><span class="line">            list,</span><br><span class="line">            listLastkey</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="comment">// Reducer</span></span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">articlesReducer</span>(<span class="params">articles = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    list: [],</span></span></span><br><span class="line"><span class="function"><span class="params">    listLastkey: <span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = ACTION_HANDLERS[action.type]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler ? handler(articles, action) : articles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>reducer函数应该是纯函数，它要保证：只要传入参数相同，那么返回的新state就一定相同。<br>所以永远不要再reducer中做如下操作：<br>✦ 修改传入的state参数<br>✦ 执行有副作用的操作，比如API请求，路由跳转等<br>✦ 调用非纯函数，比如Math.random()或Date.now()</p><p>而一旦state变得复杂、层级较多的时候，如何设计reducer就是一个比较复杂的话题了。<br>关于如何设计state？如何分拆reducer？reducer之间如何共享数据？以及如何重构reducer的代码？可以移步另一篇博客：如何最佳实践的设计reducer。</p><p>那么，回到最初的话题，引入Redux到我们的应用中，到底有什么好处？我们为什么需要一个专门的状态管理器？</p><h3 id="为啥要使用redux？"><a href="#为啥要使用redux？" class="headerlink" title="为啥要使用redux？"></a>为啥要使用redux？</h3><p>早些时候，前端并没有这么复杂，几乎不怎么涉及数据管理。<br>随着前端的发展，前端也开始引入MVC之类的架构，对数据、视图、逻辑进行拆分处理。为了保持数据和视图的同步，我们会频繁的操作DOM元素。简直是噩梦。<br>而后KnockoutJS，angularJS等出现了，他们都支持数据绑定，终于让开发可以不在频繁的操作DOM，而是仅仅修改数据，然后自动同步到view。<br>但这还不够彻底，数据仍然是分散的。我们会在controller中写很多操作数据、操作视图的代码，甚至存在冗余数据，想要修改、更新、同步的话，有很大的隐患。<br>Redux的出现，提供了对数据的集中管理，让单向数据流成为了可能。<br>另外，Redux还让前后端彻底分离变成了可能，这一点也有极大的意义。</p><h3 id="Redux的数据流"><a href="#Redux的数据流" class="headerlink" title="Redux的数据流"></a>Redux的数据流</h3><p>Redux通过一些限制告诉你：数据只能保存在我这儿，别想太分散！想要修改数据？告诉我一个带新数据的action，我会通过reducer自动修改，然后返回修改后的数据给你！<br>是的，redux很想“数据库”，数据被集中存储，并且只能通过“预先定义的action操作”来修改。</p><p>更厉害的是，配上支持数据绑定的视图库，你会发现一个神奇的事情：<br>之前我们是面向view和controller编程，随着项目的复杂，代码会彼此影响而且数据会分散到各处。<br>而引入redux之后，我们单纯的面向数据编程即可，我们在Redux中统一的管理数据，然后数据变换会反映到view上，而数据上的交互，本质上也是触发了Redux中的action。如下图</p><h3 id="Redux数据流"><a href="#Redux数据流" class="headerlink" title="Redux数据流"></a>Redux数据流</h3><p>所以，设计redux程序的时候，提前想清楚state的结构尤其重要，就好比设计数据库表结构之于后台。</p><p>服务器渲染让前后端彻底分离成为了可能<br>上图也可以看出，Redux构建出一份单向数据流。这让服务端渲染变成了可能，而这个特性，让前后端彻底分离变成了可能，还不用担心SEO的问题。<br>想当初，为了解决前后端分离的问题，大家费尽心思，奈何进展甚微，淘宝甚至提出中途岛midway项目，通过中间搭建由前端维护的Nodejs服务器来实现简单的渲染然后返回HTML，但其实这个Nodejs服务器一点都不简单，需要考虑太多东西，比如安全、性能、缓存等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redux主要用于对数据进行集中管理，并且让整个应用的数据流变得清晰。让应用开发更流畅，数据管理更有效。有了Redux，开发者们慢慢的转化为面向数据编程，而不再是频繁的操作DOM，维护越来越复杂的controller逻辑。<br>简单来说，Redux的东西不多，更重要的是理解它的思路：<br>✦ 将整个应用的state储存在唯一的store对象中。<br>✦ state只能通过触发action来修改，其中action就是一个描述性的普通对象。<br>✦ 使用reducer来描述action如何改变state。<br>✦ Redux的单向数据流，可以实现服务端渲染，让前后端彻底分离成为可能，这个有里程碑的意义。<br>✦ Redux非常适合复杂的应用，尤其是多交互、多数据源的应用。</p><p>还是那句话，Redux将数据管理拆得很细，所以会有很多新东西去了解，但其实只要了解它的思想，其他的就很顺其自然了。</p><p>作者：齐修_qixiuss<br>链接：<a href="https://www.jianshu.com/p/d296a8c34936" target="_blank" rel="noopener">https://www.jianshu.com/p/d296a8c34936</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redux由Flux演变而来，提供几个简单的API来实现状态管理，所谓状态指的是应用数据，所以，Redux本质上是用来管理数据的。&lt;br&gt;进一步，Redux配合支持数据绑定的视图库使用，就可以将应用状态和视图一一对应，开发者不需要再去关心DOM操作，只关心如何组织数据即可。
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="https://ru23.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Module not found: Error: Cannot resolve module &#39;fs&#39; in</title>
    <link href="https://ru23.com//note/20180922/cjnk45sed0004s8a1m22cdkbp/"/>
    <id>https://ru23.com//note/20180922/cjnk45sed0004s8a1m22cdkbp/</id>
    <published>2018-09-22T10:32:13.000Z</published>
    <updated>2018-10-22T09:39:00.879Z</updated>
    
    <content type="html"><![CDATA[<p>控制台报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">However I see <span class="keyword">this</span> error</span><br><span class="line"></span><br><span class="line">./~<span class="regexp">/adal-node/</span>lib/util.js</span><br><span class="line">Module not found: <span class="built_in">Error</span>: Cannot resolve <span class="built_in">module</span> <span class="string">'fs'</span> <span class="keyword">in</span> /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib</span><br><span class="line">resolve <span class="built_in">module</span> fs <span class="keyword">in</span> /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib</span><br><span class="line">  looking <span class="keyword">for</span> modules <span class="keyword">in</span> /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib</span><br><span class="line">    /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib/fs doesn<span class="string">'t exist (module as directory)</span></span><br><span class="line"><span class="string">    resolve '</span>file<span class="string">' fs in /Users/luis.valencia/Documents/GraphSamples/Sample1/node_modules/adal-node/lib</span></span><br><span class="line"><span class="string">      resolve file</span></span><br></pre></td></tr></table></figure></p><p>解决方案：</p><p>add this to webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target: <span class="string">'node'</span>,</span><br></pre></td></tr></table></figure></p><p>原文：<a href="https://stackoverflow.com/questions/40541044/module-not-found-error-cannot-resolve-module-fs-in" target="_blank" rel="noopener">https://stackoverflow.com/questions/40541044/module-not-found-error-cannot-resolve-module-fs-in</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;控制台报错：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="npm" scheme="https://ru23.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JS 数组克隆方法总结</title>
    <link href="https://ru23.com//note/20180921/cjnk45sgp001ls8a1cvut6j3r/"/>
    <id>https://ru23.com//note/20180921/cjnk45sgp001ls8a1cvut6j3r/</id>
    <published>2018-09-21T11:22:37.000Z</published>
    <updated>2018-10-22T09:38:50.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES5-方法总结"><a href="#ES5-方法总结" class="headerlink" title="ES5 方法总结"></a>ES5 方法总结</h2><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">434</span>,<span class="number">43</span>]</span><br><span class="line"><span class="keyword">let</span> arr1= arr.slice()</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1) <span class="comment">// [ 2, 4, 434, 43 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=<span class="keyword">this</span>.length;i&lt;l;i++) &#123;</span><br><span class="line">        a.push(<span class="keyword">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'aaa'</span>,<span class="string">'bbb'</span>,<span class="string">'ccc'</span>,<span class="string">'wwwww'</span>,<span class="string">'ddd'</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.clone()</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"><span class="built_in">console</span>.log( arr2 === arr )</span><br></pre></td></tr></table></figure><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.clone=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> [].concat(<span class="keyword">this</span>); </span><br><span class="line">    <span class="comment">//或者 return this.concat();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'aaa'</span>,<span class="string">'asss'</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.clone()</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1)</span><br></pre></td></tr></table></figure><h2 id="ES6-方法总结"><a href="#ES6-方法总结" class="headerlink" title="ES6 方法总结"></a>ES6 方法总结</h2><h4 id="Object-assign-浅复制，也可以实现数组的克隆"><a href="#Object-assign-浅复制，也可以实现数组的克隆" class="headerlink" title="Object.assign() 浅复制，也可以实现数组的克隆"></a>Object.assign() 浅复制，也可以实现数组的克隆</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'sdsd'</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">123</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = []</span><br><span class="line"><span class="built_in">Object</span>.assign(arr1,arr)</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'aaaa'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1) <span class="comment">// [ 'sdsd', 'aaaa', 123, 123 ] [ 'sdsd', 123, 123, 123 ]</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line">a1[<span class="number">0</span>] = <span class="string">'aaa'</span></span><br><span class="line"><span class="built_in">console</span>.log(a1,a2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES5-方法总结&quot;&gt;&lt;a href=&quot;#ES5-方法总结&quot; class=&quot;headerlink&quot; title=&quot;ES5 方法总结&quot;&gt;&lt;/a&gt;ES5 方法总结&lt;/h2&gt;&lt;h4 id=&quot;slice&quot;&gt;&lt;a href=&quot;#slice&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js代码片段" scheme="https://ru23.com/tags/js%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>前端周刊-2018年09月第3周</title>
    <link href="https://ru23.com//note/20180921/cjnk45shl002hs8a1tdzdinxh/"/>
    <id>https://ru23.com//note/20180921/cjnk45shl002hs8a1tdzdinxh/</id>
    <published>2018-09-21T08:24:00.000Z</published>
    <updated>2018-10-22T09:40:47.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写「可读」代码的实践"><a href="#编写「可读」代码的实践" class="headerlink" title="编写「可读」代码的实践"></a><a href="http://taobaofed.org/blog/2017/01/05/writing-readable-code/" target="_blank" rel="noopener">编写「可读」代码的实践</a></h2><p><strong>链接:</strong><br><a href="http://taobaofed.org/blog/2017/01/05/writing-readable-code/" target="_blank" rel="noopener">http://taobaofed.org/blog/2017/01/05/writing-readable-code/</a></p><p><strong>摘要</strong><br>伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复打磨自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。</p><h2 id="React-Redux-组件化方案"><a href="#React-Redux-组件化方案" class="headerlink" title="React + Redux 组件化方案"></a><a href="http://imweb.io/topic/57c531bc6227a4f55a8872c2" target="_blank" rel="noopener">React + Redux 组件化方案</a></h2><p><strong>链接:</strong><br><a href="http://imweb.io/topic/57c531bc6227a4f55a8872c2" target="_blank" rel="noopener">http://imweb.io/topic/57c531bc6227a4f55a8872c2</a></p><p><strong>摘要</strong><br>组件化方案:理想中的组件化，第一步应该就是组件的标签化， 例如有一个 Header 组件，无需关注组件内部的实现，我们只需要使用一个 <header> 标签就能调用它，通过设置属性的方式，来控制它的显示的内容，和对应的事件。借助 jsx 语法，React 已经实现上述想法。<br>但是由于 React 的数据流向是单向的， 子组件的数据和方法只能由父级组件赋予，一旦组件嵌套层次变深，传递数据将会变得非常复杂。<br>redux 框架解决了这个问题，简单来说，它将 react 由父级传递数据，变为了由一个统一的数据源 store 单向地向各个组件传递数据。<br>所有数据都存放在 store 中，组件内部不维护任何数据。</header></p><p>store 提供了 dispatch 方法来触发改变 store 中数据。 dispatch 传入的值被称作 action。 dispatch(action) 之后，会进入到 store 中称为 reducer 的处理函数，这些 reducer 会依据不同的 action 的类型，进行不同的处理，reducer 返回的值就会作为 store 中新的数据，一个 reducer 对应的是 store 中一个数据字段，每多一个reducer， store 中就多一个数据字段。数据发生改变后， store 就会通知对应的组件重新渲染。</p><p>通过 redux 框架提供的 connect 高阶函数， 直接从 store 选取需要的数据和申明需要使用的方法传入组件中，这些申明的方法是组件事件具体的逻辑的实现，例如发送请求，上报逻辑等等，所以通常调用 dispatch(action) 的逻辑也会包含在里面。</p><h2 id="ANT-DESIGN-PRO-开箱即用的中台前端-设计解决方案"><a href="#ANT-DESIGN-PRO-开箱即用的中台前端-设计解决方案" class="headerlink" title="ANT DESIGN PRO-开箱即用的中台前端/设计解决方案"></a><a href="http://imweb.io/topic/57c531bc6227a4f55a8872c2" target="_blank" rel="noopener">ANT DESIGN PRO-开箱即用的中台前端/设计解决方案</a></h2><p><strong>链接:</strong><br><a href="https://github.com/ant-design/ant-design-pro?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/ant-design/ant-design-pro?utm_source=gold_browser_extension</a></p><p><strong>摘要</strong><br>💎 优雅美观：基于 Ant Design 体系精心设计；<br>📐 常见设计模式：提炼自中后台应用的典型页面和场景；<br>🚀 最新技术栈：使用 React/dva/antd 等前端前沿技术开发；<br>📱 响应式：针对不同屏幕大小设计；<br>🎨 主题：可配置的主题满足多样化的品牌诉求；<br>🌐 国际化：内建业界通用的国际化方案；<br>⚙️ 最佳实践：良好的工程实践助您持续产出高质量代码；<br>🔢 Mock 数据：实用的本地数据调试方案；<br>✅ UI 测试：自动化测试保障前端产品质量；</p><h2 id="实现一个完美符合Promise-A-规范的Promise"><a href="#实现一个完美符合Promise-A-规范的Promise" class="headerlink" title="实现一个完美符合Promise/A+规范的Promise"></a><a href="https://github.com/forthealllight/blog/issues/4" target="_blank" rel="noopener">实现一个完美符合Promise/A+规范的Promise</a></h2><p><strong>链接:</strong><br><a href="https://github.com/forthealllight/blog/issues/4" target="_blank" rel="noopener">https://github.com/forthealllight/blog/issues/4</a></p><p><strong>摘要</strong><br>Promise允许我们通过链式调用的方式来解决“回调地狱”的问题，特别是在异步过程中，通过Promise可以保证代码的整洁性和可读性。本文主要解读Promise/A+规范，并在此规范的基础上，自己实现一个Promise.</p><h2 id="Vue知识点整理"><a href="#Vue知识点整理" class="headerlink" title="Vue知识点整理"></a><a href="https://segmentfault.com/a/1190000016344599" target="_blank" rel="noopener">Vue知识点整理</a></h2><p><strong>链接</strong><br><a href="https://segmentfault.com/a/1190000016344599" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016344599</a></p><ul><li>对于MVVM的理解？</li></ul><p>Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。<br>View 代表UI 组件，它负责将数据模型转化成UI 展现出来。<br>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。<br>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><ul><li>Vue的生命周期（8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后)</li></ul><p>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。<br>beforeCreate（创建前） 在数据观测和初始化事件还未开始<br>created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来<br>beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。<br>mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。<br>beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br>updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br>beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。<br>destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p><ul><li><p>Vue实现数据双向绑定的原理：Object.defineProperty（）</p></li><li><p>Vue组件间的参数传递<br>1.父组件与子组件传值<br>父组件传给子组件：子组件通过props方法接受数据;<br>子组件传给父组件：$emit方法传递参数<br>2.非父子组件间的数据传递，兄弟组件传值<br>eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适</p></li><li><p>vue路由的钩子函数</p></li></ul><p>首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。</p><p>beforeEach主要有3个参数to，from，next：</p><p>to：route即将进入的目标路由对象，</p><p>from：route当前导航正要离开的路由</p><p>next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。</p><ul><li>vuex是什么？怎么使用？哪种功能场景使用它<br>只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。<br>在main.js引入store，注入。新建了一个目录store，….. export 。<br>场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编写「可读」代码的实践&quot;&gt;&lt;a href=&quot;#编写「可读」代码的实践&quot; class=&quot;headerlink&quot; title=&quot;编写「可读」代码的实践&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://taobaofed.org/blog/2017/01/05/writing
      
    
    </summary>
    
      <category term="前端周刊" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="分享" scheme="https://ru23.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>前端开发规范-used by frank</title>
    <link href="https://ru23.com//note/20180921/cjnk45sho002ls8a1bhunip6k/"/>
    <id>https://ru23.com//note/20180921/cjnk45sho002ls8a1bhunip6k/</id>
    <published>2018-09-21T08:20:34.000Z</published>
    <updated>2018-10-22T09:40:56.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js方法注释规范"><a href="#js方法注释规范" class="headerlink" title="js方法注释规范"></a>js方法注释规范</h3><h3 id="规范的注释很重要"><a href="#规范的注释很重要" class="headerlink" title="规范的注释很重要"></a>规范的注释很重要</h3><p>代码是写给人看的，顺便给机器运行，多谢注释可以增加代码的可读性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">**************</span></span><br><span class="line"><span class="comment"> * @func 教师端请假功能 ;</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; token 教师端头部的token;</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; a - 参数a;</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; b=1 - 参数b默认值为1;</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx;</span></span><br><span class="line"><span class="comment"> * @param &#123;object&#125; d - 参数d为一个对象;</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; d.e - 参数d的e属性;</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; d.f - 参数d的f属性;</span></span><br><span class="line"><span class="comment"> * @param &#123;object[]&#125; g - 参数g为一个对象数组;</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; g.h - 参数g数组中一项的h属性;</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; g.i - 参数g数组中一项的i属性;</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; [j] - 参数j是一个可选参数;</span></span><br><span class="line"><span class="comment"> * @description  2018年4月19日被frank开发于dev_sprint65分支，</span></span><br><span class="line"><span class="comment"> *   XX年XX月被XX在xx分支修改（原因或者修改的功能）;</span></span><br><span class="line"><span class="comment"> ****************/</span></span><br></pre></td></tr></table></figure><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><p>1.标准变量命名使用驼峰式命名           <code>eg. let thisIsMyName;</code><br>2.常量全部大写，并使用下划线连接       <code>eg.  const MAX_COUNT = 10;</code></p><h3 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h3><p><strong>变量声明尽量提在函数首部，用一个var声明，不允许出现连着的两个var声明(也包括let，const)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingWithItems</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// use one var</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">10</span>,</span><br><span class="line">        result = value + <span class="number">10</span>,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = items.length; i &lt; len; i++) &#123;</span><br><span class="line">        result += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>undefind使用规范（永远不要直接使用undefined进行变量判断，使用typeof和字符串’undefined’对变量进行判断。）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">if</span> (person === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> person === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用’===’和’!==’代替’==’, ‘!=’</strong><br><strong>使用对象的属性简写</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> job = <span class="string">'FrontEnd'</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> item = &#123;</span><br><span class="line">  job: job</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> item = &#123;</span><br><span class="line">  job</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用拓展运算符 … 复制数组</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> items = []</span><br><span class="line"><span class="keyword">const</span> itemsCopy = []</span><br><span class="line"><span class="keyword">const</span> len = items.length</span><br><span class="line"><span class="keyword">let</span> i</span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">itemsCopy = [...items]</span><br></pre></td></tr></table></figure></p><p><strong>render使用</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function">(<span class="params">h, params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'div'</span>, [</span><br><span class="line">        h(<span class="string">'span'</span>, &#123;</span><br><span class="line">            attrs: &#123;</span><br><span class="line">                class: "table_details"</span><br><span class="line">            &#125;,</span><br><span class="line">            on: &#123;</span><br><span class="line">                click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.edit(params.index)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,),</span><br><span class="line">        h(<span class="string">'span'</span>, &#123;</span><br><span class="line">            attrs: &#123;</span><br><span class="line">                class: "table_continue"</span><br><span class="line">            &#125;,</span><br><span class="line">            on: &#123;</span><br><span class="line">                click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.show(params.index)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,),</span><br><span class="line">        h(<span class="string">'span'</span>, &#123;</span><br><span class="line">            attrs: &#123;</span><br><span class="line">                class: "table_more no_border_right"</span><br><span class="line">            &#125;,</span><br><span class="line">            on: &#123;</span><br><span class="line">                click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.remove(params.row.id)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,),</span><br><span class="line">        h(<span class="string">'Poptip'</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                title:<span class="string">"项目变更"</span>,</span><br><span class="line">                content:<span class="string">"项目迁出"</span>,</span><br><span class="line">                placement:<span class="string">"bottom-end"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            on: &#123;</span><br><span class="line">                <span class="string">'on-ok'</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, [</span><br><span class="line">            h(<span class="string">'span'</span>, &#123;</span><br><span class="line">                attrs: &#123;</span><br><span class="line">                    class: "table_more no_border_right"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        ])</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文档：有时间整理一下<a href="http://taobaofed.org/blog/2017/01/05/writing-readable-code/" target="_blank" rel="noopener">http://taobaofed.org/blog/2017/01/05/writing-readable-code/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js方法注释规范&quot;&gt;&lt;a href=&quot;#js方法注释规范&quot; class=&quot;headerlink&quot; title=&quot;js方法注释规范&quot;&gt;&lt;/a&gt;js方法注释规范&lt;/h3&gt;&lt;h3 id=&quot;规范的注释很重要&quot;&gt;&lt;a href=&quot;#规范的注释很重要&quot; class=&quot;head
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端自动化" scheme="https://ru23.com/tags/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>VsCode读取项目文件的Eslint规则 保存时自动修复格式错误</title>
    <link href="https://ru23.com//note/20180917/cjnk45sh0001vs8a16l9esr3u/"/>
    <id>https://ru23.com//note/20180917/cjnk45sh0001vs8a16l9esr3u/</id>
    <published>2018-09-17T08:29:10.000Z</published>
    <updated>2018-10-22T09:39:56.933Z</updated>
    
    <content type="html"><![CDATA[<h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><h5 id="安装VsCode的EsLint和vetur插件"><a href="#安装VsCode的EsLint和vetur插件" class="headerlink" title="安装VsCode的EsLint和vetur插件"></a>安装VsCode的EsLint和vetur插件</h5><h5 id="为项目安装EsLint包"><a href="#为项目安装EsLint包" class="headerlink" title="为项目安装EsLint包"></a>为项目安装EsLint包</h5><p>注意要安装在开发环境上，还有就是如果你使用的是脚手架的话，选了Eslint选项，会自带这些包。</p><h5 id="在项目的根目录下添加-eslintrc-js"><a href="#在项目的根目录下添加-eslintrc-js" class="headerlink" title="在项目的根目录下添加.eslintrc.js"></a>在项目的根目录下添加.eslintrc.js</h5><p>用于校验代码格式，根据项目情况，可自行编写校验规则：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// Eslint规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首选项设置：<br>将下面这部分放入首选项设置中：</p><pre><code class="js"><span class="string">"eslint.autoFixOnSave"</span>: <span class="literal">true</span>,  <span class="comment">//  启用保存时自动修复,默认只支持.js文件</span><span class="string">"eslint.validate"</span>: [   <span class="string">"javascript"</span>,  <span class="comment">//  用eslint的规则检测js文件</span>   {     <span class="string">"language"</span>: <span class="string">"vue"</span>,   <span class="comment">// 检测vue文件</span>     <span class="string">"autoFix"</span>: <span class="literal">true</span>   <span class="comment">//  为vue文件开启保存自动修复的功能</span>   },   {     <span class="string">"language"</span>: <span class="string">"html"</span>,     <span class="string">"autoFix"</span>: <span class="literal">true</span>   }, ],</code></pre><h3 id="大功告成："><a href="#大功告成：" class="headerlink" title="大功告成："></a>大功告成：</h3><p>点开文件，你可能会看到如下报错，无需一个一个去改，只要保存一下文件，就可以自动修复这些代码格式上的问题了。</p><blockquote><p>注意：<br>如果整个文件都飘红的话，不会一次性修改如果的格式问题，会一下改一部分，你可能需要多按几次保存。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;配置：&quot;&gt;&lt;a href=&quot;#配置：&quot; class=&quot;headerlink&quot; title=&quot;配置：&quot;&gt;&lt;/a&gt;配置：&lt;/h4&gt;&lt;h5 id=&quot;安装VsCode的EsLint和vetur插件&quot;&gt;&lt;a href=&quot;#安装VsCode的EsLint和vetur插件&quot; c
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>前端周刊-2018年09月第2周</title>
    <link href="https://ru23.com//note/20180911/cjnk45shi002ds8a1zi8wh7w2/"/>
    <id>https://ru23.com//note/20180911/cjnk45shi002ds8a1zi8wh7w2/</id>
    <published>2018-09-11T08:18:25.000Z</published>
    <updated>2018-10-22T09:40:45.456Z</updated>
    
    <content type="html"><![CDATA[<h4 id="es6常用基础合集"><a href="#es6常用基础合集" class="headerlink" title="es6常用基础合集"></a><a href="https://www.jianshu.com/p/cfb0893c34f1" target="_blank" rel="noopener">es6常用基础合集</a></h4><h5 id="url-https-www-jianshu-com-p-cfb0893c34f1"><a href="#url-https-www-jianshu-com-p-cfb0893c34f1" class="headerlink" title="url:https://www.jianshu.com/p/cfb0893c34f1"></a>url:<a href="https://www.jianshu.com/p/cfb0893c34f1" target="_blank" rel="noopener">https://www.jianshu.com/p/cfb0893c34f1</a></h5><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h5><p>let,const<br>箭头函数<br>模板字符串<br>解析结构<br>函数默认参数<br>展开运算符<br>对象字面量与class<br>Promise</p><h4 id="ES6新特性概览"><a href="#ES6新特性概览" class="headerlink" title="ES6新特性概览"></a><a href="http://www.cnblogs.com/Wayou/p/es6_new_features.html" target="_blank" rel="noopener">ES6新特性概览</a></h4><h5 id="url：-http-www-cnblogs-com-Wayou-p-es6-new-features-html"><a href="#url：-http-www-cnblogs-com-Wayou-p-es6-new-features-html" class="headerlink" title="url： http://www.cnblogs.com/Wayou/p/es6_new_features.html"></a>url： <a href="http://www.cnblogs.com/Wayou/p/es6_new_features.html" target="_blank" rel="noopener">http://www.cnblogs.com/Wayou/p/es6_new_features.html</a></h5><h5 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点:"></a>知识点:</h5><p>箭头操作符<br>类的支持<br>增强的对象字面量<br>字符串模板<br>解构<br>参数默认值，不定参数，拓展参数<br>let与const 关键字<br>for of 值遍历<br>iterator, generator<br>模块<br>Map，Set 和 WeakMap，WeakSet<br>Proxies<br>Symbols<br>Math，Number，String，Object 的新API</p><h4 id="透彻掌握Promise的使用，读这篇就够了"><a href="#透彻掌握Promise的使用，读这篇就够了" class="headerlink" title="透彻掌握Promise的使用，读这篇就够了"></a><a href="https://www.jianshu.com/p/fe5f173276bd" target="_blank" rel="noopener">透彻掌握Promise的使用，读这篇就够了</a></h4><h5 id="url：https-www-jianshu-com-p-fe5f173276bd"><a href="#url：https-www-jianshu-com-p-fe5f173276bd" class="headerlink" title="url：https://www.jianshu.com/p/fe5f173276bd"></a>url：<a href="https://www.jianshu.com/p/fe5f173276bd" target="_blank" rel="noopener">https://www.jianshu.com/p/fe5f173276bd</a></h5><h5 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h5><p>实现方法<br>1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。<br>2.resolve。成功的执行方法<br>3.reject。失败的执行方法<br>4.catch。失败的捕获。<br>5.then。链式调用下一步。<br>原理：<br>内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">result: any;</span><br><span class="line">callbacks = [];</span><br><span class="line">failbacks = [];</span><br><span class="line"><span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">resolve(res) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.callbacks.length &gt; <span class="number">0</span>) <span class="keyword">this</span>.callbacks.shift()(res, <span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">reject(res) &#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks = [];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.failbacks.length &gt; <span class="number">0</span>) <span class="keyword">this</span>.failbacks.shift()(res, <span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (fn) &#123;</span><br><span class="line"><span class="keyword">this</span>.failbacks.push(fn);</span><br><span class="line">&#125;</span><br><span class="line">then(fn) &#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">resolve(<span class="string">"成功"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">reject(<span class="string">"失败"</span>)</span><br><span class="line">&#125;).</span><br><span class="line"><span class="keyword">catch</span> (<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>es6写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建promise</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 进行一些异步或耗时操作</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/*如果成功 */</span> ) &#123;</span><br><span class="line">        resolve(<span class="string">"Stuff worked!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="built_in">Error</span>(<span class="string">"It broke"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//绑定处理程序</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="comment">//promise成功的话会执行这里</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// "Stuff worked!"</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="comment">//promise失败会执行这里</span></span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// Error: "It broke"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="4-前端算法相关"><a href="#4-前端算法相关" class="headerlink" title="4.前端算法相关"></a>4.<a href="https://github.com/qianbin01/frontend_train#sort" target="_blank" rel="noopener">前端算法相关</a></h4><h5 id="url-https-github-com-qianbin01-frontend-train-sort"><a href="#url-https-github-com-qianbin01-frontend-train-sort" class="headerlink" title="url:https://github.com/qianbin01/frontend_train#sort"></a>url:<a href="https://github.com/qianbin01/frontend_train#sort" target="_blank" rel="noopener">https://github.com/qianbin01/frontend_train#sort</a></h5><h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><p>冒泡排序</p><blockquote><p>比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样</p></blockquote><p>快速排序:</p><blockquote><p> 1) 首先，在数组中选择一个中间项作为主元<br>2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到<br> 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作<br>3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成</p></blockquote><p>选择排序:</p><blockquote><p>大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)</p></blockquote><p>归并排序:</p><blockquote><p>归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)<br>归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组</p></blockquote><p>堆排序：</p><blockquote><p>堆排序把数组当中二叉树来排序而得名。<br>1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2<em>L；4）节点R的右子节点为2</em>R + 1<br>本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个</p></blockquote><h4 id="5-javaScript常用知识点"><a href="#5-javaScript常用知识点" class="headerlink" title="5.javaScript常用知识点"></a>5.<a href="https://github.com/qianbin01/frontend_train#javascript" target="_blank" rel="noopener">javaScript常用知识点</a></h4><h5 id="url-https-github-com-qianbin01-frontend-train-javascript"><a href="#url-https-github-com-qianbin01-frontend-train-javascript" class="headerlink" title="url: https://github.com/qianbin01/frontend_train#javascript"></a>url: <a href="https://github.com/qianbin01/frontend_train#javascript" target="_blank" rel="noopener">https://github.com/qianbin01/frontend_train#javascript</a></h5><h5 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h5><p>map,reduce,filter的用法<br>js数据类型(7种)</p><blockquote><p>1.number;<br>2.string;<br>3.boolean;<br>4.undefined;<br>5.null;<br>6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。<br>7.Object.（包括Object，Array，Function）<br>闭包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        alert(x + y + (++tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo(<span class="number">2</span>); <span class="comment">// bar 现在是一个闭包</span></span><br><span class="line">bar(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>结果是16<br>es6通常用let const块级作用域代替，<br>闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题</p><p>什么是立即执行函数？使用立即执行函数的目的是什么？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见两种方式</span></span><br><span class="line"><span class="number">1.</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)()</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;)(<span class="number">12345</span>)</span><br><span class="line"><span class="number">2.</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;())</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;(<span class="number">12345</span>))</span><br><span class="line"><span class="comment">//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如</span></span><br><span class="line">（<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;...&#125;(<span class="built_in">window</span>)）</span><br></pre></td></tr></table></figure></p><p>async/await 语法<br>深浅拷贝<br>数组去重<br>思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中<br>思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。<br>思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。<br>思路4（最常用）：使用es6 set<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)]);</span><br></pre></td></tr></table></figure></p><p>JS原型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;es6常用基础合集&quot;&gt;&lt;a href=&quot;#es6常用基础合集&quot; class=&quot;headerlink&quot; title=&quot;es6常用基础合集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.jianshu.com/p/cfb0893c34f1&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="前端周刊" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="分享" scheme="https://ru23.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>reactjs中事件传参(关于event)</title>
    <link href="https://ru23.com//note/20180910/cjnk45sh5001zs8a1e0kh3qqv/"/>
    <id>https://ru23.com//note/20180910/cjnk45sh5001zs8a1e0kh3qqv/</id>
    <published>2018-09-10T07:06:44.000Z</published>
    <updated>2018-10-22T09:39:47.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>我们在事件中通常需要获取控件的值，通常通过event.target.value的方式来取值，在绑定事件时，event参数也不需要传递，在方法中直接使用即可。<br>但是，有些时候需要传入一些其他的参数，比如需要循环绑定一些输入框，在绑定onChange事件时，需要传入索引index和数据源的索引进行对应<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">onHandleChange(index,event)&#123;</span><br><span class="line">    <span class="keyword">let</span> val=event.target.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关键代码</span></span><br><span class="line">source.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;item.name&#125;</span> </span></span></span><br><span class="line"><span class="xml">      onChange=&#123;this.onHandleChange.bind(this,index)&#125; /&gt;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml">```  </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### 代码解释</span></span><br><span class="line"><span class="xml">有的同学应该已经看出区别了，onHandleChange在声明时有两个参数，但在调用时却只传递了一个参数，这就是今天要讲的:</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">&gt; **在给方法传递新参数时，方法原有的参数会排在新参数之后**</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">做过reactjs的同学都知道，event这个参数是不需要手动传递的，直接在方法中声明就可以使用，如下代码：</span></span><br><span class="line"><span class="xml">```jsx</span></span><br><span class="line"><span class="xml">onChangeHandle(event)&#123;</span></span><br><span class="line"><span class="xml">      let val=event.target.value;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">render()&#123;</span></span><br><span class="line">  return (&lt;div&gt;</span><br><span class="line">    &lt;input type="text" onChange=&#123;this.onChangeHandle.bind(this)&#125; /&gt;</span><br><span class="line">&lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="摘自"><a href="#摘自" class="headerlink" title="摘自"></a>摘自</h4><blockquote><p>作者：不将就人生<br>链接：<a href="https://www.jianshu.com/p/1026d71d04d6" target="_blank" rel="noopener">https://www.jianshu.com/p/1026d71d04d6</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;我们在事件中通常需要获取控件的值，通常通过event.target.value的方式来取值，在绑定事件时，event参数也不
      
    
    </summary>
    
    
      <category term="react" scheme="https://ru23.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端开发周刊-(2018年09月第2周)</title>
    <link href="https://ru23.com//note/20180910/cjnk45sgm001is8a1eglacy6i/"/>
    <id>https://ru23.com//note/20180910/cjnk45sgm001is8a1eglacy6i/</id>
    <published>2018-09-10T03:48:21.000Z</published>
    <updated>2018-10-22T09:37:32.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="es6常用基础合集"><a href="#es6常用基础合集" class="headerlink" title="es6常用基础合集"></a><a href="https://www.jianshu.com/p/cfb0893c34f1" target="_blank" rel="noopener">es6常用基础合集</a></h4><h5 id="url-https-www-jianshu-com-p-cfb0893c34f1"><a href="#url-https-www-jianshu-com-p-cfb0893c34f1" class="headerlink" title="url:https://www.jianshu.com/p/cfb0893c34f1"></a>url:<a href="https://www.jianshu.com/p/cfb0893c34f1" target="_blank" rel="noopener">https://www.jianshu.com/p/cfb0893c34f1</a></h5><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h5><p>let,const<br>箭头函数<br>模板字符串<br>解析结构<br>函数默认参数<br>展开运算符<br>对象字面量与class<br>Promise</p><h4 id="ES6新特性概览"><a href="#ES6新特性概览" class="headerlink" title="ES6新特性概览"></a><a href="http://www.cnblogs.com/Wayou/p/es6_new_features.html" target="_blank" rel="noopener">ES6新特性概览</a></h4><h5 id="url：-http-www-cnblogs-com-Wayou-p-es6-new-features-html"><a href="#url：-http-www-cnblogs-com-Wayou-p-es6-new-features-html" class="headerlink" title="url： http://www.cnblogs.com/Wayou/p/es6_new_features.html"></a>url： <a href="http://www.cnblogs.com/Wayou/p/es6_new_features.html" target="_blank" rel="noopener">http://www.cnblogs.com/Wayou/p/es6_new_features.html</a></h5><h5 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点:"></a>知识点:</h5><p>箭头操作符<br>类的支持<br>增强的对象字面量<br>字符串模板<br>解构<br>参数默认值，不定参数，拓展参数<br>let与const 关键字<br>for of 值遍历<br>iterator, generator<br>模块<br>Map，Set 和 WeakMap，WeakSet<br>Proxies<br>Symbols<br>Math，Number，String，Object 的新API</p><h4 id="透彻掌握Promise的使用，读这篇就够了"><a href="#透彻掌握Promise的使用，读这篇就够了" class="headerlink" title="透彻掌握Promise的使用，读这篇就够了"></a><a href="https://www.jianshu.com/p/fe5f173276bd" target="_blank" rel="noopener">透彻掌握Promise的使用，读这篇就够了</a></h4><h5 id="url：https-www-jianshu-com-p-fe5f173276bd"><a href="#url：https-www-jianshu-com-p-fe5f173276bd" class="headerlink" title="url：https://www.jianshu.com/p/fe5f173276bd"></a>url：<a href="https://www.jianshu.com/p/fe5f173276bd" target="_blank" rel="noopener">https://www.jianshu.com/p/fe5f173276bd</a></h5><h5 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h5><p>实现方法<br>1.new Promise(fn),创建一个新的Promise对象并传入第一个执行方法。<br>2.resolve。成功的执行方法<br>3.reject。失败的执行方法<br>4.catch。失败的捕获。<br>5.then。链式调用下一步。<br>原理：<br>内部使用一个数组报错需要执行的所有方法，使用then来添加新的方法。旧的方法执行完毕之后检测数组，如果有新的就执行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">result: any;</span><br><span class="line">callbacks = [];</span><br><span class="line">failbacks = [];</span><br><span class="line"><span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">resolve(res) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.callbacks.length &gt; <span class="number">0</span>) <span class="keyword">this</span>.callbacks.shift()(res, <span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">reject(res) &#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks = [];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.failbacks.length &gt; <span class="number">0</span>) <span class="keyword">this</span>.failbacks.shift()(res, <span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (fn) &#123;</span><br><span class="line"><span class="keyword">this</span>.failbacks.push(fn);</span><br><span class="line">&#125;</span><br><span class="line">then(fn) &#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">resolve(<span class="string">"成功"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">reject(<span class="string">"失败"</span>)</span><br><span class="line">&#125;).</span><br><span class="line"><span class="keyword">catch</span> (<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>es6写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建promise</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 进行一些异步或耗时操作</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/*如果成功 */</span> ) &#123;</span><br><span class="line">        resolve(<span class="string">"Stuff worked!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="built_in">Error</span>(<span class="string">"It broke"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//绑定处理程序</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="comment">//promise成功的话会执行这里</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// "Stuff worked!"</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="comment">//promise失败会执行这里</span></span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// Error: "It broke"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="4-前端算法相关"><a href="#4-前端算法相关" class="headerlink" title="4.前端算法相关"></a>4.<a href="https://github.com/qianbin01/frontend_train#sort" target="_blank" rel="noopener">前端算法相关</a></h4><h5 id="url-https-github-com-qianbin01-frontend-train-sort"><a href="#url-https-github-com-qianbin01-frontend-train-sort" class="headerlink" title="url:https://github.com/qianbin01/frontend_train#sort"></a>url:<a href="https://github.com/qianbin01/frontend_train#sort" target="_blank" rel="noopener">https://github.com/qianbin01/frontend_train#sort</a></h5><h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><p>冒泡排序</p><blockquote><p>比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样</p></blockquote><p>快速排序:</p><blockquote><p> 1) 首先，在数组中选择一个中间项作为主元<br>2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到<br> 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作<br>3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成</p></blockquote><p>选择排序:</p><blockquote><p>大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)</p></blockquote><p>归并排序:</p><blockquote><p>归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)<br>归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组</p></blockquote><p>堆排序：</p><blockquote><p>堆排序把数组当中二叉树来排序而得名。<br>1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2<em>L；4）节点R的右子节点为2</em>R + 1<br>本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个</p></blockquote><h4 id="5-javaScript常用知识点"><a href="#5-javaScript常用知识点" class="headerlink" title="5.javaScript常用知识点"></a>5.<a href="https://github.com/qianbin01/frontend_train#javascript" target="_blank" rel="noopener">javaScript常用知识点</a></h4><h5 id="url-https-github-com-qianbin01-frontend-train-javascript"><a href="#url-https-github-com-qianbin01-frontend-train-javascript" class="headerlink" title="url: https://github.com/qianbin01/frontend_train#javascript"></a>url: <a href="https://github.com/qianbin01/frontend_train#javascript" target="_blank" rel="noopener">https://github.com/qianbin01/frontend_train#javascript</a></h5><h5 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h5><p>map,reduce,filter的用法<br>js数据类型(7种)</p><blockquote><p>1.number;<br>2.string;<br>3.boolean;<br>4.undefined;<br>5.null;<br>6.symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。<br>7.Object.（包括Object，Array，Function）<br>闭包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        alert(x + y + (++tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo(<span class="number">2</span>); <span class="comment">// bar 现在是一个闭包</span></span><br><span class="line">bar(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>结果是16<br>es6通常用let const块级作用域代替，<br>闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题</p><p>什么是立即执行函数？使用立即执行函数的目的是什么？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见两种方式</span></span><br><span class="line"><span class="number">1.</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)()</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;)(<span class="number">12345</span>)</span><br><span class="line"><span class="number">2.</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;())</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;(<span class="number">12345</span>))</span><br><span class="line"><span class="comment">//作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如</span></span><br><span class="line">（<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;...&#125;(<span class="built_in">window</span>)）</span><br></pre></td></tr></table></figure></p><p>async/await 语法<br>深浅拷贝<br>数组去重<br>思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中<br>思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。<br>思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。<br>思路4（最常用）：使用es6 set<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)]);</span><br></pre></td></tr></table></figure></p><p>JS原型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;es6常用基础合集&quot;&gt;&lt;a href=&quot;#es6常用基础合集&quot; class=&quot;headerlink&quot; title=&quot;es6常用基础合集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.jianshu.com/p/cfb0893c34f1&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="优质文章分享" scheme="https://ru23.com/categories/%E4%BC%98%E8%B4%A8%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="优质文章分享" scheme="https://ru23.com/tags/%E4%BC%98%E8%B4%A8%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS连接MySQL时遇到的问题 Error Connection lost The server closed the connection.</title>
    <link href="https://ru23.com//note/20180907/cjnk45sgw001ss8a146klkk2x/"/>
    <id>https://ru23.com//note/20180907/cjnk45sgw001ss8a146klkk2x/</id>
    <published>2018-09-07T07:54:30.000Z</published>
    <updated>2018-10-22T09:39:06.050Z</updated>
    
    <content type="html"><![CDATA[<p>今天用NodeJS连接Mysql时遇到点折磨人的问题，记录下解决方法。</p><p>NodeJS和Mysql都已经正确安装了，但是NodeJS和Mysql的连接出现问题，查找网上一些解决办法都不能解决问题。<br>报错如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45206239-1cfe7e80-b2b7-11e8-96d3-c104fa5c7b14.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><p>经过查找定位，在mysql官网找到了解决方案：</p><p><a href="https://dev.mysql.com/doc/dev/connector-nodejs/8.0/" target="_blank" rel="noopener">官网链接 》》MySQL Connector/Node.js</a><br>MySql 针对node的连接器对mysql的版本有要求，且需要另外的插件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45206324-520ad100-b2b7-11e8-8814-8d6d5b2fb7ae.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>然后下载的最新版的mysql mysql-installer-community-5.7.20.0.msi</p><p>执行 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br><span class="line"></span><br><span class="line">npm install @mysql/xdevapi</span><br></pre></td></tr></table></figure></p><p>运行<a href="https://github.com/mysqljs/mysql#introduction" target="_blank" rel="noopener">官方示例</a>，成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天用NodeJS连接Mysql时遇到点折磨人的问题，记录下解决方法。&lt;/p&gt;
&lt;p&gt;NodeJS和Mysql都已经正确安装了，但是NodeJS和Mysql的连接出现问题，查找网上一些解决办法都不能解决问题。&lt;br&gt;报错如下：&lt;br&gt;&lt;figure class=&quot;image
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://ru23.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记</title>
    <link href="https://ru23.com//note/20180907/cjnk45shr002ps8a1viws5ujp/"/>
    <id>https://ru23.com//note/20180907/cjnk45shr002ps8a1viws5ujp/</id>
    <published>2018-09-07T02:57:11.000Z</published>
    <updated>2018-10-22T09:41:14.615Z</updated>
    
    <content type="html"><![CDATA[<p>前言：大家好，我叫邵威儒，大家都喜欢喊我小邵，学的金融专业却凭借兴趣爱好入了程序猿的坑，从大学买的第一本vb和自学vb，我就与编程结下不解之缘，随后自学易语言写游戏辅助、交易软件，至今进入了前端领域，看到不少朋友都写文章分享，自己也弄一个玩玩，以下文章纯属个人理解，便于记录学习，肯定有理解错误或理解不到位的地方，意在站在前辈的肩膀，分享个人对技术的通俗理解，共同成长！</p><blockquote><p>后续我会陆陆续续更新javascript方面，尽量把javascript这个学习路径体系都写一下<br>包括前端所常用的es6、angular、react、vue、nodejs、koa、express、公众号等等<br>都会从浅到深，从入门开始逐步写，希望能让大家有所收获，也希望大家关注我~</p></blockquote><blockquote><p>文章列表：<a href="https://juejin.im/user/5a84f871f265da4e82634f2d/posts" target="_blank" rel="noopener">https://juejin.im/user/5a84f871f265da4e82634f2d/posts</a></p></blockquote><blockquote><p>Author: 邵威儒<br>Email: <a href="mailto:166661688@qq.com" target="_blank" rel="noopener">166661688@qq.com</a><br>Wechat: 166661688<br>github: <a href="https://github.com/iamswr/" target="_blank" rel="noopener">https://github.com/iamswr/</a></p></blockquote><hr><p>接下来我主要给大家讲下我对常用的es6的理解，我们工作当中，其实有很多用不上的，如果想详细了解的话可以看看阮一峰老师的es6：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a>  </p><p>这篇文章主要让你学会工作当中常用的es6技巧，以及扩展如实现数据双向绑定，class用es5如何实现、如何给伪数组添加迭代器等等。</p><hr><h1 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 1.var存在变量作用域的提升</span><br><span class="line">console.log(a) // 打印输出 undefined</span><br><span class="line">var a = 1</span><br><span class="line"></span><br><span class="line">// 怎么理解作用域的提升呢？</span><br><span class="line">// var str = &apos;hello swr&apos;</span><br><span class="line">// function()&#123;</span><br><span class="line">//     console.log(str) // 打印输出 undefined</span><br><span class="line">//     var str = &apos;goodbye swr&apos;</span><br><span class="line">// &#125;</span><br><span class="line">// test()</span><br><span class="line"></span><br><span class="line">// 上面这段代码实际上是</span><br><span class="line">var str = &apos;hello swr&apos;</span><br><span class="line">function()&#123;</span><br><span class="line">    var str</span><br><span class="line">    console.log(str) // 打印输出undefined</span><br><span class="line">                     // 实际上就是var声明的变量，拿到</span><br><span class="line">                     // 当前作用域的最顶层，而此时尚未赋值</span><br><span class="line">                     // 只是声明，所以打印出undefined，而非当运行</span><br><span class="line">                     // 到这段代码时才声明，优先声明，</span><br><span class="line">                     // 当运行到那行的时候，实际上是赋值</span><br><span class="line">                     // 同样的，function xx()&#123;&#125;也存在作用域提升</span><br><span class="line">    str = &apos;goodbye swr&apos;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">// var 不存在块级作用域的概念</span><br><span class="line">// 我的理解是在es6之前，是没有块级作用域的概念，</span><br><span class="line">// 变量只有遇到函数的时候才会变为局部变量</span><br><span class="line">&#123;</span><br><span class="line">    var str 1 = &apos;hello swr&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(str1) // 打印输出 hello swr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 2.let</span><br><span class="line">// 2.1 不存在变量作用域提升，这样可以避免了我们还没声明变量就拿变量来用</span><br><span class="line">// 2.2 同一作用域的同一个变量不能够重复声明，避免我们重复声明变量</span><br><span class="line">// 2.3 let声明的变量不会到全局上</span><br><span class="line">// 2.4 let和代码块&#123;&#125;结合使用会形成块级作用域</span><br><span class="line"></span><br><span class="line">// 2.1</span><br><span class="line">// console.log(a) // 报错，a未声明</span><br><span class="line">// let a = &apos;hello swr&apos;</span><br><span class="line"></span><br><span class="line">// 2.2</span><br><span class="line">// let a = &apos;hello swr&apos;</span><br><span class="line">// let a = &apos;hello swr&apos; // 报错，变量被重复声明</span><br><span class="line"></span><br><span class="line">// 2.3</span><br><span class="line">// let a = &apos;hello swr&apos;</span><br><span class="line">// console.log(window.a) // undefined</span><br><span class="line"></span><br><span class="line">// 2.4</span><br><span class="line">// 在代码块以外调用str2，会报错</span><br><span class="line">&#123;</span><br><span class="line">    let str2 = &apos;hello swr&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(str2) // 报错，未找到变量</span><br><span class="line"></span><br><span class="line">// 上面这种写法，也有点类型es6之前的立即执行函数</span><br><span class="line">(function()&#123;</span><br><span class="line">    var str2 = &apos;hello swr&apos;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 一个例子</span><br><span class="line">// 使用var，会发现最终console.log中打印的i都是3</span><br><span class="line">// 因为for循环不是函数，而此时var i是处于全局当中</span><br><span class="line">// for循环是同步代码，所以会执行完同步代码后</span><br><span class="line">// 再执行setTimeout的异步代码，此时i已为3，所以打印出来都是3</span><br><span class="line">for(var i = 0;i &lt; 3;i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 那么我们用let试下</span><br><span class="line">// let和代码块结合起来使用会形成块级作用域</span><br><span class="line">// 那么当for时，这3个setTimeout会分别在3个不同的块级作用域</span><br><span class="line">// 当执行setTimeout的console.log(i)时，会先寻找最近的块级作用域中的i</span><br><span class="line">// 所以会依次打印出0 1 2</span><br><span class="line">for(let j = 0;j &lt; 3;j++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 3.const</span><br><span class="line">// 3.1 const和let基本上可以说是完全一致的，但是const声明的对象不能更改其指向的引用地址（即堆区）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 3.1</span><br><span class="line">// 当用普通值赋值给const声明的变量后，再重新赋值时</span><br><span class="line">// 值引用会被更改，所以会报错</span><br><span class="line">const STR1 = &apos;hello swr&apos;</span><br><span class="line">STR1 = &apos;goodbye swr&apos; // 报错,Assignment to constant variable</span><br><span class="line"></span><br><span class="line">// 当我们修改这个引用地址里面的内容时，则不会报错</span><br><span class="line">// 因为这个变量是指向这个引用地址的</span><br><span class="line">const OBJ = &#123;name:&quot;swr&quot;&#125;</span><br><span class="line">OBJ.name = &apos;hello swr&apos;</span><br><span class="line">console.log(OBJ) // &#123;name:&quot;hello swr&quot;&#125;</span><br><span class="line">// 但是当我们把这个变量重新赋值一个引用地址时，则会报错</span><br><span class="line">OBJ = &#123;&#125; // 报错</span><br></pre></td></tr></table></figure><hr><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值主要分为对象的解构和数组的解构，在没有解构赋值的时候，我们赋值是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [0,1,2]</span><br><span class="line">let a = arr[0]</span><br><span class="line">let b = arr[1]</span><br><span class="line">let c = arr[2]</span><br></pre></td></tr></table></figure></p><p>这样写很繁琐，那么我们有没办法既声明，又赋值，更优雅的写法呢？肯定是有的，那就是解构赋值，解构赋值，简单理解就是等号的左边和右边相等。</p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [0,1,2]</span><br><span class="line">let [a,b,c] = arr</span><br><span class="line">console.log(a) // 0</span><br><span class="line">console.log(b) // 1</span><br><span class="line">console.log(c) // 2</span><br></pre></td></tr></table></figure><p>但是很多时候，数据并非一一对应的，并且我们希望得到一个默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [,1,2]</span><br><span class="line">let [a=&apos;我是默认值&apos;,b,c] = arr</span><br><span class="line">console.log(a) // &apos;我是默认值&apos;</span><br><span class="line">console.log(b) // 1</span><br><span class="line">console.log(c) // 2</span><br><span class="line">// 从这个例子可以看出，在解构赋值的过程中，a=undefined时，会使用默认值</span><br><span class="line">// 那么当a=null时呢？当a=null时，那么a就不会使用默认值，而是使用null</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 数组的拼接</span><br><span class="line">let a = [0,1,2]</span><br><span class="line">let b = [3,4,5]</span><br><span class="line">let c = a.concat(b)</span><br><span class="line">console.log(c) // [0,1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">let d = [...a,...b]</span><br><span class="line">console.log(d) // [0,1,2,3,4,5]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 数组的克隆</span><br><span class="line">// 假如我们简单地把一个数组赋值给另外一个变量</span><br><span class="line">let a = [0,1,2,3]</span><br><span class="line">let b = a</span><br><span class="line">b.push(4)</span><br><span class="line">console.log(a) // [0,1,2,3,4]</span><br><span class="line">console.log(b) // [0,1,2,3,4]</span><br><span class="line">// 因为这只是简单的把引用地址赋值给b，而不是重新开辟一个内存地址，所以</span><br><span class="line">// a和b共享了同一个内存地址，该内存地址的更改，会影响到所有引用该地址的变量</span><br><span class="line">// 那么用下面的方法，把数组进行克隆一份，互不影响</span><br><span class="line"></span><br><span class="line">let a = [0,1,2,3]</span><br><span class="line">let b = [...a]</span><br><span class="line">b.push(4)</span><br><span class="line">console.log(a) // [0,1,2,3]</span><br><span class="line">console.log(b) // [0,1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>对象的解构赋值和数组的解构赋值其实类似，但是数组的数组成员是有序的<br>而对象的属性则是无序的，所以对象的解构赋值简单理解是等号的左边和右边的结构相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;name,age&#125; = &#123;name:&quot;swr&quot;,age:28&#125;</span><br><span class="line">console.log(name) // &apos;swr&apos;</span><br><span class="line">console.log(age) // 28</span><br></pre></td></tr></table></figure></p><p>对象的解构赋值是根据key值进行匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里可以看出，左侧的name和右侧的name，是互相匹配的key值</span><br><span class="line">// 而左侧的name匹配完成后，再赋值给真正需要赋值的Name</span><br><span class="line">let &#123; name:Name,age &#125; = &#123; name:&apos;swr&apos;,age:28 &#125;</span><br><span class="line">console.log(Name) // &apos;swr&apos;</span><br><span class="line">console.log(age) // 28</span><br></pre></td></tr></table></figure></p><p>那么当变量已经被声明了呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let name,age</span><br><span class="line">// 需要用圆括号，包裹起来</span><br><span class="line">(&#123;name,age&#125; = &#123;name:&quot;swr&quot;,age:28&#125;)</span><br><span class="line">console.log(name) // &apos;swr&apos;</span><br><span class="line">console.log(age) // 28</span><br></pre></td></tr></table></figure></p><p>变量能否也设置默认值？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123;name=&quot;swr&quot;,age&#125; = &#123;age:28&#125;</span><br><span class="line">console.log(name) // &apos;swr&apos;</span><br><span class="line">console.log(age) // 28</span><br><span class="line">// 这里规则和数组的解构赋值一样，当name = undefined时，则会使用默认值</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let [a] = [&#123;name:&quot;swr&quot;,age:28&#125;]</span><br><span class="line">console.log(a) // &#123;name:&quot;swr&quot;,age:28&#125;</span><br><span class="line"></span><br><span class="line">let &#123; length &#125; = &quot;hello swr&quot;</span><br><span class="line">console.log(length) // 9</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function ajax(&#123;method,url,type=&apos;params&apos;&#125;)&#123;</span><br><span class="line">    console.log(method) // &apos;get&apos;</span><br><span class="line">    console.log(url) // &apos;/&apos;</span><br><span class="line">    console.log(type) // &apos;params&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;method:&quot;get&quot;,url:&quot;/&quot;&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>我们先看下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在以往，我们给函数传不确定参数数量时，是通过arguments来获取的</span><br><span class="line">function sum() &#123;</span><br><span class="line">  console.log(arguments) // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5, &apos;5&apos;: 6 &#125;</span><br><span class="line">                         // 我们可以看出，arguments不是一个数组，而是一个伪数组</span><br><span class="line">  let total = 0</span><br><span class="line">  let &#123; length &#125; = arguments</span><br><span class="line">  for(let i = 0;i &lt; length;i++)&#123;</span><br><span class="line">    total += arguments[i]</span><br><span class="line">  &#125;</span><br><span class="line">  return total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1,2,3,4,5,6)) // 21</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 接下来我们用扩展运算符看看</span><br><span class="line">function sum(...args)&#123; // 使用...扩展运算符</span><br><span class="line">    console.log(args) // [ 1, 2, 3, 4, 5, 6 ] args是一个数组</span><br><span class="line">    return eval(args.join(&apos;+&apos;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1,2,3,4,5,6)) // 21</span><br></pre></td></tr></table></figure><p>得到的args是一个数组，直接对数组进行操作会比对伪数组进行操作更加方便，还有一些注意点需要注意<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法 扩展运算符只能放在最后一个参数</span><br><span class="line">function sum(a,b,...args)&#123;</span><br><span class="line">    console.log(a) // 1</span><br><span class="line">    console.log(b) // 2</span><br><span class="line">    console.log(args) // [ 3, 4, 5, 6 ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1,2,3,4,5,6)</span><br><span class="line"></span><br><span class="line">// 错误的写法 扩展运算符只能放在最后一个参数</span><br><span class="line">function sum(...args,a,b)&#123;</span><br><span class="line">    // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1,2,3,4,5,6)</span><br></pre></td></tr></table></figure></p><p>我们可以对比下扩展运算符的方便之处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 以往我们是这样拼接数组的</span><br><span class="line">let arr1 = [1,2,3]</span><br><span class="line">let arr2 = [4,5,6]</span><br><span class="line">let arr3 = arr1.concat(arr2)</span><br><span class="line">console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ]</span><br><span class="line"></span><br><span class="line">// 现在我们用扩展运算符看看</span><br><span class="line">let arr1 = [1,2,3]</span><br><span class="line">let arr2 = [4,5,6]</span><br><span class="line">let arr3 = [...arr1,...arr2]</span><br><span class="line">console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 以往我们这样来取数组中最大的值</span><br><span class="line">function max(...args)&#123;</span><br><span class="line">    return Math.max.apply(null,args)</span><br><span class="line">&#125;</span><br><span class="line">console.log(max(1,2,3,4,5,6)) // 6</span><br><span class="line"></span><br><span class="line">// 现在我们用扩展运算符看看</span><br><span class="line">function max(...args)&#123;</span><br><span class="line">    return Math.max(...args) // 把args [1,2,3,4,5,6]展开为1,2,3,4,5,6</span><br><span class="line">&#125;</span><br><span class="line">console.log(max(1,2,3,4,5,6)) // 6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 扩展运算符可以把argument转为数组</span><br><span class="line">function max()&#123;</span><br><span class="line">    console.log(arguments) // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5, &apos;5&apos;: 6 &#125;</span><br><span class="line">    let arr = [...arguments]</span><br><span class="line">    console.log(arr) // [1,2,3,4,5,6]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max(1,2,3,4,5,6)</span><br><span class="line"></span><br><span class="line">// 但是扩展运算符不能把伪数组转为数组（除了有迭代器iterator的伪数组，如arguments）</span><br><span class="line">let likeArr = &#123; &quot;0&quot;:1,&quot;1&quot;:2,&quot;length&quot;:2 &#125;</span><br><span class="line">let arr = [...likeArr] // 报错 TypeError: likeArr is not iterable</span><br><span class="line"></span><br><span class="line">// 但是可以用Array.from把伪数组转为数组</span><br><span class="line">let likeArr = &#123; &quot;0&quot;:1,&quot;1&quot;:2,&quot;length&quot;:2 &#125;</span><br><span class="line">let arr = Array.from(likeArr)</span><br><span class="line">console.log(arr) // [1,2]</span><br></pre></td></tr></table></figure><p>对象也可以使用扩展运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 以往我们这样合并对象</span><br><span class="line">let name = &#123; name:&quot;邵威儒&quot; &#125;</span><br><span class="line">let age = &#123; age:28 &#125;</span><br><span class="line">let person = &#123;&#125;</span><br><span class="line">Object.assign(person,name,age)</span><br><span class="line">console.log(person) // &#123; name: &apos;邵威儒&apos;, age: 28 &#125;</span><br><span class="line"></span><br><span class="line">// 使用扩展运算符</span><br><span class="line">let name = &#123; name:&quot;邵威儒&quot; &#125;</span><br><span class="line">let age = &#123; age:28 &#125;</span><br><span class="line">let person = &#123;...name,...age&#125;</span><br><span class="line">console.log(person) // &#123; name: &apos;邵威儒&apos;, age: 28 &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，通过扩展运算符和Object.assign对对象进行合并的行为，是属于浅拷贝，那么我们在开发当中，经常需要对对象进行深拷贝，接下来我们看看如何进行深拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：利用JSON.stringify和JSON.parse</span><br><span class="line">let swr = &#123;</span><br><span class="line">    name:&quot;邵威儒&quot;,</span><br><span class="line">    age:28</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let swrcopy = JSON.parse(JSON.stringify(swr))</span><br><span class="line">console.log(swrcopy) // &#123; name:&quot;邵威儒&quot;,age:28 &#125;</span><br><span class="line">// 此时我们修改swr的属性</span><br><span class="line">swr.age = 29</span><br><span class="line">console.log(swr) // &#123; name:&quot;邵威儒&quot;,age:29 &#125;</span><br><span class="line">// 但是swrcopy却不会受swr影响</span><br><span class="line">console.log(swrcopy) // &#123; name:&quot;邵威儒&quot;,age:28 &#125;</span><br><span class="line">// 这种方式进行深拷贝，只针对json数据这样的键值对有效</span><br><span class="line">// 对于函数等等反而无效，不好用，接着继续看方法二、三。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 方法二：</span><br><span class="line">function deepCopy(fromObj,toObj) &#123; // 深拷贝函数</span><br><span class="line">  // 容错</span><br><span class="line">  if(fromObj === null) return null // 当fromObj为null</span><br><span class="line">  if(fromObj instanceof RegExp) return new RegExp(fromObj) // 当fromObj为正则</span><br><span class="line">  if(fromObj instanceof Date) return new Date(fromObj) // 当fromObj为Date</span><br><span class="line"></span><br><span class="line">  toObj = toObj || &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  for(let key in fromObj)&#123; // 遍历</span><br><span class="line">    if(typeof fromObj[key] !== &apos;object&apos;)&#123; // 是否为对象</span><br><span class="line">      toObj[key] = fromObj[key] // 如果为普通值，则直接赋值</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      toObj[key] = new fromObj[key].constructor // 如果为object，则new这个object指向的构造函数</span><br><span class="line">      deepCopy(fromObj[key],toObj[key]) // 递归</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return toObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog = &#123;</span><br><span class="line">  name:&quot;小白&quot;,</span><br><span class="line">  sex:&quot;公&quot;,</span><br><span class="line">  firends:[</span><br><span class="line">    &#123;</span><br><span class="line">      name:&quot;小黄&quot;,</span><br><span class="line">      sex:&quot;母&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dogcopy = deepCopy(dog)</span><br><span class="line">// 此时我们把dog的属性进行修改</span><br><span class="line">dog.firends[0].sex = &apos;公&apos;</span><br><span class="line">console.log(dog) // &#123; name: &apos;小白&apos;,</span><br><span class="line">                      sex: &apos;公&apos;,</span><br><span class="line">                      firends: [ &#123; name: &apos;小黄&apos;, sex: &apos;公&apos; &#125;] &#125;</span><br><span class="line">// 当我们打印dogcopy，会发现dogcopy不会受dog的影响</span><br><span class="line">console.log(dogcopy) // &#123; name: &apos;小白&apos;,</span><br><span class="line">                          sex: &apos;公&apos;,</span><br><span class="line">                          firends: [ &#123; name: &apos;小黄&apos;, sex: &apos;母&apos; &#125; ] &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 方法三：</span><br><span class="line">let dog = &#123;</span><br><span class="line">  name:&quot;小白&quot;,</span><br><span class="line">  sex:&quot;公&quot;,</span><br><span class="line">  firends:[</span><br><span class="line">    &#123;</span><br><span class="line">      name:&quot;小黄&quot;,</span><br><span class="line">      sex:&quot;母&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">  if(obj === null) return null</span><br><span class="line">  if(typeof obj !== &apos;object&apos;) return obj</span><br><span class="line">  if(obj instanceof RegExp) return new RegExp(obj)</span><br><span class="line">  if(obj instanceof Date) return new Date(obj)</span><br><span class="line">  let newObj = new obj.constructor</span><br><span class="line">  for(let key in obj)&#123;</span><br><span class="line">    newObj[key] = deepCopy(obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dogcopy = deepCopy(dog)</span><br><span class="line">dog.firends[0].sex = &apos;公&apos;</span><br><span class="line">console.log(dogcopy)</span><br></pre></td></tr></table></figure><hr><h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h1><p>Object.defineProperty这个并不是es6的语法，这个是给一个对象，添加属性，但是目前框架很多实用这个方法，来实现数据劫持，也就是数据双向绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 平时我们这样给一个对象添加属性</span><br><span class="line">let obj = &#123;str:&quot;hello swr&quot;&#125;</span><br><span class="line">obj.str = &apos;goodbye swr&apos;</span><br><span class="line">console.log(obj.str) // &apos;goodbye swr&apos;</span><br></pre></td></tr></table></figure><p>那么当我们想在给一个对象，读取值或写入值时，进行别的操作，该怎么做呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用Object.defineProperty()</span><br><span class="line">// 接收的第一个参数为对象，第二个参数为属性名，第三个参数为配置对象</span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">    enumerable:true,// 是否可枚举，默认值 true</span><br><span class="line">                    // 如果为false的话，打印这个obj对象，是看不到name这个属性</span><br><span class="line">    writable:true,  // 是否可写，默认值 true</span><br><span class="line">                    // 如果为false的话，给name赋值，不会生效</span><br><span class="line">    configurable:true, // 是否可配置（是否可删除），默认值 true</span><br><span class="line">                       // 如果为true，delete obj.name，再打印obj，则显示&#123;&#125;</span><br><span class="line">                       // 如果为false，delete obj.name，再打印obj,则显示&#123;name:undefined&#125;</span><br><span class="line">   value:&apos;swr&apos;, // name对应的值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 上面的写法其实和下面的写法是一样的</span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.name = &apos;swr&apos;</span><br></pre></td></tr></table></figure></p><p>那么既然一样，我们有必要写这么大串的代码吗？</p><p>其实核心是get和set，我们继续往下看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 需要注意的是，当使用get set时，则不能使用value和writable</span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">let str</span><br><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">    enumerable:true,</span><br><span class="line">    configurable:true, </span><br><span class="line">    get()&#123; // 读，当我们读取时，则会执行到get，比如obj.name</span><br><span class="line">        // return &apos;swr&apos; // 当我们obj.name进行读取时，会返回&apos;swr&apos;</span><br><span class="line">        return str</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue)&#123; // 写，当我们写入时，则会执行到set，比如obj.name = &apos;swr&apos;</span><br><span class="line">                   // 并且会把newValue作为参数传进去</span><br><span class="line">        str = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.name = &apos;swr&apos; // 写入</span><br><span class="line">console.log(obj.name) // &apos;swr&apos;  // 读取</span><br></pre></td></tr></table></figure></p><p>这样一来，我们可以在get set函数中，写出对应的业务逻辑，</p><p>包括很多框架底层，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 一般不再选择这样的写法</span><br><span class="line">Fn.prototype.xxx = xxx</span><br><span class="line"></span><br><span class="line">// 更多的是选择这样的写法</span><br><span class="line">// 这样的好处就是当读取值的时候，可以做一系列我们想做的事情</span><br><span class="line">Object.defineProperty(Fn.prototype,&apos;xxx&apos;,&#123;...&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="那么我们实现数据双向绑定呢？"><a href="#那么我们实现数据双向绑定呢？" class="headerlink" title="那么我们实现数据双向绑定呢？"></a>那么我们实现数据双向绑定呢？</h2><p>这个问题在面试当中，会经常问这个问题，但是面试官更希望听到的是具体底层的实现方式，那么接下来我们也实现一下吧~ （ 简陋版的……(#^.^#)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;对象的数据双向绑定&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input id=&apos;input&apos; type=&quot;&quot; name=&quot;&quot; value=&quot;&quot;&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    let el = document.getElementById(&apos;input&apos;) // 1. 获取输入框的dom节点</span><br><span class="line">    let obj = &#123; // 2. 创建一个对象</span><br><span class="line">      name: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function oberseve(obj) &#123; // 3. 对对象进行观察</span><br><span class="line">      if (typeof obj !== &apos;object&apos;) return // 3.1 判断参数是否为对象</span><br><span class="line">      for (let key in obj) &#123; // 3.2 对对象进行遍历，目的是为了把每个属性都设置get/set</span><br><span class="line">        defineReactive(obj, key, obj[key])</span><br><span class="line">        oberseve(obj[key]) // 3.3 obj[key] 有可能还是一个函数，需要递归，给obj[key]里的属性进行设置get/set</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function defineReactive(target, property, value) &#123; // 4. 使用Object.defineProperty</span><br><span class="line">      Object.defineProperty(target, property, &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">          el.value = value // 4.1 当读取时，把值赋值给input框</span><br><span class="line">          return value</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal) &#123;</span><br><span class="line">          el.value = newVal // 4.1 当设置时，把赋值给input框</span><br><span class="line">          value = newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oberseve(obj) // 5.执行该函数，对obj对象里的属性进行设置get/set</span><br><span class="line">    el.addEventListener(&apos;input&apos;, function () &#123; // 6.给输入框绑定input事件</span><br><span class="line">      obj.name = this.value // 7.当输入框输入内容时，我们会把输入框的</span><br><span class="line">                            //   内容赋值给obj.name，触发obj.name的set方法</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当我们在输入框输入内容时，再到控制台输入obj.name查看这个值时，会发现打印出”hello swr”</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/165667de41433ef6?w=736&amp;h=592&amp;f=png&amp;s=37794" alt=""></p><p>当我们在控制台，给obj.name赋值时，会发现输入框的内容也会作出相应更改</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/8/23/165667ee2ec6da30?w=590&h=504&f=png&s=39703" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这样我们就实现了一个简陋版的数据双向绑定了，但是这也是有缺点的，这个只是针对对象进行了数据双向绑定,而尤大大的Vuejs就是基于Object.defineProperty实现的。</p><p>除了Object.defineProperty可以实现数据双向绑定之外，还有其他方式吗？</p><p>肯定是有其他方式可以实现的，利用es6的proxy代理也可以实现数据双向绑定，但是目前的框架还是比较少使用这种方式。</p><hr><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy代理也可以进行数据劫持，但是和Object.defineProperty不同的是，Proxy是在数据外层套了个壳，然后通过这层壳访问内部的数据，目前Proxy支持13种方式。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/24/1656b6202ef1d745?w=1128&amp;h=1602&amp;f=png&amp;s=538332" alt=""></p><p>Proxy，我的理解是在数据外层套了个壳，然后通过这层壳访问内部的数据，就像下面的图</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16583897f9a176f8" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let dog = &#123;</span><br><span class="line">  name:&quot;小黄&quot;,</span><br><span class="line">  firends:[&#123;</span><br><span class="line">    name:&quot;小红&quot;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1.首先new一个Proxy对象</span><br><span class="line">let proxy = new Proxy(dog,&#123; // 2.参数一为需要代理的数据，参数二为上图可以代理的13种的配置对象</span><br><span class="line">    get(target,property)&#123; // 3.参数1为上面dog对象，参数2为dog的属性</span><br><span class="line">        console.log(&apos;get被监控到了&apos;)</span><br><span class="line">        return target[property]</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target,property,value)&#123; // 4.参数1为上面dog对象，参数2为dog的属性，参数3为设置的新值</span><br><span class="line">                                // 有点类似Object.defineProperty</span><br><span class="line">        console.log(&apos;set被监控到了&apos;)</span><br><span class="line">        target[property] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 那么接下来我们设置一下这个属性</span><br><span class="line">// dog.name = &apos;小红&apos;  // set值时，发现不会打印 &apos;set被监控到了&apos;</span><br><span class="line">// dog.name // get值时，发现不会打印 &apos;get被监控到了&apos;</span><br><span class="line"></span><br><span class="line">// 思考：为什么在set/get值的时候不会打印出来我们需要的东西呢？</span><br><span class="line"></span><br><span class="line">// 上面说得很明白了，proxy相当于是一个壳，代理我们需要监控的数据，也就是我们要通过proxy来访问内部数据才会被监控到</span><br><span class="line"></span><br><span class="line">proxy.name = &apos;小红&apos; // 打印输出 &apos;set被监控到了&apos;</span><br><span class="line">proxy.name // 打印输出 &apos;get被监控到了&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Reflect经常和Proxy搭配使用</span><br><span class="line">// 比如我们上面的例子中</span><br><span class="line">let proxy = new Proxy(dog,&#123; </span><br><span class="line">    get(target,property)&#123; </span><br><span class="line">        console.log(&apos;get被监控到了&apos;)</span><br><span class="line">        return target[property]</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target,property,value)&#123; </span><br><span class="line">        console.log(&apos;set被监控到了&apos;)</span><br><span class="line">        // target[property] = value </span><br><span class="line">        // 这里的target[property] = value 可以用下面的写法</span><br><span class="line">        Reflect.set(target,property,value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 那么我们该怎样实现深度的数据劫持呢？</span><br><span class="line">let dog = &#123;</span><br><span class="line">  name:&quot;小黄&quot;,</span><br><span class="line">  firend:&#123;</span><br><span class="line">    name:&quot;小红&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们首先写一个set方法，希望是通过这样来调用</span><br><span class="line">set(dog.firend,funtion(obj)&#123;</span><br><span class="line">    console.log(obj) // &#123; name:&quot;小红&quot; &#125;  回调函数中的obj代表的是dog.firend的对象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 实现</span><br><span class="line">let dog = &#123;</span><br><span class="line">  name:&quot;小黄&quot;,</span><br><span class="line">  firend:&#123;</span><br><span class="line">    name:&quot;小红&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function set(obj,callback)&#123;</span><br><span class="line">    let proxy = new Proxy(obj,&#123;</span><br><span class="line">        set(target,property,value)&#123;</span><br><span class="line">            target[property] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 最后把proxy传给我们的回调函数</span><br><span class="line">    callback(proxy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set(dog.firend,function(obj)&#123;</span><br><span class="line">    console.log(obj) // &#123; name:&quot;小红&quot; &#125; 实际就是从set函数中传出来的proxy对象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>在js中，常见的数据类型有undefined null string number boolean object，而es6中，则新增了第七种数据类型symbol。  </p><p>symbol会生成一个独一无二的值，为常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol()</span><br><span class="line">let s2 = Symbol()</span><br><span class="line">console.log(s1 === s2) // false</span><br><span class="line"></span><br><span class="line">// 因为Symbol生成的是一个独一无二的值，为常量，一般是作为对象的属性</span><br><span class="line">let obj = &#123;</span><br><span class="line">  [s1]:1,</span><br><span class="line">  [s2]:2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj) // &#123; [Symbol()]: 1, [Symbol()]: 2 &#125;</span><br></pre></td></tr></table></figure><p>Symbol.for与Symbol差不多，但是Symbol.for会生成一个唯一的标识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol.for(&apos;foo&apos;)</span><br><span class="line">let s2 = Symbol.for(&apos;foo&apos;)</span><br><span class="line">console.log(s1 === s2) // true</span><br><span class="line"></span><br><span class="line">// 也可以通过Symbol.keyFor把标识找出来</span><br><span class="line">console.log(Symbol.keyFor(s1)) // foo</span><br></pre></td></tr></table></figure><hr><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>Array的常用方法有from reduce map forEach findIndex find every some filter includes等等</p><p>用法也很简单，我主要讲一下from和reduce。</p><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p>把伪数组(包括不含有迭代器的伪数组)转化为数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个伪数组</span><br><span class="line">let likeArr = &#123; 0:1,1:2,2:3,length:3 &#125;</span><br><span class="line"></span><br><span class="line">// 转换为数组</span><br><span class="line">Array.from(likeArr) // [1,2,3]</span><br></pre></td></tr></table></figure><p>那么我们用前面所说的扩展运算符，能够把伪数组转为数组吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个伪数组</span><br><span class="line">let likeArr = &#123; 0:1,1:2,2:3,length:3 &#125;</span><br><span class="line"></span><br><span class="line">// 用扩展运算符转换为数组</span><br><span class="line">let arr = [...likeArr] // 报错 likeArr is not iterable</span><br></pre></td></tr></table></figure></p><p>likeArr is not iterable意思是，likeArr这个伪数组没有迭代器， </p><p>那么可以看出，Array.from和…扩展运算符的区别了，  </p><p>Array.from可以将伪数组（包含没有迭代器的伪数组）转为数组，  </p><p>而…扩展运算符只能把拥有迭代器的伪数组转为数组，如arguments、map、set，  </p><p>那么我们如果想用…扩展运算符转为数组，该怎么办呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 既然扩展运算符只能把有迭代器的伪数组转为数组，</span><br><span class="line">// 那么我们就给伪数组添加一个迭代器</span><br><span class="line">// 迭代器iterator需要一个generator生成器生成</span><br><span class="line">// 我们给这个伪数组新增一个[Symbol.iterator]的迭代器</span><br><span class="line">let likeArr = &#123; 0:1,1:2,2:3,length:3,[Symbol.iterator]:function *() &#123;</span><br><span class="line">  for(let i = 0;i &lt; this.length;i++)&#123;</span><br><span class="line">    yield this[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br><span class="line">console.log([...likeArr]) // [1,2,3]</span><br></pre></td></tr></table></figure></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">// 参数一：前一个值</span><br><span class="line">// 参数二：下一个值（当前值）</span><br><span class="line">// 参数三：当前的索引</span><br><span class="line">// 参数四：arr数组</span><br><span class="line">let total = arr.reduce(function(prev,next,currentIndex,arr)&#123;</span><br><span class="line">    return prev + next</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(total) // 15</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 那么reduce是怎样一个运行流程呢？</span><br><span class="line">// 我们一步步拆解出来看</span><br><span class="line">let arr = [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">// arr会一直是[1,2,3,4,5]</span><br><span class="line">// 第一步：此时的prev为1，next为2，currentIndex为1</span><br><span class="line">let total = arr.reduce(function(prev,next,currentIndex,arr)&#123;</span><br><span class="line">    return prev + next // 1+2=3   并且把3当做下一次的prev</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 第二步：此时的prev为3，next为3，currentIndex为2</span><br><span class="line">let total = arr.reduce(function(prev,next,currentIndex,arr)&#123;</span><br><span class="line">    return prev + next // 3+3=6   并且把6当做下一次的prev</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 第三步：此时的prev为6，next为4，currentIndex为3</span><br><span class="line">let total = arr.reduce(function(prev,next,currentIndex,arr)&#123;</span><br><span class="line">    return prev + next // 6+4=10   并且把10当做下一次的prev</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 第四步：此时的prev为10，next为5，currentIndex为4</span><br><span class="line">let total = arr.reduce(function(prev,next,currentIndex,arr)&#123;</span><br><span class="line">    return prev + next // 10+5=15 最终结果会作为返回值返回</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那我们自己实现一个reduce，看看是如何实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce = function (callback) &#123;</span><br><span class="line">  let prev = this[0]</span><br><span class="line">  for(let i = 0;i &lt; this.length-1;i++)&#123;</span><br><span class="line">    prev = callback(prev,this[i+1],i+1,this)</span><br><span class="line">  &#125;</span><br><span class="line">  return prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [1,2,3,4,5]</span><br><span class="line">let total = arr.myReduce(function(prev,next,currentIndex,arr)&#123;</span><br><span class="line">  console.log(prev,next)</span><br><span class="line">  return prev + next</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(total) // 15</span><br></pre></td></tr></table></figure></p><h3 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h3><p>可以把数组返回成一个映射后的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3].map(item =&gt; item+1)</span><br><span class="line">console.log(arr) // [2,3,4]</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找，查找到后不再继续查找，查找不到则返回undefined，内部返回true的话，则返回当前item，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4]</span><br><span class="line"></span><br><span class="line">let val = arr.find(item=&gt;item === 3)</span><br><span class="line">console.log(val) // 3</span><br></pre></td></tr></table></figure></p><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>每个值是否满足条件，如果是则返回true，如果不是则返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4]</span><br><span class="line">let isTrue = arr.every(item =&gt; &#123;</span><br><span class="line">    return item &gt; 0</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(isTrue) // true</span><br><span class="line"></span><br><span class="line">let isTrue2 = arr.every(item =&gt; &#123;</span><br><span class="line">    return item &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(isTrue2) // false</span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>是否有其中一个值满足条件，如果是则返回true，如果不是则返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4]</span><br><span class="line">let isTrue = arr.every(item =&gt; &#123;</span><br><span class="line">    return item &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(isTrue) // true</span><br><span class="line"></span><br><span class="line">let isTrue2 = arr.every(item =&gt; &#123;</span><br><span class="line">    return item &gt; 4</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(isTrue2) // false</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>过滤，在回调函数中返回的为false的话，相当于过滤掉当前项，返回一个过滤后的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4]</span><br><span class="line"></span><br><span class="line">let newArr = arr.filter(item=&gt;&#123;</span><br><span class="line">  return item &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(newArr) // [3,4]</span><br></pre></td></tr></table></figure><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>基本和some一样</p><hr><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>set是放不重复的项，也就是去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1,2,3,4,3,2,1])</span><br><span class="line">console.log(set) // Set &#123; 1, 2, 3, 4 &#125;</span><br></pre></td></tr></table></figure><p>Set有几个常用的方法，add clear delete entries</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// add</span><br><span class="line">let set = new Set([1,2,3,4,3,2,1])</span><br><span class="line">set.add(5)</span><br><span class="line">console.log(set) // Set &#123; 1, 2, 3, 4, 5 &#125;</span><br><span class="line"></span><br><span class="line">// 添加一个已有的值，则不会添加进去</span><br><span class="line">set.add(1)</span><br><span class="line">console.log(set) // Set &#123; 1, 2, 3, 4, 5 &#125;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">set.delete(3)</span><br><span class="line">console.log(set) // Set &#123; 1, 2, 4, 5 &#125;</span><br><span class="line"></span><br><span class="line">// entries</span><br><span class="line">console.log(set.entries()) // SetIterator &#123; [ 1, 1 ],</span><br><span class="line">                                            [ 2, 2 ],</span><br><span class="line">                                            [ 4, 4 ], </span><br><span class="line">                                            [ 5, 5 ] &#125;</span><br><span class="line"></span><br><span class="line">// clear</span><br><span class="line">set.clear()</span><br><span class="line">console.log(set) // Set &#123;&#125;</span><br></pre></td></tr></table></figure><p>Set常用于去重（并集）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function distinct(arr1,arr2)&#123;</span><br><span class="line">    return [...new Set([...arr1,...arr2])]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = distinct([1,2,3],[2,3,4,5])</span><br><span class="line">console.log(arr) // [1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>求交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function intersect(arr1,arr2) &#123;</span><br><span class="line">  // 利用Set里的方法has，来判断new Set(arr2)中是否含有item，</span><br><span class="line">  // 如果含有，那么则是true，当为true时，filter函数则会保留该项</span><br><span class="line">  // 如果没有，则是false,当为false时，filter函数则不会保留该项</span><br><span class="line">  return arr1.filter(item =&gt; new Set(arr2).has(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(intersect([1,2,3],[2,3,4,5])) // [2,3]</span><br></pre></td></tr></table></figure><p>求差集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function difference(arr1,arr2)&#123;</span><br><span class="line">    return arr1.filter(item =&gt; !new Set(arr2).has(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(difference([1,2,3],[2,3,4,5])) // [1]</span><br></pre></td></tr></table></figure><hr><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>也是集合，主要格式是 key =&gt; value，同样是不能放重复的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 如果放重复的key会怎样呢？会被覆盖</span><br><span class="line">let map = new Map()</span><br><span class="line">map.set(&apos;name&apos;,&apos;邵威儒&apos;)</span><br><span class="line">map.set(&apos;name&apos;,&apos;swr&apos;)</span><br><span class="line">console.log(map) // Map &#123; &apos;name&apos; =&gt; &apos;swr&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 取的话用get</span><br><span class="line">map.get(&apos;name&apos;) // &apos;swr&apos;</span><br><span class="line"></span><br><span class="line">// 删的话用delete</span><br><span class="line">map.delete(&apos;name&apos;)</span><br><span class="line">console.log(map) // Map &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 很多方法和set差不多</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map()</span><br><span class="line">map.set(&apos;name&apos;,&apos;邵威儒&apos;)</span><br><span class="line">map.set(&apos;age&apos;,28)</span><br><span class="line">// 一般使用for ... of ... 遍历</span><br><span class="line">for(let [key,value] of map.entries())&#123;</span><br><span class="line">    console.log(key,value) // name 邵威儒</span><br><span class="line">                           // age 28</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可以用forEach</span><br><span class="line">map.forEach(item =&gt; &#123;</span><br><span class="line">    console.log(item) // 邵威儒</span><br><span class="line">                      // 28</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Set我用得最多的就是去重了，实际上Set Map我在开发中还是比较少会用到</p><hr><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>核心还是继承，而Class我认为是es5面向对象的语法糖。</p><p>在看Class之前建议看一下js的面向对象 <a href="https://juejin.im/post/5b8a8724f265da435450c591" target="_blank" rel="noopener">https://juejin.im/post/5b8a8724f265da435450c591</a></p><p>看完后，我们开始进入es6的class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">// 声明一个类</span><br><span class="line">Class Person&#123; </span><br><span class="line">    // 在constructor中写实例属性、方法</span><br><span class="line">    constructor()&#123; </span><br><span class="line">        this.name = &quot;邵威儒&quot; // 实例属性</span><br><span class="line">        this.say = function()&#123; // 实例方法</span><br><span class="line">            console.log(&quot;我是实例方法上的say&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&quot;我是原型方法上的eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 静态方法 也会被继承</span><br><span class="line">    static myName()&#123; </span><br><span class="line">        return &quot;我是静态方法的myName&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 在es6中静态属性不能这样写 static name = &quot;邵威儒&quot;  这样会报错</span><br><span class="line">    // 在es7中可以这样写static name = &quot;邵威儒&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person() // new一个对象</span><br><span class="line">console.log(p.name) // 邵威儒</span><br><span class="line">p.eat() // 我是原型方法上的eat</span><br><span class="line">console.log(Person.myName()) // 我是静态方法的myName</span><br></pre></td></tr></table></figure><p>那么子类怎么继承父类呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = &quot;swr&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    static myName()&#123;</span><br><span class="line">        return &quot;Person&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&apos;eat&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">// 子类Child继承父类Person</span><br><span class="line">// class Child extends Person实际上相当于</span><br><span class="line">// Child.prototype = Object.create(Person.prototype)</span><br><span class="line">// 打印出来可以看到</span><br><span class="line">// console.log(Child.prototype === Person.prototype) // false</span><br><span class="line">// console.log(Child.prototype.__proto__ === Person.prototype) // true</span><br><span class="line">class Child extends Person&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super() // 此处的super相当于Person.call(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我说了Class就类型es5面向对象的语法糖，为什么这样说呢？</p><p>接下来我们看一下通过es5怎么模拟实现一个Class（可以用babel转一下，看看转为es5的代码是怎样的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let Child = (function()&#123;</span><br><span class="line">    // 这种闭包的写法，好处可以把作用域封闭起来 </span><br><span class="line">    // 在Child构造函数外写一系列变量</span><br><span class="line">    // 如 let name = &quot;邵威儒&quot;;let age = 28 等等…</span><br><span class="line">    function Child()&#123;</span><br><span class="line">        console.log(this) // 打印内部this，看看指向哪里</span><br><span class="line">    &#125;</span><br><span class="line">    return Child</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 通过直接调用函数，看看什么情况</span><br><span class="line">console.log(Child()) // 此时里面的this是指向全局的</span><br><span class="line"></span><br><span class="line">// 通过new来生成对象</span><br><span class="line">console.log(new Child()) // 此时里面的this是指向这个new出来的新对象</span><br></pre></td></tr></table></figure><p>在es6中，不使用new来调用类，会报错 <code>Class constructor Child cannot be invoked without &#39;new&#39;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Child &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child() // TypeError: Class constructor Child cannot be invoked without &apos;new&apos;</span><br></pre></td></tr></table></figure><p>也就是说，想在es5中，模拟类，那么没使用new来调用构造函数时，也要抛出一个错误，那么我们会想到类的校验方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// * 1.声明一个类的校验方法</span><br><span class="line">// *   参数一：指向的构造函数</span><br><span class="line">// *   参数二：被调用时，this的指向</span><br><span class="line">function _classCallCheck(constructor,instance) &#123;</span><br><span class="line">  // * 2.如果这个instance指向的不是constructor的话，意味着不是通过new来调用构造函数</span><br><span class="line">  if(!(instance instanceof constructor))&#123;</span><br><span class="line">    // * 3.不满足时，则抛出异常</span><br><span class="line">    throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Child = (function()&#123;</span><br><span class="line">  function Child()&#123;</span><br><span class="line">    // * 4.在调用该构造函数的时候，先执行以下类的校验方法</span><br><span class="line">    _classCallCheck(Child,this)</span><br><span class="line">  &#125;</span><br><span class="line">  return Child</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 不通过new调用时，会报错</span><br><span class="line">Child() // 报错 Class constructor Child cannot be invoked without &apos;new&apos;</span><br></pre></td></tr></table></figure><p>那么我们类上，有实例属性方法、原型属性方法、静态属性方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">function _classCallCheck(constructor,instance) &#123;</span><br><span class="line">  if(!(instance instanceof constructor))&#123;</span><br><span class="line">    throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// * 4.描述器 descriptor</span><br><span class="line">//     参数一：构造函数</span><br><span class="line">//     参数二：描述原型属性方法数组</span><br><span class="line">//     参数三：描述静态属性方法数组</span><br><span class="line">function _createClass(constructor,protoProperties,staticProperties) &#123;</span><br><span class="line">  // * 5.如果protoProperties数组有数组成员</span><br><span class="line">  if(protoProperties.length)&#123;</span><br><span class="line">    // * 6.遍历</span><br><span class="line">    for(let i = 0;i &lt; protoProperties.length;i++)&#123;</span><br><span class="line">      // * 7.通过Object.defineProperty把属性方法添加到constructor的原型对象上</span><br><span class="line">      Object.defineProperty(constructor.prototype,protoProperties[i].key,&#123;</span><br><span class="line">        // * 8.利用扩展运算符，把&#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;展开</span><br><span class="line">        ...protoProperties[i]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// * 1.实例属性方法、原型属性方法、静态属性方法</span><br><span class="line">//     在es6中，原型属性方法不是通过prototype实现的</span><br><span class="line">//     而是通过一个叫描述器的东西实现的</span><br><span class="line">let Child = (function()&#123;</span><br><span class="line">  function Child()&#123;</span><br><span class="line">    _classCallCheck(Child,this)</span><br><span class="line">    // * 2.实例属性方法还是写在构造函数内</span><br><span class="line">    this.name = &apos;邵威儒&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  // * 3.描述器 descriptor</span><br><span class="line">  //     参数一：构造函数</span><br><span class="line">  //     参数二：描述原型属性方法</span><br><span class="line">  //     参数三：描述静态属性方法</span><br><span class="line">  _createClass(Child,</span><br><span class="line">    [</span><br><span class="line">      &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;,</span><br><span class="line">      &#123;key:&quot;myname&quot;,value:&quot;iamswr&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125;</span><br><span class="line">    ])</span><br><span class="line">  return Child</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// * 9.最后我们new一个对象出来，并且调用原型属性方法，看能否调用成功</span><br><span class="line">let c = new Child()</span><br><span class="line">c.say() // &apos;hello swr&apos;    调用成功</span><br></pre></td></tr></table></figure><p>接下来，我们把静态方法，staticProperties也处理一下，<br>此时会发现，protoProperties和staticProperties都会遍历然后使用Object.defineProperty<br>那么我们封装一个方法进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function _classCallCheck(constructor,instance) &#123;</span><br><span class="line">  if(!(instance instanceof constructor))&#123;</span><br><span class="line">    throw TypeError(&quot;Class constructor Child cannot be invoked without &apos;new&apos;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// * 1.封装一个方法，处理遍历和Object.defineProperty</span><br><span class="line">function _defineProperty(target,properties) &#123;</span><br><span class="line">  for (let i = 0; i &lt; properties.length; i++) &#123;</span><br><span class="line">    Object.defineProperty(target, properties[i].key, &#123;</span><br><span class="line">      ...properties[i]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _createClass(constructor,protoProperties,staticProperties) &#123;</span><br><span class="line">  if(protoProperties.length)&#123;</span><br><span class="line">    _defineProperty(constructor.prototype, protoProperties)</span><br><span class="line">  &#125;</span><br><span class="line">  // * 2.如果staticProperties数组有数组成员</span><br><span class="line">  if(staticProperties.length)&#123;</span><br><span class="line">    // * 3.静态方法需要添加在constructor</span><br><span class="line">    _defineProperty(constructor, staticProperties)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Child = (function()&#123;</span><br><span class="line">  function Child()&#123;</span><br><span class="line">    _classCallCheck(Child,this)</span><br><span class="line">    this.name = &apos;邵威儒&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  _createClass(Child,</span><br><span class="line">    [</span><br><span class="line">      &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;hello swr&quot;)&#125;&#125;,</span><br><span class="line">      &#123;key:&quot;myname&quot;,value:&quot;iamswr&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125;</span><br><span class="line">    ])</span><br><span class="line">  return Child</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let c = new Child()</span><br><span class="line">c.say()</span><br><span class="line">// * 4.最后我们通过Child来调用静态方法</span><br><span class="line">console.log(Child.total())  // 100</span><br></pre></td></tr></table></figure></p><p>这样完成了一个雏形，但是还有最重要的继承还没实现，接下来我们实现继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">function _classCallCheck(constructor,instance) &#123;</span><br><span class="line">  if(!(instance instanceof constructor))&#123;</span><br><span class="line">    throw TypeError(&quot;Class constructor Parent cannot be invoked without &apos;new&apos;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function defineProperty(target,properties) &#123;</span><br><span class="line">  for (let i = 0; i &lt; properties.length; i++) &#123;</span><br><span class="line">    Object.defineProperty(constructor.prototype, properties[i].key, &#123;</span><br><span class="line">      ...properties[i]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _createClass(constructor,protoProperties,staticProperties) &#123;</span><br><span class="line">  if(protoProperties.length)&#123;</span><br><span class="line">    defineProperty(constructor.prototype, protoProperties)</span><br><span class="line">  &#125;</span><br><span class="line">  if(staticProperties.length)&#123;</span><br><span class="line">    defineProperty(constructor, staticProperties)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// * 6.继承方法</span><br><span class="line">function _inherits(subClass, superClass) &#123;</span><br><span class="line">  if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123;</span><br><span class="line">    throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // * 7.把子类的原型对象指向新的原型对象 组合寄生式继承 继承原型属性方法</span><br><span class="line">  subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">      value: subClass, // 把constructor指向子类</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: true,</span><br><span class="line">      configurable: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // * 8.继承父类的静态方法</span><br><span class="line">  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _possibleConstructorReturn(self, call) &#123;</span><br><span class="line">  if (!self) &#123;</span><br><span class="line">    throw new ReferenceError(&quot;this hasn&apos;t been initialised - super() hasn&apos;t been called&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// * 1.父类</span><br><span class="line">let Parent = (function()&#123;</span><br><span class="line">  function Parent()&#123;</span><br><span class="line">    _classCallCheck(Parent,this)</span><br><span class="line">    this.name = &apos;父类实例属性&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  _createClass(Parent,</span><br><span class="line">    [</span><br><span class="line">      &#123;key:&quot;say&quot;,value:function()&#123;console.log(&quot;父类原型方法say&quot;)&#125;&#125;,</span><br><span class="line">      &#123;key:&quot;myname&quot;,value:&quot;父类原型属性myname&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      &#123;key:&quot;total&quot;,value:function()&#123;return 100&#125;&#125;</span><br><span class="line">    ])</span><br><span class="line">  return Parent</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// * 2.子类</span><br><span class="line">let Child = (function (Parent) &#123; // * 4.这里接收传进的参数 父类</span><br><span class="line">  // * 5.写一个继承方法，继承原型属性方法和静态方法</span><br><span class="line">  _inherits(Child, Parent);</span><br><span class="line">  function Child() &#123;</span><br><span class="line">    _classCallCheck(Child, this)</span><br><span class="line">    // * 9.继承实例属性方法</span><br><span class="line">    return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));</span><br><span class="line">  &#125;</span><br><span class="line">  return Child</span><br><span class="line">&#125;)(Parent) // * 3.在这里通过传参，把父类传进去</span><br><span class="line"></span><br><span class="line">let c = new Child()</span><br><span class="line">console.log(c.name) // &apos;父类实例属性&apos;</span><br></pre></td></tr></table></figure><p>这样就可以用es5模拟es6的class了，会发现其实es6的class是es5面向对象的一个语法糖，经过这样解剖一下源码实现，会对class有更深刻的理解。</p><p>还有个问题，我们在react中，会这样写class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    name = &quot;邵威儒&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 在正常情况下会报错，但是因为平时项目是使用了babel插件</span><br><span class="line">// 会帮我们自动编译语法，这种写法目前还处于草案阶段</span><br><span class="line">// 上面的写法实际等价于下面的写法</span><br><span class="line">class Parent&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = &quot;邵威儒&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="decorator-装饰器"><a href="#decorator-装饰器" class="headerlink" title="decorator 装饰器"></a>decorator 装饰器</h1><p>装饰器是用来装饰类的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myFunction(target) &#123;</span><br><span class="line">  target[&apos;myName&apos;] = &quot;邵威儒&quot;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(Person)</span><br><span class="line">console.log(Person[&apos;myName&apos;]) // 邵威儒</span><br></pre></td></tr></table></figure><p>这种写法，相当于给Person这个类添加了myName的属性<br>那么换成decorator该怎么写呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 在类前面写@myFunction</span><br><span class="line">@myFunction</span><br><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myFunction(target) &#123;</span><br><span class="line">  target[&apos;myName&apos;] = &quot;邵威儒&quot;</span><br><span class="line">&#125;</span><br><span class="line">// myFunction(Person)  这一步可以不写</span><br><span class="line">console.log(Person[&apos;myName&apos;]) // 邵威儒</span><br></pre></td></tr></table></figure><p>那么我们该怎么给myName传参呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@myFunction(&apos;邵威儒&apos;)</span><br><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myFunction(value) &#123;</span><br><span class="line">  return function(target)&#123; // target代表的是类</span><br><span class="line">      target[&apos;myName&apos;] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Person[&apos;myName&apos;]) // 邵威儒</span><br></pre></td></tr></table></figure></p><p>修饰符也可以修饰类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    @myFunction</span><br><span class="line">    say()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果修饰的是方法</span><br><span class="line">// 参数一：是Person.prototype</span><br><span class="line">// 参数二：是say</span><br><span class="line">// 参数三：是描述器</span><br><span class="line">function myFunction(target,key,descriptor)&#123;</span><br><span class="line">    // 给这个类添加一个原型属性</span><br><span class="line">    Object.assign(target,&#123;name:&quot;邵威儒&quot;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person()</span><br><span class="line">console.log(p.name) // 邵威儒</span><br></pre></td></tr></table></figure></p><p>修饰符也可以修饰类的属性，比如我们有个不可修改的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    @onlyRead</span><br><span class="line">    name = &apos;邵威儒&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onlyRead(target,key,descriptor)&#123;</span><br><span class="line">    descriptor.writable = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person()</span><br><span class="line">p.name = &apos;swr&apos; // 报错，不能赋值</span><br></pre></td></tr></table></figure></p><p>decorator的用处很多，包括重写函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(target,key,descriptor)&#123;</span><br><span class="line">    // 拿出原本的函数</span><br><span class="line">    let fn = descriptor.value</span><br><span class="line">    // 并且在原有的fn上加上自己的业务逻辑，比如console.log(&apos;哈哈哈&apos;)</span><br><span class="line">    descriptor.value = function()&#123;</span><br><span class="line">        // 这里写我们需要加入的内容</span><br><span class="line">        console.log(&apos;哈哈哈&apos;)</span><br><span class="line">        // 这里执行原来的fn</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>装饰器经常在react中使用~其实decorator是简写，逼格高一些。</p><hr><h4 id="es6其实还有很多新语法，但是我们平时并不常用，所以也没一一列举，可以到阮大神的es6看看"><a href="#es6其实还有很多新语法，但是我们平时并不常用，所以也没一一列举，可以到阮大神的es6看看" class="headerlink" title="es6其实还有很多新语法，但是我们平时并不常用，所以也没一一列举，可以到阮大神的es6看看~"></a>es6其实还有很多新语法，但是我们平时并不常用，所以也没一一列举，可以到阮大神的es6看看~</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：大家好，我叫邵威儒，大家都喜欢喊我小邵，学的金融专业却凭借兴趣爱好入了程序猿的坑，从大学买的第一本vb和自学vb，我就与编程结下不解之缘，随后自学易语言写游戏辅助、交易软件，至今进入了前端领域，看到不少朋友都写文章分享，自己也弄一个玩玩，以下文章纯属个人理解，便于记录
      
    
    </summary>
    
      <category term="好文分享" scheme="https://ru23.com/categories/%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="优质文章分享" scheme="https://ru23.com/tags/%E4%BC%98%E8%B4%A8%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建github.io博客</title>
    <link href="https://ru23.com//note/20180907/cjnk45si70037s8a1ap5cgv1d/"/>
    <id>https://ru23.com//note/20180907/cjnk45si70037s8a1ap5cgv1d/</id>
    <published>2018-09-07T02:57:11.000Z</published>
    <updated>2018-10-22T09:40:22.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote><p>回顾一下我三年搭建博客的历程，最初是选择wordpress，Wordpress全部由php编写，数组库采用MySQL。优点：用户只需要将Wordpress的源代码复制到网站根目录下，然后访问网站，之后的安装操作全部在浏览器上完成。即使不是软件行业的人，也可以在几分钟之内完成安装工作。甚至很多虚拟主机供应商都提供了Wordpress的一键式安装工具。用户连上传文件的步骤都省了。缺点：项目太臃肿了，Wordpress耗损CPU严重，不容易操作，运行稍慢。尤其是后期文章数目较多的时候，想要登陆下网站的管理后台，心态简直是抓狂的。loading了好久，有时候还会失败，发一篇文章也很费劲，索性就不维护了。<br>后来在github网站上找到一个vue模板：<a href="https://github.com/ye63/vue-blog-use-github-issues" target="_blank" rel="noopener">github地址</a>和<a href="https://ye63.com/jy/" target="_blank" rel="noopener">demo预览</a>二次开发了一下，的确是实现了很多功能，也挺轻便的，样式也可以自定义，博客可以直接写在github的issue，很方便，用了三个月后才发现百度的搜索引擎居然只收录了首页，搜索引擎的基础爬虫的原理就是抓取你的url，然后获取你的html源代码并解析。 而你的页面通常用了vue等js的数据绑定机制来展示页面数据，爬虫获取到的html是你的模型页面而不是最终数据的渲染页面，所以说用js来渲染数据对seo并不友好。而且github api在国内访问速度也没有想象中那么快，可能是github的CDN被墙屏了。<br> 使用github.io可以搭建一个自己的博客,把静态文件项目托管到github上,可以写博客,可以使用markdown语法,也可以展示作品.灵活性高.但是有较大的难度,但是这对于一个熟悉git操作的前端开发工程师来说，都不算什么的。重点是hexo和github.io的域名和服务器都是<strong>免费</strong>的。当然也可以选择用自己的服务器和域名。</p></blockquote><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><h4 id="安装-node-git，注册好github账号"><a href="#安装-node-git，注册好github账号" class="headerlink" title="安装 node,git，注册好github账号"></a>安装 node,git，注册好github账号</h4><p> (网站有很多教程，安装方法这里就不详细展开了，<strong>注意:github账号用户名一定不能有大写.</strong>)</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo:"></a>安装hexo:</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h4 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹:"></a>创建hexo文件夹:</h4><p>cmd窗口切换到对应的目录下,然后执行: <code>hexo init</code><br>也可以在 E:\hexo 下右键,选择git bash,在窗口中执行<code>hexo init</code><br>自动安装了需要的文件.</p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖:"></a>安装依赖:</h4><p>继续执行: <code>npm install</code></p><h4 id="完成本地安装"><a href="#完成本地安装" class="headerlink" title="完成本地安装:"></a>完成本地安装:</h4><p>继续在 <code>E:\hexo</code> 下执行:  <code>hexo generate</code></p><p>继续执行: <code>hexo server</code></p><p>然后在打开浏览器 <code>localhost:4000</code> ,就可以看到,本地已经安装好了.</p><h4 id="在github上创建博客仓库"><a href="#在github上创建博客仓库" class="headerlink" title="在github上创建博客仓库:"></a>在github上创建博客仓库:</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45201116-7ca05e00-b2a6-11e8-8e6c-8658ee49dc8f.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p> 跳转的后如下填写:(其中Repository name的格式是 ‘用户名’.github.io  ),然后点创建仓库，Repository name必须和用户名（Owner）一致，不能有大写字母<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45201238-1e27af80-b2a7-11e8-8eb4-ad31cfbaf6f6.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45201369-a73ee680-b2a7-11e8-9c20-8a347e477f0b.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><h4 id="创建SSH-keys"><a href="#创建SSH-keys" class="headerlink" title="创建SSH keys"></a>创建SSH keys</h4><h5 id="监测是否有已经存在的SSH-keys"><a href="#监测是否有已经存在的SSH-keys" class="headerlink" title="监测是否有已经存在的SSH keys:"></a>监测是否有已经存在的SSH keys:</h5><p>打开 <code>git bash</code> 终端(可以在  E:\hexo 下右键打开,也可以直接在开始菜单里打开)</p><p>执行:  <code>$ ls -al ~/.ssh</code><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45201445-f7b64400-b2a7-11e8-91d2-704c587815a6.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><h5 id="如果没有的话-就生成一个SSH-keys-写自己的邮箱"><a href="#如果没有的话-就生成一个SSH-keys-写自己的邮箱" class="headerlink" title="如果没有的话,就生成一个SSH keys: 写自己的邮箱"></a>如果没有的话,就生成一个SSH keys: 写自己的邮箱</h5><p><code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></p><p>然后会出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/you/.ssh/id_rsa):</span><br></pre></td></tr></table></figure></p><p>就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了.输入一个密码,这个密码后面会用到,所以要记住咯</p><h5 id="保存SSH-keys"><a href="#保存SSH-keys" class="headerlink" title="保存SSH keys:"></a>保存SSH keys:</h5><p>创建成功后,他会提示你SSH keys保存在哪里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in /Users/you/.ssh/id_rsa.</span><br><span class="line"></span><br><span class="line"># Your public key has been saved in /Users/you/.ssh/id_rsa.pub.</span><br><span class="line"></span><br><span class="line"># The key fingerprint is:</span><br><span class="line"></span><br><span class="line"># 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</span><br></pre></td></tr></table></figure></p><h5 id="找到SSH-keys"><a href="#找到SSH-keys" class="headerlink" title="找到SSH keys:"></a>找到SSH keys:</h5><p>根据上一步里告诉你的路径,找到保存SSH keys的地方,我的是在 C:\Users\2000104591.ssh</p><p>其中 id_rsa.pub 就是SSH keys 如果为了防止以后找不到,可以把他们自己另存到其它地方</p><h4 id="为github仓库添加SSH-keys"><a href="#为github仓库添加SSH-keys" class="headerlink" title="为github仓库添加SSH keys"></a>为github仓库添加SSH keys</h4><p>然后把创建的id_rsa.pub里的内容复制到Key里去,Title部分随便填. 点击’Add key’</p><p>添加的过程中,还要再输入一次github的密码<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45201608-c0946280-b2a8-11e8-94f4-f091267ce8d7.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><h4 id="配置-config-yml文件并发布"><a href="#配置-config-yml文件并发布" class="headerlink" title="配置_config.yml文件并发布:"></a>配置_config.yml文件并发布:</h4><p>在 <code>E:\hexo</code>(文件根目录下) 下,有一个文件叫 _config.yml ,打开它,拉到最底下,做如下修改:　</p><p>然后再执行:</p><p><code>hexo generate</code></p><p><code>hexo deploy</code></p><p>然后访问: <a href="https://ye63.github.io/" target="_blank" rel="noopener">https://ye63.github.io/</a> (用户名改成自己的),就可以看到了.</p><h4 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令"></a>快捷命令</h4><h5 id="hexo-新建一篇文章给它添加分类和标签"><a href="#hexo-新建一篇文章给它添加分类和标签" class="headerlink" title="hexo 新建一篇文章给它添加分类和标签:"></a>hexo 新建一篇文章给它添加分类和标签:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;移动端限制input框只能输入数字&quot;</span><br></pre></td></tr></table></figure><h5 id="通过mou编辑器打开：添加tags和categories"><a href="#通过mou编辑器打开：添加tags和categories" class="headerlink" title="通过mou编辑器打开：添加tags和categories"></a>通过mou编辑器打开：添加tags和categories</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: title #文章標題</span><br><span class="line">date: 2016-06-01 23:47:44 #文章生成時間</span><br><span class="line">categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略</span><br><span class="line">tags: #文章标签 可以省略</span><br><span class="line">     - 标签1</span><br><span class="line">     - 标签2</span><br><span class="line">description: #你對本頁的描述 可以省略</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h5 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h5 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;回顾一下我三年搭建博客的历程，最初
      
    
    </summary>
    
      <category term="Hexo教程" scheme="https://ru23.com/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript截取文件名的后缀</title>
    <link href="https://ru23.com//note/20180906/cjnk45sh80023s8a11uuxu94r/"/>
    <id>https://ru23.com//note/20180906/cjnk45sh80023s8a11uuxu94r/</id>
    <published>2018-09-06T11:22:37.000Z</published>
    <updated>2018-10-22T09:38:37.510Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileName=<span class="string">"text.png"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带.的格式</span></span><br><span class="line"><span class="keyword">let</span> fileFormat=fileName.substring(fileName.lastIndexOf(<span class="string">'.'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带.的格式</span></span><br><span class="line"><span class="keyword">let</span> fileFormat2=fileName.substring(fileName.lastIndexOf(<span class="string">'.'</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fileFormat,fileFormat2)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-images.githubusercontent.com/22697565/45154907-b8d2b080-b20b-11e8-944d-3adde64b69dd.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js代码片段" scheme="https://ru23.com/tags/js%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>移动端限制input框只能输入数字</title>
    <link href="https://ru23.com//note/20180903/cjnk45shx002ws8a1pmgqtnyl/"/>
    <id>https://ru23.com//note/20180903/cjnk45shx002ws8a1pmgqtnyl/</id>
    <published>2018-09-03T08:56:58.000Z</published>
    <updated>2018-10-22T09:42:10.747Z</updated>
    
    <content type="html"><![CDATA[<p>html5 中，input 的 type 属性规定 input 元素的类型。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>有很多选项，详细可以参考<a href="http://www.w3school.com.cn/html5/att_input_type.asp" target="_blank" rel="noopener">HTML 5 type 属性</a></p><p>但是在移动端，还要区分是安卓用户，还是ios用户，所以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"num_input"</span> <span class="attr">type</span>=<span class="string">'number'</span> <span class="attr">pattern</span>=<span class="string">"[0-9]*"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在安卓端设置input类型为number，可限制键盘只输入数字，在ios端，要加入pattern验证输入字段的模式，才能限制数字输入。</p><p>另： <code>autofocus=&quot;autofocus&quot;</code>可以自动对焦。</p>]]></content>
    
    <summary type="html">
    
      在安卓端设置input类型为number，可限制键盘只输入数字，在ios端，要加入pattern验证输入字段的模式，才能限制数字输入
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="html5" scheme="https://ru23.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>React Js 微信分享封装</title>
    <link href="https://ru23.com//note/20180903/cjnk45sh3001xs8a17u9ty7g0/"/>
    <id>https://ru23.com//note/20180903/cjnk45sh3001xs8a17u9ty7g0/</id>
    <published>2018-09-03T07:17:54.000Z</published>
    <updated>2018-10-22T09:39:10.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introductions"><a href="#Introductions" class="headerlink" title="Introductions"></a>Introductions</h2><p>本篇文章给大家分享的内容是代码详解React Js 微信分享封装，有着一定的参考价值，有需要的朋友可以参考一下 话不多说，直接上源代码：</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="分享功能"><a href="#分享功能" class="headerlink" title="分享功能"></a>分享功能</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Fetch <span class="keyword">from</span> <span class="string">'./FetchIt'</span>;</span><br><span class="line"><span class="keyword">import</span> API_URL <span class="keyword">from</span> <span class="string">'./url'</span>;</span><br><span class="line"><span class="keyword">import</span> Share <span class="keyword">from</span> <span class="string">'./Share'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wxUtils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 分享</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> getshareinfo?type=</span></span><br><span class="line"><span class="comment"> type :goods 课程详情 team 团详情</span></span><br><span class="line"><span class="comment"> id 课程id</span></span><br><span class="line"><span class="comment"> tid 团ID</span></span><br><span class="line"><span class="comment"> * @param config</span></span><br><span class="line"><span class="comment"> * @param shareInfo &#123;imgUrl,title,description,link&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">share2wx</span>(<span class="params">config, shareInfo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> share = <span class="keyword">new</span> Share(&#123;</span><br><span class="line">        appid: config.appid, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">        timestamp: config.timestamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">        nonceStr: config.nonceStr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">        signature: config.signature, <span class="comment">// 必填，签名</span></span><br><span class="line">    &#125;);</span><br><span class="line">    share.init(<span class="built_in">Object</span>.assign(&#123;&#125;, shareInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getConfig</span>(<span class="params">shareInfo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> href = <span class="built_in">window</span>.location.href.split(<span class="string">'#'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> url = <span class="built_in">encodeURIComponent</span>(href <span class="comment">/*window.location.href*/</span>);</span><br><span class="line">    Fetch.get(<span class="string">`<span class="subst">$&#123;API_URL.mobile.signature_path&#125;</span>?url=<span class="subst">$&#123;url&#125;</span>`</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        share2wx(data, shareInfo);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param shareInfo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">wxUtils.share = <span class="function"><span class="keyword">function</span> (<span class="params">shareInfo</span>) </span>&#123;</span><br><span class="line">    getConfig(shareInfo);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 分享结束</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否开启右上角Menu</span></span><br><span class="line"><span class="comment"> * @param open</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">wxUtils.optionMenu = <span class="function"><span class="keyword">function</span> (<span class="params">open = true</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (open) &#123;</span><br><span class="line">        openOptionMenu();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disabledOptionMenu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否禁用右上角</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disabledOptionMenu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> WeixinJSBridge === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">            <span class="built_in">document</span>.addEventListener(<span class="string">'WeixinJSBridgeReady'</span>, onBridgeReady(<span class="literal">true</span>), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) &#123;</span><br><span class="line">            <span class="built_in">document</span>.attachEvent(<span class="string">'WeixinJSBridgeReady'</span>, onBridgeReady(<span class="literal">true</span>));</span><br><span class="line">            <span class="built_in">document</span>.attachEvent(<span class="string">'onWeixinJSBridgeReady'</span>, onBridgeReady(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onBridgeReady(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启menu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openOptionMenu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> WeixinJSBridge === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">            <span class="built_in">document</span>.addEventListener(<span class="string">'WeixinJSBridgeReady'</span>, onBridgeReady(<span class="literal">false</span>), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) &#123;</span><br><span class="line">            <span class="built_in">document</span>.attachEvent(<span class="string">'WeixinJSBridgeReady'</span>, onBridgeReady(<span class="literal">false</span>));</span><br><span class="line">            <span class="built_in">document</span>.attachEvent(<span class="string">'onWeixinJSBridgeReady'</span>, onBridgeReady(<span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onBridgeReady(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onBridgeReady</span>(<span class="params">disable = true</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> WeixinJSBridge !== <span class="string">"undefined"</span>) WeixinJSBridge.call(disable ? <span class="string">'hideOptionMenu'</span> : <span class="string">'showOptionMenu'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 隐藏微信网页底部的导航栏</span></span><br><span class="line"><span class="comment"> * @param disable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">wxUtils.disabledToolbar = <span class="function"><span class="keyword">function</span> (<span class="params">disable = true</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'WeixinJSBridgeReady'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onBridgeReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 通过下面这个API隐藏底部导航栏</span></span><br><span class="line">        WeixinJSBridge.call(disable ? <span class="string">'hideToolbar'</span> : <span class="string">'showToolbar'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> wxUtils;</span><br></pre></td></tr></table></figure><h3 id="分享配置"><a href="#分享配置" class="headerlink" title="分享配置"></a>分享配置</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分享</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Share</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    wx.config(&#123;</span><br><span class="line">        debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式</span></span><br><span class="line">        appId: config.appid, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">        timestamp: config.timestamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">        nonceStr: config.nonceStr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">        signature: config.signature, <span class="comment">// 必填，签名，见附录1</span></span><br><span class="line">        jsApiList: [<span class="string">'onMenuShareTimeline'</span>, <span class="string">'onMenuShareAppMessage'</span>, <span class="string">'onMenuShareWeibo'</span>], <span class="comment">// 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Share.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Share,</span><br><span class="line"></span><br><span class="line">    init(config) &#123;</span><br><span class="line">        <span class="keyword">this</span>.imgUrl = config.imgUrl;</span><br><span class="line">        <span class="keyword">this</span>.link = config.link;</span><br><span class="line">        <span class="comment">// this.musicPath = config.musicPath;</span></span><br><span class="line">        <span class="keyword">this</span>.description = config.description;</span><br><span class="line">        <span class="keyword">this</span>.title = config.title;</span><br><span class="line"></span><br><span class="line">        wx.ready(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// if (this.musicPath) &#123;</span></span><br><span class="line">            <span class="comment">//     document.getElementById('musicIcon').play();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">this</span>.toFriend();</span><br><span class="line">            <span class="keyword">this</span>.toTimeline();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wx.error(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    toFriend() &#123;</span><br><span class="line">        wx.onMenuShareAppMessage(&#123;</span><br><span class="line">            imgUrl: <span class="keyword">this</span>.imgUrl,</span><br><span class="line">            link: <span class="keyword">this</span>.link,</span><br><span class="line">            title: <span class="keyword">this</span>.title,</span><br><span class="line">            desc: <span class="keyword">this</span>.description,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 用户确认分享后执行的回调函数</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    toTimeline() &#123;</span><br><span class="line">        wx.onMenuShareTimeline(&#123;</span><br><span class="line">            imgUrl: <span class="keyword">this</span>.imgUrl,</span><br><span class="line">            link: <span class="keyword">this</span>.link,</span><br><span class="line">            title: <span class="keyword">this</span>.title,</span><br><span class="line">            desc: <span class="keyword">this</span>.description,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 用户确认分享后执行的回调函数</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Share;</span><br></pre></td></tr></table></figure><h3 id="开启分享"><a href="#开启分享" class="headerlink" title="开启分享"></a>开启分享</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启分享</span></span><br><span class="line">BaseComponent.wxUtils.optionMenu(<span class="literal">true</span>);</span><br><span class="line">BaseComponent.wxUtils.share(&#123;</span><br><span class="line">    imgUrl: activityData.sharePicUrl,</span><br><span class="line">    title: activityData.shareTitle,</span><br><span class="line">    description: activityData.shareContent,</span><br><span class="line">    link: url,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本篇文章给大家分享的内容是代码详解React Js 微信分享封装，有着一定的参考价值，有需要的朋友可以参考一下 话不多说，直接上源代码：
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="https://ru23.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>错误码：events.js:183 throw er; // Unhandled &#39;error&#39; event—解决办法</title>
    <link href="https://ru23.com//note/20180830/cjnk45sfv000xs8a1rzwgd2k5/"/>
    <id>https://ru23.com//note/20180830/cjnk45sfv000xs8a1rzwgd2k5/</id>
    <published>2018-08-30T14:48:30.000Z</published>
    <updated>2018-10-22T09:42:18.590Z</updated>
    
    <content type="html"><![CDATA[<h4 id="控制台报错："><a href="#控制台报错：" class="headerlink" title="控制台报错："></a>控制台报错：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Hash: 78f0873c3eb47a64bfae</span><br><span class="line">Version: webpack 1.14.0</span><br><span class="line">Time: 16ms</span><br><span class="line">webpack: Compiled successfully.</span><br><span class="line">events.js:183</span><br><span class="line">      throw er; // Unhandled &apos;error&apos; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EADDRINUSE 127.0.0.1:8080</span><br><span class="line">    at Object._errnoException (util.js:1022:11)</span><br><span class="line">    at _exceptionWithHostPort (util.js:1044:20)</span><br><span class="line">    at Server.setupListenHandle [as _listen2] (net.js:1367:14)</span><br><span class="line">    at listenInCluster (net.js:1408:12)</span><br><span class="line">    at GetAddrInfoReqWrap.doListen [as callback] (net.js:1517:7)</span><br><span class="line">    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:97:10)</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! webpack-demos@1.0.0 dev: `webpack-dev-server --devtool eval --progress --colors`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the webpack-demos@1.0.0 dev script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\qian\AppData\Roaming\npm-cache\_logs\2018-08-30T14_46_37_546Z-debug.log</span><br></pre></td></tr></table></figure><h4 id="错误原因："><a href="#错误原因：" class="headerlink" title="错误原因："></a>错误原因：</h4><p>端口号被占用</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1.Win+R,cmd查询使用的端口号是否被占用：<br>netstat  -aon|findstr  “8080”<br>按回车显示占用8080端口对应的程序的PID号；<br>2.根据PID号找到对应的程序：继续输入命令：<br>tasklist|findstr “15008”<br>按回车后显示出占用该端口的程序；<br>3.按快捷键“Ctrl+Shift+Esc”调出Windows任务管理器，根据PID/<br>程序对应名称结束该程序进程即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;控制台报错：&quot;&gt;&lt;a href=&quot;#控制台报错：&quot; class=&quot;headerlink&quot; title=&quot;控制台报错：&quot;&gt;&lt;/a&gt;控制台报错：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="npm" scheme="https://ru23.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>合并数组的相同的key值，并且计算相同key值的个数</title>
    <link href="https://ru23.com//note/20180830/cjnk45sgs001ps8a1b7bz6ocb/"/>
    <id>https://ru23.com//note/20180830/cjnk45sgs001ps8a1b7bz6ocb/</id>
    <published>2018-08-30T07:33:19.000Z</published>
    <updated>2018-10-22T09:41:01.723Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><p>合并数组的相同的key值，并且计算相同key值的个数</p><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>根据list数组的每一项的key值coupon_sn合并数组，并且计数</p><h4 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h4><h5 id="json数组："><a href="#json数组：" class="headerlink" title="json数组："></a>json数组：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">let list = [&#123;</span><br><span class="line">"id": 5899,</span><br><span class="line">"is_use": 0,</span><br><span class="line">"use_time": null,</span><br><span class="line">"expired_time": "2018-12-31 00:00:00",</span><br><span class="line">"coupon": &#123;</span><br><span class="line">"coupon_sn": "1",</span><br><span class="line">"name": "满减",</span><br><span class="line">"type": 2,</span><br><span class="line">"count": 99993,</span><br><span class="line">"receive_count": 6,</span><br><span class="line">"is_fare": 0,</span><br><span class="line">"available_money": "2000.00",</span><br><span class="line">"reduce_money": "100.00",</span><br><span class="line">"discount": "1.000",</span><br><span class="line">"receive_start_time": "2018-07-27 00:00:00",</span><br><span class="line">"receive_end_time": "2020-12-31 00:00:00",</span><br><span class="line">"info": "",</span><br><span class="line">"created_at": "2018-07-27 21:22:51",</span><br><span class="line">"restriction_description": "仅限非板材使用"</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"id": 5899,</span><br><span class="line">"is_use": 0,</span><br><span class="line">"use_time": null,</span><br><span class="line">"expired_time": "2018-12-31 00:00:00",</span><br><span class="line">"coupon": &#123;</span><br><span class="line">"coupon_sn": "2",</span><br><span class="line">"name": "满减",</span><br><span class="line">"type": 2,</span><br><span class="line">"count": 99993,</span><br><span class="line">"receive_count": 6,</span><br><span class="line">"is_fare": 0,</span><br><span class="line">"available_money": "2000.00",</span><br><span class="line">"reduce_money": "100.00",</span><br><span class="line">"discount": "1.000",</span><br><span class="line">"receive_start_time": "2018-07-27 00:00:00",</span><br><span class="line">"receive_end_time": "2020-12-31 00:00:00",</span><br><span class="line">"info": "",</span><br><span class="line">"created_at": "2018-07-27 21:22:51",</span><br><span class="line">"restriction_description": "仅限非板材使用"</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"id": 5899,</span><br><span class="line">"is_use": 0,</span><br><span class="line">"use_time": null,</span><br><span class="line">"expired_time": "2018-12-31 00:00:00",</span><br><span class="line">"coupon": &#123;</span><br><span class="line">"coupon_sn": "2",</span><br><span class="line">"name": "满减",</span><br><span class="line">"type": 2,</span><br><span class="line">"count": 99993,</span><br><span class="line">"receive_count": 6,</span><br><span class="line">"is_fare": 0,</span><br><span class="line">"available_money": "2000.00",</span><br><span class="line">"reduce_money": "100.00",</span><br><span class="line">"discount": "1.000",</span><br><span class="line">"receive_start_time": "2018-07-27 00:00:00",</span><br><span class="line">"receive_end_time": "2020-12-31 00:00:00",</span><br><span class="line">"info": "",</span><br><span class="line">"created_at": "2018-07-27 21:22:51",</span><br><span class="line">"restriction_description": "仅限非板材使用"</span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h5 id="js代码-1"><a href="#js代码-1" class="headerlink" title="js代码"></a>js代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> hash = &#123;</span><br><span class="line">coupon: &#123;&#125;,</span><br><span class="line">&#125;, i = <span class="number">0</span>, res = [];</span><br><span class="line">list.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item </span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> coupon_sn = item.coupon.coupon_sn;</span><br><span class="line"><span class="keyword">if</span> (hash[coupon_sn]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!res[hash[coupon_sn] - <span class="number">1</span>].count) &#123;</span><br><span class="line">res[hash[coupon_sn] - <span class="number">1</span>].count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">res[hash[coupon_sn] - <span class="number">1</span>].count += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">hash[coupon_sn] = ++i &amp;&amp; res.push(&#123;</span><br><span class="line"><span class="string">"count"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"id"</span>: item.id,</span><br><span class="line"><span class="string">"is_use"</span>: item.is_use,</span><br><span class="line"><span class="string">"use_time"</span>: item.use_time,</span><br><span class="line"><span class="string">"expired_time"</span>: item.expired_time,</span><br><span class="line"><span class="string">"coupon"</span>: item.coupon</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;需求：&quot;&gt;&lt;a href=&quot;#需求：&quot; class=&quot;headerlink&quot; title=&quot;需求：&quot;&gt;&lt;/a&gt;需求：&lt;/h4&gt;&lt;p&gt;合并数组的相同的key值，并且计算相同key值的个数&lt;/p&gt;
&lt;h4 id=&quot;场景：&quot;&gt;&lt;a href=&quot;#场景：&quot; class=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js代码片段" scheme="https://ru23.com/tags/js%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    
  </entry>
  
</feed>
