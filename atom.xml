<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端迷</title>
  
  <subtitle>frank，前端开发爱好者，沉迷前端，无法自拔,欢迎一切技术交流（不局限于前端），邮箱fanqianweb@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ru23.com/"/>
  <updated>2018-12-18T01:43:30.654Z</updated>
  <id>https://ru23.com/</id>
  
  <author>
    <name>frank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>合理利用前端缓存优化性能</title>
    <link href="https://ru23.com/note/a1bbed4a.html"/>
    <id>https://ru23.com/note/a1bbed4a.html</id>
    <published>2018-12-17T12:47:27.000Z</published>
    <updated>2018-12-18T01:43:30.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合理利用缓存"><a href="#合理利用缓存" class="headerlink" title="合理利用缓存:"></a>合理利用缓存:</h3><p>对于web应用来说，缓存是提升页面性能同时减少服务器压力的利器。</p><p>浏览器缓存类型<br>1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；</p><p>相关的header:<br>Expires ：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。它的值为一个绝对时间的GMT格式的时间字符串， 比如Expires:Thu,21 Jan 2018 23:39:02 GMT</p><p>Cache-Control ：这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。比如Cache-Control:max-age=300，</p><p>简单概括：其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容较客户端是否已经发生了更新呢？此时我们需要协商缓存策略。</p><p>2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用。</p><p>相关的header:<br>①Last-Modified和If-Modified-Since：当第一次请求资源时，服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p><p>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT<br>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。<br>但last-modified 存在一些缺点：</p><p>Ⅰ.某些服务端不能获取精确的修改时间</p><p>Ⅱ.文件修改时间改了，但文件内容却没有变</p><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？—-ETag和If-None-Match</p><p>②ETag和If-None-Match：Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><p>两者之间对比：<br>首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。<br>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>第三在优先级上，服务器校验优先考虑Etag</p><p>缓存的机制<br>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;合理利用缓存&quot;&gt;&lt;a href=&quot;#合理利用缓存&quot; class=&quot;headerlink&quot; title=&quot;合理利用缓存:&quot;&gt;&lt;/a&gt;合理利用缓存:&lt;/h3&gt;&lt;p&gt;对于web应用来说，缓存是提升页面性能同时减少服务器压力的利器。&lt;/p&gt;
&lt;p&gt;浏览器缓存类型&lt;br&gt;1
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="缓存" scheme="https://ru23.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>http请求报文介绍</title>
    <link href="https://ru23.com/note/ef1b6cee.html"/>
    <id>https://ru23.com/note/ef1b6cee.html</id>
    <published>2018-12-06T06:11:28.000Z</published>
    <updated>2018-12-18T01:43:30.653Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p><h3 id="一、一个HTTP请求报文由请求行（request-line）、请求头部（header）、空行和请求数据4个部分组成"><a href="#一、一个HTTP请求报文由请求行（request-line）、请求头部（header）、空行和请求数据4个部分组成" class="headerlink" title="一、一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成"></a>一、一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成</h3><p>下图给出了请求报文的一般格式。<br><img src="https://cdn.ru23.com/img/2018/12/http-message.png" alt="HTTP请求报文1"><br><img src="https://cdn.ru23.com/img/2018/12/http-message2.jpg" alt="HTTP请求报文-详解"></p><p>以下逐步分析各个数据部分的作用。</p><p>1、请求行</p><p>　　　　请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。</p><p>　　　　例如打开路径<a href="http://www.baidu.com/index.php，用火狐浏览器可以查看到请求报文为：" target="_blank" rel="noopener">http://www.baidu.com/index.php，用火狐浏览器可以查看到请求报文为：</a></p><p>　　　　GET /index.php HTTP/1.1</p><p>　　　　因此用空格分隔之后得到的信息为</p><p>　　　　(1)请求方法:  GET</p><p>　　　　(2)URL信息:  /index.php</p><p>　　　　(3)HTTP协议版本:  HTTP/1.1　　<br>2、请求头部<br>　　　　User-Agent：浏览器的具体类型　　如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0</p><p> 　　　  Accept：浏览器支持哪些数据类型　　如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p><p>　　　　Accept-Charset：浏览器采用的是哪种编码　　如：Accept-Charset: ISO-8859-1</p><p>　　　　Accept-Encoding：浏览器支持解码的数据压缩格式　　如：Accept-Encoding: gzip, deflate</p><p>　　　　Accept-Language：浏览器的语言环境　　如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3</p><p> 　　　  Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>　　　   Connection：表示是否需要持久连接。Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-Alive</p><p>　　　　Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。</p><p>　　　　Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’</p><p>　　　　Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p><p>　　　　Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。</p><p>　　　　Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。</p><p> 　　　  Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。Referer: <a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a></p><p> 3.空行<br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p>4.请求数据</p><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h3 id="二、HTTP响应报文"><a href="#二、HTTP响应报文" class="headerlink" title="二、HTTP响应报文"></a>二、HTTP响应报文</h3><p> 　HTTP响应报文与HTTP请求报文是对应的，也是分为三个部分。</p><p>　　1、响应行</p><p>　　2、响应头</p><p>　　3、响应体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK　　//响应行</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Content-Type: text/html;charset=ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜/title＞</span><br><span class="line">＜/head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜/body＞</span><br><span class="line">＜/html＞</span><br></pre></td></tr></table></figure><p><img src="https://cdn.ru23.com/img/2018/12/xiangying.jpg" alt="HTTP响应报文"><br><img src="https://cdn.ru23.com/img/2018/12/xiangying2.jpg" alt="HTTP响应报文-详解"></p><p>HTTP响应报文常用属性：</p><p>Cache-Control<br>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。<br>下面，的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。</p><p>Cache-Control: max-age=3600</p><p>ETag</p><p>一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。</p><p>ETag: “737060cd8c284d8af7ad3082f209582d”</p><p>Location</p><p>我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：</p><p>Location: <a href="http://www.google.com.hk" target="_blank" rel="noopener">http://www.google.com.hk</a></p><p>Set-Cookie</p><p>服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。</p><p>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</p><p>HTTP响应体：如果请求的是HTML页面，那么返回的就是HTML代码。如果是JS就是JS代码。</p><p>HTTP响应头：而设置Cookie，缓存等信息就是在响应头属性设置的。</p><p>HTTP响应行：主要是设置响应状态等信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。&lt;/p&gt;
&lt;h3 id=&quot;一、一个HTTP请求报文由请求行（request-line）、请求头部（header）、空行和请求数据4个部分组成
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="http" scheme="https://ru23.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>2018年12月前端文章分享</title>
    <link href="https://ru23.com/note/f04f102c.html"/>
    <id>https://ru23.com/note/f04f102c.html</id>
    <published>2018-12-05T10:10:17.000Z</published>
    <updated>2018-12-18T01:43:30.652Z</updated>
    
    <content type="html"><![CDATA[<p>实现简单的MVVM：<a href="https://github.com/louzhedong/blog/issues/4" target="_blank" rel="noopener">https://github.com/louzhedong/blog/issues/4</a></p><p>手写实现bind，call，apply：<a href="https://www.jianshu.com/p/539064c644bb" target="_blank" rel="noopener">https://www.jianshu.com/p/539064c644bb</a></p><p><a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">https://juejin.im/post/59bfe84351882531b730bac2</a></p><p>深入详解函数的柯里化：<a href="https://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">https://www.jianshu.com/p/5e1899fe7d6b</a></p><p>webpack4.0性能优化：<a href="https://juejin.im/post/5bf511eae51d454e243dbe55" target="_blank" rel="noopener">https://juejin.im/post/5bf511eae51d454e243dbe55</a></p><p>vue3.0尝鲜 – 摒弃Object.defineProperty，基于 Proxy 的观察者机制探索：<a href="https://juejin.im/post/5bf3e632e51d452baa5f7375" target="_blank" rel="noopener">https://juejin.im/post/5bf3e632e51d452baa5f7375</a></p><p>彻底弄懂原型和原型链：<a href="https://juejin.im/post/5bf3d8936fb9a04a072ffba1" target="_blank" rel="noopener">https://juejin.im/post/5bf3d8936fb9a04a072ffba1</a></p><p>BFC是什么以及BFC的常见用途：<a href="https://www.cnblogs.com/libin-1/p/7098468.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/7098468.html</a></p><p>关于JSON.parse(JSON.stringify(obj))实现深拷贝应该注意的坑 ：<a href="https://www.jianshu.com/p/b084dfaad501" target="_blank" rel="noopener">https://www.jianshu.com/p/b084dfaad501</a></p><p>css margin重叠问题及解决方法（BFC）：<a href="https://github.com/aermin/blog/issues/40" target="_blank" rel="noopener">https://github.com/aermin/blog/issues/40</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现简单的MVVM：&lt;a href=&quot;https://github.com/louzhedong/blog/issues/4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/louzhedong/blog/issues/
      
    
    </summary>
    
      <category term="前端分享" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>对css重绘和重排的理解，两个有什么不同</title>
    <link href="https://ru23.com/note/8463a2db.html"/>
    <id>https://ru23.com/note/8463a2db.html</id>
    <published>2018-12-01T13:49:16.000Z</published>
    <updated>2018-12-03T02:08:48.102Z</updated>
    
    <content type="html"><![CDATA[<p>这一题考的其实是网页性能的问题，我们先理解下对网页性能产生影响到因素，了解下网页是怎么生成的</p><p>网页生成的过程，大致可以分为五步：</p><ol><li>html代码转化为dom</li><li>css代码转化为cssom</li><li>结合dom和cssom，生成一颗渲染树（包含每个节点的视觉信息）</li><li>生成布局layout，即将所有的渲染树的节点进行平面合成</li><li>将布局绘制paint在屏幕上</li></ol><p>重绘和重排</p><p>网页生成的时候，至少会渲染一次，用户访问的过程中，还会不断的重新渲染<br>以下三种情况会导致页面重新渲染<br>修改dom<br>修改样式表<br>用户事件<br>重新渲染，就需要重新生成布局和重新绘制，前者叫重排reflow，后者叫重绘repaint<br>需要注意的是重绘不一定需要重排，比如改变网页元素的颜色，就会只发生重绘，不会发生重排，因为布局没有改变，但是重排一定会导致重绘，如何改变一个网页元素的位置，就会同时触发重排和重绘，因为布局改变了</p><p>对于性能的影响<br>重绘和重排会不断触发，这是不可避免的，但是，他们是非常耗费资源的，是导致网页性能低下根本原因<br>要提高网页性能，就是要降低重排和重绘的频率和成本，尽量少触发重新渲染</p><p>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetTop/offsetLeft/offsetWidth/offsetHeight</span><br><span class="line">scrollTop/scrollLeft/scrollWidth/scrollHeight</span><br><span class="line">clientTop/clientLeft/clientWidth/clientHeight</span><br><span class="line">getComputeStyle()</span><br></pre></td></tr></table></figure></p><p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里，一般的规则是<br>样式表越简单，重绘和重排就越快<br>重排和重绘的dom层级越高，成本就越高<br>table元素的重绘和重排成本，要高于div元素</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一题考的其实是网页性能的问题，我们先理解下对网页性能产生影响到因素，了解下网页是怎么生成的&lt;/p&gt;
&lt;p&gt;网页生成的过程，大致可以分为五步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;html代码转化为dom&lt;/li&gt;
&lt;li&gt;css代码转化为cssom&lt;/li&gt;
&lt;li&gt;结合dom和c
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="css" scheme="https://ru23.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期以及注意事项</title>
    <link href="https://ru23.com/note/9a17caa7.html"/>
    <id>https://ru23.com/note/9a17caa7.html</id>
    <published>2018-11-29T03:36:28.000Z</published>
    <updated>2018-12-18T01:43:30.639Z</updated>
    
    <content type="html"><![CDATA[<p>react快速入门</p><h3 id="react组件的生命周期"><a href="#react组件的生命周期" class="headerlink" title="react组件的生命周期"></a>react组件的生命周期</h3><p>在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化 </p><blockquote><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。<br>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p></blockquote><p>组件的生命主要包括3个阶段： 挂载、更新、卸载，React 16开始还添加了错误处理。</p><p>韦博青少微信端用的是react15版本的，先简述下15版本的生命周期，react16的生命周期也是基于15上修改</p><p><img src="https://cdn.ru23.com/img/2018/12/react-life-cycle.png" alt="react生命周期"></p><h3 id="第一个是组件初始化-initialization-阶段"><a href="#第一个是组件初始化-initialization-阶段" class="headerlink" title="第一个是组件初始化(initialization)阶段"></a>第一个是组件初始化(initialization)阶段</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法(<code>constructor()</code> ),Test类继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用<br>super(props)用来调用基类的构造方法( <code>constructor()</code> ), 也将父组件的props注入给子组件，供子组件读取(组件中props只读不可变，state可变)<br>而<code>constructor()</code>用来做一些组件的初始化工作，如定义this.state的初始内容。</p><h3 id="第二个是组件的挂载-Mounting-阶段"><a href="#第二个是组件的挂载-Mounting-阶段" class="headerlink" title="第二个是组件的挂载(Mounting)阶段"></a>第二个是组件的挂载(Mounting)阶段</h3><p><strong>此阶段分为componentWillMount，render，componentDidMount三个时期</strong><br><code>componentWillMount</code>:<br>在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到<code>constructor()</code>中，所以项目中很少用。<br><code>render</code>:<br>根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。</p><p><code>componentDidMount</code>:<br>组件挂载到DOM后调用，且只会被调用一次<br>1.在<code>componentDidMount</code>请求异步加载的数据<br>2.添加事件监听 — Adding event listeners (or subscriptions)</p><h3 id="第三个是组件的更新-update-阶段"><a href="#第三个是组件的更新-update-阶段" class="headerlink" title="第三个是组件的更新(update)阶段"></a>第三个是组件的更新(update)阶段</h3><p>在讲述此阶段前需要先明确下<strong>react组件更新机制</strong>。</p><ol><li>父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render</li><li>setState引起的state更新,可通过<code>shouldComponentUpdate</code>方法优化。<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          someThings:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 虽然调用了setState ，但state并无变化</span></span><br><span class="line">        <span class="keyword">const</span> preSomeThings = <span class="keyword">this</span>.state.someThings</span><br><span class="line">         <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            someThings: preSomeThings</span><br><span class="line">         &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   shouldComponentUpdate(nextStates)&#123; <span class="comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span></span><br><span class="line">        <span class="keyword">if</span>(nextStates.someThings === <span class="keyword">this</span>.state.someThings)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span> = <span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.someThings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">`</span>componentWillReceiveProps(nextProps)<span class="string">`</span></span><br><span class="line"><span class="string">此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>shouldComponentUpdate(nextProps, nextState)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</span></span><br><span class="line"><span class="string">ps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前（如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState及当前组件的this.state的对比就一直是true了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>componentWillUpdate(nextProps, nextState)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>render<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">render方法在上文讲过，这边只是重新调用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>componentDidUpdate(prevProps, prevState)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 卸载阶段</span></span><br><span class="line"><span class="string">此阶段只有一个生命周期方法：`</span>componentWillUnmount<span class="string">`</span></span><br><span class="line"><span class="string">`</span>componentWillUnmount<span class="string">`</span></span><br><span class="line"><span class="string">此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清除定时器，清除componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">### react16 生命周期函数做的更改</span></span><br><span class="line"><span class="string">旧的生命周期十分完整，基本可以捕捉到组件更新的每一个state/props/ref，没有什么逻辑上的毛病。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是架不住官方自己搞事情，react打算在17版本推出新的Async Rendering，提出一种可被打断的生命周期，而可以被打断的阶段正是实际dom挂载之前的虚拟dom构建阶段，也就是要被去掉的三个生命周期。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生命周期一旦被打断，下次恢复的时候又会再跑一次之前的生命周期，</span></span><br><span class="line"><span class="string">因此componentWillMount，componentWillReceiveProps， componentWillUpdate都不能保证只在挂载/拿到props/状态变化的时候刷新一次了，所以这三个方法被标记为不安全。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 两个新生命周期</span></span><br><span class="line"><span class="string">`</span><span class="keyword">static</span> getDerivedStateFromProps<span class="string">`</span></span><br><span class="line"><span class="string">触发时间：在组件构建之后(虚拟dom之后，实际dom挂载之前) ，以及每次获取新的props之后。</span></span><br><span class="line"><span class="string">每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state.</span></span><br><span class="line"><span class="string">配合componentDidUpdate，可以覆盖componentWillReceiveProps的所有用法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>jsx</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// 没错，这是一个static</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>getSnapshotBeforeUpdate</code><br>触发时间: update发生的时候，在render之后，在组件dom渲染之前。<br>返回一个值，作为componentDidUpdate的第三个参数。<br>配合componentDidUpdate, 可以覆盖componentWillUpdate的所有用法。</p><h5 id="react错误处理"><a href="#react错误处理" class="headerlink" title="react错误处理"></a>react错误处理</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setState方法可能是同步的，也可能是异步的"><a href="#setState方法可能是同步的，也可能是异步的" class="headerlink" title="setState方法可能是同步的，也可能是异步的"></a>setState方法可能是同步的，也可能是异步的</h3><p>由 React 控制的事件处理过程 setState 不会同步更新 this.state</p><p>基于性能考虑，React 通常是批量合并更新，调用 setState() 之后，this.state 并没有马上修改，而是创建了一个中间态作为过渡。</p><p>但是有些例外情况，它是同步执行的，比如：eventListeners，Ajax，setTimeout 等。<br>原因是这些 JS 原生的 API 不在 React 的上下文控制范围，无法进行优化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)<span class="comment">//输出count=1</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="react事件绑定"><a href="#react事件绑定" class="headerlink" title="react事件绑定"></a>react事件绑定</h3><p>由于类的方法默认不会绑定this，因此在调用的时候如果忘记绑定，this的值将会是undefined。<br>通常如果不是直接调用，应该为方法绑定this。绑定方式有以下几种：</p><ol><li><p>在构造函数中使用bind绑定this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在调用的时候使用bind绑定this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在调用的时候使用箭头函数绑定this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;<span class="keyword">this</span>.handleClick()&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用属性初始化器语法绑定this(实验性)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>方式1是官方推荐的绑定方式，也是性能最好的方式。方式2和方式3会有性能影响并且当方法作为属性传递给子组件的时候会引起重渲问题。方式4目前属于实验性语法，但是是最好的绑定方式，需要结合bable转译</p><h3 id="react列表渲染时为什么尽量不要把索引设置为key值"><a href="#react列表渲染时为什么尽量不要把索引设置为key值" class="headerlink" title="react列表渲染时为什么尽量不要把索引设置为key值"></a>react列表渲染时为什么尽量不要把索引设置为key值</h3><p>使用数组下标做key是不被推荐的，如果遇到数组排序的情况下，将降低渲染性能。</p><h3 id="React中的核心概念"><a href="#React中的核心概念" class="headerlink" title="React中的核心概念"></a>React中的核心概念</h3><ol><li><p>虚拟DOM（Virtual DOM）<br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/13</a></p></li><li><p>Diff算法（虚拟DOM的加速器，提升React性能的法宝）<br><a href="https://github.com/zmmbreeze/blog/issues/9" target="_blank" rel="noopener">https://github.com/zmmbreeze/blog/issues/9</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;react快速入门&lt;/p&gt;
&lt;h3 id=&quot;react组件的生命周期&quot;&gt;&lt;a href=&quot;#react组件的生命周期&quot; class=&quot;headerlink&quot; title=&quot;react组件的生命周期&quot;&gt;&lt;/a&gt;react组件的生命周期&lt;/h3&gt;&lt;p&gt;在组件的整个生命周期中，随
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="react" scheme="https://ru23.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>12月份todolist</title>
    <link href="https://ru23.com/note/4bf41c9b.html"/>
    <id>https://ru23.com/note/4bf41c9b.html</id>
    <published>2018-11-28T14:45:45.000Z</published>
    <updated>2018-12-18T01:43:30.651Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="todo" scheme="https://ru23.com/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>手写一个promise，彻底掌握它的原理</title>
    <link href="https://ru23.com/note/e5037e31.html"/>
    <id>https://ru23.com/note/e5037e31.html</id>
    <published>2018-11-27T14:35:58.000Z</published>
    <updated>2018-12-17T06:53:49.299Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是异步编程的一种解决方案,解决传统的回调嵌套问题</p><p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。<br>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><!-- ### 首先，我们先搭建好代码的骨架： --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">self.status = <span class="string">'pending'</span>;</span><br><span class="line">self.data = <span class="literal">undefined</span>;</span><br><span class="line">self.onResolvedCallback = [];</span><br><span class="line">self.onRejectedCallback = [];</span><br><span class="line">callback(resolve, reject);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">self.status == <span class="string">'fulfilled'</span>;</span><br><span class="line">self.data = value;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">self.onResolvedCallBack[i].value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">self.status == <span class="string">'rejected'</span>;</span><br><span class="line">self.data = error;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">self.onResolvedCallback[i].value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> promise2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved === <span class="string">'function'</span>) &#123;</span><br><span class="line">onResolved = onResolved</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">onResolved = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected === <span class="string">'function'</span>) &#123;</span><br><span class="line">onResolved = onResolved</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">onResolved = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (self.status == <span class="string">'resolved'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">resolve(x)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (self.status == <span class="string">'rejected'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">resolve(x)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (self.status == <span class="string">'pending'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">self.onRejected.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">x.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.</span><br><span class="line"><span class="keyword">catch</span> = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ES6实现Promise```jsclass  Promise{    constructor(fn)} -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Promise 是异步编程的一种解决方案,解决传统的回调嵌套问题&lt;/p&gt;
&lt;p&gt;（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="promise" scheme="https://ru23.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>How to resolve iOS 11 Safari getUserMedia “Invalid constraint” issue</title>
    <link href="https://ru23.com/note/e4a16398.html"/>
    <id>https://ru23.com/note/e4a16398.html</id>
    <published>2018-11-26T05:01:05.000Z</published>
    <updated>2018-11-28T05:33:05.990Z</updated>
    
    <content type="html"><![CDATA[<p>I’m attempting to run the following code in Safari in iOS 11. It should prompt the user to give access to their devices camera and then display it in my <video autoplay id="video"></video> element. However, when running in iOS 11, it results in an OverconstrainedError to be thrown:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">message</span>: <span class="string">"Invalid constraint"</span>, <span class="attr">constraint</span>: <span class="string">"width"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>The code runs fine in Chorme and successfully opens the camera.<br>I’ve attempted multiple valid configurations with no luck.</p><p><strong>Code</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>);</span><br><span class="line"><span class="keyword">if</span>(navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) &#123;</span><br><span class="line">     navigator.mediaDevices.getUserMedia(&#123;<span class="attr">video</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">         .then(<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">             video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</span><br><span class="line">             video.play();</span><br><span class="line">         &#125;)</span><br><span class="line">         .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(err);</span><br><span class="line">         &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>The invalid constraint error in safari is because the browser expects that you pass a correct width, one of:</p><ul><li>320</li><li>640</li><li><p>1280<br>the height is auto calculate in an aspect ratio of 4:3 for 320 or 640, and 16:9 for 1280, then if you pass a width of 320, you video stream is set in:</p></li><li><p>320x240<br>if you set a width of 640, you video stream is set in:</p></li><li><p>640x480<br>And if you set a width of 1280, then you video stream is set in:</p></li><li><p>1280x720<br>In any other case you got a error “InvalidConstrain” for width value.</p></li></ul><p>Also you can use a min, max, exact or ideal constrains for width, please check the MDN documentation</p><p>Here an example in this codepen<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = &#123; <span class="attr">video</span>: &#123; <span class="attr">width</span>: <span class="number">320</span><span class="comment">/*320-640-1280*/</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> start = <span class="function"><span class="params">()</span> =&gt;</span> navigator.mediaDevices.getUserMedia(config)</span><br><span class="line">  .then(<span class="function"><span class="params">stream</span> =&gt;</span> v.srcObject = stream)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> v.onloadedmetadata = resolve))</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> log(<span class="string">"Success: "</span> + v.videoWidth + <span class="string">"x"</span> + v.videoHeight))</span><br><span class="line">  .catch(log);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="params">msg</span> =&gt;</span> div.innerHTML += <span class="string">"&lt;p&gt;"</span> + msg + <span class="string">"&lt;/p&gt;"</span>;</span><br></pre></td></tr></table></figure></p><p>PD: In chrome you can set a width of height and the video stream is set in these sizes, Firefox do a fitness distance, and Safari expect a exact match.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I’m attempting to run the following code in Safari in iOS 11. It should prompt the user to give access to their devices camera and then d
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="踩过的坑" scheme="https://ru23.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <link href="https://ru23.com/note/e277deca.html"/>
    <id>https://ru23.com/note/e277deca.html</id>
    <published>2018-11-23T15:14:05.000Z</published>
    <updated>2018-12-18T01:43:30.642Z</updated>
    
    <content type="html"><![CDATA[<p>眼过千遍，不如手敲一遍。<br>文章参考：<a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理HTTP请求</li><li>页面渲染</li><li>断开TCP连接</li></ol><p>仔细思考这个问题，发现确实很深，这个过程涉及到的东西很多。这个问题的回答真的能够很好的考验一个web工程师的水平<br>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，<br>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、<br>到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS查询顺序如下，若其中一步成功则直接跳到建立链接部分：</p><ul><li>浏览器自身DNS</li><li>操作系统DNS</li><li>本地hosts文件</li><li>向域名服务器发送请求</li></ul><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP三次握手(three-way handshaking)</p><ul><li>发送方:SYN(synchronize)</li><li>接收方:SYN/ACK(acknowledgement),确认信息传达</li><li>发送方:ACK - 确认接收方在线可收消息，握手结束</li><li>Accept</li></ul><p><img src="https://cdn.ru23.com/img/2018/11/three-way-handshaking.jpg" alt="TCP三次握手"></p><p>（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p><p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p><p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p><p>TCP三次握手的的好处在于：发送方可以确认接收方仍然在线，不会因为白发送而浪费资源。</p><h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><p>为什么要把HTTPS协议放在这里讲呢？</p><ul><li>因为HTTP报文是包裹在TCP报文中发送的，服务端收到TCP报文时候会解包提取出HTTP报文。</li><li>但是这个过程中存在一定的风险。HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的危险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)</li></ul><p><img src="https://cdn.ru23.com/img/2018/11/https.jpg" alt="HTTPS"></p><h4 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h4><p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。<br>HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，<br><strong>是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡</strong>。</p><h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。<br>HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。</p><p><strong>请求行：</strong><br>Method Request-URL HTTP-Version CRLF</p><p><strong>请求报头</strong><br>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</p><h4 id="事件循环-Event-loop"><a href="#事件循环-Event-loop" class="headerlink" title="事件循环(Event loop)"></a>事件循环(Event loop)</h4><ol><li>js是单线程，js解析方法时，将同步任务排队到执行栈中，异步任务排队到事件队列中。</li><li>事件队列分为:<br>宏任务：setTimeout，setInterval，setImmediate，I/O，UI交互事件<br>微任务：process.nextTick，Promise.then</li><li>浏览器环境中执行方法时，先将执行栈中的任务清空，再将微任务推到执行栈中并清空，之后检查是否存在宏任务，若存在则取出一个宏任务，执行完成检查是否有微任务，以此循环…</li></ol><h3 id="4-服务器处理HTTP请求并返回HTTP报文"><a href="#4-服务器处理HTTP请求并返回HTTP报文" class="headerlink" title="4. 服务器处理HTTP请求并返回HTTP报文"></a>4. 服务器处理HTTP请求并返回HTTP报文</h3><p>HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。</p><h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><p>强缓存和协商缓存</p><h3 id="5-浏览器解析渲染页面"><a href="#5-浏览器解析渲染页面" class="headerlink" title="5.浏览器解析渲染页面"></a>5.浏览器解析渲染页面</h3><p>使用HTML创建文件对象类型（DOM）<br>使用CSS创建CSS对象类型（CSSOM）<br>基于DOM和CSSOM执行脚本（Scripts）<br>合并DOM和CSSOM形成渲染树（Render Tree)<br>使用渲染布局（Layout）所有元素渲染（Paint）所有元素</p><h3 id="6-断开TCP连接（4次挥手）"><a href="#6-断开TCP连接（4次挥手）" class="headerlink" title="6.断开TCP连接（4次挥手）"></a>6.断开TCP连接（4次挥手）</h3><p>四次分手<br>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p>为什么要四次分手<br>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;眼过千遍，不如手敲一遍。&lt;br&gt;文章参考：&lt;a href=&quot;https://segmentfault.com/a/1190000006879700&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
  </entry>
  
  <entry>
    <title>addEventListener （type, fn , true/false）绑定事件第三个参数作用以及利用事件的冒泡，实现事件委托</title>
    <link href="https://ru23.com/note/f078bfb.html"/>
    <id>https://ru23.com/note/f078bfb.html</id>
    <published>2018-11-23T07:00:11.000Z</published>
    <updated>2018-12-18T01:43:30.640Z</updated>
    
    <content type="html"><![CDATA[<p>第一个参数type，事件的类型，如click，mouseover等；</p><p>fn，事件监听执行的function；</p><p>第三参数，决定事件执行的过程（大概这样解释。。），捕获或者冒泡，首先我们看一张图片：</p><p><img src="https://cdn.ru23.com/img/2018/11/shijianliu.gif" alt="事件流原理"></p><p>由此可以知道<br>　　1、一个完整的JS事件流是从window开始，最后回到window的一个过程<br>　　2、事件流被分为三个阶段(1~5)捕获过程、(5~6)目标过程、(6~10)冒泡过程</p><p>e.target和e.currentTarget</p><p>　　target和currentTarget都是event上面的属性，target是真正发生事件的DOM元素，而currentTarget是当前事件发生在哪个DOM元素上。</p><p>　　可以结合控制台打印出来的信息理解下，目标阶段也就是 target == currentTarget的时候。我没有打印它们两个因为太长了，所以打印了它们的nodeName，但是由于window没有nodeName这个属性，所以是undefined。</p><h3 id="事件委托和事件代理的理解"><a href="#事件委托和事件代理的理解" class="headerlink" title="事件委托和事件代理的理解"></a>事件委托和事件代理的理解</h3><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件，当我们需要对很多元素添加事件的时候，可以通过事件添加到他们的父节点二将时间委托给父节点来触发处理函数</p><p>减少与dom的交互次数，提高性能</p><h3 id="事件委托的原理？"><a href="#事件委托的原理？" class="headerlink" title="事件委托的原理？"></a>事件委托的原理？</h3><p>事件委托是利用事件的冒泡机制来实现的，何为事件冒泡呢？这里介绍下浏览器dom事件处理的过程，dom2.0模型将事件流程分为三个阶段：事件捕获阶段，事件目标阶段，事件冒泡阶段。</p><p>事件捕获：当某个元素触发某个事件，顶层对象document就会发出一个事件流，随着dom树的节点向目标元素节点流去，直到到达事件真正发生的目标元素，在这个过程中，事件相应的监听函数是不会被触发的<br>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数，如果没有绑定监听函数，那就不执行<br>事件冒泡：从目标元素开始，往顶层元素传播，途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发，如果想阻止事件冒泡，可以使用event.stopPropgation()或者event.cancelBubble=true来阻止事件的冒泡传播</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一个参数type，事件的类型，如click，mouseover等；&lt;/p&gt;
&lt;p&gt;fn，事件监听执行的function；&lt;/p&gt;
&lt;p&gt;第三参数，决定事件执行的过程（大概这样解释。。），捕获或者冒泡，首先我们看一张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="js" scheme="https://ru23.com/tags/js/"/>
    
      <category term="事件流" scheme="https://ru23.com/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>nginx 80 443 并存</title>
    <link href="https://ru23.com/note/1cdb2279.html"/>
    <id>https://ru23.com/note/1cdb2279.html</id>
    <published>2018-11-21T17:02:23.000Z</published>
    <updated>2018-12-18T03:08:14.845Z</updated>
    
    <content type="html"><![CDATA[<p>阿里云ECS主机 nginx默认目录/etc/nginx</p><p>如果一站点既要80 http访问，又要443https访问。</p><p>要让https和http并存，不能在配置文件中使用ssl on，配置listen 443 ssl;</p><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server;</span><br><span class="line">    listen       [::]:80 default_server;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">    ssl_certificate &quot;cert/1483067_www.ru23.com.pem&quot;;</span><br><span class="line">    ssl_certificate_key &quot;cert/1483067_www.ru23.com.key&quot;;</span><br><span class="line">    ssl_session_cache shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  10m;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阿里云ECS主机 nginx默认目录/etc/nginx&lt;/p&gt;
&lt;p&gt;如果一站点既要80 http访问，又要443https访问。&lt;/p&gt;
&lt;p&gt;要让https和http并存，不能在配置文件中使用ssl on，配置listen 443 ssl;&lt;/p&gt;
&lt;p&gt;实例&lt;br&gt;
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="nginx" scheme="https://ru23.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>彻底理解浏览器的缓存机制</title>
    <link href="https://ru23.com/note/5bb02710.html"/>
    <id>https://ru23.com/note/5bb02710.html</id>
    <published>2018-11-20T15:16:55.000Z</published>
    <updated>2018-11-21T08:11:26.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#概述" title="概述" target="_blank" rel="noopener"></a>概述</h2><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，<strong>HTTP报文</strong>分为两种：</p><ul><li><p><strong>HTTP请求(Request)报文</strong>，报文格式为：<strong>请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</strong>，如下图<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/Request.jpg" alt="Request"><br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/Request-header.jpg" alt="Request"></p></li><li><p><strong>HTTP响应(Response)报文</strong>，报文格式为：<strong>状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</strong>，如下图<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/Response-header.jpg" alt="Response"><br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/Response.jpg" alt="Response"></p></li></ul><p>注：<strong>通用信息头</strong>指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；<strong>实体头</strong>则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#缓存过程分析" title="缓存过程分析" target="_blank" rel="noopener"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：<strong>浏览器发起HTTP请求 – 服务器响应该请求</strong>。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/cache.jpg" alt="cache"></p><p>由上图我们可以知道：</p><ul><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<strong>强制缓存</strong>和<strong>协商缓存</strong> 。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#强制缓存" title="强制缓存" target="_blank" rel="noopener"></a>强制缓存</h3><p><strong>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</strong>，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ul><li><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/cache1.0.jpg" alt="cache"></p></li><li><p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/cache1.1.jpg" alt="cache"></p></li><li><p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/cache1.2.jpg" alt="cache"></p></li></ul><blockquote><p>那么强制缓存的缓存规则是什么？</p></blockquote><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是<strong>Expires</strong>和<strong>Cache-Control</strong>，其中Cache-Control优先级比Expires高。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#Expires" title="Expires" target="_blank" rel="noopener"></a>Expires</h4><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><blockquote><p>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</p></blockquote><p>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#Cache-Control" title="Cache-Control" target="_blank" rel="noopener"></a>Cache-Control</h4><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li><p><strong>public</strong>：所有内容都将被缓存（客户端和代理服务器都可缓存）</p></li><li><p><strong>private</strong>：所有内容只有客户端可以缓存，<strong>Cache-Control的默认取值</strong></p></li><li><p><strong>no-cache</strong>：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</p></li><li><p><strong>no-store</strong>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p></li><li><p><strong>max-age=xxx (xxx is numeric)</strong>：缓存内容将在xxx秒后失效</p></li></ul><p>接下来，我们直接看一个例子，如下：<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/example1.0.jpg" alt="example"></p><p>由上面的例子我们可以知道：</p><ul><li><p>HTTP响应报文中expires的时间值，是一个绝对值</p></li><li><p>HTTP响应报文中Cache-Control为max-age=600，是相对值</p></li></ul><p>由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</p><p>注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</p><p>了解强制缓存的过程后，我们拓展性的思考一下：</p><blockquote><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p></blockquote><p><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/disk.jpg" alt="disk"><br>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为<strong>from memory cache</strong> 和 <strong>from disk cache</strong>。</p><blockquote><p>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</p></blockquote><p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：<br><strong>访问<a href="https://heyingye.github.iohttps://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –> 200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a href="https://heyingye.github.iohttps://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –> 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</strong></p><p>过程如下：</p><ul><li><p>访问<a href="https://heyingye.github.iohttps://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a><br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/1.0.jpg" alt="200"></p></li><li><p>关闭博客的标签页</p></li><li><p>重新打开<a href="https://heyingye.github.iohttps://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a><br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/2.0.jpg" alt="from disk cache"></p></li><li><p>刷新<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/3.0.jpg" alt="from disk memory"></p></li></ul><blockquote><p>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？</p></blockquote><p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p><ul><li><p><strong>内存缓存(from memory cache)</strong>：内存缓存具有两个特点，分别是<strong>快速读取</strong>和<strong>时效性</strong>：</p><ul><li><p><strong>快速读取</strong>：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p></li><li><p><strong>时效性</strong>：一旦该进程关闭，则该进程的内存则会清空。</p></li></ul></li><li><p><strong>硬盘缓存(from disk cache)</strong>：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p></li></ul><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#协商缓存" title="协商缓存" target="_blank" rel="noopener"></a>协商缓存</h3><p><strong>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong>，主要有以下两种情况：</p><ul><li><p>协商缓存生效，返回304，如下<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/304.jpg" alt="304"></p></li><li><p>协商缓存失效，返回200和请求结果结果，如下<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/200.jpg" alt="200"></p></li></ul><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<strong>Last-Modified / If-Modified-Since和Etag / If-None-Match</strong>，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#Last-Modified-If-Modified-Since" title="Last-Modified / If-Modified-Since" target="_blank" rel="noopener"></a>Last-Modified / If-Modified-Since</h4><ul><li><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/last-modify.jpg" alt="last-modify"></p></li><li><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/since.jpg" alt="since"></p></li></ul><h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#Etag-If-None-Match" title="Etag / If-None-Match" target="_blank" rel="noopener"></a>Etag / If-None-Match</h4><ul><li><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/Etag.jpg" alt="Etag"></p></li><li><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/Etag-match.jpg" alt="Etag-match"></p></li></ul><p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#总结" title="总结" target="_blank" rel="noopener"></a>总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：<br><img src="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/img/all.jpg" alt="all"></p><p>原文出自：<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#%E6%80%BB%E7%BB%93</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/#概述&quot; title=&quot;概述&quot; targ
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
  </entry>
  
  <entry>
    <title>2018年11月月刊</title>
    <link href="https://ru23.com/note/bc5cd3d4.html"/>
    <id>https://ru23.com/note/bc5cd3d4.html</id>
    <published>2018-11-17T15:52:52.000Z</published>
    <updated>2018-12-18T01:43:30.638Z</updated>
    
    <content type="html"><![CDATA[<p>算法：<a href="https://github.com/liyanlong/front-end-test" target="_blank" rel="noopener">https://github.com/liyanlong/front-end-test</a></p><p>HTTP 协议入门： <a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p><p>AST（抽象语法树）：<a href="https://mp.weixin.qq.com/s/0-k1xZr8-nPCakN-jnfRnQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0-k1xZr8-nPCakN-jnfRnQ</a></p><p>函数柯里化 ：<a href="https://www.jianshu.com/p/f88a5175e7a2" target="_blank" rel="noopener">https://www.jianshu.com/p/f88a5175e7a2</a> </p><p>浏览器缓存知识小节以及应用：<a href="https://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/5125934.html</a> </p><p>图片详解TCP连接的三次握手，四次断开基本原理：<a href="https://blog.csdn.net/u013011841/article/details/38519971" target="_blank" rel="noopener">https://blog.csdn.net/u013011841/article/details/38519971</a></p><p>JS函数节流和函数防抖：<a href="https://juejin.im/post/5c00f7fe51882516be2ee2fc" target="_blank" rel="noopener">https://juejin.im/post/5c00f7fe51882516be2ee2fc</a></p><p>输入url发生了什么: <a href="https://mp.weixin.qq.com/s/XzKViOthLIQiEJ4lb-HRHw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XzKViOthLIQiEJ4lb-HRHw</a></p><p>剖析Vue原理&amp;实现双向绑定MVVM：<a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006599500</a></p><p>浏览器缓存机制：<a href="https://www.cnblogs.com/slly/p/6732749.html" target="_blank" rel="noopener">https://www.cnblogs.com/slly/p/6732749.html</a></p><p>浏览器渲染原理及流程：<a href="https://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="noopener">https://www.cnblogs.com/slly/p/6640761.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算法：&lt;a href=&quot;https://github.com/liyanlong/front-end-test&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liyanlong/front-end-test&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="前端分享" scheme="https://ru23.com/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="前端月刊" scheme="https://ru23.com/tags/%E5%89%8D%E7%AB%AF%E6%9C%88%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>每周攻克一个技术点</title>
    <link href="https://ru23.com/note/d196d9f1.html"/>
    <id>https://ru23.com/note/d196d9f1.html</id>
    <published>2018-11-17T12:35:36.000Z</published>
    <updated>2018-12-18T01:43:30.647Z</updated>
    
    <content type="html"><![CDATA[<p>【进阶1期】 调用堆栈<br>【进阶2期】 作用域闭包<br>【进阶3期】 this全面解析<br>【进阶4期】 深浅拷贝原理<br>【进阶5期】 原型Prototype<br>【进阶6期】 高阶函数<br>【进阶7期】 事件机制<br>【进阶8期】 Event Loop原理<br>【进阶9期】 Promise原理<br>【进阶10期】Async/Await原理<br>【进阶11期】防抖/节流原理<br>【进阶12期】模块化详解<br>【进阶13期】ES6重难点<br>【进阶14期】计算机网络概述<br>【进阶15期】浏览器渲染原理<br>【进阶16期】webpack配置<br>【进阶17期】webpack原理<br>【进阶18期】前端监控<br>【进阶19期】跨域和安全<br>【进阶20期】性能优化<br>【进阶21期】VirtualDom原理<br>【进阶22期】Diff算法<br>【进阶23期】MVVM双向绑定<br>【进阶24期】Vuex的原理<br>【进阶25期】Redux原理<br>【进阶26期】路由原理<br>【进阶27期】VueRouter源码解析<br>【进阶28期】ReactRouter源码解析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【进阶1期】 调用堆栈&lt;br&gt;【进阶2期】 作用域闭包&lt;br&gt;【进阶3期】 this全面解析&lt;br&gt;【进阶4期】 深浅拷贝原理&lt;br&gt;【进阶5期】 原型Prototype&lt;br&gt;【进阶6期】 高阶函数&lt;br&gt;【进阶7期】 事件机制&lt;br&gt;【进阶8期】 Event Loop原
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
  </entry>
  
  <entry>
    <title>vue组件之间传值</title>
    <link href="https://ru23.com/note/8b0c3b50.html"/>
    <id>https://ru23.com/note/8b0c3b50.html</id>
    <published>2018-11-09T07:25:13.000Z</published>
    <updated>2018-11-09T07:29:49.518Z</updated>
    
    <content type="html"><![CDATA[<p>vue2.0组件之间的传值</p><p>“down”—&gt;指的是下的意思，即父组件向子组件传值，用props；“up”—&gt;指的是上的意思，即子组件想父组件传值，用emit。</p><h3 id="1-子组件向父组件的传值："><a href="#1-子组件向父组件的传值：" class="headerlink" title="1.子组件向父组件的传值："></a>1.子组件向父组件的传值：</h3><p><em>Child.vue</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;/h1&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;childToParent&quot;&gt;想父组件传值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name: &apos;child&apos;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      childToParent()&#123;</span><br><span class="line">        this.$emit(&quot;childToParentMsg&quot;, &quot;子组件向父组件传值&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><em>parent.vue</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line">    &lt;Child v-on:childToParentMsg=&quot;showChildToParentMsg&quot; &gt;&lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &apos;./child/Child.vue&apos;</span><br><span class="line">  export default&#123;</span><br><span class="line">      name:&quot;parent&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      showChildToParentMsg:function(data)&#123;</span><br><span class="line">        alert(&quot;父组件显示信息：&quot;+data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;Child&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-父组件向子组件传值"><a href="#2-父组件向子组件传值" class="headerlink" title="2.父组件向子组件传值"></a>2.父组件向子组件传值</h3><p><em>parent.vue</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line">    &lt;Child v-bind:parentToChild=&quot;parentMsg&quot;&gt;&lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &apos;./child/Child.vue&apos;</span><br><span class="line">  export default&#123;</span><br><span class="line">     name:&quot;parent&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        parentMsg:&apos;父组件向子组件传值&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;Child&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><em>child.vue</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;/h1&gt;</span><br><span class="line">    &lt;span&gt;子组件显示信息：&#123;&#123;parentToChild&#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name: &apos;child&apos;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props:[&quot;parentToChild&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-采用eventBus-js传值—兄弟组件间的传值"><a href="#3-采用eventBus-js传值—兄弟组件间的传值" class="headerlink" title="3.采用eventBus.js传值—兄弟组件间的传值"></a>3.采用eventBus.js传值—兄弟组件间的传值</h3><p><em>eventBus.js</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'Vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure></p><p><em>App.vue</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;secondChild&gt;&lt;/secondChild&gt;</span><br><span class="line">    &lt;firstChild&gt;&lt;/firstChild&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import FirstChild from &apos;./components/FirstChild&apos;</span><br><span class="line">import SecondChild from &apos;./components/SecondChild&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    FirstChild,</span><br><span class="line">    SecondChild,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><em>FirstChild.vue</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;firstChild&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; placeholder=&quot;请输入文字&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;showMessage&quot;&gt;向组件传值&lt;/button&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import bus from &apos;../assets/eventBus&apos;;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name: &apos;firstChild&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &apos;你好&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      showMessage () &#123;</span><br><span class="line">       alert(this.message)</span><br><span class="line">        bus.$emit(&apos;userDefinedEvent&apos;, this.message);//传值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><em>SecondChild.vue</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;SecondChild&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import bus from &apos;../assets/eventBus&apos;;</span><br><span class="line">    export default&#123;</span><br><span class="line">        name:&apos;SecondChild&apos;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: &apos;&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            var self = this;</span><br><span class="line">            bus.$on(&apos;userDefinedEvent&apos;,function(message)&#123;</span><br><span class="line">                self.message = message;//接值</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue2.0组件之间的传值&lt;/p&gt;
&lt;p&gt;“down”—&amp;gt;指的是下的意思，即父组件向子组件传值，用props；“up”—&amp;gt;指的是上的意思，即子组件想父组件传值，用emit。&lt;/p&gt;
&lt;h3 id=&quot;1-子组件向父组件的传值：&quot;&gt;&lt;a href=&quot;#1-子组件向父
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="vue" scheme="https://ru23.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>$nextTick的作用</title>
    <link href="https://ru23.com/note/891492f1.html"/>
    <id>https://ru23.com/note/891492f1.html</id>
    <published>2018-11-09T07:23:02.000Z</published>
    <updated>2018-11-09T07:29:49.509Z</updated>
    
    <content type="html"><![CDATA[<p>请看如下一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    list: []</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$http.get(<span class="string">'/api/article'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = res.data.data.list</span><br><span class="line">        <span class="comment">// ref  list 引用了ul元素，我想把第一个li颜色变为红色</span></span><br><span class="line">        <span class="keyword">this</span>.$refs.list.getElementsByTagName(<span class="string">'li'</span>)[<span class="number">0</span>].style.color = <span class="string">'red'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在获取到数据后赋值给数据模型中list属性，然后想引用ul元素找到第一个li把它的颜色变为红色，但是事实上，这个要报错了，我们知道，在执行这句话时，ul下面并没有li，也就是说刚刚进行的赋值操作，当前并没有引起视图层的更新。因此，在这样的情况下，vue给我们提供了$nextTick方法，如果我们想对未来更新后的视图进行操作，我们只需要把要执行的函数传递给this.$nextTick方法，vue就会给我们做这个工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$http.get(<span class="string">"/api/article"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.list = res.data.data.list;</span><br><span class="line">            <span class="comment">// ref  list 引用了ul元素，我想把第一个li颜色变为红色</span></span><br><span class="line">             <span class="keyword">this</span>.$refs.list.getElementsByTagName(<span class="string">"li"</span>)[<span class="number">0</span>].style.color =<span class="string">"red"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>  这就是一个this.$nextTick的实现，其中利用了优雅降序的巧妙手法，使代码尽可能优化。而且还提供了promise的写法，虽然我们不经常用，但是有总比没有好。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请看如下一段代码：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="vue" scheme="https://ru23.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>html5 Drop 事件详解（摘自w3school）</title>
    <link href="https://ru23.com/note/40559693.html"/>
    <id>https://ru23.com/note/40559693.html</id>
    <published>2018-11-09T07:22:12.000Z</published>
    <updated>2018-11-10T01:15:54.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设置元素为可拖放"><a href="#设置元素为可拖放" class="headerlink" title="设置元素为可拖放"></a>设置元素为可拖放</h3><p>首先，为了使元素可拖动，把 draggable 属性设置为 true ：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="拖动什么-ondragstart-和-setData"><a href="#拖动什么-ondragstart-和-setData" class="headerlink" title="拖动什么 - ondragstart 和 setData()"></a>拖动什么 - ondragstart 和 setData()</h3><p>然后，规定当元素被拖动时，会发生什么。<br>在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。<br>dataTransfer.setData() 方法设置被拖数据的数据类型和值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">ev.dataTransfer.setData(<span class="string">"Text"</span>, ev.target.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。</p><h3 id="放到何处-ondragover"><a href="#放到何处-ondragover" class="headerlink" title="放到何处 - ondragover"></a>放到何处 - ondragover</h3><p>ondragover 事件规定在何处放置被拖动的数据。<br>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。<br>这要通过调用 ondragover 事件的 event.preventDefault() 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault()</span><br></pre></td></tr></table></figure></p><h3 id="进行放置-ondrop"><a href="#进行放置-ondrop" class="headerlink" title="进行放置 - ondrop"></a>进行放置 - ondrop</h3><p>当放置被拖数据时，会发生 drop 事件。<br>在上面的例子中，ondrop 属性调用了一个函数，drop(event)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line"><span class="keyword">var</span> data = ev.dataTransfer.getData(<span class="string">"Text"</span>);</span><br><span class="line">ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码解释：</strong></p><ol><li>调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）</li><li>通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。</li><li>被拖数据是被拖元素的 id (“drag1”)</li><li>把被拖元素追加到放置元素（目标元素）中</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设置元素为可拖放&quot;&gt;&lt;a href=&quot;#设置元素为可拖放&quot; class=&quot;headerlink&quot; title=&quot;设置元素为可拖放&quot;&gt;&lt;/a&gt;设置元素为可拖放&lt;/h3&gt;&lt;p&gt;首先，为了使元素可拖动，把 draggable 属性设置为 true ：&lt;br&gt;&lt;figur
      
    
    </summary>
    
    
      <category term="html5" scheme="https://ru23.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>vue.js 兄弟组件传值</title>
    <link href="https://ru23.com/note/83060485.html"/>
    <id>https://ru23.com/note/83060485.html</id>
    <published>2018-11-09T07:20:45.000Z</published>
    <updated>2018-11-09T07:29:49.514Z</updated>
    
    <content type="html"><![CDATA[<p>1、兄弟之间传递数据需要借助于事件车，通过事件车的方式传递数据</p><p>2、创建一个Vue的实例，让各个兄弟共用同一个事件机制。</p><p>3、传递数据方，通过一个事件触发bus.$emit(方法名，传递的数据)。</p><p>4、接收数据方，通过mounted(){}触发bus.$on(方法名，function(接收数据的参数){用该组件的数据接收传递过来的数据})，此时函数中的this已经发生了改变，可以使用箭头函数。</p><p>源码：</p><p>我们可以创建一个单独的js文件<strong>eventVue.js,</strong>内容如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue</span><br></pre></td></tr></table></figure></p><p>假如父组件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;components-a&gt;&lt;/components-a&gt;</span><br><span class="line">     &lt;components-b&gt;&lt;/components-b&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p><strong>组件a</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">      &lt;div class=&quot;components-a&quot;&gt;</span><br><span class="line">           &lt;button @click=&quot;abtn&quot;&gt;A按钮&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventVue from &apos;../../js/event.js&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    ...</span><br><span class="line">      methods:&#123;</span><br><span class="line">           abtn:function()&#123;</span><br><span class="line">                   eventVue .$emit(&quot;myFun&quot;,&quot;组件A的值&quot;)   //$emit这个方法会触发一个事件</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>组件b</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div class=&quot;components-a&quot;&gt;</span><br><span class="line">         &lt;div&gt;&#123;&#123;btext&#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventVue from &apos;../../js/event.js&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    ....</span><br><span class="line">   created:function()&#123;</span><br><span class="line">       this.bbtn();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods:&#123;</span><br><span class="line">       bbtn:function()&#123;</span><br><span class="line">            eventVue .$on(&quot;myFun&quot;,(message)=&gt;&#123;   //这里最好用箭头函数，不然this指向有问题</span><br><span class="line">                 this.btext = message      </span><br><span class="line">            &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、兄弟之间传递数据需要借助于事件车，通过事件车的方式传递数据&lt;/p&gt;
&lt;p&gt;2、创建一个Vue的实例，让各个兄弟共用同一个事件机制。&lt;/p&gt;
&lt;p&gt;3、传递数据方，通过一个事件触发bus.$emit(方法名，传递的数据)。&lt;/p&gt;
&lt;p&gt;4、接收数据方，通过mounted
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
      <category term="vue" scheme="https://ru23.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>韦博英语教师端vue踩坑记录（2）</title>
    <link href="https://ru23.com/note/a9e5fae8.html"/>
    <id>https://ru23.com/note/a9e5fae8.html</id>
    <published>2018-11-09T07:12:15.000Z</published>
    <updated>2018-11-09T07:29:49.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue项目在nginx中部署"><a href="#vue项目在nginx中部署" class="headerlink" title="vue项目在nginx中部署"></a>vue项目在nginx中部署</h3><p><strong>nginx的配置文件：</strong><br>添加如下server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 7070;</span><br><span class="line">server_name localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 / 50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">        root html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        root /data / xytest / project / zkview - ui / dist;</span><br><span class="line">index index.html;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">try_files $uri $uri / @router;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location@router &#123;</span><br><span class="line">rewrite ^ . * $ / index.html last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加完成后热加载nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx - s reload</span><br></pre></td></tr></table></figure></p><p>nginx如何正确配置部署在子目录的vue项目（History模式）<br><strong>Q1：Vue项目用Webpack打包后放到服务器上，但访问是404页面？</strong><br>原因是vue的项目为单页应用，路由找不到所致。所以要在nginx服务器配置对所有的路径或者文件夹进行跳转。重定向到首页index下，这样就都能找到路由了。<br>nginx配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  try_files $uri $uri/ /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为项目是子项目，所以不能放在根目录下，index.html需要放在一个新建的teacher目录 </p><p><strong>Q2：配置好nginx后，发现这样虽然不会404，但是页面全部转到了根目录的index.html，访问的是空白页面？</strong></p><p>于是调整了nginx和vue-router的配置如下：<br>nginx配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">###教师端 vue项目</span><br><span class="line">location /teacher/ &#123;</span><br><span class="line">    index  index.html index.htm index.php;</span><br><span class="line">    try_files $uri $uri/ /teacher/index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vue路由配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">routes: [&#123;</span><br><span class="line">path: <span class="string">'/teacher/login'</span>,</span><br><span class="line">name: <span class="string">'Login'</span>,</span><br><span class="line">component: Login,</span><br><span class="line">meta: &#123;</span><br><span class="line">title: <span class="string">'教师端登录中心'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/teacher/courseCenter'</span>,</span><br><span class="line">name: <span class="string">'CourseCenter'</span>,</span><br><span class="line">component: CourseCenter,</span><br><span class="line">meta: &#123;</span><br><span class="line">title: <span class="string">'CourseCenter'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><blockquote><p>拓展：<br>apache 做web服务器的虚拟空间，开启.htaccess文件支持,也可以解决vue项目配置子目录的问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">  Options +FollowSymlinks</span><br><span class="line">  RewriteEngine On</span><br><span class="line">  </span><br><span class="line">  RewriteCond %&#123;REQUEST_URI&#125; ^/(teacher|teacher/.*)$</span><br><span class="line">  RewriteRule ^/teacher/index\.html$ - [L,NC]</span><br><span class="line">  </span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">  RewriteRule ^(teacher|teacher/.*)$ teacher/index.html [L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h3 id="element-ui-的-upload组件的clearFiles方法调用方法"><a href="#element-ui-的-upload组件的clearFiles方法调用方法" class="headerlink" title="element-ui 的 upload组件的clearFiles方法调用方法"></a>element-ui 的 upload组件的clearFiles方法调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-button @click=&quot;clearUploadedImage&quot;&gt;重新上传&lt;/el-button&gt;</span><br><span class="line">    &lt;el-upload ref=&quot;upload&quot;&gt;&lt;/el-upload&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    clearUploadedImage () &#123;</span><br><span class="line">      this.$refs.upload.clearFiles();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="vue模板初始化报错："><a href="#vue模板初始化报错：" class="headerlink" title="vue模板初始化报错："></a>vue模板初始化报错：</h3><p>vue模板初始化报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Failed to compile with 2 errors                                                                                                                                                                                                                                                           21:49:02</span><br><span class="line"> error  in ./src/App.vue</span><br><span class="line"></span><br><span class="line">Module build failed: Error: No parser and no file path given, couldn&apos;t infer a parser.</span><br><span class="line">    at normalize (path\node_modules\prettier\index.js:7051:13)</span><br><span class="line">    at formatWithCursor (path\node_modules\prettier\index.js:10370:12)</span><br><span class="line">    at path\node_modules\prettier\index.js:31115:15</span><br><span class="line">    at Object.format (path\node_modules\prettier\index.js:31134:12)</span><br><span class="line">    at Object.module.exports (path\node_modules\vue-loader\lib\template-compiler\index.js:80:23)</span><br><span class="line"></span><br><span class="line"> @ ./src/App.vue 11:0-354</span><br><span class="line"> @ ./src/main.js</span><br><span class="line"> @ multi (webpack)-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./src/main.js</span><br><span class="line"></span><br><span class="line"> error  in ./src/components/HelloWorld.vue</span><br><span class="line"></span><br><span class="line">Module build failed: Error: No parser and no file path given, couldn&apos;t infer a parser.</span><br><span class="line">    at normalize (path\node_modules\prettier\index.js:7051:13)</span><br><span class="line">    at formatWithCursor (path\node_modules\prettier\index.js:10370:12)</span><br><span class="line">    at path\node_modules\prettier\index.js:31115:15</span><br><span class="line">    at Object.format (path\node_modules\prettier\index.js:31134:12)</span><br><span class="line">    at Object.module.exports (path\node_modules\vue-loader\lib\template-compiler\index.js:80:23)</span><br></pre></td></tr></table></figure><p>Prettier has caused this regression in their 1.13.0 update which occurred today. Downgrade to the previous version to fix this error:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev prettier@1.12.0</span><br><span class="line"></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>That should do the trick.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue项目在nginx中部署&quot;&gt;&lt;a href=&quot;#vue项目在nginx中部署&quot; class=&quot;headerlink&quot; title=&quot;vue项目在nginx中部署&quot;&gt;&lt;/a&gt;vue项目在nginx中部署&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;nginx的配置文件：&lt;/s
      
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
  </entry>
  
  <entry>
    <title>vue watch监听对象及对应值的变化(computed)</title>
    <link href="https://ru23.com/note/4560708.html"/>
    <id>https://ru23.com/note/4560708.html</id>
    <published>2018-11-09T06:56:17.000Z</published>
    <updated>2018-11-09T07:29:49.516Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="front-end" scheme="https://ru23.com/categories/front-end/"/>
    
    
  </entry>
  
</feed>
